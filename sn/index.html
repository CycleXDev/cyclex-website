
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>CycleX Security Hub â€” On-Chain Tools</title>
  <meta name="description" content="Quick Scan, RPC Health Checker, Tx Decoder, Dev Tools â€” all in one place. Free, client-side, no wallet needed." />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <meta name="theme-color" content="#05060a">
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js" defer></script>
<style>
  :root {
    --bg:#05060a;
    --cyan:#00e5ff;
    --green:#5dffb2;
    --purple:#7c5cff;
    --red:#ff4757;
    --yellow:#ffd166;
    --text:rgba(244,246,255,1);
    --muted:rgba(244,246,255,.65);
    --card:rgba(255,255,255,.055);
    --border:rgba(255,255,255,.12);
    --radius:22px;
    --radius-sm:14px;
    --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
    --sans:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{min-height:100%;overflow-x:hidden}
  html{font-size:16px;background:#05060a!important}
  body{
    font-family:var(--sans);
    background:
      radial-gradient(1200px 720px at 14% 10%,rgba(0,229,255,.18),transparent 58%),
      radial-gradient(1200px 720px at 86% 12%,rgba(124,92,255,.18),transparent 56%),
      radial-gradient(980px 680px at 55% 120%,rgba(0,58,76,.42),transparent 62%),
      linear-gradient(160deg,#05060a,#0b0a18,#021b24)!important;
    background-repeat:no-repeat!important;
    background-attachment:fixed!important;
    background-size:cover!important;
    color:var(--text);
    min-height:100vh;
    -webkit-font-smoothing:antialiased;
  }
  body::before{
    content:"";position:fixed;inset:0;pointer-events:none;
    background:
      radial-gradient(740px 640px at 20% 14%,rgba(0,229,255,.10),transparent 60%),
      radial-gradient(940px 780px at 78% 18%,rgba(124,92,255,.09),transparent 62%),
      radial-gradient(820px 700px at 52% 78%,rgba(93,255,178,.06),transparent 64%);
    opacity:.10;z-index:0
  }
  a{color:inherit;text-decoration:none}

  /* â”€â”€ PAGE SHELL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .page-shell{width:100%;max-width:1160px;margin:0 auto;padding:32px 20px 80px;position:relative;z-index:1}

  /* â”€â”€ TOP BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .top-bar{
    position:sticky;top:14px;z-index:999;
    display:flex;align-items:center;justify-content:space-between;gap:12px;
    padding:12px 16px;margin:0 auto 36px;
    width:min(1160px,calc(100% - 24px));
    border-radius:999px;
    background:rgba(10,12,22,.55);
    border:1px solid rgba(255,255,255,.14);
    backdrop-filter:blur(18px) saturate(1.12);
    -webkit-backdrop-filter:blur(18px) saturate(1.12);
    box-shadow:0 14px 50px rgba(0,0,0,.50),inset 0 1px 0 rgba(255,255,255,.06);
  }
  .top-bar::before{
    content:"";position:absolute;inset:0;border-radius:999px;padding:1px;
    background:linear-gradient(120deg,rgba(0,229,255,.22),rgba(124,92,255,.16),rgba(255,255,255,.10));
    -webkit-mask:linear-gradient(#000 0 0) content-box,linear-gradient(#000 0 0);
    -webkit-mask-composite:xor;mask-composite:exclude;pointer-events:none;opacity:.55
  }
  .brand{display:flex;align-items:center;gap:10px;position:relative;z-index:1}
  .brand-logo{width:42px;height:42px;border-radius:14px;object-fit:contain;background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.06);box-shadow:0 12px 32px rgba(0,0,0,.7);flex:0 0 auto}
  .brand-text{display:flex;flex-direction:column;gap:2px}
  .brand-title{font-weight:950;letter-spacing:.10em;font-size:13px;text-transform:uppercase;white-space:nowrap}
  .brand-sub{font-size:10px;letter-spacing:.18em;text-transform:uppercase;color:rgba(244,246,255,.56);white-space:nowrap}
  .top-right{display:flex;align-items:center;gap:10px;position:relative;z-index:1}
  .lang-switch{display:inline-flex;align-items:center;padding:4px;border-radius:999px;
    background:rgba(255,255,255,.045);border:1px solid rgba(255,255,255,.12);
    backdrop-filter:blur(12px);gap:2px;flex:0 0 auto}
  .lang-btn{border:none;background:transparent;color:rgba(244,246,255,.56);
    font-size:11px;padding:5px 9px;border-radius:999px;cursor:pointer;
    transition:background .18s,color .18s,transform .18s;white-space:nowrap}
  .lang-btn:hover{transform:translateY(-1px)}
  .lang-btn.active{background:rgba(0,229,255,.14);color:rgba(0,229,255,.95)}
  body.lang-switching{animation:langFade .24s ease}
  @keyframes langFade{from{opacity:.5;transform:translateY(3px)}to{opacity:1;transform:translateY(0)}}

  /* Back to Site */
  .back-link{
    font-size:11px;letter-spacing:.16em;text-transform:uppercase;
    color:rgba(244,246,255,.72);padding:8px 14px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);
    transition:all .18s ease;cursor:pointer;text-decoration:none
  }
  .back-link:hover{background:rgba(255,255,255,.08);color:var(--text)}

  /* â”€â”€ FIREWALL BUTTON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  /* Small nav pill â€” refined, subtle red tint like the Firewall app badge */
  .btn-firewall{
    display:inline-flex;align-items:center;gap:7px;
    padding:7px 14px;border-radius:999px;
    font-size:11px;font-weight:800;letter-spacing:.10em;text-transform:uppercase;
    cursor:pointer;white-space:nowrap;text-decoration:none;
    background:rgba(255,80,80,.10);
    border:1px solid rgba(255,80,80,.32);
    color:#ff7272;
    transition:all .2s ease;
  }
  .btn-firewall:hover{
    background:rgba(255,80,80,.18);
    border-color:rgba(255,80,80,.55);
    color:#ff9494;
  }
  .fw-dot{
    width:6px;height:6px;border-radius:50%;
    background:#ff5050;
    animation:fwDotPulse 1.8s ease-in-out infinite;
    flex-shrink:0;
  }
  @keyframes fwDotPulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.45;transform:scale(.8)}}

  /* â”€â”€ HERO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .hero{position:relative;max-width:1100px;margin:4px auto 30px;padding:6px 0 20px;text-align:center;z-index:1}

  .hero-note-small{font-size:11px;color:rgba(255,255,255,.35);margin-top:18px;letter-spacing:.01em}

  /* â”€â”€ FIREWALL HERO BLOCK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .fw-hero-block{
    margin:24px auto 0;
    display:flex;flex-direction:column;align-items:center;gap:14px;
    max-width:580px;
  }
  /* Big hero CTA â€” clean like Firewall's btn-scan, premium & refined */
  .btn-firewall-hero{
    padding:15px 44px !important;
    font-size:14px !important;
    font-weight:900 !important;
    letter-spacing:.09em !important;
    border-radius:999px !important;
    background:linear-gradient(135deg,#ff4757,#ff6b6b) !important;
    border:none !important;
    color:#fff !important;
    box-shadow:0 14px 44px rgba(255,71,87,.40),0 4px 12px rgba(0,0,0,.30) !important;
    animation:none !important;
    position:relative;overflow:hidden;
    transition:transform .22s ease, box-shadow .22s ease !important;
  }
  .btn-firewall-hero::after{
    content:"";position:absolute;inset:0;border-radius:999px;
    background:linear-gradient(180deg,rgba(255,255,255,.14) 0%,transparent 60%);
    pointer-events:none;
  }
  .btn-firewall-hero:hover{
    transform:translateY(-2px) !important;
    box-shadow:0 22px 64px rgba(255,71,87,.58),0 6px 18px rgba(0,0,0,.30) !important;
  }
  .btn-firewall-hero .fw-dot{
    background:#fff;
    opacity:.9;
  }
  .fw-hero-tagline{
    margin:0;
    font-size:14px;line-height:1.7;
    color:rgba(255,255,255,.65);
    letter-spacing:.01em;
  }
  .fw-hero-tagline em{
    font-style:normal;
    color:#ff8080;
    font-weight:600;
  }
  .hero-kicker{
    display:inline-flex;align-items:center;gap:8px;
    font-size:11px;letter-spacing:.24em;text-transform:uppercase;
    color:rgba(0,229,255,.9);margin-bottom:18px;
    padding:6px 14px;border-radius:999px;border:1px solid rgba(0,229,255,.22);background:rgba(0,229,255,.07)
  }
  .hero-title{
    font-size:clamp(38px,5vw,70px);line-height:1.05;font-weight:950;letter-spacing:-.04em;
    margin-bottom:12px;
    background:linear-gradient(110deg,rgba(244,246,255,1) 0%,rgba(0,229,255,.95) 40%,rgba(124,92,255,.90) 100%);
    -webkit-background-clip:text;background-clip:text;color:transparent;
    background-size:200% 200%;animation:titleSheen 8s ease-in-out infinite
  }
  @keyframes titleSheen{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}
  .hero-sub{max-width:60ch;margin:0 auto 18px;font-size:14px;line-height:1.65;color:var(--muted)}
  .hero-note{max-width:72ch;margin:16px auto 0;font-size:11.5px;line-height:1.6;color:rgba(244,246,255,.40);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.07);background:rgba(255,255,255,.02)}

  /* â”€â”€ TOOLS GRID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .tools-section{margin-bottom:32px}
  .section-label{
    font-size:11px;letter-spacing:.22em;text-transform:uppercase;
    color:var(--muted);margin-bottom:16px;
    display:flex;align-items:center;gap:10px
  }
  .section-label::after{content:"";flex:1;height:1px;background:rgba(255,255,255,.08)}
  #toolGrid{
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:14px;
  }
  .tool-card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:20px;
    padding:20px 18px;
    cursor:pointer;
    position:relative;overflow:hidden;
    transition:transform .22s ease,border-color .22s ease,box-shadow .22s ease;
    box-shadow:0 12px 40px rgba(0,0,0,.45);
  }
  .tool-card::before{
    content:"";position:absolute;inset:0;border-radius:20px;
    opacity:0;pointer-events:none;transition:opacity .3s ease;
  }
  .tool-card.tc-quick::before{background:radial-gradient(ellipse at 30% 0%,rgba(0,229,255,.18),transparent 65%)}
  .tool-card.tc-rpc::before{background:radial-gradient(ellipse at 30% 0%,rgba(93,255,178,.15),transparent 65%)}
  .tool-card.tc-tx::before{background:radial-gradient(ellipse at 30% 0%,rgba(255,193,7,.14),transparent 65%)}
  .tool-card.tc-dev::before{background:radial-gradient(ellipse at 30% 0%,rgba(124,92,255,.17),transparent 65%)}
  .tool-card:hover,.tool-card.active{transform:translateY(-3px)}
  .tool-card:hover::before,.tool-card.active::before{opacity:1}
  .tool-card.active{border-color:rgba(0,229,255,.35);box-shadow:0 18px 60px rgba(0,0,0,.55),0 0 0 1px rgba(0,229,255,.10)}
  .tool-card.active.tc-rpc{border-color:rgba(93,255,178,.35)}
  .tool-card.active.tc-tx{border-color:rgba(255,193,7,.35)}
  .tool-card.active.tc-dev{border-color:rgba(124,92,255,.35)}
  .tc-icon{
    width:40px;height:40px;border-radius:12px;
    display:flex;align-items:center;justify-content:center;
    font-size:18px;margin-bottom:12px;
    background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);
  }
  .tc-quick .tc-icon{background:rgba(0,229,255,.10);border-color:rgba(0,229,255,.2)}
  .tc-rpc .tc-icon{background:rgba(93,255,178,.10);border-color:rgba(93,255,178,.2)}
  .tc-tx .tc-icon{background:rgba(255,193,7,.10);border-color:rgba(255,193,7,.2)}
  .tc-dev .tc-icon{background:rgba(124,92,255,.10);border-color:rgba(124,92,255,.2)}
  .tc-name{font-size:14px;font-weight:800;margin-bottom:5px;letter-spacing:-.01em}
  .tc-desc{font-size:11px;color:var(--muted);line-height:1.5;margin-bottom:12px}
  .tc-badges{display:flex;flex-wrap:wrap;gap:5px}
  .tc-badge{
    font-size:9.5px;font-weight:700;letter-spacing:.06em;text-transform:uppercase;
    padding:3px 8px;border-radius:999px;
    background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.10);color:var(--muted)
  }
  .tc-quick .tc-badge{background:rgba(0,229,255,.07);border-color:rgba(0,229,255,.16);color:var(--cyan)}
  .tc-rpc .tc-badge{background:rgba(93,255,178,.07);border-color:rgba(93,255,178,.16);color:var(--green)}
  .tc-tx .tc-badge{background:rgba(255,193,7,.07);border-color:rgba(255,193,7,.16);color:var(--yellow)}
  .tc-dev .tc-badge{background:rgba(124,92,255,.07);border-color:rgba(124,92,255,.16);color:#b09fff}

  /* â”€â”€ PANELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  /* â”€â”€ MODAL OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .modal-backdrop{
    display:none;position:fixed;inset:0;z-index:1000;
    background:rgba(3,4,10,.82);
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
    align-items:flex-start;justify-content:center;
    padding:24px 16px 40px;
    overflow-y:auto;
  }
  .modal-backdrop.open{display:flex;animation:backdropIn .2s ease-out}
  @keyframes backdropIn{from{opacity:0}to{opacity:1}}

  .panel-shell{
    background:var(--card);border:1px solid var(--border);border-radius:24px;
    padding:26px 28px;width:100%;max-width:1060px;flex-shrink:0;
    box-shadow:0 32px 80px rgba(0,0,0,.70);
    animation:panelIn .28s cubic-bezier(.22,1,.36,1) forwards;
    margin:auto;
  }
  @keyframes panelIn{from{opacity:0;transform:translateY(24px) scale(.98)}to{opacity:1;transform:translateY(0) scale(1)}}
  .panel-shell.hidden{display:none!important}
  .panel-head{display:flex;align-items:flex-start;justify-content:space-between;gap:16px;margin-bottom:22px;padding-bottom:18px;border-bottom:1px solid rgba(255,255,255,.07)}
  .panel-kicker{font-size:10px;letter-spacing:.22em;text-transform:uppercase;color:var(--cyan);margin-bottom:4px}
  .panel-title{font-size:20px;font-weight:850;letter-spacing:-.02em;margin-bottom:4px}
  .panel-sub{font-size:12.5px;color:var(--muted);line-height:1.55;max-width:56ch}
  .panel-actions{display:flex;align-items:center;gap:8px;flex-shrink:0}
  .btn-close-modal{
    width:32px;height:32px;border-radius:50%;border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.06);color:var(--muted);
    font-size:16px;line-height:1;cursor:pointer;
    display:flex;align-items:center;justify-content:center;
    transition:all .18s;flex-shrink:0;
  }
  .btn-close-modal:hover{background:rgba(255,71,87,.2);border-color:rgba(255,71,87,.4);color:#ff7a8a}
  .grid-2{display:grid;grid-template-columns:370px 1fr;gap:16px}

  /* â”€â”€ QUICK SCAN RESULT CARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .qs-result-card{
    background:linear-gradient(135deg,rgba(0,180,180,.12) 0%,rgba(0,130,160,.08) 100%);
    border:1px solid rgba(0,229,255,.18);border-radius:16px;
    padding:18px 20px;margin-bottom:14px;
  }
  .qs-result-name{font-size:20px;font-weight:900;letter-spacing:-.02em;color:#5dffd9;margin-bottom:6px}
  .qs-result-meta{font-size:12px;color:rgba(255,255,255,.65);line-height:1.8}
  .qs-result-meta b{color:var(--text)}
  .qs-result-meta .mono{font-size:11px;color:rgba(255,255,255,.5)}
  .qs-result-meta a{color:var(--cyan);text-decoration:none}
  .qs-result-meta a:hover{text-decoration:underline}
  .qs-score-badge{
    display:inline-block;padding:3px 10px;border-radius:999px;
    font-size:11px;font-weight:800;letter-spacing:.06em;margin-left:8px;
    vertical-align:middle;
  }
  .qs-score-ok{background:rgba(93,255,178,.15);color:var(--green);border:1px solid rgba(93,255,178,.3)}
  .qs-score-warn{background:rgba(255,193,7,.12);color:#ffd166;border:1px solid rgba(255,193,7,.25)}
  .qs-score-bad{background:rgba(255,71,87,.12);color:#ff7a8a;border:1px solid rgba(255,71,87,.25)}

  /* â”€â”€ CHIPS GRID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .chips-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px}
  .chip{
    display:flex;align-items:center;gap:9px;
    padding:10px 13px;border-radius:12px;border:1px solid;
    font-size:12.5px;line-height:1.3;
  }
  .chip-ok{background:rgba(93,255,178,.06);border-color:rgba(93,255,178,.22)}
  .chip-warn{background:rgba(255,193,7,.06);border-color:rgba(255,193,7,.20)}
  .chip-bad{background:rgba(255,71,87,.08);border-color:rgba(255,71,87,.24)}
  .chip-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
  .chip-ok .chip-dot{background:#5dffb2}
  .chip-warn .chip-dot{background:#ffd166}
  .chip-bad .chip-dot{background:#ff7a8a}
  .chip-ok .chip-label{color:var(--green)}
  .chip-warn .chip-label{color:#ffd166}
  .chip-bad .chip-label{color:#ff7a8a}
  .chip-label{font-weight:800;font-size:11.5px}
  .chip-value{color:rgba(255,255,255,.65);font-size:11.5px;margin-left:2px}

  /* â”€â”€ RPC RESULT CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .rpc-cards{display:flex;flex-direction:column;gap:10px;margin-top:4px}
  .rpc-card{
    border-radius:14px;border:1px solid rgba(255,255,255,.1);
    background:rgba(255,255,255,.03);padding:14px 16px;transition:all .2s;
  }
  .rpc-card.rpc-card-ok{border-color:rgba(93,255,178,.28);background:rgba(93,255,178,.04)}
  .rpc-card.rpc-card-fail{border-color:rgba(255,71,87,.22);background:rgba(255,71,87,.04)}
  .rpc-card.rpc-card-best{border-color:rgba(0,229,255,.4)!important;background:rgba(0,229,255,.07)!important;box-shadow:0 0 0 1px rgba(0,229,255,.2)}
  .rpc-card-top{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:10px;flex-wrap:wrap}
  .rpc-card-host{font-size:12.5px;font-weight:700;color:var(--text);font-family:var(--mono);word-break:break-all}
  .rpc-card-best .rpc-card-host{color:var(--cyan)}
  .rpc-card-right{display:flex;align-items:center;gap:6px;flex-shrink:0}
  .rpc-ms{font-size:11px;font-weight:700;padding:3px 8px;border-radius:999px;white-space:nowrap}
  .rpc-ms-ok{background:rgba(93,255,178,.12);color:var(--green)}
  .rpc-ms-slow{background:rgba(255,193,7,.12);color:#ffd166}
  .rpc-ms-fail{background:rgba(255,71,87,.12);color:#ff7a8a}
  .rpc-checks{display:flex;flex-wrap:wrap;gap:6px}
  .rpc-check{
    display:inline-flex;align-items:center;gap:4px;
    font-size:11px;padding:3px 9px;border-radius:999px;
    border:1px solid rgba(255,255,255,.1);background:rgba(255,255,255,.04);color:var(--muted);
  }
  .rpc-check.pass{background:rgba(93,255,178,.08);border-color:rgba(93,255,178,.22);color:var(--green)}
  .rpc-check.fail-chk{background:rgba(255,71,87,.08);border-color:rgba(255,71,87,.20);color:#ff7a8a}
  .rpc-best-badge{font-size:10px;font-weight:800;letter-spacing:.08em;text-transform:uppercase;background:rgba(0,229,255,.15);color:var(--cyan);border:1px solid rgba(0,229,255,.3);padding:2px 8px;border-radius:999px}

  /* â”€â”€ CARDS (inside panels) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .card{
    background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);
    border-radius:16px;padding:20px;
  }
  .card h3{font-size:13px;font-weight:800;letter-spacing:.02em;margin-bottom:14px;color:var(--text);text-transform:uppercase;letter-spacing:.10em}

  /* â”€â”€ FORMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .field{margin-bottom:16px}
  .field:last-child{margin-bottom:0}
  .label{font-size:11px;font-weight:700;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);margin-bottom:7px}
  input[type=text],input:not([type]),textarea,select{
    width:100%;background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.14);border-radius:10px;
    color:var(--text);font-family:var(--sans);font-size:13px;padding:10px 12px;outline:none;
    transition:border-color .18s ease;
  }
  input[type=text]:focus,input:not([type]):focus,textarea:focus,select:focus{border-color:rgba(0,229,255,.38);background:rgba(255,255,255,.07)}
  input.mono,textarea.mono{font-family:var(--mono);font-size:12px}
  select{cursor:pointer;appearance:none}
  textarea{resize:vertical;min-height:80px}
  .toggle{display:flex;align-items:center;gap:8px;cursor:pointer;font-size:12px;color:var(--muted);line-height:1.4}
  .toggle input[type=checkbox]{accent-color:var(--cyan);width:14px;height:14px;cursor:pointer;flex:0 0 auto}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}

  /* â”€â”€ BUTTONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .btn{
    display:inline-flex;align-items:center;justify-content:center;gap:6px;
    border-radius:999px;border:1px solid transparent;padding:9px 14px;
    font-size:11.5px;font-weight:900;letter-spacing:.07em;text-transform:uppercase;
    cursor:pointer;transition:all .22s ease;user-select:none;white-space:nowrap
  }
  .btn:disabled{opacity:.45;cursor:not-allowed;transform:none!important}
  .btn-primary{background:linear-gradient(135deg,#00e5ff,#7df2ff);color:#03040a;border:none;box-shadow:0 10px 40px rgba(0,229,255,.28)}
  .btn-primary:hover{transform:translateY(-1px);box-shadow:0 16px 55px rgba(0,229,255,.44)}
  .btn-secondary{background:rgba(0,229,255,.10);color:var(--cyan);border-color:rgba(0,229,255,.3)}
  .btn-secondary:hover{background:rgba(0,229,255,.18);transform:translateY(-1px)}
  .btn-ghost{background:rgba(255,255,255,.04);color:var(--text);border-color:rgba(255,255,255,.14)}
  .btn-ghost:hover{background:rgba(255,255,255,.08);border-color:rgba(0,229,255,.24);transform:translateY(-1px)}

  /* â”€â”€ STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .status{display:none;padding:12px 14px;border-radius:12px;font-size:12.5px;line-height:1.6;word-break:break-word}
  .status.info{display:block;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);color:var(--muted)}
  .status.ok{display:block;background:rgba(93,255,178,.07);border:1px solid rgba(93,255,178,.22);color:var(--green)}
  .status.warn{display:block;background:rgba(255,193,7,.07);border:1px solid rgba(255,193,7,.22);color:#ffd166}
  .status.bad{display:block;background:rgba(255,71,87,.07);border:1px solid rgba(255,71,87,.22);color:#ff7a8a}

  /* â”€â”€ TABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .table{width:100%;overflow-x:auto}
  .trow{display:grid;border-bottom:1px solid rgba(255,255,255,.05);padding:9px 4px;align-items:center}
  .trow.head{font-size:10px;font-weight:800;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);border-bottom-color:rgba(255,255,255,.10)}
  .trow.rpc{grid-template-columns:2fr 2fr 1fr}
  /* pairs table: addr | type | target | result */
  #qsLiqTable .trow{grid-template-columns:2fr 1fr 1.5fr 2fr}
  .trow:not(.head):hover{background:rgba(255,255,255,.02)}
  .cell{font-size:12px;padding:0 4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .cell.wrap{white-space:normal;word-break:break-all}
  .cell.muted{color:var(--muted)}
  .highlight{background:rgba(0,229,255,.05)!important;border-radius:8px}
  .highlight .cell{color:var(--cyan)}

  /* â”€â”€ RISK BADGES (kept for compat) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .risk-badges{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px}
  .sig{display:inline-flex;align-items:center;gap:6px;padding:4px 9px;border-radius:999px;font-size:11px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);color:var(--muted)}
  .sig.bad{border-color:rgba(255,71,87,.25);background:rgba(255,71,87,.10);color:#ff7a8a}
  .sig.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08);color:#ffd166}
  .sig.ok{border-color:rgba(93,255,178,.25);background:rgba(93,255,178,.08);color:var(--green)}
  .sig-dot{width:6px;height:6px;border-radius:50%;background:currentColor;flex:0 0 auto}
  /* risk class used by qsMiniChip â†’ mapped to chip */
  .risk{display:flex;align-items:center;gap:9px;padding:10px 13px;border-radius:12px;border:1px solid;font-size:12px;line-height:1.3}
  .risk .dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
  .risk.ok{background:rgba(93,255,178,.06);border-color:rgba(93,255,178,.22);color:var(--green)}
  .risk.ok .dot{background:#5dffb2}
  .risk.warn{background:rgba(255,193,7,.06);border-color:rgba(255,193,7,.20);color:#ffd166}
  .risk.warn .dot{background:#ffd166}
  .risk.bad{background:rgba(255,71,87,.08);border-color:rgba(255,71,87,.24);color:#ff7a8a}
  .risk.bad .dot{background:#ff7a8a}

  /* â”€â”€ SMALL TEXT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .small{font-size:11.5px;color:var(--muted);line-height:1.55}
  .muted{color:var(--muted)}
  .mono{font-family:var(--mono)}

  /* â”€â”€ Tx Decoder specific â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  /* tx-sum styles now below with colors */
  /* â”€â”€ TX detail card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .tx-detail-card{border:1px solid rgba(255,255,255,.08);border-radius:14px;overflow:hidden;margin-bottom:12px}
  .tx-detail-row{display:flex;align-items:flex-start;gap:12px;padding:8px 14px;border-bottom:1px solid rgba(255,255,255,.05)}
  .tx-detail-k{font-size:10px;font-weight:800;letter-spacing:.10em;text-transform:uppercase;color:var(--muted);min-width:72px;flex:0 0 auto;padding-top:2px}
  .tx-detail-v{font-size:12.5px;font-weight:500;word-break:break-all;flex:1}
  /* â”€â”€ TX event rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .tx-event-row{display:flex;align-items:flex-start;gap:10px;padding:8px 0;border-bottom:1px solid rgba(255,255,255,.04)}
  .tx-event-row:last-child{border-bottom:none}
  .tx-event-icon{font-size:14px;flex-shrink:0;padding-top:1px}
  .tx-event-body{font-size:12px;line-height:1.5;flex:1;display:flex;flex-wrap:wrap;align-items:center;gap:2px}

  /* â”€â”€ Bookmarklet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .bm-drag{
    display:inline-flex;align-items:center;gap:8px;padding:8px 14px;
    border-radius:10px;border:1px dashed rgba(0,229,255,.3);
    background:rgba(0,229,255,.05);color:var(--cyan);font-size:12px;font-weight:700;
    cursor:grab;margin-top:10px;text-decoration:none
  }
  .bm-drag-icon{width:18px;height:18px;border-radius:4px;background:rgba(255,255,255,.1)}
  .bm-tip{font-size:11px;color:var(--muted);line-height:1.55;margin-top:10px;padding:10px;background:rgba(255,255,255,.02);border-radius:8px}
  
  /* â”€â”€ QS Pairs Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .qs-pairs-table{width:100%;border-collapse:collapse;font-size:11px;margin-top:6px}
  .qs-pairs-table th{text-align:left;padding:5px 6px;color:var(--muted);font-size:10px;font-weight:700;letter-spacing:.06em;text-transform:uppercase;border-bottom:1px solid rgba(255,255,255,.08)}
  .qs-pairs-table td{padding:6px 6px;border-bottom:1px solid rgba(255,255,255,.04);color:var(--text)}
  .qs-share{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}

  /* â”€â”€ QS compact layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .qs-input-card{display:flex;flex-direction:column;gap:0}
  /* API block: row1 = toggle+select, row2 = input+save */
  .api-block{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:10px;margin:10px 0}
  .api-block-row1{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .api-block-row2{display:flex;align-items:center;gap:6px}
  .api-block-row2 input{flex:1;min-width:0}
  .api-net-sel{flex:1;min-width:0}
  .api-sm-btn{padding:7px 10px!important;font-size:11px!important;flex-shrink:0}
  /* QS main + grid buttons */
  .qs-main-btn-row{display:flex;align-items:center;gap:8px;margin-top:12px}
  .qs-scan-btn{flex:1}
  .qs-btns-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px}
  .qs-json-toggle{display:flex;align-items:center;justify-content:center;gap:4px}
  /* RPC CTA */
  .rpc-full-btn{width:100%}
  .rpc-2btn-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  /* util */
  .input-btn-row{display:flex;gap:6px;align-items:center}
  .input-btn-row input{flex:1;min-width:0}
  .label-muted{font-weight:400;opacity:.55;font-size:10px}

  /* â”€â”€ API accordion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .api-accordion{border:1px solid rgba(255,255,255,.08);border-radius:10px;margin-top:10px;overflow:hidden}
  .api-accordion-summary{
    display:flex;align-items:center;gap:8px;padding:9px 12px;
    font-size:11.5px;font-weight:700;color:var(--muted);cursor:pointer;
    list-style:none;user-select:none;
  }
  .api-accordion-summary::-webkit-details-marker{display:none}
  .api-accordion[open] .api-accordion-summary{color:var(--cyan);border-bottom:1px solid rgba(255,255,255,.07)}
  .api-accordion-summary:hover{color:var(--text)}
  .api-accordion-body{padding:10px 12px}
  .api-key-row{display:flex;gap:8px;align-items:center}
  .api-key-row input{flex:1}

  /* â”€â”€ TX decoder colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .tx-sum{border:1px solid rgba(255,255,255,.08);border-radius:14px;overflow:hidden;margin-top:10px}
  .tx-sum-line{display:flex;align-items:flex-start;gap:12px;padding:10px 14px;border-bottom:1px solid rgba(255,255,255,.05)}
  .tx-sum-line:last-child{border-bottom:none}
  .tx-sum-k{font-size:10px;font-weight:800;letter-spacing:.10em;text-transform:uppercase;color:var(--muted);min-width:80px;flex:0 0 auto;padding-top:3px}
  .tx-sum-v{font-size:13px;font-weight:600;word-break:break-all;flex:1}
  /* colored badge spans used by tx_badge() */
  .tx-sum-v .v{display:inline-flex;align-items:center;gap:6px;padding:3px 10px;border-radius:999px;font-size:12px;font-weight:700}
  .tx-sum-v .v .dot{width:7px;height:7px;border-radius:50%;flex-shrink:0}
  .tx-sum-v .v.ok{background:rgba(93,255,178,.1);border:1px solid rgba(93,255,178,.25);color:var(--green)}
  .tx-sum-v .v.ok .dot{background:#5dffb2}
  .tx-sum-v .v.warn{background:rgba(255,193,7,.1);border:1px solid rgba(255,193,7,.22);color:#ffd166}
  .tx-sum-v .v.warn .dot{background:#ffd166}
  .tx-sum-v .v.bad{background:rgba(255,71,87,.1);border:1px solid rgba(255,71,87,.22);color:#ff7a8a}
  .tx-sum-v .v.bad .dot{background:#ff7a8a}
  .tx-sum-v .v.unk{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.12);color:var(--muted)}
  .tx-sum-v .v.unk .dot{background:rgba(255,255,255,.25)}

  /* â”€â”€ qs actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .qs-actions{display:flex;flex-wrap:wrap;gap:8px}

  /* â”€â”€ FOOTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .footer{border-top:1px solid rgba(255,255,255,.06);margin-top:32px;padding-top:18px;display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:10px;font-size:12px;color:var(--muted)}
  .footer-brand{color:var(--cyan);font-weight:700}

  /* â”€â”€ RESPONSIVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media(max-width:900px){
    #toolGrid{grid-template-columns:1fr 1fr}
    .grid-2{grid-template-columns:1fr!important}
    .panel-shell{max-width:100%;padding:22px 18px}
  }
  @media(max-width:640px){
    #toolGrid{grid-template-columns:1fr 1fr}
    .grid-2{grid-template-columns:1fr!important}
    .chips-grid{grid-template-columns:1fr}
    .risk-badges{grid-template-columns:1fr 1fr}
    .api-block-row1{flex-wrap:wrap}
    .qs-btns-grid{grid-template-columns:1fr 1fr}
    .qs-scan-btn{font-size:15px;padding:13px}
    .rpc-2btn-row{grid-template-columns:1fr 1fr}
    #qsLiqTable .trow{font-size:10px}
    .top-bar{flex-wrap:wrap;padding:10px 12px;border-radius:18px;gap:8px;margin-bottom:18px}
    .brand-sub{display:none}
    .back-link{display:none}
    .modal-backdrop{padding:0;align-items:flex-end}
    .panel-shell{border-radius:20px 20px 0 0;margin:0;max-width:100%;padding:22px 18px;max-height:90vh;overflow-y:auto}
    .rpc-card-top{flex-direction:column;align-items:flex-start}
    .panel-head{flex-direction:column;gap:8px}
    .panel-actions{width:100%;justify-content:flex-end}
    .panel-title{font-size:20px}
    .hero-title{font-size:clamp(28px,8vw,48px)}
    .fw-hero-block{padding:14px}
    .btn-firewall-hero{padding:12px 28px !important;font-size:13px !important}
    .tool-card{padding:14px 12px}
    .qs-main-btn-row{gap:6px}
    .tx-detail-card,.tx-sum{font-size:11px}
    .tx-detail-k{min-width:60px}
    .rpc-full-btn{font-size:15px;padding:13px}
  }
  @media(max-width:480px){
    #toolGrid{grid-template-columns:1fr 1fr}
    .fw-hero-tagline{font-size:13px}
    .risk-badges{grid-template-columns:1fr}
    .qs-btns-grid{grid-template-columns:1fr 1fr}
  }
  @media(min-width:901px){html{zoom:1.10}}
  @media(max-width:600px){html{zoom:1!important}}
</style>
</head>
<body>
<div class="page-shell">
  <!-- TOP BAR -->
  <nav class="top-bar">
    <a class="brand" href="https://cyclex.network/">
      <img src="/logo.png" alt="CycleX" class="brand-logo" />
      <div class="brand-text">
        <div class="brand-title">CycleX</div>
        <div class="brand-sub" data-i18n="brand_sub">On-Chain Security &amp; Rewards</div>
      </div>
    </a>
    <div class="top-right">
      <a href="https://cyclex.network/" class="back-link" data-i18n="btn_back">â† Back to Site</a>
      <a href="/firewall" class="btn-firewall">
        <span class="fw-dot"></span>
        <span data-i18n="btn_firewall">Firewall</span>
      </a>
      <div class="lang-switch" aria-label="Language selector" data-i18n-aria-label="aria_lang_selector">
        <button class="lang-btn active" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="zh">ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="ar">AR</button>
        <button class="lang-btn" data-lang="ru">RU</button>
      </div>
    </div>
  </nav>

  <main>
    <!-- HERO -->
    <div class="hero">
      <div class="hero-kicker" data-i18n="hero_kicker">CycleX Security Hub</div>
      <h1 class="hero-title" data-i18n="hero_title">Advanced Security Tools</h1>
      <p class="hero-sub" data-i18n="hero_subtitle">
        Quick Scan tokens, verify RPC health, decode transactions, and build dev tools â€” all client-side, no wallet needed.
      </p>
      <!-- FIREWALL HERO BLOCK -->
      <div class="fw-hero-block">
        <a href="/firewall" class="btn-firewall btn-firewall-hero">
          <span class="fw-dot"></span>
          <span data-i18n="fw_hero_btn">ğŸ›¡ï¸ CycleX Firewall â€” Protect Your Wallet</span>
        </a>
        <p class="fw-hero-tagline" data-i18n="fw_hero_tagline">
          Real-time wallet scanner â€” checks approvals, flags risky contracts &amp; sends <em>live alerts</em>.
          Wallet Passport Â· Permission Guard Â· One-click revoke. Your keys, always safe.
        </p>
      </div>
      <p class="hero-note-small" data-i18n="hero_note">
        Informational checks only â€” no signatures, no transactions. Always verify independently.
      </p>
    </div>

    <!-- TOOLS GRID -->
    <div class="tools-section">
      <div class="section-label" data-i18n="tools_kicker">CHOOSE A TOOL</div>
      <div id="toolGrid">

        <!-- Quick Scan -->
        <div class="tool-card tc-quick" data-tool="quick">
          <div class="tc-icon">âš¡</div>
          <div class="tc-name" data-i18n="cube_quick_title">Quick Scan</div>
          <div class="tc-desc" data-i18n="cube_quick_desc">Fast token sanity-check + shareable report + cache.</div>
          <div class="tc-badges">
            <span class="tc-badge" data-i18n="badge_fast">Fast</span>
            <span class="tc-badge" data-i18n="badge_share">Share</span>
            <span class="tc-badge" data-i18n="badge_cache">Cache</span>
          </div>
        </div>

        <!-- RPC Health Checker -->
        <div class="tool-card tc-rpc" data-tool="rpc">
          <div class="tc-icon">ğŸ“¡</div>
          <div class="tc-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
          <div class="tc-desc" data-i18n="cube_rpc_desc">Latency + chainId + block + eth_call + read logs + dev custom test.</div>
          <div class="tc-badges">
            <span class="tc-badge">Latency</span>
            <span class="tc-badge">ChainId</span>
            <span class="tc-badge" data-i18n="badge_dev">Dev</span>
          </div>
        </div>

        <!-- Tx Decoder -->
        <div class="tool-card tc-tx" data-tool="tx">
          <div class="tc-icon">ğŸ”</div>
          <div class="tc-name" data-i18n="cube_tx_title">Tx Decoder</div>
          <div class="tc-desc" data-i18n="cube_tx_desc">Decode inputs + common events (Transfer/Approval) from a tx hash.</div>
          <div class="tc-badges">
            <span class="tc-badge" data-i18n="badge_decode">Decode</span>
            <span class="tc-badge" data-i18n="badge_events">Events</span>
            <span class="tc-badge" data-i18n="badge_receipt">Receipt</span>
          </div>
        </div>

        <!-- Dev Tools -->
        <div class="tool-card tc-dev" data-tool="dev">
          <div class="tc-icon">ğŸ› </div>
          <div class="tc-name" data-i18n="cube_dev_title">Dev Tools</div>
          <div class="tc-desc" data-i18n="cube_dev_desc">Bookmarklet generator + local contract monitor (no server).</div>
          <div class="tc-badges">
            <span class="tc-badge" data-i18n="badge_bookmarklet">Bookmarklet</span>
            <span class="tc-badge" data-i18n="badge_local">Local</span>
          </div>
        </div>

      </div>
    </div>

    <!-- MODAL BACKDROP (shared) -->
    <div class="modal-backdrop" id="modalBackdrop">

    <!-- Quick Scan Panel -->
    <section class="panel-shell hidden" id="panel-quick">
      <div class="panel-head">
        <div>
          <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
          <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
          <div class="panel-sub" data-i18n="p_quick_sub">Paste a token address, run scan. Cached 10 min Â· shareable report.</div>
        </div>
        <div class="panel-actions">
          <button class="btn-close-modal" id="btnCloseQuick" aria-label="Close">âœ•</button>
        </div>
      </div>
      <div class="grid-2">
        <div class="card qs-input-card">
          <!-- Network + Address -->
          <div class="field">
            <div class="label" data-i18n="net_label">Network</div>
            <select id="qs-net">
              <option value="bsc">BSC (BNB Chain)</option>
              <option value="eth">Ethereum</option>
            </select>
          </div>
          <div class="field">
            <div class="label" data-i18n="addr_label">Token address</div>
            <input id="qs-token" class="mono" placeholder="0x..." />
          </div>

          <!-- API Keys: toggle+select on row 1, input+save on row 2 -->
          <div class="api-block">
            <div class="api-block-row1">
              <label class="toggle">
                <input type="checkbox" id="api-use">
                <span class="small">ğŸ”‘ Explorer API</span>
              </label>
              <select id="api-key-select" class="mono api-net-sel">
                <option value="bscscan">BscScan</option>
                <option value="unified">Unified</option>
                <option value="etherscan">Etherscan</option>
              </select>
            </div>
            <div class="api-block-row2">
              <input id="api-bscscan" class="mono" placeholder="Paste API keyâ€¦" />
              <input id="api-unified" class="mono" placeholder="Paste API keyâ€¦" style="display:none" />
              <input id="api-etherscan" class="mono" placeholder="Paste API keyâ€¦" style="display:none" />
              <button class="btn btn-ghost api-sm-btn" id="api-save">Save</button>
              <button class="btn btn-ghost api-sm-btn" id="api-clear">Ã—</button>
            </div>
          </div>

          <!-- SCAN full-width -->
          <div style="margin-top:14px">
            <button class="btn btn-primary rpc-full-btn" id="qs-run" data-i18n="btn_scan">Scan</button>
          </div>
          <!-- Secondary: 2-col grid -->
          <div class="qs-btns-grid">
            <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
            <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
            <button class="btn btn-ghost" id="qs-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
            <button class="btn btn-ghost" id="qs-share-x" data-i18n="btn_share_x">Share to X</button>
            <button class="btn btn-ghost" id="qs-share-tg" data-i18n="btn_share_tg">Share to Telegram</button>
            <button class="btn btn-ghost" id="qs-copy-xtext" data-i18n="btn_copy_xtext">Copy X Text</button>
          </div>
          <div style="margin-top:6px;display:flex;align-items:center;gap:6px">
            <label class="toggle">
              <input type="checkbox" id="qs-show-json" checked>
              <span class="small" data-i18n="opt_show_json">Enable JSON report</span>
            </label>
          </div>
          <div id="qs-status" class="status info"></div>
        </div>
        <div class="card">
          <h3 data-i18n="results_title">Results</h3>
          <div class="small" data-i18n="results_hint">Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.</div>
          <div id="qs-out" class="status info" style="display:block;margin-top:10px;" data-i18n="qs_ready_html">
            <strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.
          </div>
          <div id="qs-risk" class="chips-grid"></div>
          <div id="qs-pairsWrap" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <!-- RPC Health Panel -->
    <section class="panel-shell hidden" id="panel-rpc">
      <div class="panel-head">
        <div>
          <div class="panel-kicker" style="color:var(--green)" data-i18n="p_rpc_kicker">RPC Health Checker</div>
          <div class="panel-title" data-i18n="p_rpc_title">Find the fastest endpoint</div>
          <div class="panel-sub" data-i18n="p_rpc_sub">Tests latency Â· chainId Â· block Â· eth_call Â· getLogs for each RPC.</div>
        </div>
        <div class="panel-actions">
          <button class="btn-close-modal" id="btnCloseRpc" aria-label="Close">âœ•</button>
        </div>
      </div>
      <div class="grid-2">
        <div class="card rpc-input-card">
          <!-- Network -->
          <div class="field">
            <div class="label" data-i18n="net_label">Network</div>
            <select id="rpc-net">
              <option value="bsc">BSC (BNB Chain)</option>
              <option value="eth">Ethereum</option>
            </select>
          </div>
          <!-- Private RPC inline save -->
          <div class="field">
            <div class="label" data-i18n="rpc_private_label">Private RPC <span class="label-muted">(saved locally)</span></div>
            <div class="input-btn-row">
              <input id="rpc-private" class="mono" placeholder="https://..." />
              <button class="btn btn-ghost" id="rpc-private-save" style="padding:8px 10px;font-size:11px;flex-shrink:0">Save</button>
              <button class="btn btn-ghost" id="rpc-private-clear" style="padding:8px 10px;font-size:11px;flex-shrink:0">Ã—</button>
            </div>
          </div>
          <!-- Custom RPC -->
          <div class="field">
            <div class="label" data-i18n="rpc_custom_label">Custom RPC <span class="label-muted">(top priority)</span></div>
            <input id="rpc-custom" class="mono" placeholder="https://..." />
          </div>
          <!-- CTA -->
          <div style="margin-top:14px">
            <button class="btn btn-primary rpc-full-btn" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
          </div>
          <div class="rpc-2btn-row">
            <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
            <button class="btn btn-ghost" id="rpc-share-x" data-i18n="btn_share_x">Share ğ•</button>
          </div>
          <div id="rpc-status" class="status info" style="margin-top:10px"></div>
          <!-- Dev logs test (collapsible) -->
          <details class="api-accordion" style="margin-top:10px">
            <summary class="api-accordion-summary">ğŸ›  Dev: custom logs test</summary>
            <div class="api-accordion-body">
              <div class="field">
                <div class="label" data-i18n="rpc_dev_addr">Contract address</div>
                <input id="rpc-dev-addr" class="mono" placeholder="0x..." />
              </div>
              <div class="field">
                <div class="label" data-i18n="rpc_dev_topic">Topic0</div>
                <input id="rpc-dev-topic" class="mono" placeholder="0xddf252ad..." />
              </div>
              <button class="btn btn-ghost" id="rpc-dev-run" style="margin-top:8px;padding:8px 14px;font-size:11px">Run test</button>
            </div>
          </details>
        </div>
        <div class="card">
          <h3 data-i18n="rpc_results">Results</h3>
          <div id="rpc-table" class="rpc-cards"></div>
          <div class="small" style="margin-top:10px" data-i18n="rpc_tip">Some RPCs fail due to CORS/timeouts â€” pick the stable fastest.</div>
        </div>
      </div>
    </section>

    <!-- Tx Decoder Panel -->
    <section class="panel-shell hidden" id="panel-tx">
      <div class="panel-head">
        <div>
          <div class="panel-kicker" style="color:var(--yellow)" data-i18n="p_tx_kicker">Tx Decoder</div>
          <div class="panel-title" data-i18n="p_tx_title">Decode a transaction</div>
          <div class="panel-sub" data-i18n="p_tx_sub">Paste a tx hash. We fetch tx + receipt and decode common inputs and events.</div>
        </div>
        <div class="panel-actions">
          <button class="btn-close-modal" id="btnCloseTx" aria-label="Close">âœ•</button>
        </div>
      </div>
      <div class="grid-2">
        <div class="card">
          <h3 data-i18n="tx_input_title">Tx Input</h3>
          <div class="field">
            <div class="label" data-i18n="net_label">Network</div>
            <select id="tx-net">
              <option value="bsc">BSC (BNB Chain)</option>
              <option value="eth">Ethereum</option>
            </select>
          </div>
          <div class="field">
            <div class="label" data-i18n="tx_hash_label">Transaction hash</div>
            <input id="tx-hash" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
            <div class="small" style="margin-top:6px" data-i18n="tx_tip">Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.</div>
          </div>
          <div class="field">
            <div class="row">
              <button class="btn btn-primary" id="tx-run" data-i18n="btn_decode">Decode</button>
              <button class="btn btn-ghost" id="tx-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
            </div>
          </div>
          <div id="tx-status" class="status info"></div>
        </div>
        <div class="card">
          <h3 data-i18n="tx_results_title">Decoded Output</h3>
          <div id="tx-out" class="status info" style="display:block;margin-top:0;margin-bottom:10px;" data-i18n="tx_ready_html">
            <strong>Ready.</strong><br>Paste a tx hash and click <b>Decode</b>.
          </div>
          <div id="tx-sum" class="tx-sum">
            <div class="tx-sum-line">
              <span class="tx-sum-k" data-i18n="tx_sum_action_k">Action</span>
              <span class="tx-sum-v" id="tx-sum-action">â€”</span>
            </div>
            <div class="tx-sum-line">
              <span class="tx-sum-k" data-i18n="tx_sum_risk_k">Risk</span>
              <span class="tx-sum-v" id="tx-sum-risk">â€”</span>
            </div>
            <div class="tx-sum-line">
              <span class="tx-sum-k" data-i18n="tx_sum_target_k">Target</span>
              <span class="tx-sum-v" id="tx-sum-target">â€”</span>
            </div>
            <div class="tx-sum-line">
              <span class="tx-sum-k" data-i18n="tx_sum_impact_k">Max Impact</span>
              <span class="tx-sum-v" id="tx-sum-impact">â€”</span>
            </div>
          </div>
          <div id="tx-events" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <!-- Dev Tools Panel -->
    <section class="panel-shell hidden" id="panel-dev">
      <div class="panel-head">
        <div>
          <div class="panel-kicker" style="color:#b09fff" data-i18n="p_dev_kicker">Dev Tools</div>
          <div class="panel-title" data-i18n="p_dev_title">Bookmarklet + Local Monitor</div>
          <div class="panel-sub" data-i18n="p_dev_sub">Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor.</div>
        </div>
        <div class="panel-actions">
          <button class="btn-close-modal" id="btnCloseDev" aria-label="Close">âœ•</button>
        </div>
      </div>
      <div class="grid-2">
        <div class="card">
          <h3 data-i18n="bm_title">Bookmarklet Generator</h3>
          <div class="small" style="margin-bottom:12px" data-i18n="bm_hint">Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.</div>
          <div class="field">
            <div class="label" data-i18n="bm_base_label">Hub URL (this page)</div>
            <input id="bm-base" class="mono" />
          </div>
          <div class="field">
            <div class="row">
              <button class="btn btn-primary" id="bm-generate" data-i18n="bm_generate">Generate</button>
              <button class="btn btn-ghost" id="bm-copy" data-i18n="bm_copy">Copy Bookmarklet</button>
            </div>
          </div>
          <a id="bm-drag" class="bm-drag" href="#">
            <img class="bm-drag-icon" src="/logo.png" alt="CycleX">
            <span data-i18n="bm_drag_label">CycleX â€“ Security Hub</span>
          </a>
          <div id="bm-out" class="status info"></div>
          <div id="bm-tip" class="bm-tip" data-i18n="bm_tip">Add the bookmarklet to your browser, then check any contract from any site with one click.</div>
        </div>
        <div class="card">
          <h3 data-i18n="mon_list_title">Contract Monitor (local)</h3>
          <div class="small" style="margin-bottom:12px" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>
          <div class="field">
            <div class="label" data-i18n="net_label">Network</div>
            <select id="mon-net">
              <option value="bsc">BSC (BNB Chain)</option>
              <option value="eth">Ethereum</option>
            </select>
          </div>
          <div class="field">
            <div class="label" data-i18n="addr_label">Contract address</div>
            <input id="mon-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
          </div>
          <div class="field">
            <div class="row">
              <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
              <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
              <button class="btn btn-ghost" id="mon-export" data-i18n="mon_export">Copy JSON</button>
            </div>
          </div>
          <div id="mon-status" class="status info"></div>
          <div id="mon-table" class="table" style="margin-top:12px;">
            <div class="trow head" style="grid-template-columns:2fr 1fr 1fr 1fr auto">
              <div class="cell" data-i18n="th_contract">Contract</div>
              <div class="cell" data-i18n="th_network">Network</div>
              <div class="cell hide-sm" data-i18n="th_last_seen">Last seen</div>
              <div class="cell" data-i18n="th_status">Status</div>
              <div class="cell" aria-hidden="true"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    </div><!-- end modal-backdrop -->

    <footer class="footer">
      <div><span class="footer-brand">CycleX Security Hub</span> â€” <span data-i18n="footer_left">runs client-side and reads public on-chain data.</span></div>
      <div data-i18n="footer_tagline">Verify twice. Connect only when you trust the page.</div>
    </footer>
  </main>
</div>

<script type="module">
"use strict";
var E = window.E || window.ethers;
window.E = E;
window.CX = window.CX || {};

const APPKIT_PROJECT_ID = "7886bcb95105e9e47337cec481d5de75";
let _appkitLoadPromise = null;
async function loadAppKit() {
  if (window.CxAppKitModal) return window.CxAppKitModal;
  if (_appkitLoadPromise) return _appkitLoadPromise;
  _appkitLoadPromise = (async () => {
    const [{ createAppKit }, { EthersAdapter }, { bsc, mainnet }] = await Promise.all([
      import("https://esm.sh/@reown/appkit@1.8.15"),
      import("https://esm.sh/@reown/appkit-adapter-ethers@1.8.15"),
      import("https://esm.sh/@reown/appkit/networks"),
    ]);
    const appkit = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc, mainnet],
      defaultNetwork: bsc,
      projectId: APPKIT_PROJECT_ID,
      analytics: false,
      metadata: { name: "CycleX", description: "CycleX Security Hub", url: window.location.origin, icons: [`${window.location.origin}/logo.png`] }
    });
    window.CxAppKitModal = appkit;
    if (!window.E && window.ethers) { window.E = window.ethers; E = window.ethers; }
    return appkit;
  })();
  return _appkitLoadPromise;
}


   // =========================
// i18n (4 languages)
// =========================
const translations = {
  en: {
    // header / hero
    brand_sub: "On-Chain Security & Rewards",
    hero_kicker: "CycleX Security Hub",
    hero_title: "Advanced Security Tools",
    hero_subtitle: "Quick Scan tokens, verify RPC health, decode transactions, and build dev tools â€” all client-side, no wallet needed.",
    btn_back: "Back to Site",
    btn_firewall: "Firewall",
    fw_hero_btn: "ğŸ›¡ï¸ CycleX Firewall â€” Protect Your Wallet",
    fw_hero_tagline: "Real-time wallet scanner â€” checks approvals, flags risky contracts & sends <em>live alerts</em>. Wallet Passport Â· Permission Guard Â· One-click revoke. Your keys, always safe.",
    hub_title: "Advanced Security Tools",
    hub_subtitle: "Quick Scan tokens, verify RPC health, decode transactions, and build dev tools â€” all client-side, no wallet needed.",

    btn_access: "Get Access (PASS / CYCX)",
    wallet_not_connected: "not connected",
    btn_quick: "Run Quick Scan",
    hero_note: "Note: These checks are informational and do not guarantee safety. No signatures. No transactions. Always verify contracts and URLs independently.",
    hero_micro_quick: "Start here â€” no wallet needed.",
    hero_micro_access: "Unlock advanced approvals + revoke tools.",
    tools_kicker: "CHOOSE A TOOL",

    // tiles
    cube_quick_title: "Quick Scan",
    cube_quick_desc: "Fast token sanity-check + shareable report + cache.",
    cube_liq_title: "Token + Liquidity Scan",
    cube_liq_desc: "DEX registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc: "Check and revoke ERC-20 allowances safely (approve â†’ 0).",
    cube_rpc_title: "RPC Health Checker",
    cube_rpc_desc: "Latency + chainId + block + eth_call + read logs + dev custom test.",
    cube_tx_title: "Tx Decoder",
    cube_tx_desc: "Decode inputs + common events (Transfer/Approval) from a tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc: "Bookmarklet generator + local contract monitor (no server).",
    cube_walletdna_title: "Wallet Security DNA",
    cube_walletdna_desc: "Approval & Permission Risk Snapshot - Export",

    // tile badges
    badge_fast: "Fast",
    badge_share: "Share",
    badge_cache: "Cache",
    badge_dex: "DEX",
    badge_pairs: "Pairs",
    badge_wallet: "Wallet",
    badge_safe: "Safe",
    badge_copy: "Copy",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",
    badge_safe: "Safe",

    // generic
    pill_wallet: "Wallet",
    btn_close: "Close",
    btn_save: "Save",
    btn_clear: "Clear",
    btn_scan: "Scan",
    btn_decode: "Decode",
    btn_copy_md: "Copy Markdown",
    btn_copy_link: "Copy Share Link",
    btn_copy_json: "Copy JSON",
    btn_copy_xtext: "Copy X text",

    // quick panel
    p_quick_kicker: "Quick Scan",
    p_quick_title: "Score a token in seconds",
    p_quick_sub: "Paste a token address, run scan. Cached 10 min Â· shareable report.",
    quick_input_title: "Token Input",
    net_label: "Network",
    addr_label: "Token contract",
    qs_tip:
      'Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).',
    options_label: "Options",
    opt_require_liq: "Require liquidity (stricter score)",
    opt_show_json: "Enable JSON report (copy)",
    api_keys_label: "Explorer API keys (optional)",
    opt_use_explorer_apis: "Use BscScan/Etherscan (adds Verified + ABI heuristics)",
    api_keys_tip:
      "Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.",
    results_title: "Results",
    results_hint:
      "Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.",

    // liquidity panel
    p_liq_kicker: "Token + Liquidity Scan",
    p_liq_title: "DEX registry liquidity checks",
    p_liq_sub:
      "We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.",
    liq_input_title: "Token + Network",
    liq_tip:
      'Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.',
    liq_dex_label: "DEX registry (checked)",
    liq_results_title: "Liquidity Results",
    liq_results_hint:
      "V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.",

    
    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "Check and revoke allowances",
    p_app_sub:
      "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
    ap_settings_title: "Settings",
    ap_connected: "Connected:",
    ap_connect: "Connect / Refresh",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "Start with a router preset, then add tokens you want to clean up.",
    ap_tokens_label: "Token list (one per line)",
    ap_seed: "Seed common tokens",
    ap_seed_history: "Use scan history",
    ap_check: "Check Allowances",
    ap_revoke_all: "Revoke All (non-zero)",
    ap_results: "Allowances",
    ap_results_hint:
      "If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.",
    safe_mode_note:
      "Safe mode: actions that require a signature are disabled until you connect a wallet.",
    // DNA (Wallet Security DNA)
p_dna_kicker: "WALLET SECURITY DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Approval & Permission Risk Snapshot - Export",

pill_wallet: "Wallet",
wallet_not_connected: "not connected",
btn_close: "Close",

dna_controls_title: "DNA Scan",
dna_wallet_address_label: "Wallet Address",
dna_wallet_address_ph: "0x... (optional if you connect)",
dna_wallet_address_tip: "You can scan by address first. Connect a wallet only when you want to revoke.",

net_label: "Network",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Connected:",
dna_connect: "Connect Wallet",
dna_run: "Scan",
dna_reset: "Reset",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "Score is a snapshot. Always verify before signing.",

dna_score: "Score",
dna_risk_level: "Risk",

dna_tips_title: "Tips",
dna_tips_placeholder: "â€”",
dna_share: "Share score",

dna_allowances_title: "Approvals",
dna_table_note: "Tip: revoke â€œinfiniteâ€ approvals you donâ€™t fully trust. Verified status and flags are informational only.",

dna_full_access_btn: "UNLOCK ADVANCED (PASS / CYCX)",
 dna_locked_title: "Unlock to see who can spend your tokens â€” and revoke in 1 click.",
    dna_locked_body: "Full access (spender details + revoke tools) is available for:",
    dna_locked_body_fp: "Founder Pass holders",
    dna_locked_body_cycx: "CYCX holders (after launch).",
    dna_locked_safe_title: "Safe check:",
    dna_locked_safe_body:
      "Connect to check eligibility (public address + on-chain balance).<br>" +
      "<span style=\"font-weight:750;\">No signature. No transactions.</span><br>" +
      "We only read on-chain data. Any revoke requires your explicit approval in-wallet.",
    dna_locked_cta: "Unlock includes spender reveal, revoke buttons, and Revoke All (non-zero).",
dna_elig_checking: "Checking eligibility (PASS / CYCX)â€¦",
dna_elig_ok: "Eligible â€” unlocking approvals",
dna_elig_no: "Not eligible for full access (need 1 PASS or at least 100 CYCX).",
dna_elig_wrong_net: "Please switch to BSC (BNB Chain) to check PASS / CYCX eligibility.",
dna_elig_error: "Could not check eligibility. Please try again.",
    dna_meta_approvals_detected: "Approvals detected:",
dna_meta_spenders_hidden: "Spender details hidden until unlock",

    access_title: "Get Access",
access_desc: "Unlock Advanced DNA tools in seconds. Your access pass is non-tradable (soulbound), and later you can convert it to CYCX when the public sale begins.",
access_note: "No signature needed to unlock. Revoke actions always require your approval in-wallet.",
access_pay_bnb: "Buy Access Pass (BNB)",
access_pay_usdt: "Buy Access Pass (USDT)",
access_foot: "Early access: $9 for first 500 access passes, then $19. 1 pass per wallet.",
    access_price_label: "Price:",

    // rpc panel
    p_rpc_kicker: "RPC Health Checker",
    p_rpc_title: "Find the best endpoint",
    p_rpc_sub:
      "We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.",
    rpc_inputs: "Inputs",
    rpc_private_label: "Private RPC (saved locally)",
    rpc_private_tip:
      "Not embedded in HTML. Stored in your browser only (localStorage).",
    rpc_custom_label: "Optional custom RPC (top priority)",
    rpc_test: "Test RPCs",
    rpc_copy_best: "Copy Best RPC",
    rpc_results: "Results",
    rpc_tip:
      "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",
    rpc_dev_title: "Developer custom logs test",
    rpc_dev_hint:
      "Optional: test logs for a contract. This helps developers verify their own RPC stability.",
    rpc_dev_addr: "Contract address (optional)",
    rpc_dev_topic: "Topic0 (optional)",
    rpc_dev_run: "Run custom test",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Decode a transaction",
    p_tx_sub:
      "Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).",
    tx_input_title: "Tx Input",
    tx_hash_label: "Transaction hash",
    tx_tip:
      'Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.',
    tx_results_title: "Decoded Output",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + Local Monitor",
    p_dev_sub:
      "Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).",
    bm_title: "Bookmarklet Generator",
    bm_hint:
      "Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.",
    bm_base_label: "Hub URL (this page)",
    bm_generate: "Generate",
    bm_copy: "Copy Bookmarklet",

    mon_add_title: "Add to watchlist",
    mon_list_title: "Contract Monitor (local)",
    mon_list_hint: "Stored locally only. No server tracking.",
    mon_add: "Add",
    mon_check: "Check all",
    mon_export: "Copy JSON",

    // footer
    footer_left:
      "CycleX Security Hub runs client-side and reads public on-chain data.",
    footer_tagline: "Verify twice. Connect only when you trust the page.",
    // --- ADD THESE KEYS (EN) ---
title_back_to_cyclex: "Back to CycleX",
aria_lang_selector: "Language selector",
badge_table: "Table",
btn_share_x: "Share to X",
btn_share_tg: "Share to Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "Customâ€¦",

th_token: "Token",
th_allowance: "Allowance",
th_symbol: "Symbol",
th_action: "Action",
th_rpc: "RPC",
th_ms: "ms",
th_chain: "chain",
th_block: "block",
th_call: "call",
th_logs: "logs",
th_status: "status",
th_contract: "Contract",
th_network: "Network",
th_last_seen: "Last seen",
    th_remove: "Remove",
    bm_tip: "Add the bookmarklet to your browser, then check any contract from any site with one click.",
bm_drag_label: "CycleX â€“ Security Hub",

qs_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
liq_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
tx_ready_html: "<strong>Ready.</strong><br>Paste a tx hash and click <b>Decode</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (stored locally)",
ph_unified_key: "Unified API Key (Stored Locally)",
ph_etherscan_key: "Etherscan API key (stored locally)",
ph_rpc_private: "https://... (stored locally only)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) or leave empty"

    
  },

  zh: {
    // header / hero
    brand_sub: "é“¾ä¸Šå®‰å…¨ä¸å¥–åŠ±",
    hero_kicker: "CycleX å®‰å…¨ä¸­å¿ƒ",
    hero_title: "é«˜çº§å®‰å…¨å·¥å…·",
    hero_subtitle: "å¿«é€Ÿæ‰«æä»£å¸ã€éªŒè¯ RPC å¥åº·ã€è§£ç äº¤æ˜“ â€” å…¨éƒ¨åœ¨å®¢æˆ·ç«¯è¿è¡Œï¼Œæ— éœ€è¿æ¥é’±åŒ…ã€‚",
    btn_back: "è¿”å›ä¸»ç«™",
    btn_firewall: "é˜²ç«å¢™",
    fw_hero_btn: "ğŸ›¡ï¸ CycleX Firewall â€” ä¿æŠ¤æ‚¨çš„é’±åŒ…",
    fw_hero_tagline: "å®æ—¶é’±åŒ…æ‰«æå™¨ â€” æ£€æŸ¥æˆæƒã€æ ‡è®°é«˜é£é™©åˆçº¦å¹¶å‘é€<em>å®æ—¶è­¦æŠ¥</em>ã€‚é’±åŒ…æŠ¤ç…§ Â· æƒé™å®ˆå« Â· ä¸€é”®æ’¤é”€ã€‚æ‚¨çš„ç§é’¥ï¼Œå§‹ç»ˆå®‰å…¨ã€‚",
    hub_title: "é«˜çº§å®‰å…¨å·¥å…·",
    hub_subtitle: "å¿«é€Ÿæ‰«æä»£å¸ã€éªŒè¯ RPC å¥åº·ã€è§£ç äº¤æ˜“ã€æ„å»ºå¼€å‘å·¥å…· â€” å…¨éƒ¨åœ¨å®¢æˆ·ç«¯è¿è¡Œï¼Œæ— éœ€è¿æ¥é’±åŒ…ã€‚",

    btn_access: "è·å–è®¿é—®æƒé™ï¼ˆPASS / CYCX)",
    wallet_not_connected: "æœªè¿æ¥",
    btn_quick: "è¿è¡Œå¿«é€Ÿæ‰«æ",
    hero_note: "æç¤ºï¼šè¿™äº›æ£€æŸ¥ä»…ä¾›å‚è€ƒï¼Œä¸èƒ½ä¿è¯å®‰å…¨ã€‚æ— éœ€ç­¾åï¼Œæ— éœ€äº¤æ˜“ã€‚è¯·åŠ¡å¿…è‡ªè¡Œæ ¸å¯¹åˆçº¦ä¸é“¾æ¥ï¼ˆURLï¼‰ã€‚",
    hero_micro_quick: "ä»è¿™é‡Œå¼€å§‹ â€” æ— éœ€è¿æ¥é’±åŒ…ã€‚",
    hero_micro_access: "è§£é”é«˜çº§æˆæƒåˆ†æ + æ’¤é”€å·¥å…·ã€‚",
    tools_kicker: "é€‰æ‹©å·¥å…·",

    // tiles
    cube_quick_title: "å¿«é€Ÿæ‰«æ",
    cube_quick_desc: "å¿«é€Ÿä»£å¸ä½“æ£€ + å¯åˆ†äº«æŠ¥å‘Š + ç¼“å­˜ã€‚",
    cube_liq_title: "ä»£å¸ + æµåŠ¨æ€§æ‰«æ",
    cube_liq_desc: "DEX æ£€æŸ¥ï¼ˆPancake/Uniï¼‰ï¼šä»£å¸ vs WBNB/WETH ä¸ USDTã€‚",
    cube_approvals_title: "æˆæƒå«å£«",
    cube_approvals_desc: "æ£€æŸ¥å¹¶å®‰å…¨æ’¤é”€ ERC-20 æˆæƒï¼ˆapprove â†’ 0ï¼‰ã€‚",
    cube_rpc_title: "RPC å¥åº·æ£€æµ‹",
    cube_rpc_desc: "å»¶è¿Ÿ + chainId + åŒºå— + eth_call + è¯»å– logs + å¼€å‘è‡ªå®šä¹‰æµ‹è¯•ã€‚",
    cube_tx_title: "äº¤æ˜“è§£ç ",
    cube_tx_desc: "ä»äº¤æ˜“å“ˆå¸Œè§£ç è¾“å…¥ä¸å¸¸è§äº‹ä»¶ï¼ˆTransfer/Approvalï¼‰ã€‚",
    cube_dev_title: "å¼€å‘å·¥å…·",
    cube_dev_desc: "ä¹¦ç­¾è„šæœ¬ç”Ÿæˆå™¨ + æœ¬åœ°åˆçº¦ç›‘æ§ï¼ˆæ— æœåŠ¡å™¨ï¼‰ã€‚",
    cube_walletdna_title: "é’±åŒ…å®‰å…¨ DNA",
    cube_walletdna_desc: "å®¡æ‰¹ä¸æƒé™é£é™©å¿«ç…§ - å¯¼å‡º",

    // tile badges
    badge_fast: "å¿«é€Ÿ",
    badge_share: "åˆ†äº«",
    badge_cache: "ç¼“å­˜",
    badge_dex: "DEX",
    badge_pairs: "äº¤æ˜“å¯¹",
    badge_wallet: "é’±åŒ…",
    badge_safe: "å®‰å…¨",
    badge_copy: "å¤åˆ¶",
    badge_dev: "å¼€å‘",
    badge_decode: "è§£ç ",
    badge_receipt: "å›æ‰§",
    badge_events: "äº‹ä»¶",
    badge_tools: "å·¥å…·",
    badge_bookmarklet: "ä¹¦ç­¾è„šæœ¬",
    badge_local: "æœ¬åœ°",
    badge_safe: "å®‰å…¨",

    // generic
    pill_wallet: "é’±åŒ…",
    btn_close: "å…³é—­",
    btn_save: "ä¿å­˜",
    btn_clear: "æ¸…é™¤",
    btn_scan: "æ‰«æ",
    btn_decode: "è§£ç ",
    btn_copy_md: "å¤åˆ¶ Markdown",
    btn_copy_link: "å¤åˆ¶åˆ†äº«é“¾æ¥",
    btn_copy_json: "å¤åˆ¶ JSON",
    btn_copy_xtext: "å¤åˆ¶ X æ–‡æ¡ˆ",

    // quick panel
    p_quick_kicker: "å¿«é€Ÿæ‰«æ",
    p_quick_title: "å‡ ç§’å†…ç»™ä»£å¸æ‰“åˆ†",
    p_quick_sub:
      "ç²˜è´´ä»£å¸åœ°å€ï¼Œæ‰«æã€‚ç¼“å­˜10åˆ†é’Ÿ Â· å¯åˆ†äº«æŠ¥å‘Šã€‚",
    quick_input_title: "ä»£å¸è¾“å…¥",
    net_label: "ç½‘ç»œ",
    addr_label: "ä»£å¸åˆçº¦",
    qs_tip:
      'æç¤ºï¼šå¯ç”¨ <span class="mono">?tool=quick&net=bsc&token=0x...</span> æ‰“å¼€è‡ªåŠ¨è¿è¡Œï¼ˆé™é€Ÿï¼‰ã€‚',
    options_label: "é€‰é¡¹",
    opt_require_liq: "è¦æ±‚æœ‰æµåŠ¨æ€§ï¼ˆæ›´ä¸¥æ ¼è¯„åˆ†ï¼‰",
    opt_show_json: "å¯ç”¨ JSON æŠ¥å‘Šï¼ˆå¯å¤åˆ¶ï¼‰",
    api_keys_label: "åŒºå—æµè§ˆå™¨ API Keyï¼ˆå¯é€‰ï¼‰",
    opt_use_explorer_apis: "ä½¿ç”¨ BscScan/Etherscanï¼ˆå¢åŠ  Verified + ABI è§„åˆ™ï¼‰",
    api_keys_tip:
      "Key ä»…ä¿å­˜åœ¨æµè§ˆå™¨æœ¬åœ°ï¼ˆlocalStorageï¼‰ã€‚ä¸è¦æŠŠ Key å†™è¿›å…¬å¼€ HTMLã€‚",
    results_title: "ç»“æœ",
    results_hint:
      "ç»¿è‰² / é»„è‰² / çº¢è‰²ä¿¡å·ã€‚ä¸æ˜¯ä¿è¯â€”â€”åªæ˜¯å¯éªŒè¯çš„é“¾ä¸Šæ£€æŸ¥ã€‚",

    // liquidity panel
    p_liq_kicker: "ä»£å¸ + æµåŠ¨æ€§æ‰«æ",
    p_liq_title: "DEX æ³¨å†Œè¡¨æµåŠ¨æ€§æ£€æŸ¥",
    p_liq_sub:
      "æ£€æŸ¥ PancakeSwapï¼ˆBSCï¼‰/ Uniswapï¼ˆETHï¼‰V2 + V3 å·¥å‚ã€‚æµ‹è¯•äº¤æ˜“å¯¹ï¼šä»£å¸ vs WBNB/WETH ä¸ä»£å¸ vs USDTã€‚",
    liq_input_title: "ä»£å¸ + ç½‘ç»œ",
    liq_tip:
      'æç¤ºï¼šå¯ç”¨ <span class="mono">?tool=liq&net=bsc&token=0x...</span> æ‰“å¼€è‡ªåŠ¨è¿è¡Œã€‚',
    liq_dex_label: "DEX æ³¨å†Œè¡¨ï¼ˆå·²æ£€æŸ¥ï¼‰",
    liq_results_title: "æµåŠ¨æ€§ç»“æœ",
    liq_results_hint:
      "V2ï¼šäº¤æ˜“å¯¹ + å‚¨å¤‡å¿«ç…§ã€‚V3ï¼šæ± å­å­˜åœ¨æ€§ + liquidity() + slot0 tick å¿«ç…§ã€‚",

    // approvals panel
    p_app_kicker: "æˆæƒå«å£«",
    p_app_title: "æ£€æŸ¥å¹¶æ’¤é”€æˆæƒ",
    p_app_sub:
      "å¡«å†™ spender + ä»£å¸åˆ—è¡¨ï¼ˆæˆ–ä¸€é”®å¡«å…¥å¸¸ç”¨ä»£å¸ï¼‰ã€‚è¯»å– allowance(owner, spender)ï¼Œå¹¶ç”¨ approve(spender, 0) æ’¤é”€ã€‚",
    ap_settings_title: "è®¾ç½®",
    ap_connected: "å·²è¿æ¥ï¼š",
    ap_connect: "è¿æ¥ / åˆ·æ–°",
    ap_spender_label: "Spender é¢„è®¾",
    ap_spender_tip: "å…ˆé€‰è·¯ç”±é¢„è®¾ï¼Œå†æ·»åŠ ä½ æƒ³æ¸…ç†çš„ä»£å¸ã€‚",
    ap_tokens_label: "ä»£å¸åˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰",
    ap_seed: "å¡«å…¥å¸¸ç”¨ä»£å¸",
    ap_seed_history: "ä½¿ç”¨æ‰«æå†å²",
    ap_check: "æ£€æŸ¥æˆæƒ",
    ap_revoke_all: "æ’¤é”€å…¨éƒ¨ï¼ˆéé›¶ï¼‰",
    ap_results: "æˆæƒåˆ—è¡¨",
    ap_results_hint:
      "è‹¥æˆæƒä¸ºâ€œæ— é™â€ï¼Œé™¤éä½ å®Œå…¨ä¿¡ä»»è¯¥ spenderï¼Œå¦åˆ™å»ºè®®æ’¤é”€ã€‚",
    safe_mode_note:
      "å®‰å…¨æ¨¡å¼ï¼šéœ€è¦ç­¾åçš„æ“ä½œä¼šåœ¨è¿æ¥é’±åŒ…å‰è¢«ç¦ç”¨ã€‚",
    // DNAï¼ˆé’±åŒ…å®‰å…¨ DNAï¼‰
p_dna_kicker: "é’±åŒ…å®‰å…¨ DNA",
p_dna_title: "é’±åŒ…å®‰å…¨ DNA",
p_dna_sub: "æˆæƒä¸æƒé™é£é™©å¿«ç…§",

pill_wallet: "é’±åŒ…",
wallet_not_connected: "æœªè¿æ¥",
btn_close: "å…³é—­",

dna_controls_title: "DNA æ‰«æ",
dna_wallet_address_label: "é’±åŒ…åœ°å€",
dna_wallet_address_ph: "0x...ï¼ˆå¯é€‰ï¼Œè¿æ¥é’±åŒ…åå¯è‡ªåŠ¨å¡«å…¥ï¼‰",
dna_wallet_address_tip: "å¯å…ˆç”¨åœ°å€æ‰«æã€‚ä»…åœ¨éœ€è¦æ’¤é”€æ—¶å†è¿æ¥é’±åŒ…ã€‚",

net_label: "ç½‘ç»œ",
net_bsc: "BSCï¼ˆBNB Chainï¼‰",
net_eth: "ä»¥å¤ªåŠ",
net_polygon: "Polygon",

dna_connected: "å·²è¿æ¥ï¼š",
dna_connect: "è¿æ¥é’±åŒ…",
dna_run: "æ‰«æ",
dna_reset: "é‡ç½®",

dna_results_title: "é’±åŒ…å®‰å…¨ DNA",
dna_results_hint: "è¯„åˆ†æ˜¯å¿«ç…§ã€‚ç­¾åå‰è¯·åŠ¡å¿…è‡ªè¡Œæ ¸å®ã€‚",

dna_score: "è¯„åˆ†",
dna_risk_level: "é£é™©",

dna_tips_title: "æç¤º",
dna_tips_placeholder: "â€”",
dna_share: "åˆ†äº«è¯„åˆ†",

dna_allowances_title: "æˆæƒ",
dna_table_note: "æç¤ºï¼šä¸å®Œå…¨ä¿¡ä»»çš„â€œæ— é™â€æˆæƒå»ºè®®æ’¤é”€ã€‚Verified ä¸ Flags ä»…ä¾›å‚è€ƒã€‚",
        dna_full_access_btn: "è§£é”é«˜çº§åŠŸèƒ½ï¼ˆé€šè¡Œè¯ / CYCXï¼‰",
   dna_locked_title: "è§£é”ä»¥æŸ¥çœ‹è°èƒ½åŠ¨ç”¨ä½ çš„ä»£å¸ï¼Œå¹¶ä¸€é”®æ’¤é”€æˆæƒã€‚",
    dna_locked_body: "å®Œæ•´æƒé™ï¼ˆæˆæƒæ–¹è¯¦æƒ… + æ’¤é”€å·¥å…·ï¼‰é€‚ç”¨äºï¼š",
    dna_locked_body_fp: "Founder Pass æŒæœ‰è€…",
    dna_locked_body_cycx: "CYCX æŒæœ‰è€…ï¼ˆä¸Šçº¿åï¼‰ã€‚",
    dna_locked_safe_title: "å®‰å…¨æ£€æŸ¥ï¼š",
    dna_locked_safe_body:
      "è¿æ¥é’±åŒ…ä»¥æ£€æŸ¥èµ„æ ¼ï¼ˆå…¬å¼€åœ°å€ + é“¾ä¸Šä½™é¢ï¼‰ã€‚<br>" +
      "<span style=\"font-weight:750;\">æ— éœ€ç­¾åã€‚æ— ä»»ä½•äº¤æ˜“ã€‚</span><br>" +
      "æˆ‘ä»¬åªè¯»å–é“¾ä¸Šæ•°æ®ã€‚ä»»ä½•æ’¤é”€æ“ä½œéƒ½éœ€è¦ä½ åœ¨é’±åŒ…å†…æ˜ç¡®ç¡®è®¤ã€‚",
    dna_locked_cta: "è§£é”åŒ…å«ï¼šæ˜¾ç¤ºæˆæƒæ–¹ã€æ’¤é”€æŒ‰é’®ï¼Œä»¥åŠâ€œä¸€é”®æ’¤é”€ï¼ˆéé›¶ï¼‰â€ã€‚",
    dna_elig_checking: "æ­£åœ¨æ£€æŸ¥èµ„æ ¼ï¼ˆPASS / CYCXï¼‰â€¦",
    dna_elig_ok: "ç¬¦åˆèµ„æ ¼ â€” æ­£åœ¨è§£é”æˆæƒä¿¡æ¯",
    dna_elig_no: "ä¸ç¬¦åˆå®Œæ•´è®¿é—®èµ„æ ¼ï¼ˆéœ€è¦ 1 ä¸ª PASS æˆ–è‡³å°‘ 100 CYCXï¼‰ã€‚",
    dna_elig_wrong_net: "è¯·åˆ‡æ¢åˆ° BSCï¼ˆBNB Chainï¼‰ä»¥æ£€æŸ¥ PASS / CYCX èµ„æ ¼ã€‚",
    dna_elig_error: "æ— æ³•æ£€æŸ¥èµ„æ ¼ï¼Œè¯·é‡è¯•ã€‚",
    dna_meta_approvals_detected: "æ£€æµ‹åˆ°æˆæƒï¼š",
dna_meta_spenders_hidden: "è§£é”å‰éšè—æˆæƒæ–¹è¯¦æƒ…",

    access_title: "è·å–è®¿é—®æƒé™",
access_note: "è§£é”æ— éœ€ç­¾åã€‚ä»»ä½•æ’¤é”€æ“ä½œéƒ½éœ€è¦ä½ åœ¨é’±åŒ…ä¸­ç¡®è®¤ã€‚",
access_pay_bnb: "è´­ä¹°è®¿é—®é€šè¡Œè¯ï¼ˆBNBï¼‰",
access_pay_usdt: "è´­ä¹°è®¿é—®é€šè¡Œè¯ï¼ˆUSDTï¼‰",
access_desc: "å‡ ç§’å†…è§£é”é«˜çº§ DNA å·¥å…·ã€‚ä½ çš„ Access Pass ä¸å¯è½¬è®©ï¼ˆSoulboundï¼‰ï¼Œå¹¶ä¸”ä»…åœ¨å…¬å¼€å‘å”®å¼€å§‹æ—¶å¯è½¬æ¢ä¸º CYCXã€‚",
access_foot: "æ—©é¸Ÿï¼šå‰ 500 ä¸ª Access Pass ä»… $9ï¼Œä¹‹å $19ã€‚æ¯ä¸ªé’±åŒ…é™ 1 ä¸ªã€‚",
    access_price_label: "ä»·æ ¼ï¼š",

    // rpc panel
    p_rpc_kicker: "RPC å¥åº·æ£€æµ‹",
    p_rpc_title: "æ‰¾åˆ°æœ€ä½³èŠ‚ç‚¹",
    p_rpc_sub:
      "æµ‹è¯• RPCï¼šå»¶è¿Ÿ + chainId + åŒºå— + eth_call + è¯»å– logsã€‚åŒ…å«å¼€å‘è€…è‡ªå®šä¹‰ logs æµ‹è¯•ï¼Œå¹¶æŠŠæœ€ä½³ RPC å­˜åˆ°æœ¬åœ°ã€‚",
    rpc_inputs: "è¾“å…¥",
    rpc_private_label: "ç§æœ‰ RPCï¼ˆæœ¬åœ°ä¿å­˜ï¼‰",
    rpc_private_tip:
      "ä¸ä¼šå†™è¿› HTMLï¼Œåªä¿å­˜åœ¨ä½ çš„æµè§ˆå™¨ï¼ˆlocalStorageï¼‰ã€‚",
    rpc_custom_label: "å¯é€‰è‡ªå®šä¹‰ RPCï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰",
    rpc_test: "æµ‹è¯• RPC",
    rpc_copy_best: "å¤åˆ¶æœ€ä½³ RPC",
    rpc_results: "ç»“æœ",
    rpc_tip:
      "æç¤ºï¼šéƒ¨åˆ† RPC ä¼šå›  CORS/è¶…æ—¶å¤±è´¥ã€‚è¿è¡Œæµ‹è¯•å¹¶é€‰æ‹©ç¨³å®šä¸”æœ€å¿«çš„ã€‚",
    rpc_dev_title: "å¼€å‘è€…è‡ªå®šä¹‰ logs æµ‹è¯•",
    rpc_dev_hint:
      "å¯é€‰ï¼šå¯¹æŸåˆçº¦æµ‹è¯• logsï¼Œå¸®åŠ©å¼€å‘è€…éªŒè¯ RPC çš„ç¨³å®šæ€§ã€‚",
    rpc_dev_addr: "åˆçº¦åœ°å€ï¼ˆå¯é€‰ï¼‰",
    rpc_dev_topic: "Topic0ï¼ˆå¯é€‰ï¼‰",
    rpc_dev_run: "è¿è¡Œè‡ªå®šä¹‰æµ‹è¯•",

    // tx panel
    p_tx_kicker: "äº¤æ˜“è§£ç ",
    p_tx_title: "è§£ç ä¸€ç¬”äº¤æ˜“",
    p_tx_sub:
      "ç²˜è´´äº¤æ˜“å“ˆå¸Œã€‚è·å– tx + receiptï¼Œå¹¶è§£ç å¸¸è§è¾“å…¥ä¸äº‹ä»¶ï¼ˆTransfer / Approval + å¸¸è§ swap è°ƒç”¨ï¼‰ã€‚",
    tx_input_title: "äº¤æ˜“è¾“å…¥",
    tx_hash_label: "äº¤æ˜“å“ˆå¸Œ",
    tx_tip:
      'æç¤ºï¼šå¯ç”¨ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> æ‰“å¼€è‡ªåŠ¨è¿è¡Œã€‚',
    tx_results_title: "è§£ç è¾“å‡º",

    // dev panel
    p_dev_kicker: "å¼€å‘å·¥å…·",
    p_dev_title: "ä¹¦ç­¾è„šæœ¬ + æœ¬åœ°ç›‘æ§",
    p_dev_sub:
      "ç”Ÿæˆä¹¦ç­¾è„šæœ¬ï¼ŒæŠŠæµè§ˆå™¨é¡µé¢ä¸Šçš„ä»£å¸/äº¤æ˜“ä¸€é”®å‘é€åˆ° CycleX Hubã€‚ä¹ŸåŒ…å«æœ¬åœ°åˆçº¦ç›‘æ§ï¼ˆåˆ—è¡¨ä¿å­˜åœ¨æµè§ˆå™¨ï¼‰ã€‚",
    bm_title: "ä¹¦ç­¾è„šæœ¬ç”Ÿæˆå™¨",
    bm_hint:
      "æ‹–åˆ°ä¹¦ç­¾æ æˆ–å¤åˆ¶ç”Ÿæˆçš„ä¹¦ç­¾è„šæœ¬ã€‚åœ¨ BscScan/Etherscan é¡µé¢ä½¿ç”¨ã€‚",
    bm_base_label: "Hub URLï¼ˆå½“å‰é¡µé¢ï¼‰",
    bm_generate: "ç”Ÿæˆ",
    bm_copy: "å¤åˆ¶ä¹¦ç­¾è„šæœ¬",

    mon_add_title: "åŠ å…¥ç›‘æ§åˆ—è¡¨",
    mon_list_title: "åˆçº¦ç›‘æ§ï¼ˆæœ¬åœ°ï¼‰",
    mon_list_hint: "ä»…æœ¬åœ°ä¿å­˜ã€‚æ— æœåŠ¡å™¨è·Ÿè¸ªã€‚",
    mon_add: "æ·»åŠ ",
    mon_check: "å…¨éƒ¨æ£€æŸ¥",
    mon_export: "å¤åˆ¶ JSON",

    // footer
    footer_left: "CycleX å®‰å…¨ä¸­å¿ƒåœ¨æœ¬åœ°è¿è¡Œï¼Œè¯»å–å…¬å¼€é“¾ä¸Šæ•°æ®ã€‚",
    footer_tagline: "å¤šéªŒè¯ä¸€æ¬¡ã€‚åªåœ¨ä¿¡ä»»é¡µé¢æ—¶è¿æ¥é’±åŒ…ã€‚",
    // --- ADD THESE KEYS (ZH) ---
title_back_to_cyclex: "è¿”å› CycleX",
aria_lang_selector: "è¯­è¨€é€‰æ‹©",
badge_table: "è¡¨æ ¼",
btn_share_x: "åˆ†äº«åˆ° X",
btn_share_tg: "åˆ†äº«åˆ° Telegram",
net_bsc: "BSCï¼ˆBNB Chainï¼‰",
net_eth: "ä»¥å¤ªåŠ",
spender_pcs_router: "PancakeSwap è·¯ç”±å™¨ï¼ˆBSCï¼‰",
spender_uni_router: "Uniswap V2 è·¯ç”±å™¨ï¼ˆETHï¼‰",
spender_custom: "è‡ªå®šä¹‰â€¦",

th_token: "ä»£å¸",
th_allowance: "æˆæƒé¢åº¦",
th_symbol: "ç¬¦å·",
th_action: "æ“ä½œ",
th_rpc: "RPC",
th_ms: "æ¯«ç§’",
th_chain: "é“¾",
th_block: "åŒºå—",
th_call: "è°ƒç”¨",
th_logs: "æ—¥å¿—",
th_status: "çŠ¶æ€",
th_contract: "åˆçº¦",
th_network: "ç½‘ç»œ",
th_last_seen: "ä¸Šæ¬¡å‡ºç°",
    th_remove: "ç§»é™¤",
    bm_tip: "å°†ä¹¦ç­¾å°å·¥å…·æ·»åŠ åˆ°æµè§ˆå™¨ï¼Œç„¶åä¸€é”®ä»ä»»ä½•ç½‘ç«™æ£€æŸ¥ä»»ä½•åˆçº¦ã€‚",
bm_drag_label: "CycleX â€“ å®‰å…¨ä¸­å¿ƒ",

qs_ready_html: "<strong>å‡†å¤‡å°±ç»ªã€‚</strong><br>ç²˜è´´ä»£å¸åœ°å€å¹¶ç‚¹å‡» <b>æ‰«æ</b>ã€‚",
liq_ready_html: "<strong>å‡†å¤‡å°±ç»ªã€‚</strong><br>ç²˜è´´ä»£å¸åœ°å€å¹¶ç‚¹å‡» <b>æ‰«æ</b>ã€‚",
tx_ready_html: "<strong>å‡†å¤‡å°±ç»ªã€‚</strong><br>ç²˜è´´äº¤æ˜“å“ˆå¸Œå¹¶ç‚¹å‡» <b>è§£ç </b>ã€‚",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API Keyï¼ˆæœ¬åœ°ä¿å­˜ï¼‰",
ph_unified_key: "Unified API Key (æœ¬åœ°ä¿å­˜)",
ph_etherscan_key: "Etherscan API Keyï¼ˆæœ¬åœ°ä¿å­˜ï¼‰",
ph_rpc_private: "https://...ï¼ˆä»…æœ¬åœ°ä¿å­˜ï¼‰",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad...ï¼ˆTransferï¼‰æˆ–ç•™ç©º"

  },

  ar: {
    // header / hero
    brand_sub: "Ø£Ù…Ø§Ù† ÙˆÙ…ÙƒØ§ÙØ¢Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
    hero_kicker: "Ù…Ø±ÙƒØ² Ø£Ù…Ø§Ù† CycleX",
    hero_title: "Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©",
    hero_subtitle: "ÙØ­Øµ Ø³Ø±ÙŠØ¹ Ù„Ù„ØªÙˆÙƒÙ†Ø§ØªØŒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© RPCØŒ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª â€” Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ØŒ Ø¨Ø¯ÙˆÙ† Ù…Ø­ÙØ¸Ø©.",
    btn_back: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆÙ‚Ø¹",
    btn_firewall: "Ø¬Ø¯Ø§Ø± Ø§Ù„Ø­Ù…Ø§ÙŠØ©",
    fw_hero_btn: "ğŸ›¡ï¸ CycleX Firewall â€” Ø§Ø­Ù…Ù Ù…Ø­ÙØ¸ØªÙƒ",
    fw_hero_tagline: "Ù…Ø§Ø³Ø­ Ù…Ø­ÙØ¸Ø© ÙÙˆØ±ÙŠ â€” ÙŠÙØ­Øµ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§ØªØŒ ÙŠÙØ­Ø°Ù‘Ø± Ù…Ù† Ø§Ù„Ø¹Ù‚ÙˆØ¯ Ø§Ù„Ø®Ø·Ø±Ø© ÙˆÙŠÙØ±Ø³Ù„ <em>ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø­ÙŠØ©</em>. Ø¬ÙˆØ§Ø² Ø§Ù„Ù…Ø­ÙØ¸Ø© Â· Ø­Ø§Ø±Ø³ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Â· Ø¥Ù„ØºØ§Ø¡ Ø¨Ù†Ù‚Ø±Ø© ÙˆØ§Ø­Ø¯Ø©. Ù…ÙØ§ØªÙŠØ­ÙƒØŒ Ø¢Ù…Ù†Ø© Ø¯Ø§Ø¦Ù…Ù‹Ø§.",
    hub_title: "Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©",
    hub_subtitle: "ÙØ­Øµ Ø³Ø±ÙŠØ¹ Ù„Ù„ØªÙˆÙƒÙ†Ø§ØªØŒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© RPCØŒ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§ØªØŒ ÙˆØ¨Ù†Ø§Ø¡ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ·ÙˆÙŠØ± â€” ÙƒÙ„ Ø°Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ØŒ Ø¨Ø¯ÙˆÙ† Ù…Ø­ÙØ¸Ø©.",

    btn_access: "Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙˆØµÙˆÙ„ (PASS / CYCX)",
    wallet_not_connected: "ØºÙŠØ± Ù…ØªØµÙ„",
    btn_quick: "ØªØ´ØºÙŠÙ„ ÙØ­Øµ Ø³Ø±ÙŠØ¹",
    hero_note: "Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ù‡ Ø§Ù„ÙØ­ÙˆØµØ§Øª Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠØ© ÙˆÙ„Ø§ ØªØ¶Ù…Ù† Ø§Ù„Ø³Ù„Ø§Ù…Ø©. Ø¨Ø¯ÙˆÙ† ØªÙˆÙ‚ÙŠØ¹. Ø¨Ø¯ÙˆÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª. ØªØ­Ù‚Ù‘Ù‚ Ø¯Ø§Ø¦Ù…Ù‹Ø§ Ù…Ù† Ø§Ù„Ø¹Ù‚ÙˆØ¯ ÙˆØ§Ù„Ø±ÙˆØ§Ø¨Ø· (URL) Ø¨Ù†ÙØ³Ùƒ.",
    hero_micro_quick: "Ø§Ø¨Ø¯Ø£ Ù…Ù† Ù‡Ù†Ø§ â€” Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ø±Ø¨Ø· Ø§Ù„Ù…Ø­ÙØ¸Ø©.",
    hero_micro_access: "Ø§ÙØªØ­ ØªØ­Ù„ÙŠÙ„Ø§Øª Ø£Ø°ÙˆÙ†Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø© + Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¥Ù„ØºØ§Ø¡.",
    tools_kicker: "Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø©",

    // tiles
    cube_quick_title: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
    cube_quick_desc: "ÙØ­Øµ Ø³Ø±ÙŠØ¹ Ù„Ù„ØªÙˆÙƒÙ† + ØªÙ‚Ø±ÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© + ÙƒØ§Ø´.",
    cube_liq_title: "ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ† + Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
    cube_liq_desc: "ÙØ­Øµ DEX (Pancake/Uni): Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù‚Ø§Ø¨Ù„ WBNB/WETH Ùˆ USDT.",
    cube_approvals_title: "Ø­Ø§Ø±Ø³ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    cube_approvals_desc: "ØªØ­Ù‚Ù‚ ÙˆØ£Ù„ØºÙ ØµÙ„Ø§Ø­ÙŠØ§Øª ERC-20 Ø¨Ø£Ù…Ø§Ù† (approve â†’ 0).",
    cube_rpc_title: "ÙØ­Øµ ØµØ­Ø© RPC",
    cube_rpc_desc: "Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© + chainId + Ø¨Ù„ÙˆÙƒ + eth_call + Ù‚Ø±Ø§Ø¡Ø© logs + Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø·ÙˆÙ‘Ø±.",
    cube_tx_title: "ÙÙƒ ØªØ´ÙÙŠØ± Tx",
    cube_tx_desc: "ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª + Ø£Ø­Ø¯Ø§Ø« Ø´Ø§Ø¦Ø¹Ø© (Transfer/Approval) Ù…Ù† tx hash.",
    cube_dev_title: "Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·ÙˆÙ‘Ø±",
    cube_dev_desc: "Ù…ÙˆÙ„Ù‘Ø¯ Bookmarklet + Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ù‚Ø¯ Ù…Ø­Ù„ÙŠØ© (Ø¨Ø¯ÙˆÙ† Ø³ÙŠØ±ÙØ±).",
    cube_walletdna_title: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø© (DNA)",
    cube_walletdna_desc: "Ù„Ù‚Ø·Ø© Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª ÙˆØ§Ù„Ø£Ø°ÙˆÙ†Ø§Øª - ØªØµØ¯ÙŠØ±",

    // tile badges
    badge_fast: "Ø³Ø±ÙŠØ¹",
    badge_share: "Ù…Ø´Ø§Ø±ÙƒØ©",
    badge_cache: "ÙƒØ§Ø´",
    badge_dex: "DEX",
    badge_pairs: "Ø£Ø²ÙˆØ§Ø¬",
    badge_wallet: "Ù…Ø­ÙØ¸Ø©",
    badge_safe: "Ø¢Ù…Ù†",
    badge_copy: "Ù†Ø³Ø®",
    badge_dev: "Ù…Ø·ÙˆÙ‘Ø±",
    badge_decode: "ÙÙƒ",
    badge_receipt: "Ø¥ÙŠØµØ§Ù„",
    badge_events: "Ø£Ø­Ø¯Ø§Ø«",
    badge_tools: "Ø£Ø¯ÙˆØ§Øª",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Ù…Ø­Ù„ÙŠ",
    badge_safe: "Ø¢Ù…Ù†",

    // generic
    pill_wallet: "Ù…Ø­ÙØ¸Ø©",
    btn_close: "Ø¥ØºÙ„Ø§Ù‚",
    btn_save: "Ø­ÙØ¸",
    btn_clear: "Ù…Ø³Ø­",
    btn_scan: "ÙØ­Øµ",
    btn_decode: "ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±",
    btn_copy_md: "Ù†Ø³Ø® Markdown",
    btn_copy_link: "Ù†Ø³Ø® Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©",
    btn_copy_json: "Ù†Ø³Ø® JSON",
    btn_copy_xtext: "Ù†Ø³Ø® Ù†Øµ X",

    // quick panel
    p_quick_kicker: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
    p_quick_title: "Ù‚ÙŠÙ‘Ù… ØªÙˆÙƒÙ† Ø®Ù„Ø§Ù„ Ø«ÙˆØ§Ù†Ù",
    p_quick_sub:
      "Ø£Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ´ØºÙ‘Ù„ Ø§Ù„ÙØ­Øµ. ÙƒØ§Ø´ 10 Ø¯Ù‚Ø§Ø¦Ù‚ Â· ØªÙ‚Ø±ÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ©.",
    quick_input_title: "Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†",
    net_label: "Ø§Ù„Ø´Ø¨ÙƒØ©",
    addr_label: "Ø¹Ù‚Ø¯ Ø§Ù„ØªÙˆÙƒÙ†",
    qs_tip:
      'Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ <span class="mono">?tool=quick&net=bsc&token=0x...</span> Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ (Ù…Ø­Ø¯ÙˆØ¯).',
    options_label: "Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª",
    opt_require_liq: "ÙŠØªØ·Ù„Ø¨ Ø³ÙŠÙˆÙ„Ø© (ØªÙ‚ÙŠÙŠÙ… Ø£ÙƒØ«Ø± ØµØ±Ø§Ù…Ø©)",
    opt_show_json: "ØªÙØ¹ÙŠÙ„ ØªÙ‚Ø±ÙŠØ± JSON (Ù†Ø³Ø®)",
    api_keys_label: "Ù…ÙØ§ØªÙŠØ­ API Ù„Ù„Ù…Ø³ØªÙƒØ´Ù (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    opt_use_explorer_apis: "Ø§Ø³ØªØ®Ø¯Ø§Ù… BscScan/Etherscan (ÙŠØ²ÙŠØ¯ Verified + Ù‚ÙˆØ§Ø¹Ø¯ ABI)",
    api_keys_tip:
      "Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ØªÙØ­ÙØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ (localStorage) ÙÙ‚Ø·. Ù„Ø§ ØªØ¶Ø¹Ù‡Ø§ Ø¯Ø§Ø®Ù„ HTML Ø¹Ø§Ù….",
    results_title: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
    results_hint:
      "Ø¥Ø´Ø§Ø±Ø§Øª Ø®Ø¶Ø±Ø§Ø¡/ØµÙØ±Ø§Ø¡/Ø­Ù…Ø±Ø§Ø¡. Ù„ÙŠØ³Øª Ø¶Ù…Ø§Ù†Ø§Ù‹ â€” Ù…Ø¬Ø±Ø¯ ÙØ­ÙˆØµØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚.",

    // liquidity panel
    p_liq_kicker: "ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ† + Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
    p_liq_title: "ÙØ­Øµ Ø³ÙŠÙˆÙ„Ø© DEX",
    p_liq_sub:
      "Ù†ÙØ¬Ø±ÙŠ ÙØ­Øµ PancakeSwap (BSC) / Uniswap (ETH) V2 + V3. Ø§Ù„Ø£Ø²ÙˆØ§Ø¬: Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù‚Ø§Ø¨Ù„ WBNB/WETH Ùˆ USDT.",
    liq_input_title: "ØªÙˆÙƒÙ† + Ø´Ø¨ÙƒØ©",
    liq_tip:
      'Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ <span class="mono">?tool=liq&net=bsc&token=0x...</span> Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.',
    liq_dex_label: "Ø³Ø¬Ù„ DEX (Ù…ÙØ­ÙˆØµ)",
    liq_results_title: "Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
    liq_results_hint:
      "V2: Ø²ÙˆØ¬ + Ù„Ù‚Ø·Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ. V3: ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø­ÙˆØ¶ + liquidity() + Ù„Ù‚Ø·Ø© slot0/tick.",

    // approvals panel
    p_app_kicker: "Ø­Ø§Ø±Ø³ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    p_app_title: "ØªØ­Ù‚Ù‚ ÙˆØ£Ù„ØºÙ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    p_app_sub:
      "Ø£Ø¯Ø®Ù„ spender + Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (Ø£Ùˆ Ø£Ø¶Ù Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©). Ù†Ù‚Ø±Ø£ allowance(owner, spender) ÙˆÙ†Ù„ØºÙŠ Ø¹Ø¨Ø± approve(spender, 0).",
    ap_settings_title: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
    ap_connected: "Ù…ØªØµÙ„:",
    ap_connect: "Ø§ØªØµØ§Ù„ / ØªØ­Ø¯ÙŠØ«",
    ap_spender_label: "Ø¥Ø¹Ø¯Ø§Ø¯ spender",
    ap_spender_tip:
      "Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø®ØªÙŠØ§Ø± Ø±Ø§ÙˆØªØ± Ø¬Ø§Ù‡Ø²ØŒ Ø«Ù… Ø£Ø¶Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªÙ†Ø¸ÙŠÙÙ‡Ø§.",
    ap_tokens_label: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (ÙƒÙ„ Ø³Ø·Ø± Ø¹Ù†ÙˆØ§Ù†)",
    ap_seed: "Ø¥Ø¶Ø§ÙØ© ØªÙˆÙƒÙ†Ø§Øª Ø´Ø§Ø¦Ø¹Ø©",
    ap_seed_history: "Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø¬Ù„ Ø§Ù„ÙØ­Øµ",
    ap_check: "ÙØ­Øµ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    ap_revoke_all: "Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„ (ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ©)",
    ap_results: "Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    ap_results_hint:
      "Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© â€œØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©â€ØŒ ÙŠÙÙ†ØµØ­ Ø¨Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ù…Ø§ Ù„Ù… ØªÙƒÙ† ØªØ«Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹ Ø¨Ø§Ù„Ù€ spender.",
    safe_mode_note:
      "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¢Ù…Ù†: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØªØ·Ù„Ø¨ ØªÙˆÙ‚ÙŠØ¹Ø§Ù‹ Ù…Ø¹Ø·Ù„Ø© Ø­ØªÙ‰ ØªØªØµÙ„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø©.",
    // DNA (Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©)
p_dna_kicker: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
p_dna_title: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
p_dna_sub: "Ù„Ù‚Ø·Ø© Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª ÙˆØ§Ù„Ø£Ø°ÙˆÙ†Ø§Øª",

pill_wallet: "Ø§Ù„Ù…Ø­ÙØ¸Ø©",
wallet_not_connected: "ØºÙŠØ± Ù…ØªØµÙ„",
btn_close: "Ø¥ØºÙ„Ø§Ù‚",

dna_controls_title: "ÙØ­Øµ DNA",
dna_wallet_address_label: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
dna_wallet_address_ph: "0x... (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ø¥Ø°Ø§ Ù‚Ù…Øª Ø¨Ø§Ù„Ø§ØªØµØ§Ù„)",
dna_wallet_address_tip: "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ÙØ­Øµ Ø¨Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø£ÙˆÙ„Ø§Ù‹. Ø§ØªØµÙ„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø© ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø±ØºØ¨ØªÙƒ ÙÙŠ Ø§Ù„Ø¥Ù„ØºØ§Ø¡.",

net_label: "Ø§Ù„Ø´Ø¨ÙƒØ©",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Ù…ØªØµÙ„:",
dna_connect: "Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø©",
dna_run: "ÙØ­Øµ",
dna_reset: "Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·",

dna_results_title: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
dna_results_hint: "Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù‚Ø·Ø© Ø³Ø±ÙŠØ¹Ø©. ØªØ­Ù‚Ù‘Ù‚ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„ØªÙˆÙ‚ÙŠØ¹.",

dna_score: "Ø§Ù„Ù†ØªÙŠØ¬Ø©",
dna_risk_level: "Ø§Ù„Ù…Ø®Ø§Ø·Ø±",

dna_tips_title: "Ù†ØµØ§Ø¦Ø­",
dna_tips_placeholder: "â€”",
dna_share: "Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù†ØªÙŠØ¬Ø©",

dna_allowances_title: "Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
dna_table_note: "Ù†ØµÙŠØ­Ø©: Ø£Ù„ØºÙ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª â€œØºÙŠØ± Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯Ø©â€ Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ«Ù‚ Ø¨Ù‡Ø§ ØªÙ…Ø§Ù…Ø§Ù‹. Ø­Ø§Ù„Ø© Verified Ùˆ Flags Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠØ© ÙÙ‚Ø·.",
    dna_full_access_btn: "ÙØªØ­ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© (PASS / CYCX)",
    dna_locked_title: "Ø§ÙØªØ­ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ù„Ø±Ø¤ÙŠØ© Ù…Ù† ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ù†ÙØ§Ù‚ Ø±Ù…ÙˆØ²Ùƒ â€” ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¨Ù†Ù‚Ø±Ø© ÙˆØ§Ø­Ø¯Ø©.",
    dna_locked_body: "Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„ (ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¬Ù‡Ø© Ø§Ù„Ù…ÙÙ†ÙÙ‚ÙØ© + Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¥Ù„ØºØ§Ø¡) Ù…ØªØ§Ø­ Ù„Ù€:",
    dna_locked_body_fp: "Ø­Ø§Ù…Ù„ÙŠ Founder Pass",
    dna_locked_body_cycx: "Ø­Ø§Ù…Ù„ÙŠ CYCX (Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚).",
    dna_locked_safe_title: "ÙØ­Øµ Ø¢Ù…Ù†:",
    dna_locked_safe_body:
      "Ø§ØªØµÙ„ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù‡Ù„ÙŠØ© (Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¹Ø§Ù… + Ø§Ù„Ø±ØµÙŠØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©).<br>" +
      "<span style=\"font-weight:750;\">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªÙˆÙ‚ÙŠØ¹. Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª.</span><br>" +
      "Ù†Ø­Ù† Ù†Ù‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø© ÙÙ‚Ø·. Ø£ÙŠ Ø¥Ù„ØºØ§Ø¡ ÙŠØªØ·Ù„Ø¨ Ù…ÙˆØ§ÙÙ‚ØªÙƒ Ø§Ù„ØµØ±ÙŠØ­Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø­ÙØ¸Ø©.",
    dna_locked_cta: "ÙØªØ­ Ø§Ù„Ù‚ÙÙ„ ÙŠØªØ¶Ù…Ù†: ÙƒØ´Ù Ø§Ù„Ø¬Ù‡Ø© Ø§Ù„Ù…ÙÙ†ÙÙ‚ÙØ©ØŒ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ù„ØºØ§Ø¡ØŒ Ùˆ\"Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„ (ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠ)\".",
    dna_elig_checking: "Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù‡Ù„ÙŠØ© (PASS / CYCX)â€¦",
    dna_elig_ok: "Ù…Ø¤Ù‡Ù„ â€” Ø¬Ø§Ø±Ù ÙØªØ­ Ù‚Ø³Ù… Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
    dna_elig_no: "ØºÙŠØ± Ù…Ø¤Ù‡Ù„ Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„ (ØªØ­ØªØ§Ø¬ PASS ÙˆØ§Ø­Ø¯ Ø£Ùˆ 100 CYCX Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„).",
    dna_elig_wrong_net: "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ BSC (BNB Chain) Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù‡Ù„ÙŠØ© PASS / CYCX.",
    dna_elig_error: "ØªØ¹Ø°Ø± Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù‡Ù„ÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
    dna_meta_approvals_detected: "Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©:",
dna_meta_spenders_hidden: "ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…ÙÙ†ÙÙ‚ Ù…Ø®ÙÙŠØ© Ø­ØªÙ‰ ÙØªØ­ Ø§Ù„ÙˆØµÙˆÙ„",

    access_title: "Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙˆØµÙˆÙ„",
access_note: "Ù„Ø§ ÙŠÙ„Ø²Ù… ØªÙˆÙ‚ÙŠØ¹ Ù„ÙØªØ­ Ø§Ù„ÙˆØµÙˆÙ„. Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ© Ø¥Ù„ØºØ§Ø¡ ØªØªØ·Ù„Ø¨ Ù…ÙˆØ§ÙÙ‚ØªÙƒ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø­ÙØ¸Ø©.",
access_pay_bnb: "Ø´Ø±Ø§Ø¡ Ø¨Ø·Ø§Ù‚Ø© ÙˆØµÙˆÙ„ (BNB)",
access_pay_usdt: "Ø´Ø±Ø§Ø¡ Ø¨Ø·Ø§Ù‚Ø© ÙˆØµÙˆÙ„ (USDT)",
access_desc: "Ø§ÙØªØ­ Ø£Ø¯ÙˆØ§Øª DNA Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø®Ù„Ø§Ù„ Ø«ÙˆØ§Ù†Ù. Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¯Ø§ÙˆÙ„ (Soulbound)ØŒ ÙˆÙŠÙ…ÙƒÙ†Ùƒ Ù„Ø§Ø­Ù‚Ù‹Ø§ ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø¥Ù„Ù‰ CYCX Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ø¹Ø§Ù….",
access_foot: "ÙˆØµÙˆÙ„ Ù…Ø¨ÙƒØ±: 9$ Ù„Ø£ÙˆÙ„ 500 Ø¨Ø·Ø§Ù‚Ø© ÙˆØµÙˆÙ„ØŒ Ø«Ù… 19$. Ø¨Ø·Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø© Ù„ÙƒÙ„ Ù…Ø­ÙØ¸Ø©.",
    access_price_label: "Ø§Ù„Ø³Ø¹Ø±:",

    // rpc panel
    p_rpc_kicker: "ÙØ­Øµ ØµØ­Ø© RPC",
    p_rpc_title: "Ø§Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Endpoint",
    p_rpc_sub:
      "Ù†Ø®ØªØ¨Ø± RPC: Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© + chainId + Ø¨Ù„ÙˆÙƒ + eth_call + Ù‚Ø±Ø§Ø¡Ø© logs. ÙŠØªØ¶Ù…Ù† Ø§Ø®ØªØ¨Ø§Ø± logs Ù„Ù„Ù…Ø·ÙˆØ± ÙˆÙŠØ­ÙØ¸ Ø£ÙØ¶Ù„ RPC Ù…Ø­Ù„ÙŠØ§Ù‹.",
    rpc_inputs: "Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª",
    rpc_private_label: "RPC Ø®Ø§Øµ (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
    rpc_private_tip:
      "ØºÙŠØ± Ù…Ø¯Ù…Ø¬ ÙÙŠ HTML. Ù…Ø­ÙÙˆØ¸ ÙÙŠ Ù…ØªØµÙØ­Ùƒ ÙÙ‚Ø· (localStorage).",
    rpc_custom_label: "RPC Ù…Ø®ØµØµ (Ø£ÙˆÙ„ÙˆÙŠØ© Ø£Ø¹Ù„Ù‰)",
    rpc_test: "Ø§Ø®ØªØ¨Ø§Ø± RPCs",
    rpc_copy_best: "Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC",
    rpc_results: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
    rpc_tip:
      "Ù†ØµÙŠØ­Ø©: Ø¨Ø¹Ø¶ RPCs ØªÙØ´Ù„ Ø¨Ø³Ø¨Ø¨ CORS/Ù…Ù‡Ù„Ø©. Ø´ØºÙ‘Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ø®ØªØ± Ø§Ù„Ø£Ø³Ø±Ø¹ ÙˆØ§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªÙ‚Ø±Ø§Ø±Ø§Ù‹.",
    rpc_dev_title: "Ø§Ø®ØªØ¨Ø§Ø± logs Ù…Ø®ØµØµ Ù„Ù„Ù…Ø·ÙˆØ±",
    rpc_dev_hint:
      "Ø§Ø®ØªÙŠØ§Ø±ÙŠ: Ø§Ø®ØªØ¨Ø± logs Ù„Ø¹Ù‚Ø¯ Ù…Ø­Ø¯Ø¯ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ù€ RPC.",
    rpc_dev_addr: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¹Ù‚Ø¯ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    rpc_dev_topic: "Topic0 (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    rpc_dev_run: "ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±",

    // tx panel
    p_tx_kicker: "ÙÙƒ ØªØ´ÙÙŠØ± Tx",
    p_tx_title: "ÙÙƒ ØªØ´ÙÙŠØ± Ù…Ø¹Ø§Ù…Ù„Ø©",
    p_tx_sub:
      "Ø£Ù„ØµÙ‚ tx hash. Ù†Ø¬Ù„Ø¨ tx + receipt ÙˆÙ†ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© (Transfer / Approval + Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª swap).",
    tx_input_title: "Ø¥Ø¯Ø®Ø§Ù„ Tx",
    tx_hash_label: "Ù‡Ø§Ø´ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©",
    tx_tip:
      'Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.',
    tx_results_title: "Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª",

    // dev panel
    p_dev_kicker: "Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·ÙˆÙ‘Ø±",
    p_dev_title: "Bookmarklet + Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø­Ù„ÙŠØ©",
    p_dev_sub:
      "Ø£Ù†Ø´Ø¦ Bookmarklet ÙŠØ±Ø³Ù„ Ø§Ù„ØªÙˆÙƒÙ†/Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªÙƒØ´Ù Ø¥Ù„Ù‰ CycleX Hub. ÙˆÙŠØªØ¶Ù…Ù† Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ù‚Ø¯ Ù…Ø­Ù„ÙŠØ© (Ù‚Ø§Ø¦Ù…Ø© Ù…Ø­ÙÙˆØ¸Ø© ÙÙŠ Ù…ØªØµÙØ­Ùƒ).",
    bm_title: "Ù…ÙˆÙ„Ù‘Ø¯ Bookmarklet",
    bm_hint:
      "Ø§Ø³Ø­Ø¨ Ø¥Ù„Ù‰ Ø´Ø±ÙŠØ· Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø£Ùˆ Ø§Ù†Ø³Ø® Ø§Ù„Ù€ Bookmarklet. Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙŠ ØµÙØ­Ø§Øª BscScan/Etherscan.",
    bm_base_label: "Ø±Ø§Ø¨Ø· Hub (Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©)",
    bm_generate: "Ø¥Ù†Ø´Ø§Ø¡",
    bm_copy: "Ù†Ø³Ø® Bookmarklet",

    mon_add_title: "Ø¥Ø¶Ø§ÙØ© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©",
    mon_list_title: "Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù‚ÙˆØ¯ (Ù…Ø­Ù„ÙŠ)",
    mon_list_hint: "Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙ‚Ø·. Ø¨Ø¯ÙˆÙ† ØªØªØ¨Ø¹ Ø³ÙŠØ±ÙØ±.",
    mon_add: "Ø¥Ø¶Ø§ÙØ©",
    mon_check: "ÙØ­Øµ Ø§Ù„ÙƒÙ„",
    mon_export: "Ù†Ø³Ø® JSON",

    // footer
    footer_left:
      "CycleX Security Hub ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆÙŠÙ‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
    footer_tagline: "ØªØ­Ù‚Ù‚ Ù…Ø±ØªÙŠÙ†. Ù„Ø§ ØªØªØµÙ„ Ø¥Ù„Ø§ Ø¹Ù†Ø¯Ù…Ø§ ØªØ«Ù‚ Ø¨Ø§Ù„ØµÙØ­Ø©.",
    // --- ADD THESE KEYS (AR) ---
title_back_to_cyclex: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ CycleX",
aria_lang_selector: "Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©",
badge_table: "Ø¬Ø¯ÙˆÙ„",
btn_share_x: "Ù…Ø´Ø§Ø±ÙƒØ© Ø¹Ù„Ù‰ X",
btn_share_tg: "Ù…Ø´Ø§Ø±ÙƒØ© Ø¹Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ø¥ÙŠØ«Ø±ÙŠÙˆÙ…",
spender_pcs_router: "Ø±Ø§ÙˆØªØ± PancakeSwap (BSC)",
spender_uni_router: "Ø±Ø§ÙˆØªØ± Uniswap V2 (ETH)",
spender_custom: "Ù…Ø®ØµØµâ€¦",

th_token: "Ø§Ù„ØªÙˆÙƒÙ†",
th_allowance: "Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©",
th_symbol: "Ø§Ù„Ø±Ù…Ø²",
th_action: "Ø¥Ø¬Ø±Ø§Ø¡",
th_rpc: "RPC",
th_ms: "Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©",
th_chain: "Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
th_block: "Ø¨Ù„ÙˆÙƒ",
th_call: "Ø§Ø³ØªØ¯Ø¹Ø§Ø¡",
th_logs: "Ø³Ø¬Ù„Ø§Øª",
th_status: "Ø§Ù„Ø­Ø§Ù„Ø©",
th_contract: "Ø§Ù„Ø¹Ù‚Ø¯",
th_network: "Ø§Ù„Ø´Ø¨ÙƒØ©",
th_last_seen: "Ø¢Ø®Ø± Ø¸Ù‡ÙˆØ±",
    th_remove: "Ø¥Ø²Ø§Ù„Ø©",
    bm_tip: "Ø£Ø¶ÙÙ Ø£Ø¯Ø§Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ù…Ø±Ø¬Ø¹ÙŠØ© Ø¥Ù„Ù‰ Ù…ØªØµÙØ­ÙƒØŒ Ø«Ù… Ø§ÙØ­Øµ Ø£ÙŠ Ø¹Ù‚Ø¯ Ù…Ù† Ø£ÙŠ Ù…ÙˆÙ‚Ø¹ Ø¨Ù†Ù‚Ø±Ø© ÙˆØ§Ø­Ø¯Ø©.",
bm_drag_label: "CycleX â€“ Ù…Ø±ÙƒØ² Ø§Ù„Ø£Ù…Ø§Ù†",

qs_ready_html: "<strong>Ø¬Ø§Ù‡Ø².</strong><br>Ø£Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ† Ø«Ù… Ø§Ø¶ØºØ· <b>ÙØ­Øµ</b>.",
liq_ready_html: "<strong>Ø¬Ø§Ù‡Ø².</strong><br>Ø£Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ† Ø«Ù… Ø§Ø¶ØºØ· <b>ÙØ­Øµ</b>.",
tx_ready_html: "<strong>Ø¬Ø§Ù‡Ø².</strong><br>Ø£Ù„ØµÙ‚ tx hash Ø«Ù… Ø§Ø¶ØºØ· <b>ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "Ù…ÙØªØ§Ø­ BscScan API (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
ph_unified_key: "Unified API Key (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
ph_etherscan_key: "Ù…ÙØªØ§Ø­ Etherscan API (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
ph_rpc_private: "https://... (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙ‚Ø·)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) Ø£Ùˆ Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹"

  },

  ru: {
    // header / hero
    brand_sub: "ĞĞ½Ñ‡ĞµĞ¹Ğ½ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ¸ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñ‹",
    hero_kicker: "Ğ¦ĞµĞ½Ñ‚Ñ€ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ CycleX",
    hero_title: "ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸",
    hero_subtitle: "ĞŸĞ¾Ğ½Ğ¸Ğ¼Ğ°Ğ¹Ñ‚Ğµ ÑĞ²Ğ¾Ğ¸ approvals, Ğ²Ñ‹ÑĞ²Ğ»ÑĞ¹Ñ‚Ğµ Ñ€Ğ¸ÑĞºĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… spenderâ€™Ğ¾Ğ² Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ revoke â€” Ğ´Ğ»Ñ BSC Ğ¸ Ethereum.",
    btn_back: "ĞĞ°Ğ·Ğ°Ğ´ Ğ½Ğ° ÑĞ°Ğ¹Ñ‚",
    btn_firewall: "Ğ¤Ğ°Ğ¹Ñ€Ğ²Ğ¾Ğ»",
    fw_hero_btn: "ğŸ›¡ï¸ CycleX Firewall â€” Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº",
    fw_hero_tagline: "Ğ¡ĞºĞ°Ğ½ĞµÑ€ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ° Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ â€” Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ°Ğ¿Ñ€ÑƒĞ²Ñ‹, Ğ²Ñ‹ÑĞ²Ğ»ÑĞµÑ‚ Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğµ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñ‹ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ <em>Ğ¶Ğ¸Ğ²Ñ‹Ğµ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ñ</em>. ĞŸĞ°ÑĞ¿Ğ¾Ñ€Ñ‚ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ° Â· Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¿Ñ€Ğ°Ğ² Â· ĞÑ‚Ğ·Ñ‹Ğ² Ğ² Ğ¾Ğ´Ğ¸Ğ½ ĞºĞ»Ğ¸Ğº. Ğ’Ğ°ÑˆĞ¸ ĞºĞ»ÑÑ‡Ğ¸ â€” Ğ²ÑĞµĞ³Ğ´Ğ° Ğ² Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸.",
    hub_title: "ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸",
    hub_subtitle: "Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ÑĞºĞ°Ğ½ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ², Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° RPC, Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹ Ğ¸ dev-Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ â€” Ğ²ÑÑ‘ Ğ½Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğµ, ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½.",

    btn_access: "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ (PASS / CYCX)",
    wallet_not_connected: "Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½",
    btn_quick: "Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ÑĞºĞ°Ğ½",
    hero_note: "ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ğµ: ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ½Ğ¾ÑÑÑ‚ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ñ…Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€ Ğ¸ Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒÑÑ‚ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ. Ğ‘ĞµĞ· Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞµĞ¹. Ğ‘ĞµĞ· Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñ‹ Ğ¸ ÑÑÑ‹Ğ»ĞºĞ¸ (URL) ÑĞ°Ğ¼Ğ¾ÑÑ‚Ğ¾ÑÑ‚ĞµĞ»ÑŒĞ½Ğ¾.",
    hero_micro_quick: "ĞĞ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ğ·Ğ´ĞµÑÑŒ â€” ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½.",
    hero_micro_access: "ĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· approvals + Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ revoke.",

    tools_kicker: "Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞœĞ•ĞĞ¢",

    // tiles
    cube_quick_title: "Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ÑĞºĞ°Ğ½",
    cube_quick_desc: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¾ĞºĞµĞ½Ğ° + ÑˆĞ°Ñ€Ğ¸Ğ¼Ñ‹Ğ¹ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ + ĞºÑÑˆ.",
    cube_liq_title: "Ğ¢Ğ¾ĞºĞµĞ½ + Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ",
    cube_liq_desc: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° DEX (Pancake/Uni): Ñ‚Ğ¾ĞºĞµĞ½ vs WBNB/WETH Ğ¸ USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc:
      "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ·Ñ‹Ğ² ERC-20 allowance (approve â†’ 0).",
    cube_rpc_title: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° RPC",
    cube_rpc_desc:
      "Latency + chainId + block + eth_call + Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ logs + dev custom test.",
    cube_tx_title: "Ğ”ĞµĞºĞ¾Ğ´ĞµÑ€ Tx",
    cube_tx_desc:
      "Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€ÑƒĞµÑ‚ input Ğ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ (Transfer/Approval) Ğ¿Ğ¾ tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc:
      "Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ bookmarklet + Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ¾Ğ² (Ğ±ĞµĞ· ÑĞµÑ€Ğ²ĞµÑ€Ğ°).",
    cube_walletdna_title: "Security DNA ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ°",
    cube_walletdna_desc: "Ğ¡Ğ½Ğ¸Ğ¼Ğ¾Ğº Ñ€Ğ¸ÑĞºĞ¾Ğ² Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ¸Ğ¹ Ğ¸ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ â€” ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚",

    // tile badges
    badge_fast: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾",
    badge_share: "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ",
    badge_cache: "ĞšÑÑˆ",
    badge_dex: "DEX",
    badge_pairs: "ĞŸĞ°Ñ€Ñ‹",
    badge_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
    badge_safe: "Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾",
    badge_copy: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",
    badge_safe: "Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾",

    // generic
    pill_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
    btn_close: "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
    btn_save: "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ",
    btn_clear: "ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ",
    btn_scan: "Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
    btn_decode: "Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
    btn_copy_md: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Markdown",
    btn_copy_link: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
    btn_copy_json: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ JSON",
    btn_copy_xtext: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚ Ğ´Ğ»Ñ X",

    // quick panel
    p_quick_kicker: "Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ÑĞºĞ°Ğ½",
    p_quick_title: "ĞÑ†ĞµĞ½Ğ¸Ñ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½ Ğ·Ğ° ÑĞµĞºÑƒĞ½Ğ´Ñ‹",
    p_quick_sub:
      "Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ°Ğ´Ñ€ĞµÑ Ñ‚Ğ¾ĞºĞµĞ½Ğ° Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ ÑĞºĞ°Ğ½. ĞšÑÑˆ 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚ Â· ÑˆĞ°Ñ€Ğ¸Ğ½Ğ³ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ğ°.",
    quick_input_title: "Ğ’Ğ²Ğ¾Ğ´ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
    net_label: "Ğ¡ĞµÑ‚ÑŒ",
    addr_label: "ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
    qs_tip:
      'Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ <span class="mono">?tool=quick&net=bsc&token=0x...</span> Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾-ÑÑ‚Ğ°Ñ€Ñ‚Ğ° (Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾).',
    options_label: "ĞĞ¿Ñ†Ğ¸Ğ¸",
    opt_require_liq: "Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ (ÑÑ‚Ñ€Ğ¾Ğ¶Ğµ)",
    opt_show_json: "Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ JSON Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ (ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ)",
    api_keys_label: "API ĞºĞ»ÑÑ‡Ğ¸ Explorer (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
    opt_use_explorer_apis:
      "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ BscScan/Etherscan (Verified + ABI ÑĞ²Ñ€Ğ¸ÑÑ‚Ğ¸ĞºĞ¸)",
    api_keys_tip:
      "ĞšĞ»ÑÑ‡Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑÑÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ² Ğ²Ğ°ÑˆĞµĞ¼ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ (localStorage). ĞĞµ Ğ²ÑÑ‚Ğ°Ğ²Ğ»ÑĞ¹Ñ‚Ğµ ĞºĞ»ÑÑ‡Ğ¸ Ğ² Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ HTML.",
    results_title: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
    results_hint:
      "Ğ—ĞµĞ»Ñ‘Ğ½Ñ‹Ğµ / Ğ¶Ñ‘Ğ»Ñ‚Ñ‹Ğµ / ĞºÑ€Ğ°ÑĞ½Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹. Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ â€” Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼Ñ‹Ğµ Ğ¾Ğ½Ñ‡ĞµĞ¹Ğ½-Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸.",

    // liquidity panel
    p_liq_kicker: "Ğ¢Ğ¾ĞºĞµĞ½ + Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ",
    p_liq_title: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚Ğ¸ DEX",
    p_liq_sub:
      "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºĞ¸. ĞŸĞ°Ñ€Ñ‹: Ñ‚Ğ¾ĞºĞµĞ½ vs WBNB/WETH Ğ¸ Ñ‚Ğ¾ĞºĞµĞ½ vs USDT.",
    liq_input_title: "Ğ¢Ğ¾ĞºĞµĞ½ + ÑĞµÑ‚ÑŒ",
    liq_tip:
      'Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ <span class="mono">?tool=liq&net=bsc&token=0x...</span> Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾-ÑÑ‚Ğ°Ñ€Ñ‚Ğ°.',
    liq_dex_label: "DEX Ñ€ĞµĞµÑÑ‚Ñ€ (Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ÑÑ)",
    liq_results_title: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚Ğ¸",
    liq_results_hint:
      "V2: Ğ¿Ğ°Ñ€Ğ° + snapshot Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¾Ğ². V3: Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° + liquidity() + slot0/tick snapshot.",

    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ² allowance",
    p_app_sub:
      "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ spender + Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ (Ğ¸Ğ»Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ). Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ allowance(owner, spender) Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· approve(spender, 0).",
    ap_settings_title: "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸",
    ap_connected: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾:",
    ap_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ / ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "ĞĞ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ñ Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ğ°, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ¸.",
    ap_tokens_label: "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² (Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ)",
    ap_seed: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹",
    ap_seed_history: "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞºĞ°Ğ½Ğ¾Ğ²",
    ap_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ allowance",
    ap_revoke_all: "ĞÑ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ (Ğ½ĞµĞ½ÑƒĞ»ĞµĞ²Ñ‹Ğµ)",
    ap_results: "Allowances",
    ap_results_hint:
      "Ğ•ÑĞ»Ğ¸ allowance â€œĞ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹â€, Ğ»ÑƒÑ‡ÑˆĞµ Ğ¾Ñ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ, ĞµÑĞ»Ğ¸ Ğ²Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ spender.",
    safe_mode_note:
      "Safe mode: Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ, Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒ, Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ñ‹ Ğ´Ğ¾ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ°.",
    // DNA (Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ°)
p_dna_kicker: "Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞĞ¡Ğ¢Ğ¬ ĞšĞĞ¨Ğ•Ğ›Ğ¬ĞšĞ DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Ğ¡Ğ½Ğ¸Ğ¼Ğ¾Ğº Ñ€Ğ¸ÑĞºĞ¾Ğ² Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ Ğ¸ Ğ¿Ñ€Ğ°Ğ²",

pill_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
wallet_not_connected: "Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½",
btn_close: "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",

dna_controls_title: "DNA-ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
dna_wallet_address_label: "ĞĞ´Ñ€ĞµÑ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ°",
dna_wallet_address_ph: "0x... (Ğ½ĞµĞ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾, ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº)",
dna_wallet_address_tip: "ĞœĞ¾Ğ¶Ğ½Ğ¾ ÑĞ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ Ğ°Ğ´Ñ€ĞµÑÑƒ. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°Ğ¹Ñ‚Ğµ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ³Ğ´Ğ° Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ.",

net_label: "Ğ¡ĞµÑ‚ÑŒ",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾:",
dna_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº",
dna_run: "Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
dna_reset: "Ğ¡Ğ±Ñ€Ğ¾Ñ",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "ĞÑ†ĞµĞ½ĞºĞ° â€” ÑÑ‚Ğ¾ ÑĞ½Ğ¸Ğ¼Ğ¾Ğº. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ´ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒÑ.",

dna_score: "ĞÑ†ĞµĞ½ĞºĞ°",
dna_risk_level: "Ğ Ğ¸ÑĞº",

dna_tips_title: "Ğ¡Ğ¾Ğ²ĞµÑ‚Ñ‹",
dna_tips_placeholder: "â€”",
dna_share: "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ñ†ĞµĞ½ĞºĞ¾Ğ¹",

dna_allowances_title: "Ğ Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ",
dna_table_note: "Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ â€œĞ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğµâ€ approvals, ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ Ğ¸Ğ¼ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ. Verified Ğ¸ Flags â€” Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞ¿Ñ€Ğ°Ğ²Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ.",
dna_full_access_btn: "ĞĞ¢ĞšĞ Ğ«Ğ¢Ğ¬ Ğ ĞĞ¡Ğ¨Ğ˜Ğ Ğ•ĞĞĞĞ• (PASS / CYCX)",
    dna_locked_title: "Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ, ĞºÑ‚Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ñ‚Ñ€Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ²Ğ°ÑˆĞ¸ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ â€” Ğ¸ Ğ¾Ñ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ² 1 ĞºĞ»Ğ¸Ğº.",
    dna_locked_body: "ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ (Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ spender + Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°) Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ´Ğ»Ñ:",
    dna_locked_body_fp: "Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†ĞµĞ² Founder Pass",
    dna_locked_body_cycx: "Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†ĞµĞ² CYCX (Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°).",
    dna_locked_safe_title: "Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°:",
    dna_locked_safe_body:
      "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ (Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ñ€ĞµÑ + on-chain Ğ±Ğ°Ğ»Ğ°Ğ½Ñ).<br>" +
      "<span style=\"font-weight:750;\">Ğ‘ĞµĞ· Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸. Ğ‘ĞµĞ· Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹.</span><br>" +
      "ĞœÑ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ğ±Ğ»Ğ¾ĞºÑ‡ĞµĞ¹Ğ½Ğ°. Ğ›ÑĞ±Ğ¾Ğ¹ revoke Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ ÑĞ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ² ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞµ.",
    dna_locked_cta: "Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ²ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚: Ğ¿Ğ¾ĞºĞ°Ğ· spender, ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ revoke Ğ¸ Revoke All (non-zero).",
    dna_elig_checking: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° (PASS / CYCX)â€¦",
    dna_elig_ok: "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ñ€Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½ â€” Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ approvals",
    dna_elig_no: "ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ½Ğ° Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ (Ğ½ÑƒĞ¶ĞµĞ½ 1 PASS Ğ¸Ğ»Ğ¸ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ 100 CYCX).",
    dna_elig_wrong_net: "ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ĞµÑÑŒ Ğ½Ğ° BSC (BNB Chain), Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¾ PASS / CYCX.",
    dna_elig_error: "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.",
    dna_meta_approvals_detected: "ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹:",
dna_meta_spenders_hidden: "Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ spender ÑĞºÑ€Ñ‹Ñ‚Ñ‹ Ğ´Ğ¾ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸",

    access_title: "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿",
access_note: "Ğ”Ğ»Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒ Ğ½Ğµ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ. Ğ›ÑĞ±Ğ¾Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Revoke Ğ²ÑĞµĞ³Ğ´Ğ° Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ² ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞµ.",
access_pay_bnb: "ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ access pass (BNB)",
access_pay_usdt: "ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ access pass (USDT)",
access_desc: "Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ DNA Ğ·Ğ° ÑĞµĞºÑƒĞ½Ğ´Ñ‹. Ğ’Ğ°Ñˆ Access Pass Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‘Ñ‚ÑÑ (soulbound), Ğ° Ğ¿Ğ¾Ğ·Ğ¶Ğµ Ğ²Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞµĞ³Ğ¾ Ğ² CYCX, ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğ°Ñ‡Ğ½Ñ‘Ñ‚ÑÑ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ°.",
access_foot: "Ğ Ğ°Ğ½Ğ½Ğ¸Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿: $9 Ğ·Ğ° Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ 500 Access Pass, Ğ·Ğ°Ñ‚ĞµĞ¼ $19. 1 pass Ğ½Ğ° ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº.",
    access_price_label: "Ğ¦ĞµĞ½Ğ°:",

    // rpc panel
    p_rpc_kicker: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° RPC",
    p_rpc_title: "ĞĞ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ endpoint",
    p_rpc_sub:
      "Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ RPC: latency + chainId + block + eth_call + Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ logs. Ğ•ÑÑ‚ÑŒ dev custom logs test, Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ÑÑ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾.",
    rpc_inputs: "Ğ’Ğ²Ğ¾Ğ´",
    rpc_private_label: "ĞŸÑ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ñ‹Ğ¹ RPC (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾)",
    rpc_private_tip:
      "ĞĞµ Ğ²ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ğ² HTML. Ğ¥Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ² Ğ²Ğ°ÑˆĞµĞ¼ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ (localStorage).",
    rpc_custom_label: "ĞšĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ñ‹Ğ¹ RPC (Ğ²Ñ‹ÑÑˆĞ¸Ğ¹ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚)",
    rpc_test: "Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ RPC",
    rpc_copy_best: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC",
    rpc_results: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
    rpc_tip:
      "Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ RPC Ğ¿Ğ°Ğ´Ğ°ÑÑ‚ Ğ¸Ğ·-Ğ·Ğ° CORS/timeout. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ñ‚ĞµÑÑ‚ Ğ¸ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹.",
    rpc_dev_title: "Dev custom logs test",
    rpc_dev_hint:
      "ĞĞ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾: Ñ‚ĞµÑÑ‚ logs Ğ¿Ğ¾ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ RPC.",
    rpc_dev_addr: "ĞĞ´Ñ€ĞµÑ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ° (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
    rpc_dev_topic: "Topic0 (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
    rpc_dev_run: "Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ñ‚ĞµÑÑ‚",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ",
    p_tx_sub:
      "Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ tx hash. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ğ¼ tx + receipt Ğ¸ Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ input Ğ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ (Transfer / Approval + Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ swap Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹).",
    tx_input_title: "Ğ’Ğ²Ğ¾Ğ´ Tx",
    tx_hash_label: "Ğ¥ÑÑˆ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸",
    tx_tip:
      'Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾-ÑÑ‚Ğ°Ñ€Ñ‚Ğ°.',
    tx_results_title: "Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ²Ğ¾Ğ´",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€",
    p_dev_sub:
      "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ bookmarklet, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ token/tx ÑĞ¾ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ† explorer Ğ² CycleX Hub. Ğ¢Ğ°ĞºĞ¶Ğµ ĞµÑÑ‚ÑŒ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ¾Ğ² (ÑĞ¿Ğ¸ÑĞ¾Ğº Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ).",
    bm_title: "Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Bookmarklet",
    bm_hint:
      "ĞŸĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ Ğ² Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ·Ğ°ĞºĞ»Ğ°Ğ´Ğ¾Ğº Ğ¸Ğ»Ğ¸ ÑĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ bookmarklet. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ½Ğ° BscScan/Etherscan.",
    bm_base_label: "Hub URL (ÑÑ‚Ğ° ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°)",
    bm_generate: "Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
    bm_copy: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Bookmarklet",

    mon_add_title: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº",
    mon_list_title: "ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ¾Ğ² (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾)",
    mon_list_hint: "Ğ¥Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾. Ğ‘ĞµĞ· ÑĞµÑ€Ğ²ĞµÑ€Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ°.",
    mon_add: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
    mon_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ",
    mon_export: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ JSON",

    // footer
    footer_left:
      "CycleX Security Hub Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ½Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğµ Ğ¸ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¾Ğ½Ñ‡ĞµĞ¹Ğ½-Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.",
    footer_tagline: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°Ğ¹Ñ‚ĞµÑÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ.",
    // --- ADD THESE KEYS (RU) ---
title_back_to_cyclex: "ĞĞ°Ğ·Ğ°Ğ´ Ğº CycleX",
aria_lang_selector: "Ğ’Ñ‹Ğ±Ğ¾Ñ€ ÑĞ·Ñ‹ĞºĞ°",
badge_table: "Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°",
btn_share_x: "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ² X",
btn_share_tg: "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ² Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ğ­Ñ„Ğ¸Ñ€Ğ¸ÑƒĞ¼",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğ¹â€¦",

th_token: "Ğ¢Ğ¾ĞºĞµĞ½",
th_allowance: "Ğ›Ğ¸Ğ¼Ğ¸Ñ‚",
th_symbol: "Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ»",
th_action: "Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ",
th_rpc: "RPC",
th_ms: "Ğ¼Ñ",
th_chain: "ÑĞµÑ‚ÑŒ",
th_block: "Ğ±Ğ»Ğ¾Ğº",
th_call: "call",
th_logs: "Ğ»Ğ¾Ğ³Ğ¸",
th_status: "ÑÑ‚Ğ°Ñ‚ÑƒÑ",
th_contract: "ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚",
th_network: "Ğ¡ĞµÑ‚ÑŒ",
th_last_seen: "ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ñ€Ğ°Ğ·",
th_remove: "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ",
    bm_tip: "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ±ÑƒĞºĞ¼Ğ°Ñ€ĞºĞ»ĞµÑ‚ Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ»ÑĞ±Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ Ñ Ğ»ÑĞ±Ğ¾Ğ³Ğ¾ ÑĞ°Ğ¹Ñ‚Ğ° Ğ¾Ğ´Ğ½Ğ¸Ğ¼ ĞºĞ»Ğ¸ĞºĞ¾Ğ¼.",
bm_drag_label: "CycleX â€“ Security Hub",

qs_ready_html: "<strong>Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾.</strong><br>Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ°Ğ´Ñ€ĞµÑ Ñ‚Ğ¾ĞºĞµĞ½Ğ° Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ <b>Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ</b>.",
liq_ready_html: "<strong>Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾.</strong><br>Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ°Ğ´Ñ€ĞµÑ Ñ‚Ğ¾ĞºĞµĞ½Ğ° Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ <b>Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ</b>.",
tx_ready_html: "<strong>Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾.</strong><br>Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ tx hash Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ <b>Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾)",
ph_unified_key: "Unified API Key (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾)",
ph_etherscan_key: "Etherscan API key (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾)",
ph_rpc_private: "https://... (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) Ğ¸Ğ»Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼"

  }

};
// =========================
// i18n (after translations)
// =========================
let currentLang = "en";
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

function normalizeLang(x){
  const v = String(x || "").trim().toLowerCase();
  const map = { "cn":"zh", "zh-cn":"zh", "zh-hans":"zh" };
  return map[v] || v;
}

function setDirForLang(lang) {
  const html = document.documentElement;
  html.setAttribute("lang", lang === "zh" ? "zh" : lang);
  html.setAttribute("dir", lang === "ar" ? "rtl" : "ltr");
}

// âœ… t(lang,key) with EN fallback
function t(lang, key) {
  return (translations?.[lang]?.[key] ?? translations?.en?.[key] ?? "");
}

function applyI18n(lang) {
  const L = normalizeLang(lang || currentLang);
  currentLang = translations?.[L] ? L : "en";

  if (document.body) {
    document.body.classList.add("lang-switching");
    setTimeout(() => document.body && document.body.classList.remove("lang-switching"), 260);
  }

  // normal text/HTML
  $$("[data-i18n]").forEach((el) => {
    const key = el.getAttribute("data-i18n");
    const val = t(currentLang, key);
    if (val) el.innerHTML = val;
  });

  // placeholders
  $$("[data-i18n-placeholder]").forEach((el) => {
    const key = el.getAttribute("data-i18n-placeholder");
    const val = t(currentLang, key);
    if (val) el.setAttribute("placeholder", val);
  });

  // title attr
  $$("[data-i18n-title]").forEach((el) => {
    const key = el.getAttribute("data-i18n-title");
    const val = t(currentLang, key);
    if (val) el.setAttribute("title", val);
  });

  // aria-label attr
  $$("[data-i18n-aria-label]").forEach((el) => {
    const key = el.getAttribute("data-i18n-aria-label");
    const val = t(currentLang, key);
    if (val) el.setAttribute("aria-label", val);
  });

  setDirForLang(currentLang);

  // keep your existing behavior
  try { renderWalletLabels && renderWalletLabels(); } catch {}
}

function setLang(lang) {
  const picked = normalizeLang(lang);
  currentLang = translations?.[picked] ? picked : "en";

  try { localStorage.setItem("cx_sec_lang", currentLang); } catch {}

  $$(".lang-btn").forEach((b) => {
    const bl = normalizeLang(b.dataset?.lang || b.getAttribute("data-lang") || "");
    b.classList.toggle("active", bl === currentLang);
  });

  applyI18n(currentLang);
}

function initLang() {
  let saved = null;
  try { saved = localStorage.getItem("cx_sec_lang"); } catch {}

  const s = normalizeLang(saved);
  setLang(translations?.[s] ? s : "en");
}

// =========================
// i18n buttons wiring (FIX)
// =========================
function bindLangButtons(){
  $$(".lang-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      try { e.preventDefault(); } catch {}

      const raw = btn.dataset?.lang || btn.getAttribute("data-lang") || "";
      const lang = normalizeLang(raw);

      setLang(lang);
      try { gtagEvent && gtagEvent("sec_lang_change", { lang }); } catch {}
    }, { passive: false });
  });
}
    // =========================
    // Utils (dedup, single source of truth)

    // =========================
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const nowTs = () => Math.floor(Date.now() / 1000);

    const DEAD = "0x000000000000000000000000000000000000dEaD";
    const ZERO = "0x0000000000000000000000000000000000000000";

    function shortAddr(a) {
      return (!a || typeof a !== "string") ? "â€”" : `${a.slice(0, 6)}â€¦${a.slice(-4)}`;
    }
    function safeJson(obj) {
      try { return JSON.stringify(obj, null, 2); } catch { return "{}"; }
    }
    function isAddr(x){
      try { return E.isAddress(String(x||"").trim()); } catch { return false; }
    }
    function normAddr(x){
      return E.getAddress(String(x||"").trim());
    }
    function isBurnAddr(a){
      if (!a) return false;
      const z = String(a).toLowerCase();
      return z === ZERO.toLowerCase() || z === DEAD.toLowerCase();
    }
    function dnaFormatLastUpdated(ts) {
  const s = String(ts ?? "").trim();
  if (!s || s === "â€”") return `<span class="muted">â€”</span>`;

  const d = new Date(s);
  if (!isNaN(d.getTime())) {
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mi = String(d.getMinutes()).padStart(2, "0");
    const nice = `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    return `<span class="mono" title="${window.escapeHtml(s)}">${window.escapeHtml(nice)}</span>`;
  }

  return `<span class="mono">${window.escapeHtml(s)}</span>`;
}


    async function copyText(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
          return true;
        } catch {
          return false;
        }
      }
    }
    
    function setStatus(el, type, html) {
      if (!el) return;
      el.classList.remove("ok", "warn", "bad", "info");
      el.classList.add(type);
      el.style.display = "block";
      el.innerHTML = html;
    }
    function clearStatus(el) {
      if (!el) return;
      el.style.display = "none";
      el.innerHTML = "";
      el.classList.remove("ok", "warn", "bad", "info");
    }

    function gtagEvent(name, params = {}) {
      try { if (typeof window.gtag === "function") window.gtag("event", name, params); } catch {}
    }

    



// Wallet stub (read-only tools don't need full wallet)
const wallet = { providerRaw: null, browserProvider: null, signer: null, address: "", chainId: 0 };
window.wallet = wallet;
window.__wallet = wallet;
function renderWalletLabels() {}

    const CHAINS = {
     bsc: {
  chainId: 56,
  name: "BSC",
  wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  usdt: "0x55d398326f99059fF775485246999027B3197955",
  explorer: "https://bscscan.com",
  addressUrl: (a) => `https://bscscan.com/address/${a}`,
  txUrl: (h) => `https://bscscan.com/tx/${h}`,
  publicRpcs: [
    "https://bsc-dataseed.binance.org",
    "https://bsc-dataseed1.binance.org",
    "https://bsc-dataseed2.binance.org",
    "https://bsc-dataseed3.binance.org",
    "https://bsc-dataseed4.binance.org",
    "https://rpc.ankr.com/bsc",
    "https://bsc-rpc.publicnode.com",
    "https://bsc.meowrpc.com",
    "https://bsc.drpc.org",
    "https://binance.llamarpc.com",
    "https://1rpc.io/bnb",
    "https://bsc-mainnet.nodereal.io/v1/64a9df0874fb4a93b9d0a3849de012d3"
  ]
},


      eth: {
        chainId: 1,
        name: "Ethereum",
        wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        usdt: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        explorer: "https://etherscan.io",
        addressUrl: (a) => `https://etherscan.io/address/${a}`,
        txUrl: (h) => `https://etherscan.io/tx/${h}`,
        publicRpcs: [
  "https://ethereum-rpc.publicnode.com",
  "https://rpc.ankr.com/eth",
  "https://eth.llamarpc.com",
  "https://1rpc.io/eth",
  "https://eth.drpc.org",
  "https://cloudflare-eth.com",
  "https://eth.meowrpc.com",
  "https://rpc.mevblocker.io",
  "https://mainnet.gateway.tenderly.co"
]

      }
    };

    const DEX = {
      bsc: {
        v2Factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73",
        v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865",
        routerV2: "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        label: "PancakeSwap"
      },
      eth: {
        v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
        v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
        routerV2: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
        label: "Uniswap"
      }
    };

    // =========================
    // ABIs (minimal) â€” âœ… V3 token0/token1 added
    // =========================
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)"
    ];

    const V2_FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];
    const V2_PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const V3_FACTORY_ABI = [
      "function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)"
    ];
    const V3_POOL_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function liquidity() view returns (uint128)",
      "function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked)"
    ];

    const TRANSFER_TOPIC0 = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
    const APPROVAL_TOPIC0 = "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";

    // =========================
    // Local storage keys
    // =========================
    const LS_BEST_RPC = (net) => `cx_sec_best_rpc_${net}`;
    const LS_PRIV_RPC = (net) => `cx_sec_private_rpc_${net}`;
    const LS_QS_CACHE = "cx_sec_qs_cache_v2";
    const LS_QS_HISTORY = "cx_sec_qs_history_v1";
    const LS_MON = "cx_sec_monitor_v1";

    // =========================
    // Unified RPC layer (âœ… item #1 + #2)
    // =========================
    function uniq(arr) {
      const s = new Set();
      const out = [];
      for (const x of arr) {
        const k = String(x || "").trim();
        if (!k) continue;
        if (s.has(k)) continue;
        s.add(k);
        out.push(k);
      }
      return out;
    }

    function getSavedBestRpc(net) {
      try { return localStorage.getItem(LS_BEST_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedBestRpc(net, url) {
      try { localStorage.setItem(LS_BEST_RPC(net), url); } catch {}
    }

    function getSavedPrivateRpc(net) {
      try { return localStorage.getItem(LS_PRIV_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedPrivateRpc(net, url) {
      try { localStorage.setItem(LS_PRIV_RPC(net), url); } catch {}
    }

    async function rpcRequest(url, method, params = [], timeoutMs = 9000) {
      const ctrl = new AbortController();
      const tmr = setTimeout(() => ctrl.abort(), timeoutMs);
      const body = JSON.stringify({ jsonrpc: "2.0", id: 1, method, params });

      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body,
          signal: ctrl.signal
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const j = await res.json();
        if (j.error) throw new Error(j.error.message || "RPC error");
        return j.result;
      } finally {
        clearTimeout(tmr);
      }
    }

    function buildRpcCandidates(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const privSaved = getSavedPrivateRpc(net);
      const privInput = ($("#rpc-private")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      return uniq([custom, privInput, privSaved, bestSaved, ...(chain?.publicRpcs || [])]);
    }

    const _providerCache = new Map(); // key: net|url
    function getProviderForUrl(net, url){
  const key = `${net}|${url}`;
  if (_providerCache.has(key)) return _providerCache.get(key);

  const n = E.Network.from({
  name: CHAINS[net].name.toLowerCase(),
  chainId: CHAINS[net].chainId
});
const p = new E.JsonRpcProvider(url, n, { staticNetwork: n });


  _providerCache.set(key, p);
  return p;
}


    async function withRpcFallback(net, fn, { timeoutMs = 9500, preferUrls = null } = {}) {
      const urls = preferUrls && preferUrls.length ? preferUrls : buildRpcCandidates(net);
      let lastErr = null;
      for (const url of urls) {
        try {
          const provider = getProviderForUrl(net, url);
          const res = await Promise.race([
            fn(provider, url),
            new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), timeoutMs))
          ]);
          return { ok: true, url, res };
        } catch (e) {
          lastErr = e;
          continue;
        }
      }
      return { ok: false, url: "", err: lastErr || new Error("All RPCs failed") };
    }

    async function getCodeSafe(net, addr){
      const a = normAddr(addr);
      // Use raw eth_getCode (faster + abortable) with fallback
      const urls = buildRpcCandidates(net);
      let last = null;
      for (const url of urls) {
        try {
          const code = await rpcRequest(url, "eth_getCode", [a, "latest"], 9000);
          if (typeof code === "string") {
            // mark as â€œbestâ€ if it works well
            return { ok: true, url, code };
          }
        } catch (e) { last = e; }
      }
      return { ok: false, url: "", err: last || new Error("eth_getCode failed"), code: "0x" };
    }

function getReadProvider(net) {
  const chain = CHAINS?.[net];
  if (!chain || typeof E === "undefined" || !E?.JsonRpcProvider) return null;

  const custom = ($("#rpc-custom")?.value || "").trim();
  const bestSaved = (typeof getSavedBestRpc === "function") ? (getSavedBestRpc(net) || "").trim() : "";
  const privSaved = (typeof getSavedPrivateRpc === "function") ? (getSavedPrivateRpc(net) || "").trim() : "";

  // priority:
  // 1) custom (input)
  // 2) private saved
  // 3) best saved
  // 4) first public fallback
  const candidates = [];
  if (custom) candidates.push(custom);
  if (privSaved) candidates.push(privSaved);
  if (bestSaved) candidates.push(bestSaved);

  const list = Array.isArray(chain.publicRpcs) ? chain.publicRpcs : [];
  for (const u of list) {
    if (u && !candidates.includes(u)) candidates.push(u);
  }

  const first = candidates[0] || "";
  if (!first) return null;

  try {
    const p = new E.JsonRpcProvider(first, chain.chainId);
    p.__cxCandidates = candidates;
    return p;
  } catch {
    return null;
  }
}


window.CX = window.CX || {};
window.CX.getReadProvider = getReadProvider;

window.getReadProvider = getReadProvider;


    function netFromSelect(selId) {
      const v = ($(selId)?.value || "bsc").toLowerCase();
      return (v === "eth") ? "eth" : "bsc";
    }

    // =========================
    // Explorer API (optional)
    // =========================
    function explorerApiBase(net) {
  return net === "bsc" ? "https://api.bscscan.com/api" : "https://api.etherscan.io/api";
}

async function explorerGetSource(net, addr, apiKey, isUnified) {
  const keyTrim = String(apiKey || "").trim();

  const v2Base = "https://api.etherscan.io/v2/api";
  const chainid = (net === "bsc") ? "56" : "1"; 

  const useV2 = !!isUnified; 

  const u = new URL(useV2 ? v2Base : explorerApiBase(net));
  if (useV2) u.searchParams.set("chainid", chainid);

  u.searchParams.set("module", "contract");
  u.searchParams.set("action", "getsourcecode");
  u.searchParams.set("address", addr);
  if (keyTrim) u.searchParams.set("apikey", keyTrim);

  const r = await fetch(u.toString());
  const j = await r.json().catch(() => null);
  if (!j || j.status !== "1" || !j.result || !j.result[0]) return { ok: false, raw: j };

  const row = j.result[0];

  const abiRaw = String(row.ABI || "").trim();
  const isVerified =
    !!abiRaw &&
    abiRaw !== "Contract source code not verified" &&
    abiRaw !== "[]" &&
    abiRaw.startsWith("[");

  let abiJson = null;
  if (isVerified) {
    try { abiJson = JSON.parse(abiRaw); } catch { abiJson = null; }
  }

  const isProxy = String(row.Proxy || row.proxy || "").trim() === "1";
  const impl = String(row.Implementation || row.implementation || "").trim();
  const contractName = String(row.ContractName || row.contractName || "").trim();

  return {
    ok: true,
    verified: isVerified,
    abi: abiJson,
    isProxy,
    implementation: impl,
    contractName,
    raw: row
  };
}


window.CX = window.CX || {};
window.CX.getReadProvider = getReadProvider;

window.getReadProvider = getReadProvider;



    // =========================
    // Explorer API keys (local)
    // =========================
    const LS_KEYS = "cx_sec_explorer_keys";
    function loadApiKeys() {
    try {
    const raw = localStorage.getItem(LS_KEYS);
    if (!raw) return { use: false, unified: "", bscscan: "", etherscan: "" };

    const o = JSON.parse(raw) || {};
    return {
      use: !!o.use,
      unified: String(o.unified || "").trim(),
      bscscan: String(o.bscscan || "").trim(),
      etherscan: String(o.etherscan || "").trim()
    };
  } catch {
    return { use: false, unified: "", bscscan: "", etherscan: "" };
  }
}

    function saveApiKeys(keys) {
  try { localStorage.setItem(LS_KEYS, JSON.stringify(keys || {})); } catch {}
}
    
    function initApiKeysUi() {
      const keys = loadApiKeys();
      const useEl = $("#api-use"); if (useEl) useEl.checked = keys.use;
      const b1 = $("#api-bscscan"); if (b1) b1.value = keys.bscscan;
      const b2 = $("#api-etherscan"); if (b2) b2.value = keys.etherscan;
      const u1 = $("#api-unified"); if (u1) u1.value = keys.unified || "";

      // API network selector â€” shows correct input
      const sel = $("#api-key-select");
      const inputs = {
        bscscan: $("#api-bscscan"),
        unified: $("#api-unified"),
        etherscan: $("#api-etherscan")
      };
      function showApiInput(which) {
        Object.entries(inputs).forEach(([k, el]) => {
          if (el) el.style.display = k === which ? "" : "none";
        });
      }
      if (sel) {
        sel.addEventListener("change", () => showApiInput(sel.value));
        showApiInput(sel.value);
      }

      $("#api-save")?.addEventListener("click", () => {
        const nk = {
          use: !!$("#api-use")?.checked,
          unified: ($("#api-unified")?.value || "").trim(),
          bscscan: ($("#api-bscscan")?.value || "").trim(),
          etherscan: ($("#api-etherscan")?.value || "").trim()
        };
        saveApiKeys(nk);
        setStatus($("#qs-status"), "ok", "Keys saved.");
        gtagEvent("sec_keys_saved", { use: nk.use ? 1 : 0 });
      });

      $("#api-clear")?.addEventListener("click", () => {
        saveApiKeys({ use: false, unified: "", bscscan: "", etherscan: "" });
        Object.values(inputs).forEach(el => { if (el) el.value = ""; });
        const u = $("#api-use"); if (u) u.checked = false;
        setStatus($("#qs-status"), "ok", "Keys cleared.");
        gtagEvent("sec_keys_cleared");
      });
    }



// =========================
// Panel / Tool switching
// =========================
let toolCards = [];
let panels = {};

function initPanels() {
  toolCards = Array.from(document.querySelectorAll("#toolGrid .tool-card"));
  const backdrop = document.querySelector("#modalBackdrop");
  panels = {
    quick: document.querySelector("#panel-quick"),
    rpc: document.querySelector("#panel-rpc"),
    tx: document.querySelector("#panel-tx"),
    dev: document.querySelector("#panel-dev")
  };

  function showPanel(key) {
    Object.entries(panels).forEach(([k, el]) => { if (el) el.classList.toggle("hidden", k !== key); });
    toolCards.forEach((c) => c.classList.toggle("active", c.dataset.tool === key));
    if (backdrop) backdrop.classList.toggle("open", !!key);
    if (key) document.body.style.overflow = "hidden";
    else document.body.style.overflow = "";
  }

  window.showPanel = showPanel;
  toolCards.forEach((card) => card.addEventListener("click", () => showPanel(card.dataset.tool)));

  // Close on X button
  ["btnCloseQuick","btnCloseRpc","btnCloseTx","btnCloseDev"].forEach(id => {
    document.querySelector("#" + id)?.addEventListener("click", () => showPanel(null));
  });

  // Close on backdrop click (outside panel)
  backdrop?.addEventListener("click", (e) => {
    if (e.target === backdrop) showPanel(null);
  });
}

// Quick Scan (client-only) âœ… FIXED: no collisions, no TDZ, clean table
// =========================
(function () {
  "use strict";

  // âœ… Unique LS keys (avoid collisions with other features)
  const QS_LS_CACHE    = "cx_sec_qs_cache_safe_v6";
  const QS_LS_HISTORY  = "cx_sec_qs_history_safe_v6";
  const QS_LS_API_KEYS = "cx_sec_explorer_keys"; // {use,bscscan,etherscan} if exists

  // EIP-1967 implementation slot
  const EIP1967_IMPL_SLOT =
    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";

  // Minimal ABIs (self-contained â€” does NOT depend on Liquidity Scan script)
  const ERC20_MIN_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)"
  ];
  const ERC20_BALANCE_ABI = [
  "function balanceOf(address) view returns (uint256)"
];

  const OWNER_ABI = ["function owner() view returns (address)"];
  const PAUSABLE_ABI = ["function paused() view returns (bool)"];

  // V2/V3 minimal ABIs for the small liquidity table
  const QS_V2_FACTORY_ABI = ["function getPair(address,address) view returns (address)"];
  const QS_V2_PAIR_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function getReserves() view returns (uint112,uint112,uint32)"
  ];
  const QS_V3_FACTORY_ABI = ["function getPool(address,address,uint24) view returns (address)"];
  const QS_V3_POOL_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function liquidity() view returns (uint128)",
    "function slot0() view returns (uint160,int24,uint16,uint16,uint16,uint8,bool)"
  ];

  // PUSH4 selector scan (bytecode heuristic)
  const SEL = {
    mint: ["40c10f19", "a0712d68"],         // mint(address,uint256), mint(uint256)
    pause: ["8456cb59"],                   // pause()
    unpause: ["3f4ba83a"],                 // unpause()
    paused: ["5c975abb"],                  // paused()
    owner: ["8da5cb5b"],                   // owner()
    transferOwnership: ["f2fde38b"]         // transferOwnership(address)
  };

  const DEAD_ADDRESSES = new Set([
    "0x0000000000000000000000000000000000000000",
    "0x000000000000000000000000000000000000dead"
  ]);

  // QuickScan DEX targets (single â€œmainâ€ DEX for the compact table)
  const QS_NET = {
  bsc: {
  name: "BSC (BNB Chain)",
  wrapped: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", // WBNB
  usdt:    "0x55d398326f99059ff775485246999027b3197955", // USDT (BSC)
  busd:    "0xe9e7cea3dedca5984780bafc599bd69add087d56", // BUSD (BSC)

  // backward-compat
  v2Factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73", // Pancake V2
  v3Factory: "0x0bfbcf9fa4f9c56b0f40a671ad40e0805a091865", // Pancake V3

  v2Factories: [
    { name: "Pancake V2", addr: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73" },
    { name: "Four.meme V2", addr: "0x5c952063c7fc8610ffdb798152d69f0b9550762b" },
    { name: "Biswap V2",  addr: "0x858e3312ed3a876947ea49d572a7c42de08af7ee" },
    { name: "ApeSwap V2", addr: "0x0841bd0b734e4f5853f0dd8d7ea041c241fb0da6" },
    { name: "Bakery V2",  addr: "0x01bf7c66c6bd861915cdaae475042d3c4bae16a7" }
  ],
  v3Factories: [
    { name: "Pancake V3", addr: "0x0bfbcf9fa4f9c56b0f40a671ad40e0805a091865" }
  ],

  addressUrl: (a)=> `https://bscscan.com/address/${a}`
},

eth: {
  name: "Ethereum",
  wrapped: "0xc02aa39b223fe8d0a0e5c4f27ead9083c756cc2",
  usdt:    "0xdac17f958d2ee523a2206206994597c13d831ec7",

  v2Factory: "0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f",
  v3Factory: "0x1f98431c8ad98523631ae4a59f267346ea31f984",

  v2Factories: [
    { name: "Uniswap V2", addr: "0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f" },
    { name: "Sushi V2",   addr: "0xc0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac" }
  ],
  v3Factories: [
    { name: "Uniswap V3", addr: "0x1f98431c8ad98523631ae4a59f267346ea31f984" }
  ],

  addressUrl: (a)=> `https://etherscan.io/address/${a}`
}
};
  // Minimum effective liquidity thresholds (rough heuristic)
const QS_LIQ_FLOOR = {
  bsc: { wrappedTiny: 0.03, wrappedLow: 0.30, usdtTiny: 80,  usdtLow: 800 },
  eth: { wrappedTiny: 0.015, wrappedLow: 0.15, usdtTiny: 120, usdtLow: 1200 }
};


  // -------------------------
  // Tiny safe helpers (local)
  // -------------------------
  function qsLower(x) { return String(x || "").toLowerCase(); }
  function qsClamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function qsNowTs() { return Math.floor(Date.now() / 1000); }

  function qsEscapeHtml(s){
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function qsIsAddr(a){
    try {
      if (typeof isAddr === "function") return !!isAddr(a);
      if (typeof E !== "undefined" && E?.isAddress) return E.isAddress(a);
    } catch {}
    return false;
  }
  function qsNormAddr(a){
    try {
      if (typeof normAddr === "function") return normAddr(a);
      if (typeof E !== "undefined" && E?.getAddress) return E.getAddress(a);
    } catch {}
    return String(a || "");
  }
 function qsSafeAddr(a){
  const s = String(a || "").trim();
  if (!s) return "";
  try { return E.getAddress(s); } catch {}
  if (/^0x[a-fA-F0-9]{40}$/.test(s)) return s.toLowerCase();
  return "";
}

  function qsShortAddr(a){
    try { if (typeof shortAddr === "function") return shortAddr(a); } catch {}
    const s = String(a || "");
    return s.length > 12 ? (s.slice(0, 6) + "â€¦" + s.slice(-4)) : s;
  }

  function qsFmtNum(x, digits = 2){
    const n = Number(x);
    if (!Number.isFinite(n)) return "â€”";
    const d = qsClamp(digits, 0, 8);
    try { return n.toLocaleString(undefined, { maximumFractionDigits: d }); } catch { return String(n); }
  }
  function qsFmtBig(bn, decimals = 18, digits = 4){
    try {
      if (typeof E === "undefined" || !E?.formatUnits) return "â€”";
      const v = Number(E.formatUnits(bn, decimals));
      if (!Number.isFinite(v)) return "â€”";
      return qsFmtNum(v, digits);
    } catch { return "â€”"; }
  }
  function qsPctFromBig(part, total){
  try{
    const p = BigInt(part || 0n);
    const t = BigInt(total || 0n);
    if (t <= 0n) return null;
    const bp = Number((p * 10000n) / t); // basis points
    return bp / 100; // percent
  } catch { return null; }
}


  // -------------------------
// Market risk helpers (Quick Scan hardening)
// -------------------------
function qsToNum(v, d = 0){
  const n = Number(v);
  return Number.isFinite(n) ? n : d;
}

function qsComputeMarketRisk(rep){
  // We only use data we already have in QuickScan to avoid breaking dependencies.
  // If external metrics are missing, we set lower confidence instead of assuming "safe".
  const m = {
    // currently available
    hasLiquidity: !!rep?.liq?.any,
    ownerPct: (typeof rep?.meta?.ownerPct === "number") ? rep.meta.ownerPct : null,

    // optional future hooks (if you later inject them)
    holders: qsToNum(rep?.meta?.holders, NaN),
    liquidityUsd: qsToNum(rep?.meta?.liquidityUsd, NaN),
    volume1hUsd: qsToNum(rep?.meta?.volume1hUsd, NaN),
    trades1h: qsToNum(rep?.meta?.trades1h, NaN),
    priceChange1hPct: qsToNum(rep?.meta?.priceChange1hPct, NaN)
  };

  let marketScore = 100;
  const flags = [];
  let confidence = "low";

  // Base from what we definitely know
  if (!m.hasLiquidity) {
  marketScore -= 38;
  flags.push("no_clear_liquidity_signal");
}

  if (m.ownerPct !== null) {
    confidence = "medium";
    if (m.ownerPct >= 50) { marketScore -= 22; flags.push("extreme_owner_concentration"); }
    else if (m.ownerPct >= 35) { marketScore -= 16; flags.push("high_owner_concentration"); }
    else if (m.ownerPct >= 20) { marketScore -= 10; flags.push("elevated_owner_concentration"); }
  } else {
    flags.push("holder_concentration_unknown");
  }

  // Optional extra penalties only if data exists
  if (Number.isFinite(m.liquidityUsd)) {
    confidence = "high";
    if (m.liquidityUsd < 10000) { marketScore -= 18; flags.push("very_low_liquidity_usd"); }
    else if (m.liquidityUsd < 50000) { marketScore -= 10; flags.push("low_liquidity_usd"); }
  }

  if (Number.isFinite(m.holders)) {
    confidence = "high";
    if (m.holders < 50) { marketScore -= 14; flags.push("very_few_holders"); }
    else if (m.holders < 200) { marketScore -= 8; flags.push("few_holders"); }
  }

  if (Number.isFinite(m.priceChange1hPct) && Number.isFinite(m.trades1h)) {
    confidence = "high";
    if (Math.abs(m.priceChange1hPct) > 250 && m.trades1h < 30) {
      marketScore -= 16;
      flags.push("possible_manipulated_move");
    } else if (Math.abs(m.priceChange1hPct) > 120) {
      marketScore -= 9;
      flags.push("extreme_short_term_volatility");
    }
  }

  marketScore = qsClamp(Math.round(marketScore), 0, 100);
if (
  rep?.meta?.liqQuality === "healthy" &&
  Number(rep.meta?.liqUsdtAmt || 0) >= 100000 &&
  Number(rep.meta?.liqActivePools || 0) >= 2
) {
  marketScore = qsClamp(Math.round(marketScore + 8), 0, 100);
}

  return { marketScore, flags, confidence };
}

function qsApplyScoreGates(finalScore, rep, marketFlags){
  let maxScore = 100;

  // Hard caps from known signals (safe defaults)
  if (!rep?.liq?.any) maxScore = Math.min(maxScore, 74);

  const ownerPct = (typeof rep?.meta?.ownerPct === "number") ? rep.meta.ownerPct : null;
  if (ownerPct !== null) {
    if (ownerPct > 70) maxScore = Math.min(maxScore, 69);
    else if (ownerPct >= 50) maxScore = Math.min(maxScore, 74);
    else if (ownerPct >= 35) maxScore = Math.min(maxScore, 79);
  }

  if ((marketFlags || []).includes("possible_manipulated_move")) {
    maxScore = Math.min(maxScore, 64);
  }

  return Math.min(finalScore, maxScore);
}



  function loadQsCache(){
    try { return JSON.parse(localStorage.getItem(QS_LS_CACHE) || "{}"); } catch { return {}; }
  }
  function saveQsCache(obj){
    try { localStorage.setItem(QS_LS_CACHE, JSON.stringify(obj || {})); } catch {}
  }
  function loadQsHistory(){
    try { return JSON.parse(localStorage.getItem(QS_LS_HISTORY) || "[]"); } catch { return []; }
  }
  function saveQsHistory(arr){
    try { localStorage.setItem(QS_LS_HISTORY, JSON.stringify(arr || [])); } catch {}
  }
  function qsCacheKey(net, token, useApis){
   return `${net}:${qsLower(token)}:${useApis ? 1 : 0}`;
  }
  function addQsHistory(net, token){
    try{
      const arr = loadQsHistory();
      const key = `${net}:${qsLower(token)}`;
      const filtered = arr.filter(x => x?.key !== key);
      filtered.unshift({ key, net, token: qsNormAddr(token), ts: qsNowTs() });
      saveQsHistory(filtered.slice(0, 80));
    } catch {}
  }
  function qsBuildShareLink(net, token){
    const u = new URL(location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", net);
    u.searchParams.set("token", token);
    return u.toString();
  }

 // âœ… safe explorer key read
function qsExplorerKeyFor(net){
  // 1) optional legacy helper
  try{
    if (typeof explorerKeyFor === "function") {
      const k = String(explorerKeyFor(net) || "").trim();
      return { key: k, isUnified: false };
    }
  } catch {}

  // 2) localStorage (V2 unified first, then per-net)
  try{
    const raw = localStorage.getItem(QS_LS_API_KEYS) || "";
    if (!raw) return { key: "", isUnified: false };

    const o = JSON.parse(raw) || {};

    // âœ… FIRST: if user disabled API usage
    if (typeof o.use === "boolean" && o.use === false) {
      return { key: "", isUnified: false };
    }

    // âœ… THEN: unified key has priority
    const unified = String(o.unified || "").trim();
    if (unified) return { key: unified, isUnified: true };

    // âœ… fallback: per-network keys
    if (net === "bsc") return { key: String(o.bscscan || "").trim(), isUnified: false };
    if (net === "eth") return { key: String(o.etherscan || "").trim(), isUnified: false };

    return { key: "", isUnified: false };
  } catch {
    return { key: "", isUnified: false };
  }
}
  // âœ… UI (TEMP) explorer key read (no-save)
// Supports unified V2 key OR per-network keys if present in the UI.
function qsUiExplorerKeyFor(net){
  try{
    const unifiedEl = $("#api-unified");
    const bscEl = $("#api-bscscan");
    const ethEl = $("#api-etherscan");

    const unified = String(unifiedEl?.value || "").trim();
    if (unified) return { key: unified, isUnified: true };

    if (net === "bsc") {
      const k = String(bscEl?.value || "").trim();
      if (k) return { key: k, isUnified: false };
    }
    if (net === "eth") {
      const k = String(ethEl?.value || "").trim();
      if (k) return { key: k, isUnified: false };
    }

    return { key: "", isUnified: false };
  } catch {
    return { key: "", isUnified: false };
  }
}
  // Chip UI
  function qsMiniChip(type, title, value){
    const map = { ok:"ok", warn:"warn", bad:"bad", info:"warn" };
    const cls = map[type] || "warn";
    return `<div class="risk ${cls}"><span class="dot"></span><span><b>${qsEscapeHtml(title)}</b><span style="opacity:.7;font-weight:400;"> â€” ${qsEscapeHtml(value)}</span></span></div>`;
  }

  function codeHasSelector(bytecode, selHex){
    try{
      const code = qsLower(bytecode || "");
      const sel = qsLower(selHex || "").replace(/^0x/,"");
      if (!sel || sel.length !== 8) return false;
      return code.includes("63" + sel); // PUSH4 <selector>
    } catch { return false; }
  }
  function anySelector(bytecode, sels){
    for (const s of (sels || [])) if (codeHasSelector(bytecode, s)) return true;
    return false;
  }

  async function tryReadOwner(net, token){
    const _getRP =
  (typeof getReadProvider === "function" && getReadProvider) ||
  (typeof window.getReadProvider === "function" && window.getReadProvider) ||
  (typeof window.CX?.getReadProvider === "function" && window.CX.getReadProvider) ||
  null;
const read = _getRP ? _getRP(net) : null;

    if (!read) return "";
    try{
      const c = new E.Contract(token, OWNER_ABI, read);
      const o = await c.owner();
      return qsIsAddr(o) ? qsNormAddr(o) : "";
    } catch { return ""; }
  }

  async function tryReadPaused(net, token){
    const _getRP =
  (typeof getReadProvider === "function" && getReadProvider) ||
  (typeof window.getReadProvider === "function" && window.getReadProvider) ||
  (typeof window.CX?.getReadProvider === "function" && window.CX.getReadProvider) ||
  null;
const read = _getRP ? _getRP(net) : null;

    if (!read) return null;
    try{
      const c = new E.Contract(token, PAUSABLE_ABI, read);
      const p = await c.paused();
      return !!p;
    } catch { return null; }
  }

  async function tryEip1967Impl(net, token){
    const _getRP =
  (typeof getReadProvider === "function" && getReadProvider) ||
  (typeof window.getReadProvider === "function" && window.getReadProvider) ||
  (typeof window.CX?.getReadProvider === "function" && window.CX.getReadProvider) ||
  null;
const read = _getRP ? _getRP(net) : null;

    if (!read) return "";
    try{
      const raw = await read.getStorage(token, EIP1967_IMPL_SLOT);
      const hex = String(raw || "0x");
      if (!hex || hex === "0x") return "";
      const addr = "0x" + hex.slice(-40);
      if (!qsIsAddr(addr)) return "";
      const norm = qsNormAddr(addr);
      if (qsLower(norm) === "0x0000000000000000000000000000000000000000") return "";
      return norm;

    } catch { return ""; }
  }

  // =========================
  // Compact Liquidity table (ONLY QuickScan)
  // - shows ONLY existing pairs/pools (reduces rows)
  // - does NOT touch Liquidity Scan panel
  // =========================
  const QS_ERC20_META_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)"
  ];
  const _qsErc20MetaCache = new Map();

  function _qsToBI(x){
    try { return (typeof x === "bigint") ? x : BigInt(x); } catch { return 0n; }
  }
  async function _qsGetErc20Meta(addr, provider){
    const key = String(addr || "").toLowerCase();
    if (_qsErc20MetaCache.has(key)) return _qsErc20MetaCache.get(key);

    const c = new E.Contract(addr, QS_ERC20_META_ABI, provider);
    let decimals = 18;
    let symbol = qsShortAddr(addr);

    try { decimals = Number(await c.decimals()); } catch {}
    try {
      const s = await c.symbol();
      if (s && String(s).trim()) symbol = String(s).trim();
    } catch {}

    const meta = { decimals, symbol };
    _qsErc20MetaCache.set(key, meta);
    return meta;
  }

  function _qsCompactDecimalString(str, dp = 2){
    if (str == null) return "0";
    let s = String(str).trim();
    if (!s) return "0";

    let neg = false;
    if (s[0] === "-") { neg = true; s = s.slice(1); }

    const parts = s.split(".");
    let intp = (parts[0] || "0").replace(/^0+(?=\d)/, "");
    const frac = parts[1] || "";

    const len = intp.length;
    let pow = 0, suf = "";
    if (len >= 16) { pow = 15; suf = "Q"; }
    else if (len >= 13) { pow = 12; suf = "T"; }
    else if (len >= 10) { pow = 9;  suf = "B"; }
    else if (len >= 7)  { pow = 6;  suf = "M"; }
    else if (len >= 4)  { pow = 3;  suf = "K"; }

    if (pow === 0){
      const frac6 = frac.slice(0, 6).replace(/0+$/,"");
      const out = frac6 ? `${intp}.${frac6}` : intp;
      return (neg ? "-" : "") + out;
    }

    const wholeLen = len - pow;
    const whole = intp.slice(0, wholeLen) || "0";
    const rest = intp.slice(wholeLen);

    const dec = (rest + "0".repeat(dp)).slice(0, dp).replace(/0+$/,"");
    const out = dec ? `${whole}.${dec}${suf}` : `${whole}${suf}`;
    return (neg ? "-" : "") + out;
  }

  function _qsFmtUnits(amount, decimals, dp = 2){
    try {
      const s = E.formatUnits(amount, decimals);
      return _qsCompactDecimalString(s, dp);
    } catch {
      return "0";
    }
  }

 async function qsLiqCheckBasic(net, token, provider) {
  const cfg = QS_NET?.[net];
  if (!cfg || !provider) return { any:false, hint:"none", rows:[] };

  const rows = [];
  let any = false;
  const ZERO = "0x0000000000000000000000000000000000000000";
  const tok = qsSafeAddr(token);
  if (!tok) return { any:false, hint:"none", rows:[] };

  // broaden targets so real liquidity is found more often
  const targets = [
    { label: "Wrapped", addr: qsSafeAddr(cfg.wrapped) },
    { label: "USDT",    addr: qsSafeAddr(cfg.usdt) },
    { label: "BUSD",    addr: net === "bsc" ? qsSafeAddr("0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56") : "" },
    { label: "USDC",    addr: net === "bsc" ? qsSafeAddr("0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d") : qsSafeAddr("0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48") },
    { label: "FDUSD",   addr: net === "bsc" ? qsSafeAddr("0xc5f0f7b66764f6ec8c8dff7ba683102295e16409") : "" }
  ].filter(t => !!t.addr);

  // ---------- V2 ----------
  const v2Factories = Array.isArray(cfg.v2Factories) && cfg.v2Factories.length
    ? cfg.v2Factories
    : (cfg.v2Factory ? [{ name: "V2", addr: cfg.v2Factory }] : []);

 for (const vf of v2Factories) {
  const vfAddr = qsSafeAddr(vf?.addr);
  if (!vfAddr) continue;

  let fac;
  try {
    fac = new E.Contract(vfAddr, QS_V2_FACTORY_ABI, provider);
  } catch {
    continue;
  }

    for (const t of targets) {
      let pair = ZERO;
      try { pair = await fac.getPair(tok, t.addr); } catch {}

      if (!pair || pair === ZERO) {
  continue; // don't add noisy "not found" rows
}
      try {
        const p = new E.Contract(pair, QS_V2_PAIR_ABI, provider);
        let token0 = tok, token1 = t.addr;
        try { token0 = await p.token0(); } catch {}
        try { token1 = await p.token1(); } catch {}

        const [r0Raw, r1Raw] = await p.getReserves().then(x => [x[0], x[1]]).catch(()=>[0n,0n]);
        const r0 = _qsToBI(r0Raw), r1 = _qsToBI(r1Raw);

        const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
        const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

        const ok = (r0 > 0n || r1 > 0n);
        any = any || ok;

      rows.push({
  type: `V2${vf?.name ? " â€¢ " + vf.name : ""}`,
  target: t.label,
  addr: pair,
  ok,
  note: ok
    ? `reserves: ${_qsFmtUnits(r0, m0.decimals, 2)} ${m0.symbol} / ${_qsFmtUnits(r1, m1.decimals, 2)} ${m1.symbol}`
    : "reserves: 0",

  // structured fields (for liquidity quality / USD estimate)
  token0: qsNormAddr(token0),
  token1: qsNormAddr(token1),
  symbol0: String(m0.symbol || ""),
  symbol1: String(m1.symbol || ""),
  decimals0: Number(m0.decimals ?? 18),
  decimals1: Number(m1.decimals ?? 18),
  raw0: r0.toString(),
  raw1: r1.toString()
});
      } catch {
        rows.push({
          type: `V2 â€¢ ${vf.name || "V2"}`,
          target: t.label,
          addr: qsShortAddr(pair),
          ok: false,
          note: "pair read failed"
        });
      }
    }
  }

  // ---------- V3 ----------
  const v3Factories = Array.isArray(cfg.v3Factories) && cfg.v3Factories.length
    ? cfg.v3Factories
    : (cfg.v3Factory ? [{ name: "V3", addr: cfg.v3Factory }] : []);

  const feeTiers = [100, 500, 2500, 3000, 10000]; // broaden coverage

  for (const vf of v3Factories) {
  const vfAddr = qsSafeAddr(vf?.addr);
  if (!vfAddr) continue;

  let fac3;
  try {
    fac3 = new E.Contract(vfAddr, QS_V3_FACTORY_ABI, provider);
  } catch {
    continue;
  }

    for (const t of targets) {
      for (const fee of feeTiers) {
        let pool = ZERO;
        try { pool = await fac3.getPool(tok, t.addr, fee); } catch {}

        if (!pool || pool === ZERO) {
  continue; // don't add noisy "not found" rows
}

        try {
          const p = new E.Contract(pool, QS_V3_POOL_ABI, provider);

          let token0 = tok, token1 = t.addr;
          try { token0 = await p.token0(); } catch {}
          try { token1 = await p.token1(); } catch {}

          const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
          const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

          const c0 = new E.Contract(token0, QS_ERC20_META_ABI, provider);
          const c1 = new E.Contract(token1, QS_ERC20_META_ABI, provider);

          let b0 = 0n, b1 = 0n;
          try { b0 = _qsToBI(await c0.balanceOf(pool)); } catch {}
          try { b1 = _qsToBI(await c1.balanceOf(pool)); } catch {}

          const ok = (b0 > 0n && b1 > 0n);
          any = any || ok;

          rows.push({
  type: `V3 ${fee}${vf?.name ? " â€¢ " + vf.name : ""}`,
  target: t.label,
  addr: pool,
  ok,
  note: ok
    ? `balances: ${_qsFmtUnits(b0, m0.decimals, 2)} ${m0.symbol} / ${_qsFmtUnits(b1, m1.decimals, 2)} ${m1.symbol}`
    : "balances: 0",

  // structured fields (for liquidity quality / USD estimate)
  token0: qsNormAddr(token0),
  token1: qsNormAddr(token1),
  symbol0: String(m0.symbol || ""),
  symbol1: String(m1.symbol || ""),
  decimals0: Number(m0.decimals ?? 18),
  decimals1: Number(m1.decimals ?? 18),
  raw0: b0.toString(),
  raw1: b1.toString()
});
        } catch {
          rows.push({
            type: `V3 ${fee} â€¢ ${vf.name || "V3"}`,
            target: t.label,
            addr: qsShortAddr(pool),
            ok: false,
            note: "pool read failed"
          });
        }
      }
    }
  }

  return { any, hint: any ? "liquidity found" : "none", rows };
}



  function qsRenderLiquidityTable(container, liqRes){
    if (!container) return;

   const rows = [...(liqRes?.rows || [])].sort((a, b) => {
  const ao = a?.ok ? 1 : 0;
  const bo = b?.ok ? 1 : 0;
  if (bo !== ao) return bo - ao; // ok first
  // secondary sort: V2 before V3 (optional but clean)
  const at = String(a?.type || "");
  const bt = String(b?.type || "");
  const av2 = at.includes("V2") ? 0 : 1;
  const bv2 = bt.includes("V2") ? 0 : 1;
  return av2 - bv2;
});

    const body = rows.length ? rows.map(r => `
      <div class="trow ${r.ok ? "highlight" : ""}">
        <div class="cell wrap"><span class="mono">${r.addr ? qsEscapeHtml(qsShortAddr(r.addr)) : "â€”"}</span></div>
        <div class="cell">${qsEscapeHtml(r.type)}</div>
        <div class="cell">${qsEscapeHtml(r.target)}</div>
        <div class="cell">${r.ok ? "âœ…" : "â€”"} ${qsEscapeHtml(r.note || "")}</div>
      </div>
    `).join("") : `
      <div class="trow">
        <div class="cell muted">â€”</div>
        <div class="cell muted">â€”</div>
        <div class="cell muted">â€”</div>
        <div class="cell muted">No pairs/pools detected</div>
      </div>
    `;

    container.innerHTML = `
      <div id="qsLiqTable" class="table">
        <div class="trow head">
          <div class="cell">PAIR/POOL</div>
          <div class="cell">TYPE</div>
          <div class="cell">TARGET</div>
          <div class="cell">RESULT</div>
        </div>
        ${body}
      </div>
    `;
  }

  function qsBuildMarkdownReport(rep){
    const lines = [];
    lines.push(`## Quick Scan â€” ${rep.chainName || rep.net}`);
    lines.push(`Token: \`${rep.token}\``);
    lines.push(`Explorer: ${rep.explorer}`);
    lines.push(`Score: **${rep.score}/100** (${rep.overallText})`);
    lines.push("");
    lines.push(`### Signals`);
    for (const c of (rep.mini || [])) lines.push(`- ${c.title}: ${c.value}`);
    if (rep.redFlags?.length) {
      lines.push("");
      lines.push(`### Red Flags`);
      for (const f of rep.redFlags) lines.push(`- â— ${f}`);
    }
    lines.push("");
    lines.push(`> ${rep.disclaimer}`);
    return lines.join("\n");
  }

  function qsBuildXText(rep){
    const base = `Quick Scan (${rep.chainName || rep.net})\nToken: ${qsShortAddr(rep.token)}\nScore: ${rep.score}/100 (${rep.overallText})\n`;
    return `${base}${rep.shareLink || ""}`.trim();
  }
  async function cxReadWithFallback(net, runner) {
  const base = getReadProvider(net);
  if (!base) throw new Error("No read provider");

  const chain = CHAINS?.[net];
  const candidates = base.__cxCandidates || [base?._getConnection?.()?.url].filter(Boolean);

  let lastErr;
  for (const url of candidates) {
    try {
      const p = new E.JsonRpcProvider(url, chain.chainId);
      const out = await runner(p);
      return out;
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error("All RPC candidates failed");
}

 

  async function runQuickScan(){
    const st = $("#qs-status");
    const out = $("#qs-out");
    const chipsWrap = $("#qs-risk");
    const pairsWrap = $("#qs-pairsWrap");

    clearStatus(st);

    const net = netFromSelect("#qs-net");
    const tokenRaw = ($("#qs-token")?.value || "").trim();
    const uiKey = ($("#api-unified")?.value || "").trim();
    const useApis = !!$("#api-use")?.checked;

    if (!tokenRaw || !qsIsAddr(tokenRaw)) {
      setStatus(st, "warn", "Please paste a valid token address.");
      return;
    }
    const token = qsNormAddr(tokenRaw);

    if (typeof E === "undefined" || !E?.Contract) {
      setStatus(st, "bad", "Ethers not loaded.");
      return;
    }
  const getRP =
  (typeof getReadProvider === "function" && getReadProvider) ||
  (typeof window.getReadProvider === "function" && window.getReadProvider) ||
  (typeof window.CX?.getReadProvider === "function" && window.CX.getReadProvider) ||
  null;

if (!getRP) {
  setStatus(st, "bad", "RPC provider missing (getReadProvider not found).");
  return;
}

    setStatus(st, "info", "Scanningâ€¦");

    const cache = loadQsCache();
    const ckey = qsCacheKey(net, token, useApis);
    const cached = cache?.[ckey];

    // âœ… Render is SAFE now (no TDZ vars)
 if (cached?.rep && cached?.ts && (qsNowTs() - cached.ts) < 600) {
  if (qsLower(cached.rep.token) === qsLower(token) && cached.rep.net === net) {
    setStatus(st, "ok", "Loaded cached result (â‰¤10 min).");
    render(cached.rep);
    return;
  }
}


    const cfg = QS_NET?.[net];
    const read = getRP(net);
    if (!cfg || !read) {
      setStatus(st, "bad", "No network config / RPC available.");
      return;
    }


    const rep = {
      ts: qsNowTs(),
      net,
      chainName: cfg.name,
      token,
      explorer: cfg.addressUrl(token),
      shareLink: qsBuildShareLink(net, token),
      disclaimer: "Informational checks only. Not an audit. No safety guarantee.",
      score: 0,
      overallText: "Unknown",
      meta: {},
      liq: { any:false, hint:"none", rows:[] },
      mini: [],
      redFlags: [],
      json: ""
    };

    // 1) Bytecode exists
    let code = "0x";
    try {
      if (typeof getCodeSafe === "function") {
        const codeRes = await getCodeSafe(net, token);
        code = codeRes?.code || "0x";
      } else {
        code = await read.getCode(token);
      }
    } catch {}

    const hasCode = !!(code && code !== "0x");
    if (!hasCode) {
      rep.score = 0;
      rep.overallText = "Invalid";
      rep.redFlags.push("No contract code (EOA or invalid address).");
      rep.json = safeJson(rep);
      cache[ckey] = { ts: qsNowTs(), rep };
      saveQsCache(cache);
      addQsHistory(net, token);
      setStatus(st, "bad", "No contract code detected.");
      render(rep);
      return;
    }

 // 2) ERC-20 basics (robust: ETH/BSC, string/bytes32 tolerant)
try {
  const meta = await cxReadWithFallback(net, async (read) => {
    let name = "", symbol = "", decimals = 18, totalSupply = 0n;

    const c = new E.Contract(token, ERC20_MIN_ABI, read);

    // name()
    try {
      const n = await c.name();
      if (n != null) name = String(n).trim();
    } catch {}

    // symbol()
    try {
      const s = await c.symbol();
      if (s != null) symbol = String(s).trim();
    } catch {}

    // decimals()
    try {
      const d = await c.decimals();
      const dn = Number(d);
      if (Number.isFinite(dn) && dn >= 0 && dn <= 255) decimals = dn;
    } catch {}

    // totalSupply()
    try {
      const ts = await c.totalSupply();
      try {
        totalSupply = (typeof ts === "bigint") ? ts : BigInt(String(ts));
      } catch {
        totalSupply = 0n;
      }
    } catch {}

    // Fallback for old/non-standard tokens that return bytes32 for name/symbol
    // only if still missing
    if ((!name || !symbol) && E?.Interface && read?.call) {
      try {
        const iface = new E.Interface([
          "function name() view returns (bytes32)",
          "function symbol() view returns (bytes32)"
        ]);

        if (!name) {
          try {
            const data = iface.encodeFunctionData("name", []);
            const ret = await read.call({ to: token, data });
            const [b] = iface.decodeFunctionResult("name", ret);
            const parsed = String(b || "").replace(/\u0000/g, "").trim();
            if (parsed) name = parsed;
          } catch {}
        }

        if (!symbol) {
          try {
            const data = iface.encodeFunctionData("symbol", []);
            const ret = await read.call({ to: token, data });
            const [b] = iface.decodeFunctionResult("symbol", ret);
            const parsed = String(b || "").replace(/\u0000/g, "").trim();
            if (parsed) symbol = parsed;
          } catch {}
        }
      } catch {}
    }

    return {
      name,
      symbol,
      decimals,
      totalSupply: totalSupply.toString()
    };
  });

  rep.meta = meta;
} catch {}

    // 3) Liquidity rows (compact table)
    try {
      const liqFn =
  window.CX?.modules?.qs?.qsLiqCheckBasic ||
  window.qsLiqCheckBasic ||
  qsLiqCheckBasic;

rep.liq = await liqFn(net, token, read);

    } catch {}
    const totalRows = Array.isArray(rep?.liq?.rows) ? rep.liq.rows.length : 0;
    const activeRows = Array.isArray(rep?.liq?.rows) ? rep.liq.rows.filter(r => r?.ok).length : 0;

// rough coverage confidence
const liqCoverageLow = totalRows > 0 && activeRows === 0;
const liqCoveragePartial = totalRows > 0 && activeRows <= 1;

rep.meta = {
  ...(rep.meta || {}),
  liqCoverageLow,
  liqCoveragePartial
};

// --- liquidity quality heuristic (USD-tiered, stable-based) ---
let liqQuality = "unknown"; // unknown | tiny | low | medium | healthy
try {
  const rows = Array.isArray(rep?.liq?.rows) ? rep.liq.rows : [];
  const active = rows.filter(r => r?.ok);

  const netCfg = QS_NET?.[net] || {};
  const wrappedAddr = qsLower(netCfg.wrapped || "");
  const usdtAddr    = qsLower(netCfg.usdt || "");
  const busdAddr    = qsLower(netCfg.busd || "");

  // common stables (BSC/ETH) â€“ we treat as ~$1 each
  const usdcAddr = qsLower(
    net === "bsc"
      ? "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d"
      : "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  );
  const fdusdAddr = qsLower(net === "bsc" ? "0xc5f0f7b66764f6ec8c8dff7ba683102295e16409" : "");

  // aggregated amounts (human units)
  let wrappedAmt = 0;
  let usdtAmt = 0;
  let usdcAmt = 0;
  let busdAmt = 0;
  let fdusdAmt = 0;

  for (const r of active) {
    const t0 = qsLower(r?.token0 || "");
    const t1 = qsLower(r?.token1 || "");

    const d0 = Number(r?.decimals0 ?? 18);
    const d1 = Number(r?.decimals1 ?? 18);

    let raw0 = 0n, raw1 = 0n;
    try { raw0 = BigInt(String(r?.raw0 ?? "0")); } catch { raw0 = 0n; }
    try { raw1 = BigInt(String(r?.raw1 ?? "0")); } catch { raw1 = 0n; }

    let a0 = 0, a1 = 0;
    try { a0 = Number(E.formatUnits(raw0, d0)); } catch { a0 = 0; }
    try { a1 = Number(E.formatUnits(raw1, d1)); } catch { a1 = 0; }

    if (t0 === wrappedAddr && Number.isFinite(a0)) wrappedAmt += a0;
    if (t1 === wrappedAddr && Number.isFinite(a1)) wrappedAmt += a1;

    if (t0 === usdtAddr && Number.isFinite(a0)) usdtAmt += a0;
    if (t1 === usdtAddr && Number.isFinite(a1)) usdtAmt += a1;

    if (t0 === usdcAddr && Number.isFinite(a0)) usdcAmt += a0;
    if (t1 === usdcAddr && Number.isFinite(a1)) usdcAmt += a1;

    if (busdAddr) {
      if (t0 === busdAddr && Number.isFinite(a0)) busdAmt += a0;
      if (t1 === busdAddr && Number.isFinite(a1)) busdAmt += a1;
    }

    if (fdusdAddr) {
      if (t0 === fdusdAddr && Number.isFinite(a0)) fdusdAmt += a0;
      if (t1 === fdusdAddr && Number.isFinite(a1)) fdusdAmt += a1;
    }
  }

  // store what we already show elsewhere
  rep.meta = {
    ...(rep.meta || {}),
    liqWrappedAmt: wrappedAmt,
    liqUsdtAmt: usdtAmt,
    liqUsdcAmt: usdcAmt,
    liqBusdAmt: busdAmt,
    liqFdusdAmt: fdusdAmt,
    liqActivePools: active.length
  };

  // USD estimate (stable-side + wrapped-side)
const stableUsdSide = (usdtAmt + usdcAmt + busdAmt + fdusdAmt);

// Fallback native prices (rough, but much closer than ignoring wrapped pools)
// You can tune these anytime.
const QS_NATIVE_USD_FALLBACK = {
  bsc: 650,   // BNB
  eth: 3000   // ETH
};

// Optional override if you later inject a live price somewhere into rep.meta
const nativeUsdPrice = Number(
  rep?.meta?.nativeUsdPrice ?? QS_NATIVE_USD_FALLBACK[net] ?? NaN
);

// wrappedAmt is WBNB/WETH amount on the "wrapped side" across token-wrapped pools
const wrappedUsdSide =
  (Number.isFinite(wrappedAmt) && wrappedAmt > 0 && Number.isFinite(nativeUsdPrice) && nativeUsdPrice > 0)
    ? (wrappedAmt * nativeUsdPrice)
    : 0;

// In AMM pools, token side value ~= quote side value, so TVL ~= 2 * one-side value
const oneSideUsd = (Number.isFinite(stableUsdSide) ? stableUsdSide : 0) + wrappedUsdSide;
const liquidityUsdEst = (oneSideUsd > 0) ? (oneSideUsd * 2) : NaN;

rep.meta = {
  ...(rep.meta || {}),
  nativeUsdPrice: Number.isFinite(nativeUsdPrice) ? nativeUsdPrice : null,
  stableUsdSide: Number.isFinite(stableUsdSide) ? stableUsdSide : 0,
  wrappedUsdSide: Number.isFinite(wrappedUsdSide) ? wrappedUsdSide : 0,
  liquidityUsdEst: Number.isFinite(liquidityUsdEst) ? liquidityUsdEst : null
};

  // Tiers (edit these numbers freely)
  // tiny  : < 25k
  // low   : 25k â€“ < 250k
  // medium: 250k â€“ < 500k
  // healthy: >= 500k
  if (active.length === 0) {
    liqQuality = "unknown";
  } else if (Number.isFinite(liquidityUsdEst)) {
    if (liquidityUsdEst < 25000) liqQuality = "tiny";
    else if (liquidityUsdEst < 250000) liqQuality = "low";
    else if (liquidityUsdEst < 500000) liqQuality = "medium";
    else liqQuality = "healthy";
  } else {
    // fallback when no stable-side liquidity was detected (e.g., only WBNB pools)
    // keep your old heuristic thresholds as a conservative fallback:
    const floor = (QS_LIQ_FLOOR && QS_LIQ_FLOOR[net]) || {
      wrappedTiny: 0.03, wrappedLow: 0.3, usdtTiny: 80, usdtLow: 800
    };

    if (wrappedAmt < floor.wrappedTiny && usdtAmt < floor.usdtTiny) liqQuality = "tiny";
    else if (wrappedAmt < floor.wrappedLow && usdtAmt < floor.usdtLow) liqQuality = "low";
    else liqQuality = "low";

   // no-stable fallback: never mark "healthy" (USD unknown)

  }
} catch {}

    // 4) Proxy
    let impl = await tryEip1967Impl(net, token);
    let isProxy = !!impl;

    // 5) Owner
    const owner = await tryReadOwner(net, token);
    const ownerIsRenounced = owner && DEAD_ADDRESSES.has(qsLower(owner));
    const ownerShown = owner ? qsShortAddr(owner) : "No/Unknown";
   // 5.5) Holder concentration (owner wallet share)
let ownerBal = 0n;
let ownerPct = null;
let holderConcText = "No/Unknown";
let holderConcType = "warn";

// normalize total supply from rep.meta (string -> bigint)
let totalSupplyBI = 0n;
try {
  totalSupplyBI = BigInt(rep?.meta?.totalSupply || "0");
} catch {
  totalSupplyBI = 0n;
}

if (owner && !ownerIsRenounced) {
  try{
    const bc = new E.Contract(token, ERC20_BALANCE_ABI, read);
    ownerBal = BigInt(await bc.balanceOf(owner).catch(()=> 0n));
    ownerPct = qsPctFromBig(ownerBal, totalSupplyBI);
  } catch {}
}


if (ownerPct === null) {
  holderConcText = owner ? "No/Unknown" : "No owner";
  holderConcType = "warn";
} else {
  holderConcText = `${qsFmtNum(ownerPct, 2)}% (owner wallet)`;

  if (ownerPct >= 35) holderConcType = "bad";
  else if (ownerPct >= 20) holderConcType = "warn";
  else holderConcType = "ok";
}


    // 6) Pause (INFO)
    const pausedState = await tryReadPaused(net, token);
    const pauseDetected =
      (pausedState !== null) ||
      anySelector(code, SEL.pause) ||
      anySelector(code, SEL.unpause) ||
      anySelector(code, SEL.paused);
    const pauseText = pausedState === true ? "Detected (paused)" : pauseDetected ? "Detected" : "No/Unknown";

    // 7) Mint
    const mintDetected = anySelector(code, SEL.mint);

    // 8) Verified (optional)
let verified = null;

if (useApis) {
  const ui = qsUiExplorerKeyFor(net);
  let apiKey = ui.key;
  let isUnified = ui.isUnified;

  if (!apiKey) {
    const k = qsExplorerKeyFor(net);
    apiKey = k.key;
    isUnified = k.isUnified;
  }

  if (typeof explorerGetSource === "function") {
    try {
      const src = await explorerGetSource(net, token, apiKey, isUnified);
      if (src?.ok) {
        verified = (src.verified === true) ? true : (src.verified === false) ? false : null;
        if (!isProxy && src.isProxy) isProxy = true;
        if (!impl && src.implementation) impl = String(src.implementation || "");
      }
    } catch {}
  }

  // B) fallback: direct explorer call (ONLY if still unknown)
  if (verified === null && typeof qsExplorerGetSourceDirect === "function") {
    try {
      const src2 = await qsExplorerGetSourceDirect(net, token, apiKey);
      if (src2?.ok) {
        verified = (src2.verified === true) ? true : (src2.verified === false) ? false : null;
        if (!isProxy && src2.isProxy) isProxy = true;
        if (!impl && src2.implementation) impl = String(src2.implementation || "");
      }
    } catch {}
  }
}

   // Score model (hardened: Contract + Market + Gates)
// Score model (hardened: Contract + Market + Gates)
let contractScore = 75;

if (rep.liq?.any) {
  contractScore += 10;
} else {
  // fixed penalty (option removed)
  contractScore -= 30;
}
if (mintDetected) contractScore -= 22;

if (isProxy) contractScore -= 12;
else contractScore += 3;

if (!owner) contractScore += 0;
else if (ownerIsRenounced) contractScore += 5;
else contractScore -= 6;

// Holder concentration penalty (owner wallet share)
if (ownerPct !== null) {
  if (ownerPct >= 50) contractScore -= 20;
  else if (ownerPct >= 35) contractScore -= 14;
  else if (ownerPct >= 20) contractScore -= 8;
  else if (ownerPct >= 10) contractScore -= 3;
}

if (verified === true) contractScore += 8;
if (verified === false) contractScore -= 6;

if (!rep?.meta?.symbol && !rep?.meta?.name) contractScore -= 5;

// liquidity penalty handled later (coverage-aware); keep contract leg cleaner
contractScore = qsClamp(Math.round(contractScore), 0, 100);


// market leg
const market = qsComputeMarketRisk(rep);
let marketScore = Number(market.marketScore ?? 100);
const marketFlags = Array.isArray(market.flags) ? market.flags : [];
// Confidence (derived from real scan coverage, not only market module)
// Confidence for UI (separate var to avoid collisions with market module)
let uiConfidence = "low";

const verifiedYes = (verified === true);
const ownerKnown = !!owner;
const liqAny = !!rep?.liq?.any;
const activePoolsNum = Number(rep?.meta?.liqActivePools || 0);

// IMPORTANT: reuse existing flags if already declared earlier
const covLow = !!rep?.meta?.liqCoverageLow;
const covPartial = !!rep?.meta?.liqCoveragePartial;

let uiConfPoints = 0;
if (verifiedYes) uiConfPoints += 2;
if (ownerKnown) uiConfPoints += 1;
if (liqAny) uiConfPoints += 1;
if (activePoolsNum >= 2) uiConfPoints += 1;
if (!covLow && !covPartial) uiConfPoints += 1;

if (covLow) uiConfPoints -= 2;
else if (covPartial) uiConfPoints -= 1;

if (uiConfPoints >= 4) uiConfidence = "high";
else if (uiConfPoints >= 2) uiConfidence = "medium";
else uiConfidence = "low";

// force market score to respect on-chain effective liquidity (stricter)
if (liqQuality === "tiny") {
  marketScore = Math.min(marketScore, 28);
} else if (liqQuality === "low") {
  marketScore = Math.min(marketScore, 58);
} else if (liqQuality === "medium") {
  marketScore = Math.min(marketScore, 75);
}
marketScore = qsClamp(Math.round(marketScore), 0, 100);
if (
  liqQuality === "healthy" &&
  Number(rep.meta?.liqUsdtAmt || 0) >= 100000 &&
  Number(rep.meta?.liqActivePools || 0) >= 2
) {
  marketScore = qsClamp(Math.round(marketScore + 8), 0, 100);
}


// base blend
let score = Math.round(contractScore * 0.40 + marketScore * 0.60);

// existing gates util
score = qsApplyScoreGates(score, rep, marketFlags);

// one normalized flags set
const mFlags = new Set((marketFlags || []).map(s => String(s).toLowerCase()));

// market penalties
if (mFlags.has("possible_manipulated_move")) score -= 22;
if (mFlags.has("extreme_short_term_volatility")) score -= 14;
if (mFlags.has("very_low_liquidity_usd")) score -= 22;
else if (mFlags.has("low_liquidity_usd")) score -= 10;
if (mFlags.has("very_few_holders")) score -= 18;
else if (mFlags.has("few_holders")) score -= 8;
if (mFlags.has("holder_concentration_unknown")) score -= 8;

// liquidity caps with coverage-awareness (stricter + tier-aligned)
if (liqQuality === "tiny") {
  if (rep.meta?.liqCoverageLow) {
    score -= 14; // coverage weak, but still harsh
    if (score > 54) score = 54;
    if (!rep.redFlags.includes("Liquidity appears very low, but DEX coverage may be incomplete.")) {
      rep.redFlags.push("Liquidity appears very low, but DEX coverage may be incomplete.");
    }
  } else {
    score -= 26;
    if (score > 49) score = 49; // force High risk tier max
    if (!rep.redFlags.includes("Very low effective liquidity (thin market, high manipulation risk).")) {
      rep.redFlags.push("Very low effective liquidity (thin market, high manipulation risk).");
    }
  }
} else if (liqQuality === "low") {
  // low liquidity = red, should not look safe
  if (rep.meta?.liqCoverageLow) {
    score -= 12;
    if (score > 62) score = 62;
  } else {
    score -= 20;
    if (score > 58) score = 58; // strong cap inside Caution
  }
  if (!rep.redFlags.includes("Low effective liquidity detected.")) {
    rep.redFlags.push("Low effective liquidity detected.");
  }
} else if (liqQuality === "medium") {
  // medium = yellow, mild cap (a bit stricter)
  score -= 4;
  if (score > 78) score = 78;
}


// critical cap
const hasCritical =
  mFlags.has("possible_manipulated_move") ||
  mFlags.has("very_low_liquidity_usd") ||
  mFlags.has("very_few_holders");
if (hasCritical && score > 69) score = 69;

// confidence/coverage cap
const strongLiquidityEvidence =
  rep?.meta?.liqQuality === "healthy" &&
  Number(rep.meta?.liqUsdtAmt || 0) >= 100000 &&
  Number(rep.meta?.liqActivePools || 0) >= 2 &&
  rep.meta?.liqCoverageLow === false;

if (mFlags.has("holder_concentration_unknown") && rep.meta?.liqCoverageLow && score > 64) {
  score = 64;
}

// ----- guardrails (aligned with tiers + safe caps) -----
//
// Goal:
// - If everything looks healthy (verified/known signals + healthy liquidity), allow high scores.
// - Prevent "too safe" scoring when key info is missing or liquidity is weak.
// - Keep thresholds aligned with overallText:
//   Good >= 85, Mixed >= 70, Caution >= 50, High risk < 50

// A) Unknown Verified + Unknown Owner -> never reach "Good"
const ownerUnknown = !owner;
if (verified !== true && ownerUnknown && score > 84) score = 84; // max Mixed

// B) No liquidity signal at all -> never exceed Caution (and hard cap)
if (!rep?.liq?.any && score > 64) score = 64;
if (hasCode && !rep?.liq?.any && score > 54) score = 54; // strongest cap for "no liquidity"

// C) Low confidence + serious market flags -> never reach "Good"
const lowConf = (uiConfidence === "low");
const hasSeriousMarketFlag =
  mFlags.has("possible_manipulated_move") ||
  mFlags.has("very_low_liquidity_usd") ||
  mFlags.has("very_few_holders");

if (lowConf && hasSeriousMarketFlag && score > 84) score = 84; // max Mixed

if (liqQuality === "tiny" && score > 49) score = 49; // High risk
if (liqQuality === "low"  && score > 69) score = 69; // Caution max
if (liqQuality === "medium" && verified !== true && score > 84) score = 84; // no Good unless verified
// âœ… Tiny verified+healthy bonus (ONLY when truly clean)
try {
  // optional: treat owner concentration as "serious" too
  const ownerPctNum = (typeof ownerPct === "number") ? ownerPct : null;
  const ownerConcentrationSerious = (ownerPctNum !== null && ownerPctNum >= 35);

  if (
    liqQuality === "healthy" &&
    verified === true &&
    !hasSeriousMarketFlag &&
    !ownerConcentrationSerious
  ) {
    score = qsClamp(score + 2, 0, 100);
  }
} catch {}


// final clamp
score = qsClamp(score, 0, 100);
   
const overallText =
  score >= 85 ? "Good" :
  score >= 70 ? "Mixed signals" :
  score >= 50 ? "Caution" :
  "High risk";

rep.score = score;
rep.overallText = overallText;

 rep.meta = {
  ...(rep.meta || {}),
  contractScore,
  marketScore,
  confidence: uiConfidence,
  liqQuality,
  liqCoverageLow: !!rep.meta?.liqCoverageLow,
  liqCoveragePartial: !!rep.meta?.liqCoveragePartial,
  liqWrappedAmt: Number(rep.meta?.liqWrappedAmt || 0),
  liqUsdtAmt: Number(rep.meta?.liqUsdtAmt || 0),
  liqActivePools: Number(rep.meta?.liqActivePools || 0),

  // keep existing fields:
  ownerBalance: ownerBal?.toString?.() || "0",
  ownerPct: ownerPct,
  marketFlags: Array.from(marketFlags || [])
};
    
    rep.mini = [
  { type: score >= 85 ? "ok" : score >= 70 ? "warn" : score >= 50 ? "warn" : "bad", title: "Overall", value: overallText },
  { type: contractScore >= 85 ? "ok" : contractScore >= 70 ? "warn" : "bad", title: "Contract Score", value: String(contractScore) },
  { type: marketScore >= 85 ? "ok" : marketScore >= 70 ? "warn" : "bad", title: "Market Score", value: String(marketScore) },
 {
  type: uiConfidence === "high" ? "ok" : "warn",
  title: "Confidence",
  value: uiConfidence
},
  { type: verified === true ? "ok" : "warn", title: "Verified", value: verified === true ? "Yes" : "No/Unknown" },
  { type: isProxy ? "warn" : "ok", title: "Proxy", value: isProxy ? "Detected" : "No/Unknown" },
  { type: owner ? (ownerIsRenounced ? "ok" : "warn") : "warn", title: "Owner", value: ownerShown },
  { type: holderConcType, title: "Holder Concentration", value: holderConcText },
{
  type:
    !rep.liq?.any ? "warn" :
    liqQuality === "tiny" ? "bad" :
    liqQuality === "low" ? "bad" :
    liqQuality === "medium" ? "warn" : "ok",
  title: "Liquidity",
   value: (() => {
  if (!rep.liq?.any) return "No/Unknown";

 const usd = rep?.meta?.liquidityUsdEst;
 const wrapped = Number(rep?.meta?.liqWrappedAmt || 0);
 const pools = Number(rep?.meta?.liqActivePools || 0);
 const poolsTxt = (pools > 0) ? ` â€¢ pools: ${pools}` : "";
     
  // Prefer stable-based USD estimate if we have it
  if (typeof usd === "number") {
    const usdTxt = ` â€¢ ~$${qsFmtNum(usd, 0)}${poolsTxt}`;
    if (liqQuality === "tiny") return `Very low (thin)${usdTxt}`;
    if (liqQuality === "low") return `Low${usdTxt}`;
    if (liqQuality === "medium") return `Medium${usdTxt}`;
    return `Healthy${usdTxt}`;
  }

  // Fallback: show WBNB amount (and optional USD estimate if you pass BNB price later)
  const wTxt = (wrapped > 0) ? ` â€¢ ~${qsFmtNum(wrapped, 3)} WBNB${poolsTxt}` : poolsTxt;

  if (liqQuality === "tiny") return `Very low (thin)${wTxt}`;
  if (liqQuality === "low") return `Low${wTxt}`;
  if (liqQuality === "medium") return `Medium${wTxt}`;
  return `Healthy${wTxt}`;
})()

},
  { type: mintDetected ? "bad" : "ok", title: "Mint", value: mintDetected ? "Detected" : "No/Unknown" },
  { type: "ok", title: "Pause", value: pauseText }
];


    if (mintDetected) rep.redFlags.push("Mint surface detected (supply risk).");
    if (isProxy) rep.redFlags.push("Proxy detected (upgrade risk).");
    if (!rep.liq?.any) rep.redFlags.push("No clear DEX liquidity signal detected.");
    if (ownerPct !== null && ownerPct >= 35) {
  rep.redFlags.push(`Owner wallet concentration is high (${qsFmtNum(ownerPct, 2)}%).`);
} else if (ownerPct !== null && ownerPct >= 20) {
  rep.redFlags.push(`Owner wallet concentration is elevated (${qsFmtNum(ownerPct, 2)}%).`);
}

    // market-derived red flags
for (const f of (marketFlags || [])) {
  if (f === "possible_manipulated_move") rep.redFlags.push("Price action suggests possible manipulation (high move / thin trading).");
  else if (f === "very_low_liquidity_usd") rep.redFlags.push("Very low liquidity (USD) increases slippage/manipulation risk.");
  else if (f === "low_liquidity_usd") rep.redFlags.push("Low liquidity (USD) detected.");
  else if (f === "very_few_holders") rep.redFlags.push("Very few holders detected.");
  else if (f === "few_holders") rep.redFlags.push("Few holders detected.");
  else if (f === "extreme_short_term_volatility") rep.redFlags.push("Extreme short-term volatility detected.");
  else if (f === "holder_concentration_unknown") rep.redFlags.push("Holder concentration data is incomplete (confidence reduced).");
  else if (f === "no_clear_liquidity_signal" && !rep.redFlags.includes("No clear DEX liquidity signal detected.")) {
    rep.redFlags.push("No clear liquidity signal detected.");
  }

}
    rep.json = safeJson(rep);

    cache[ckey] = { ts: qsNowTs(), rep };
    saveQsCache(cache);
    addQsHistory(net, token);

    setStatus(st, score >= 70 ? "ok" : score >= 50 ? "warn" : "bad", `Done. Score: <b>${score}/100</b> (${overallText}).`);
    render(rep);
    // âœ… Activity counter: count "High-risk contract" when score is 0..80
try {
  if (typeof cxActivitySend === "function" && Number(score) <= 80) {
    cxActivitySend("high_risk_contract", 1);
  }
} catch {}

  function render(rep){
  const sym = rep.meta?.symbol || "Token";
  const nm = rep.meta?.name ? ` â€” ${rep.meta.name}` : "";


      // âœ… compute supply inside render (no TDZ, safe for cached rep)
      let supplyTxt = "â€”";
      try {
        const ts = rep?.meta?.totalSupply;
        const dec = Number(rep?.meta?.decimals ?? 18);
        if (ts != null) supplyTxt = qsFmtBig(BigInt(ts), dec, 4);
      } catch {}

      out.className = "";
      out.style.display = "block";

      const score = rep.score ?? 0;
      const scoreCls = score >= 75 ? "qs-score-ok" : score >= 50 ? "qs-score-warn" : "qs-score-bad";
      const thinLiqWarn = (rep?.meta?.liqQuality === "tiny")
        ? `<div style="margin-top:10px;padding:8px 12px;background:rgba(255,107,107,.1);border:1px solid rgba(255,107,107,.3);border-radius:10px;font-size:12px;color:#ff8a8a;font-weight:700;">
             âš ï¸ Thin liquidity â€” price impact/slippage may be extreme
           </div>`
        : "";

out.innerHTML = `
  <div class="qs-result-card">
    <div class="qs-result-name">
      ${qsEscapeHtml(sym)} â€” ${qsEscapeHtml(nm)}
      <span class="qs-score-badge ${scoreCls}">${score}/100 Â· ${qsEscapeHtml(rep.overallText)}</span>
    </div>
    <div class="qs-result-meta">
      <div>Network: <b>${qsEscapeHtml(rep.chainName || rep.net)}</b></div>
      <div>Token: <span class="mono">${qsEscapeHtml(rep.token)}</span></div>
      <div>Supply: <span class="mono">${qsEscapeHtml(supplyTxt)}</span></div>
      <div>Explorer: <a href="${qsEscapeHtml(rep.explorer)}" target="_blank" rel="noopener">open â†—</a></div>
    </div>
    ${thinLiqWarn}
  </div>
`;

      if (chipsWrap){
        chipsWrap.innerHTML = (rep.mini || []).map(x => qsMiniChip(x.type, x.title, x.value)).join("");
      }

      if (pairsWrap){
        qsRenderLiquidityTable(pairsWrap, rep.liq);
      }
    }
  }

  function initQuickScanUi(){
    if (window.__cx_qs_bound_v6) return;
    window.__cx_qs_bound_v6 = true;
    
    // âœ… Auto checkbox UX (TEMP key without saving)
// Works for unified OR per-network keys, and supports manual override.
// âœ… Auto checkbox UX (works for unified + per-net, supports manual override)
(function qsBindApiAutoCheckbox(){
  const useEl = $("#api-use");
  if (!useEl) return;

  const unifiedEl = $("#api-unified");   
  const bscEl = $("#api-bscscan");       
  const ethEl = $("#api-etherscan");     
  const netEl = $("#qs-net");

  let userOverrode = false;

  function currentNet(){
    try { return netFromSelect("#qs-net"); } catch { return ""; }
  }

  function hasRelevantKey(){
  const u = String(unifiedEl?.value || "").trim();
  const b = String(bscEl?.value || "").trim();
  const e = String(ethEl?.value || "").trim();
  return !!(u || b || e);
}

  function apply(){
    const hasKey = hasRelevantKey();

    if (!hasKey) {
      useEl.checked = false;
      userOverrode = false;
      return;
    }

    if (!userOverrode) useEl.checked = true;
  }

  apply();

  useEl.addEventListener("change", () => { userOverrode = true; });

  const onInput = () => apply();
  unifiedEl?.addEventListener("input", onInput);
  bscEl?.addEventListener("input", onInput);
  ethEl?.addEventListener("input", onInput);
  netEl?.addEventListener("change", onInput);
})();

    $("#qs-run")?.addEventListener("click", () => {
      runQuickScan();
      try { gtagEvent("sec_qs_run"); } catch {}
    });

    $("#qs-copy-link")?.addEventListener("click", async () => {
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");
      const link = qsBuildShareLink(net, qsNormAddr(token));
      const ok = await copyText(link);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_link"); } catch {}
    });

    $("#qs-copy-json")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const ok = await copyText(rep.json || safeJson(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_json"); } catch {}
    });

    $("#qs-copy-md")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const md = qsBuildMarkdownReport(rep);
      const ok = await copyText(md);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied Markdown report." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_md"); } catch {}
    });

    $("#qs-share-x")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const text = qsBuildXText(rep);
      const u = new URL("https://twitter.com/intent/tweet");
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_x"); } catch {}
    });

    $("#qs-share-tg")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const link = rep.shareLink || qsBuildShareLink(net, qsNormAddr(token));
      const text = qsBuildXText(rep);
      const u = new URL("https://t.me/share/url");
      u.searchParams.set("url", link);
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_tg"); } catch {}
    });

    $("#qs-copy-xtext")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const ok = await copyText(qsBuildXText(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied X text." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_xtext"); } catch {}
    });
  } // end initQuickScanUi

  window.CX_QS_V6 = window.CX_QS_V6 || {};
window.CX_QS_V6.initQuickScanUi = initQuickScanUi;
window.CX_QS_V6.runQuickScan = runQuickScan;
window.CX_QS_V6.qsLiqCheckBasic = qsLiqCheckBasic;

// keep compatibility
window.initQuickScanUi = initQuickScanUi;
window.runQuickScan = runQuickScan;

// expose for other modules (Liquidity Scan / external callers)
window.CX = window.CX || {};
window.CX.modules = window.CX.modules || {};
window.CX.modules.qs = window.CX.modules.qs || {};
window.CX.modules.qs.qsLiqCheckBasic = qsLiqCheckBasic;
window.qsLiqCheckBasic = qsLiqCheckBasic;

})(); // end Quick Scan IIFE

    // =========================
    // RPC Health Checker
    // =========================
    function rpcRowHtml(url, ms, chain, block, callOk, logsOk, status, isBest){
  const ok = status === "ok";
  let host = url;
  try { host = new URL(url).host; } catch {}

  const msTxt = (ms != null && ms !== "â€”") ? ms + "ms" : "â€”";
  const msNum = typeof ms === "number" ? ms : parseInt(ms);
  const msCls = !ok ? "rpc-ms-fail" : msNum < 500 ? "rpc-ms-ok" : "rpc-ms-slow";

  function chk(val, label){
    const pass = val === "âœ…" || (typeof val === "number") || (val && val !== "â€”" && val !== false);
    const icon = pass ? "âœ…" : "âŒ";
    const cls = pass ? "pass" : "fail-chk";
    return `<span class="rpc-check ${cls}">${icon} ${label}</span>`;
  }

  const chainOk = (chain && chain !== "â€”") ? "âœ…" : "â€”";

  return `
    <div class="rpc-card ${ok ? "rpc-card-ok" : "rpc-card-fail"}${isBest ? " rpc-card-best" : ""}">
      <div class="rpc-card-top">
        <div class="rpc-card-host">${host}</div>
        <div class="rpc-card-right">
          ${isBest ? '<span class="rpc-best-badge">â­ Best</span>' : ""}
          <span class="rpc-ms ${msCls}">${ok ? msTxt : "failed"}</span>
        </div>
      </div>
      <div class="rpc-checks">
        ${chk(chainOk, "chainId")}
        ${chk(block, "block")}
        ${chk(callOk, "eth_call")}
        ${chk(logsOk, "getLogs")}
      </div>
    </div>
  `;
}


    async function rpcTestOne(net, url){
      const chainIdExpected = CHAINS[net].chainId;

      const t0 = performance.now();
      let chainId = null;
      let block = null;
      let callOk = "â€”";
      let logsOk = "â€”";

      try{
        const cid = await rpcRequest(url, "eth_chainId", [], 8000);
        chainId = parseInt(cid, 16);
        if (chainId !== chainIdExpected) throw new Error(`wrong chainId ${chainId}`);
      } catch (e){
        const ms = Math.round(performance.now() - t0);
        return { ok: false, url, ms, chainId: chainId ?? "â€”", block: "â€”", callOk: "â€”", logsOk: "â€”", err: e };
      }

      try{
        const bn = await rpcRequest(url, "eth_blockNumber", [], 8000);
        block = parseInt(bn, 16);
      } catch {}

      try{
        // simple eth_call to get WETH/WBNB decimals (cheap)
        const wrapped = CHAINS[net].wrapped;
        const dataDecimals = "0x313ce567"; // decimals()
        const res = await rpcRequest(url, "eth_call", [{ to: wrapped, data: dataDecimals }, "latest"], 8000);
        callOk = (res && res !== "0x") ? "âœ…" : "â€”";
      } catch {
        callOk = "â€”";
      }

      try{
        // lightweight logs read: last 200 blocks, Transfer topic on wrapped
        const latest = block || (parseInt(await rpcRequest(url, "eth_blockNumber", [], 8000), 16));
        const from = Math.max(0, latest - 200);
        const filter = {
          address: CHAINS[net].wrapped,
          fromBlock: "0x" + from.toString(16),
          toBlock: "0x" + latest.toString(16),
          topics: [TRANSFER_TOPIC0]
        };
        const logs = await rpcRequest(url, "eth_getLogs", [filter], 8500);
        logsOk = Array.isArray(logs) ? "âœ…" : "â€”";
      } catch {
        logsOk = "â€”";
      }

      const ms = Math.round(performance.now() - t0);
      return { ok: true, url, ms, chainId, block, callOk, logsOk };
    }

    async function runRpcTest(){
      const st = $("#rpc-status");
      clearStatus(st);

      const net = netFromSelect("#rpc-net");
      const table = $("#rpc-table");
      if (table) table.innerHTML = "";

      const urls = buildRpcCandidates(net);
      if (!urls.length) return setStatus(st, "warn", "No RPCs available.");

      setStatus(st, "info", `Testing ${urls.length} RPC(s)â€¦`);

      // collect all results first, then re-render with best marked
      const results = [];
      for (const url of urls) {
        const r = await rpcTestOne(net, url);
        results.push(r);
        if (table) {
          table.insertAdjacentHTML("beforeend", rpcRowHtml(
            url, r.ms ?? "â€”", r.chainId ?? "â€”", r.block ?? "â€”",
            r.callOk ?? "â€”", r.logsOk ?? "â€”", r.ok ? "ok" : "fail", false
          ));
        }
      }

      // find best
      const okResults = results.filter(r => r.ok);
      const best = okResults.length ? okResults.reduce((a,b) => a.ms < b.ms ? a : b) : null;

      if (best) {
        setSavedBestRpc(net, best.url);
        // re-render all with best marked
        if (table) {
          table.innerHTML = "";
          results.forEach(r => {
            table.insertAdjacentHTML("beforeend", rpcRowHtml(
              r.url, r.ms ?? "â€”", r.chainId ?? "â€”", r.block ?? "â€”",
              r.callOk ?? "â€”", r.logsOk ?? "â€”", r.ok ? "ok" : "fail",
              r.url === best.url
            ));
          });
        }
        setStatus(st, "ok", `Best RPC: <span class="mono" style="font-size:11px">${best.url}</span>`);
        gtagEvent("sec_rpc_best_saved", { net });
      } else {
        setStatus(st, "bad", "All RPCs failed (CORS/timeout/blocked). Try adding a custom RPC.");
      }
      gtagEvent("sec_rpc_test", { net });
    }

    async function rpcCopyBest(){
      const net = netFromSelect("#rpc-net");
      const best = getSavedBestRpc(net);
      if (!best) return setStatus($("#rpc-status"), "warn", "No saved best RPC yet. Run test first.");
      const ok = await copyText(best);
      setStatus($("#rpc-status"), ok ? "ok" : "warn", ok ? "Copied best RPC." : "Copy failed.");
    }

    function initRpcUi(){
      const netSel = $("#rpc-net");
      const privInput = $("#rpc-private");

      const loadPrivToInput = () => {
        const net = netFromSelect("#rpc-net");
        const saved = getSavedPrivateRpc(net);
        if (privInput) privInput.value = saved;
      };

      netSel?.addEventListener("change", loadPrivToInput);
      loadPrivToInput();

      $("#rpc-private-save")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const v = ($("#rpc-private")?.value || "").trim();
        if (v) setSavedPrivateRpc(net, v);
        setStatus($("#rpc-status"), "ok", "Saved private RPC locally.");
      });

      $("#rpc-private-clear")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        setSavedPrivateRpc(net, "");
        if ($("#rpc-private")) $("#rpc-private").value = "";
        setStatus($("#rpc-status"), "ok", "Cleared private RPC.");
      });

      $("#rpc-test")?.addEventListener("click", runRpcTest);
      $("#rpc-copy-best")?.addEventListener("click", rpcCopyBest);

      $("#rpc-share-x")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const best = getSavedBestRpc(net) || "â€”";
        const u = new URL("https://twitter.com/intent/tweet");
        u.searchParams.set("text", `RPC Health (${CHAINS[net].name})\nBest: ${best}\nCycleX Security Hub`);
        window.open(u.toString(), "_blank", "noopener,noreferrer");
      });

      // Dev custom logs test
      $("#rpc-dev-run")?.addEventListener("click", async () => {
        const net = netFromSelect("#rpc-net");
        const addrRaw = ($("#rpc-dev-addr")?.value || "").trim();
        const topic0 = ($("#rpc-dev-topic")?.value || "").trim() || TRANSFER_TOPIC0;
        if (!addrRaw) return setStatus($("#rpc-status"), "warn", "Enter a contract address for the dev test.");
        if (!isAddr(addrRaw)) return setStatus($("#rpc-status"), "warn", "Invalid contract address.");

        const addr = normAddr(addrRaw);
        const urls = buildRpcCandidates(net);
        if (!urls.length) return setStatus($("#rpc-status"), "warn", "No RPCs available.");

        setStatus($("#rpc-status"), "info", "Running custom logs testâ€¦");
        const latest = await withRpcFallback(net, async (provider, url) => {
          const bn = await provider.getBlockNumber();
          return { url, bn };
        }, { timeoutMs: 9500 });

        if (!latest.ok) return setStatus($("#rpc-status"), "bad", `Failed to read block number: ${String(latest.err?.message || latest.err)}`);

        const bn = latest.res.bn;
        const from = Math.max(0, bn - 2000);

        const r = await withRpcFallback(net, async (provider, url) => {
          const logs = await provider.getLogs({
            address: addr,
            fromBlock: from,
            toBlock: bn,
            topics: [topic0]
          });
          return { url, count: logs.length };
        }, { timeoutMs: 10500 });

        if (r.ok) {
          setStatus($("#rpc-status"), "ok", `Custom logs test OK (${r.res.count} logs) â€” RPC: <span class="mono">${r.url}</span>`);
        } else {
          setStatus($("#rpc-status"), "bad", `Custom logs test failed: ${String(r.err?.message || r.err)}`);
        }
        gtagEvent("sec_rpc_dev_logs", { net });
      });
    }

// =========================
// Tx Decoder (4-line fixed DOM + Allowance line + MethodId + Tokens touched)

// Tx Decoder (4-line fixed DOM + Allowance line + MethodId + Tokens touched)
// Drop-in replacement for your whole Tx Decoder block.
// =========================

(() => {
  // ---- Minimal ABIs ----
  const tx_ROUTER_ABI_MIN = [
    "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETH(uint256,uint256,address[],address,uint256)",
    "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)"
  ];

  const tx_ERC20_ABI_MIN = [
    "function symbol() view returns (string)",
    "function name() view returns (string)",
    "function decimals() view returns (uint8)"
  ];

  // ---- Constants ----
  const tx_U256_MAX = (1n << 256n) - 1n;

  // Known routers (lowercase keys)
  const tx_KNOWN_ROUTERS = {
    bsc: {
      "0x10ed43c718714eb63d5aa57b78b54704e256024e": "PancakeSwap Router",
      "0x13f4ea83d0bd40e75c8222255bc855a974568dd4": "PancakeSwap V3 Router"
    },
    eth: {
      "0x7a250d5630b4cf539739df2c5dacb4c659f2488d": "Uniswap V2 Router",
      "0xef1c6e67703c7bd7107eed8303fbe6ec2554bf6b": "Uniswap Universal Router"
    }
  };

  // ---- Token meta cache ----
  const tx_TOKEN_META_CACHE = {}; // key: `${net}:${addr}` -> {symbol,name,decimals}

  // ---- Helpers ----
  function tx_esc(s){
    try{
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    } catch { return ""; }
  }

  function tx_badge(kind, label) {
    const k = (kind === "ok" || kind === "warn" || kind === "bad" || kind === "unk") ? kind : "unk";
    return `<span class="v ${k}"><span class="dot"></span>${tx_esc(label)}</span>`;
  }

  function tx_setSum(sel, html) {
    const el = document.querySelector(sel);
    if (el) el.innerHTML = html;
  }

  // Titles already exist in HTML on the left; we only set the value HTML.
  function tx_setLine(sel, _title, badgeHtml) {
    tx_setSum(sel, badgeHtml);
  }

  // Impact line supports a subline (Allowance)
  function tx_setImpactLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-impact", `${badgeHtml}${sub}`);
  }

  // NEW: Target line supports a subline (Tokens touched)
  function tx_setTargetLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-target", `${badgeHtml}${sub}`);
  }

  function tx_resetSummary() {
    tx_setLine("#tx-sum-action", "Action", tx_badge("unk", "â€”"));
    tx_setLine("#tx-sum-risk", "Risk", tx_badge("unk", "â€”"));
    // use Target line with empty subline (keeps same DOM, just value HTML)
    tx_setTargetLine(tx_badge("unk", "â€”"), "");
    tx_setImpactLine(tx_badge("unk", "â€”"), "");
  }

  function tx_isUnlimitedApprove(vBigInt) {
    try { return typeof vBigInt === "bigint" && vBigInt === tx_U256_MAX; } catch { return false; }
  }

  function tx_getKnownRouterName(net, addr) {
    const m = (tx_KNOWN_ROUTERS && tx_KNOWN_ROUTERS[net]) ? tx_KNOWN_ROUTERS[net] : {};
    if (!addr) return "";
    const k = isAddr(addr) ? normAddr(addr) : String(addr).toLowerCase();
    return m[k] || "";
  }

  function tx_decodeTransferLog(log) {
    try {
      const from = "0x" + log.topics[1].slice(26);
      const to   = "0x" + log.topics[2].slice(26);
      const val  = BigInt(log.data);
      return { token: normAddr(log.address), from: normAddr(from), to: normAddr(to), value: val };
    } catch { return null; }
  }

  function tx_decodeApprovalLog(log) {
    try {
      const owner   = "0x" + log.topics[1].slice(26);
      const spender = "0x" + log.topics[2].slice(26);
      const val     = BigInt(log.data);
      return { token: normAddr(log.address), owner: normAddr(owner), spender: normAddr(spender), value: val };
    } catch { return null; }
  }

  // Method selector (4 bytes)
  function tx_callSelector(txData) {
    try {
      const d = String(txData || "");
      if (d && d.startsWith("0x") && d.length >= 10) return d.slice(0, 10);
      return "";
    } catch { return ""; }
  }

  async function tx_getTokenMeta(readProvider, net, tokenAddr) {
    try {
      if (!tokenAddr || !isAddr(tokenAddr)) return null;
      const a = normAddr(tokenAddr);
      const key = `${net}:${a}`;
      if (tx_TOKEN_META_CACHE[key]) return tx_TOKEN_META_CACHE[key];

      const c = new E.Contract(a, tx_ERC20_ABI_MIN, readProvider);
      const [symbol, name, decimals] = await Promise.allSettled([c.symbol(), c.name(), c.decimals()]);

      const meta = {
        symbol: symbol.status === "fulfilled" ? String(symbol.value || "") : "",
        name: name.status === "fulfilled" ? String(name.value || "") : "",
        decimals: decimals.status === "fulfilled" ? Number(decimals.value) : null
      };

      tx_TOKEN_META_CACHE[key] = meta; // cache even partial
      return meta;
    } catch {
      return null;
    }
  }

  function tx_formatUnitsSafe(valueBigInt, decimals) {
    try {
      if (decimals == null || Number.isNaN(decimals)) return null;
      return E.formatUnits(valueBigInt, decimals);
    } catch {
      return null;
    }
  }

  function tx_pickPrimaryToken(approvals, transfers) {
    return (approvals[0]?.token) || (transfers[0]?.token) || "";
  }

  function tx_pickPrimaryApproval(approvals, net){
    // Prefer: unlimited > known-router > larger value > first
    let best = null;
    let bestIsUnlimited = false;
    let bestHasRouter = false;

    for (const a of approvals) {
      if (!a) continue;
      if (!best) { best = a; bestIsUnlimited = tx_isUnlimitedApprove(a.value); bestHasRouter = !!tx_getKnownRouterName(net, a.spender); continue; }

      const aUnlimited = tx_isUnlimitedApprove(a.value);
      const aHasRouter = !!tx_getKnownRouterName(net, a.spender);

      if (!bestIsUnlimited && aUnlimited) { best = a; bestIsUnlimited = true; bestHasRouter = aHasRouter; continue; }
      if (bestIsUnlimited && aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
      }
      if (!bestIsUnlimited && !aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
        if (typeof a.value === "bigint" && typeof best.value === "bigint" && a.value > best.value) { best = a; continue; }
      }
    }
    return best;
  }

  // =========================
  // Main
  // =========================
  async function runTxDecode() {
    const st = $("#tx-status");
    const out = $("#tx-out");
    const evWrap = $("#tx-events");
    clearStatus(st);

    tx_resetSummary();

    const net = netFromSelect("#tx-net");
    const hash = ($("#tx-hash")?.value || "").trim();
    if (!hash || !/^0x([A-Fa-f0-9]{64})$/.test(hash)) {
      setStatus(st, "warn", "Please paste a valid tx hash.");
      return;
    }

    const urls = buildRpcCandidates(net);
if (!urls.length) return setStatus(st, "bad", "No RPC available.");

setStatus(st, "info", "Fetching tx + receiptâ€¦");

try {
  const r = await withRpcFallback(net, async (provider, url) => {
    const [tx, rc] = await Promise.all([
      provider.getTransaction(hash),
      provider.getTransactionReceipt(hash)
    ]);

    if (!tx) throw new Error("tx_null");
    return { provider, tx, rc };
  }, { timeoutMs: 12000 });

  if (!r.ok) {
    const msg = String(r.err?.message || r.err || "");
    if (msg.includes("tx_null")) return setStatus(st, "bad", "Tx not found (wrong network / unsynced RPC).");
    return setStatus(st, "bad", `RPC failed: ${msg}`);
  }

  const read = r.res.provider;
  const tx = r.res.tx;
  const rc = r.res.rc;


      const chain = CHAINS[net];
      const txLink = chain.txUrl(hash);

      // best-effort decode (router calls)
      let decoded = null;
      try {
        const iface = new E.Interface(tx_ROUTER_ABI_MIN);
        decoded = iface.parseTransaction({ data: tx.data, value: tx.value });
      } catch {}

      const logs = rc?.logs || [];
      const transfersRaw = logs.filter(l => l.topics?.[0] === TRANSFER_TOPIC0).slice(0, 50);
      const approvalsRaw = logs.filter(l => l.topics?.[0] === APPROVAL_TOPIC0).slice(0, 50);

      const transfers = transfersRaw.map(tx_decodeTransferLog).filter(Boolean);
      const approvals = approvalsRaw.map(tx_decodeApprovalLog).filter(Boolean);

      const decodedName = decoded?.name || "";
      const hasRouterSwap = decodedName.toLowerCase().includes("swap");
      const hasApproval = approvals.length > 0;
      const hasTransfers = transfers.length > 0;

      const rcStatus = (rc && typeof rc.status !== "undefined") ? rc.status : undefined;
      const reverted = (rcStatus === 0 || rcStatus === 0n);

      // --- MethodId (selector) for unknown calls ---
      const methodId = (!decodedName && tx?.to) ? tx_callSelector(tx.data) : "";

      // -------------------------
      // Token meta preload (1â€“3 tokens touched)
      // Keep it fast and stable: prefer primary token first.
      // -------------------------
      const primaryToken = tx_pickPrimaryToken(approvals, transfers);

      const tokenSet = new Set();
      if (primaryToken) tokenSet.add(primaryToken);
      for (const t of transfers) if (t?.token) tokenSet.add(t.token);
      for (const a of approvals) if (a?.token) tokenSet.add(a.token);

      const tokenList = Array.from(tokenSet).slice(0, 3);
      const metaMap = {};

      await Promise.all(tokenList.map(async (addr) => {
        const meta = await tx_getTokenMeta(read, net, addr);
        metaMap[addr] = meta || null;
      }));

      const tokensTouched = tokenList
        .map(addr => (metaMap[addr]?.symbol || metaMap[addr]?.name || "").trim())
        .filter(Boolean)
        .slice(0, 3);

      // -------------------------
      // Action
      // -------------------------
      let actionLabel = "Unknown";
      let actionKind  = "unk";

      if (!tx.to && rc?.contractAddress) {
        actionLabel = "Contract creation";
        actionKind = reverted ? "warn" : "ok";
      } else if (decodedName) {
        actionLabel = decodedName;
        actionKind  = hasRouterSwap ? "ok" : "warn";
      } else if ((tx.data === "0x" || !tx.data) && tx.value && BigInt(tx.value) > 0n) {
        actionLabel = "Native transfer";
        actionKind = "warn";
      } else if (tx.to) {
        actionLabel = methodId ? `Contract call (unknown â€¢ ${methodId})` : "Contract call (unknown)";
        actionKind = "warn";
      }

      // -------------------------
      // Approval analysis
      // -------------------------
      let sawUnlimited = false;
      let sawKnownRouterUnlimited = false;
      let sawFiniteApprove = false;
      let sawRevoke = false;

      const knownRouterNames = new Set();

      for (const a of approvals) {
        if (!a) continue;

        const rn = tx_getKnownRouterName(net, a.spender);
        if (rn) knownRouterNames.add(rn);

        if (tx_isUnlimitedApprove(a.value)) {
          sawUnlimited = true;
          if (rn) sawKnownRouterUnlimited = true;
        } else {
          if (a.value === 0n) sawRevoke = true;
          else sawFiniteApprove = true;
        }
      }

      // -------------------------
      // Allowance subline (ONLY when approvals exist)
      // Allowance: TOKEN â†’ SPENDER (Unlimited / Limited / Revoked)
      // -------------------------
      let allowanceSub = "";
      if (hasApproval) {
        const bestAppr = tx_pickPrimaryApproval(approvals, net);
        if (bestAppr) {
          const tokenAddr = bestAppr.token;
          const spenderAddr = bestAppr.spender;

          const tokenMeta = metaMap[tokenAddr] || null;
          const tokName = (tokenMeta?.symbol || tokenMeta?.name || shortAddr(tokenAddr)).trim();

          const spenderRouter = tx_getKnownRouterName(net, spenderAddr);
          const spenderName = spenderRouter ? spenderRouter : shortAddr(spenderAddr);

          let status = "";
          if (tx_isUnlimitedApprove(bestAppr.value)) {
            status = "Unlimited";
          } else if (bestAppr.value === 0n) {
            status = "Revoked";
          } else {
            // show amount if decimals known
            const dec = tokenMeta?.decimals;
            const pretty = (dec != null) ? tx_formatUnitsSafe(bestAppr.value, dec) : null;
            status = pretty ? `Limited: ${pretty}` : "Limited";
          }

          allowanceSub = `Allowance: ${tokName} \u2192 ${spenderName} (${status})`;
        }
      }

      // -------------------------
      // Target (Token/Asset + creation support)
      // -------------------------
      let targetKind = "unk";
      let targetLabel = "â€”";

      if (!tx.to && rc?.contractAddress) {
        targetLabel = `New contract (${shortAddr(rc.contractAddress)})`;
        targetKind = reverted ? "warn" : "ok";
      } else if (tx.to) {
        const toRouterName = tx_getKnownRouterName(net, tx.to);
        if (toRouterName) {
          targetLabel = `${toRouterName} (${shortAddr(tx.to)})`;
          targetKind = "warn";
        } else if (primaryToken) {
          const meta = metaMap[primaryToken] || null;
          const nm = (meta?.symbol || meta?.name || "").trim();
          targetLabel = nm ? `${nm} (${shortAddr(primaryToken)})` : shortAddr(primaryToken);
          targetKind = "ok";
        } else {
          targetLabel = shortAddr(tx.to);
          targetKind = "ok";
        }
      }

      // NEW: Tokens touched subline for Summary (only when we have 1â€“3)
      const touchedSub = tokensTouched.length ? `Tokens touched: ${tokensTouched.join(", ")}` : "";

      // -------------------------
      // Risk (heuristics)
      // -------------------------
      let riskLabel = "Unknown";
      let riskKind  = "unk";

      if (reverted) {
        riskLabel = "Tx reverted (failed)";
        riskKind = "warn";
      } else if (hasRouterSwap) {
        riskLabel = "Likely DEX swap";
        riskKind = "ok";
      } else if (sawUnlimited && !sawKnownRouterUnlimited) {
        riskLabel = "High risk: unlimited approval (unknown spender)";
        riskKind = "bad";
      } else if (sawUnlimited && sawKnownRouterUnlimited) {
        const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
        riskLabel = `Unlimited approval (known router${names ? ": " + names : ""})`;
        riskKind = "warn";
      } else if (hasApproval && !decodedName) {
        riskLabel = "Approval without decoded call";
        riskKind = "warn";
      } else if (!decodedName && hasTransfers) {
        riskLabel = "Transfer activity (unknown call)";
        riskKind = "warn";
      } else if (decodedName) {
        riskLabel = "Contract interaction";
        riskKind = "warn";
      }

      // -------------------------
      // Max impact (Allowance-aware + largest transfer)
      // -------------------------
      let impactLabel = "â€”";
      let impactKind = "unk";

      if (sawUnlimited) {
        if (sawKnownRouterUnlimited) {
          const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
          impactLabel = `Unlimited spending approved (known router${names ? ": " + names : ""})`;
          impactKind = "warn";
        } else {
          impactLabel = "Unlimited spending approved (unknown spender)";
          impactKind = "bad";
        }
      } else if (sawFiniteApprove) {
        impactLabel = "Spending approved (limited)";
        impactKind = "warn";
      } else if (sawRevoke && !hasTransfers) {
        impactLabel = "Allowance revoked";
        impactKind = "ok";
      } else if (tx.value && BigInt(tx.value) > 0n) {
        impactLabel = `Sends ${E.formatEther(tx.value)} native`;
        impactKind = "warn";
      } else if (hasTransfers) {
        let largest = transfers[0];
        for (const t of transfers) if (t.value > largest.value) largest = t;

        const meta = metaMap[largest?.token] || null;
        const sym = (meta?.symbol || "").trim();
        const dec = meta?.decimals;

        const pretty = (dec != null) ? tx_formatUnitsSafe(largest.value, dec) : null;
        if (pretty && sym) impactLabel = `Largest transfer: ${pretty} ${sym}`;
        else if (sym) impactLabel = `Largest transfer: ${sym} (raw)`;
        else impactLabel = `${transfers.length} token transfer(s)`;

        impactKind = "ok";
      } else if (hasApproval) {
        impactLabel = "Allowance changed";
        impactKind = "warn";
      }

      // -------------------------
      // Fill the 4 fixed lines
      // (Target now includes Tokens touched subline)
      // (+ allowance subline under Max impact)
      // -------------------------
      tx_setLine("#tx-sum-action", "Action", tx_badge(actionKind, actionLabel));
      tx_setLine("#tx-sum-risk", "Risk", tx_badge(riskKind, riskLabel));
      tx_setTargetLine(tx_badge(targetKind, targetLabel), touchedSub);
      tx_setImpactLine(tx_badge(impactKind, impactLabel), allowanceSub);

      // -------------------------
      // Details panel (professional: Status + Gas + MethodId + Tokens touched)
      // -------------------------
      const gasUsed = rc?.gasUsed ? String(rc.gasUsed) : "â€”";
      const statusTxt = (typeof rcStatus === "undefined") ? "â€”" : (reverted ? "FAILED" : "SUCCESS");
      const statusColor = reverted ? "#ff7a8a" : "#5dffb2";
      out.className = "";
      out.innerHTML = `
        <div class="tx-detail-card">
          <div class="tx-detail-row">
            <span class="tx-detail-k">Tx</span>
            <span class="tx-detail-v"><a href="${txLink}" target="_blank" rel="noopener" style="color:var(--cyan)">${shortAddr(hash)}</a> <span style="color:var(--muted);font-size:11px">${tx_esc(String(net).toUpperCase())}</span></span>
          </div>
          <div class="tx-detail-row">
            <span class="tx-detail-k">Status</span>
            <span class="tx-detail-v" style="color:${statusColor};font-weight:700">${tx_esc(statusTxt)}</span>
          </div>
          <div class="tx-detail-row">
            <span class="tx-detail-k">Gas used</span>
            <span class="tx-detail-v mono">${tx_esc(gasUsed)}</span>
          </div>
          ${tokensTouched.length ? `<div class="tx-detail-row"><span class="tx-detail-k">Tokens</span><span class="tx-detail-v" style="color:var(--cyan)">${tx_esc(tokensTouched.join(", "))}</span></div>` : ""}
          ${methodId ? `<div class="tx-detail-row"><span class="tx-detail-k">Method</span><span class="tx-detail-v mono" style="color:var(--muted)">${tx_esc(methodId)}</span></div>` : ""}
          <div class="tx-detail-row">
            <span class="tx-detail-k">From</span>
            <span class="tx-detail-v mono" style="font-size:11px;word-break:break-all">${tx_esc(tx.from)}</span>
          </div>
          <div class="tx-detail-row">
            <span class="tx-detail-k">To</span>
            <span class="tx-detail-v mono" style="font-size:11px;word-break:break-all">${tx_esc(tx.to || "â€”")}</span>
          </div>
          <div class="tx-detail-row" style="border-bottom:none">
            <span class="tx-detail-k">Value</span>
            <span class="tx-detail-v mono">${tx_esc(tx.value ? E.formatEther(tx.value) : "0")}</span>
          </div>
        </div>
      `;
      out.style.display = "block";

      // -------------------------
      // Events (with token labels best-effort)
      // -------------------------
      const items = [];

      if (decoded?.args) {
        const args = [];
        decoded.args.forEach((v, i) => {
          args.push(`<div class="small mono" style="margin-top:6px;">arg${i}: ${tx_esc(String(v))}</div>`);
        });
        items.push(`
          <div class="card">
            <h3>Decoded Inputs</h3>
            <div class="small">Best-effort decode for common router calls.</div>
            ${args.join("")}
          </div>
        `);
      }

      if (transfers.length) {
        const rows = transfers.map(d => {
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const dec = meta?.decimals;
          const pretty = (dec != null) ? tx_formatUnitsSafe(d.value, dec) : null;
          const amount = pretty ? `<span style="color:#5dffb2;font-weight:700">${tx_esc(pretty)} ${tx_esc(sym)}</span>` : `<span class="muted">${tx_esc(d.value.toString())}</span>`;
          return `<div class="tx-event-row">
            <span class="tx-event-icon" style="color:#5dffb2">â‡„</span>
            <span class="tx-event-body">
              <span class="mono" style="font-size:11px">${shortAddr(d.from)}</span>
              <span style="color:var(--muted);margin:0 4px">â†’</span>
              <span class="mono" style="font-size:11px">${shortAddr(d.to)}</span>
              <span style="margin:0 6px">Â·</span>${amount}
            </span>
          </div>`;
        }).join("");
        items.push(`<div class="card"><h3 style="color:#5dffb2">Transfer Events</h3>${rows}</div>`);
      }

      if (approvals.length) {
        const rows = approvals.map(d => {
          const routerName = tx_getKnownRouterName(net, d.spender);
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const isUnlim = tx_isUnlimitedApprove(d.value);
          const isRevoke = d.value === 0n;
          const badgeColor = isUnlim ? "#ff7a8a" : isRevoke ? "#5dffb2" : "#ffd166";
          const badgeText = isUnlim ? "UNLIMITED" : isRevoke ? "REVOKED" : "Limited";
          const spenderLabel = routerName ? `${routerName} (${shortAddr(d.spender)})` : shortAddr(d.spender);
          return `<div class="tx-event-row">
            <span class="tx-event-icon" style="color:${badgeColor}">âœ“</span>
            <span class="tx-event-body">
              <span class="mono" style="font-size:11px">${sym ? tx_esc(sym) + " " : ""}approval â†’ ${tx_esc(spenderLabel)}</span>
              <span style="margin-left:6px;padding:2px 7px;border-radius:999px;font-size:10px;font-weight:700;background:${badgeColor}22;color:${badgeColor};border:1px solid ${badgeColor}44">${badgeText}</span>
            </span>
          </div>`;
        }).join("");
        items.push(`<div class="card"><h3 style="color:#ffd166">Approval Events</h3>${rows}</div>`);
      }

      evWrap.innerHTML = items.length
        ? `<div class="grid-2">${items.join("")}</div>`
        : `<div class="small muted">No common events detected (or log count is zero).</div>`;

      setStatus(st, "ok", "Done.");
      gtagEvent("sec_tx_decode", { net });

    } catch (e) {
      setStatus(st, "bad", `Decode failed: ${String(e?.message || e)}`);
    }
  }

  // =========================
  // UI wiring (idempotent)
  // =========================
  let tx_ui_inited = false;

  function initTxUi() {
    if (tx_ui_inited) return;
    tx_ui_inited = true;

    $("#tx-run")?.addEventListener("click", runTxDecode);

    $("#tx-copy-md")?.addEventListener("click", async () => {
      const a = (document.querySelector("#tx-sum-action")?.innerText || "Action â€”").trim();
      const r = (document.querySelector("#tx-sum-risk")?.innerText || "Risk â€”").trim();
      const t = (document.querySelector("#tx-sum-target")?.innerText || "Target â€”").trim();
      const m = (document.querySelector("#tx-sum-impact")?.innerText || "Max impact â€”").trim();
      const body = ($("#tx-out")?.innerText || "").trim();

      const txt = ["Tx Decoder Summary", a, r, t, m, "", body].join("\n");

      const ok = await copyText(txt);
      setStatus($("#tx-status"), ok ? "ok" : "warn", ok ? "Copied." : "Copy failed.");
    });
  }

  // =========================
  // Export
  // =========================
  window.CX = window.CX || {};
  window.CX.runTxDecode = runTxDecode;
  window.CX.initTxUi = initTxUi;
  window.CX.txDecoder = window.CX.txDecoder || {};
  window.CX.txDecoder.getTokenMeta = tx_getTokenMeta;
  window.CX.txDecoder.metaCache = tx_TOKEN_META_CACHE;

})();


    // =========================
    // Dev Tools (Bookmarklet + Monitor)
    // =========================
    function renderBmHelp(){
      const el = $("#bm-help");
      if (!el) return;
      el.innerHTML = t(currentLang, "bm_help_html") || "";
    }

    function bmGenerate(){
      const base = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
      const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${base}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

      const bm = `javascript:${encodeURIComponent(js)}`;
      setStatus($("#bm-out"), "ok", `Bookmarklet generated. <span class="mono">(copy it)</span>`);
      $("#bm-out").dataset.bm = bm;
      const drag = $("#bm-drag");
if (drag) {
  drag.href = bm;                 
  drag.classList.remove("hidden");
  drag.setAttribute("data-ready", "1");
}
      renderBmHelp();
      gtagEvent("sec_bm_generate");
    }

    async function bmCopy(){
      const bm = $("#bm-out")?.dataset?.bm || "";
      if (!bm) return setStatus($("#bm-out"), "warn", "Generate first.");
      const ok = await copyText(bm);
      setStatus($("#bm-out"), ok ? "ok" : "warn", ok ? "Copied bookmarklet." : "Copy failed.");
    }

    function loadMonitor(){
      try { return JSON.parse(localStorage.getItem(LS_MON) || "[]"); } catch { return []; }
    }
    function saveMonitor(list){
      try { localStorage.setItem(LS_MON, JSON.stringify(list || [])); } catch {}
    }

    function renderMonitorTable(){
      const table = $("#mon-table");
      if (!table) return;
      const head = table.querySelector(".trow.head");
      table.innerHTML = "";
      if (head) table.appendChild(head);

      const list = loadMonitor();
      if (!list.length) {
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell muted">â€”</div>
    <div class="cell muted">â€”</div>
    <div class="cell muted hide-sm">â€”</div>
    <div class="cell muted">â€”</div>
    <div class="cell muted">â€”</div>
  </div>
`);
        return;
      }

      for (const item of list) {
        const chain = CHAINS[item.net];
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell mono"><a href="${chain.addressUrl(item.addr)}" target="_blank" rel="noopener">${shortAddr(item.addr)}</a></div>
    <div class="cell">${String(item.net || "").toUpperCase()}</div>
    <div class="cell hide-sm">${
  item.lastSeen
    ? new Date(item.lastSeen * 1000).toLocaleString().replace(", ", "<br>")
    : "â€”"
}</div>
    <div class="cell">${item.status || "â€”"}</div>

    <div class="cell">
      <button class="mon-remove" type="button"
              data-action="mon-remove"
              data-addr="${item.addr}"
              data-net="${item.net}"
              title="Remove"
              aria-label="Remove">Ã—</button>
    </div>
  </div>
`);
      }
    }

    async function monAdd(){
      const st = $("#mon-status");
      clearStatus(st);

      const net = netFromSelect("#mon-net");
      const addrRaw = ($("#mon-addr")?.value || "").trim();
      if (!isAddr(addrRaw)) return setStatus(st, "warn", "Enter a valid contract address.");

      const addr = normAddr(addrRaw);
      const list = loadMonitor();
      const key = `${net}:${safeLower(addr)}`;
      const filtered = list.filter(x => `${x.net}:${safeLower(x.addr)}` !== key);
      filtered.unshift({ net, addr, status: "added", lastSeen: nowTs() });
      saveMonitor(filtered.slice(0, 50));
      renderMonitorTable();
      setStatus(st, "ok", "Added to monitor list (local).");
      gtagEvent("sec_mon_add", { net });
    }

    async function monCheckAll(){
      const st = $("#mon-status");
      clearStatus(st);

      const list = loadMonitor();
      if (!list.length) return setStatus(st, "warn", "Monitor list is empty.");

      setStatus(st, "info", `Checking ${list.length} contract(s)â€¦`);

      for (const item of list) {
        try{
          const codeRes = await getCodeSafe(item.net, item.addr);
          item.status = (codeRes.ok && codeRes.code && codeRes.code !== "0x") ? "code âœ…" : "no code âŒ";
          item.lastSeen = nowTs();
        } catch {
          item.status = "error";
          item.lastSeen = nowTs();
        }
      }

      saveMonitor(list);
      renderMonitorTable();
      setStatus(st, "ok", "Monitor check done.");
      gtagEvent("sec_mon_check");
    }

    async function monExport(){
      const list = loadMonitor();
      const ok = await copyText(safeJson(list));
      setStatus($("#mon-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
    }
    function monRemove(addr, net){
  const st = $("#mon-status");
  const addrLower = safeLower(String(addr || "").trim());
  const netLower  = safeLower(String(net || "").trim());

  const list = loadMonitor();
  const next = list.filter(it =>
    !(safeLower(it.net) === netLower && safeLower(it.addr) === addrLower)
  );

  saveMonitor(next);
  renderMonitorTable();
  setStatus(st, "ok", "Removed.");
  gtagEvent("sec_mon_remove", { net: netLower });
}

function bindMonRemove(){
  const table = $("#mon-table");
  if (!table || table.__cxBoundRemove) return;
  table.__cxBoundRemove = true;

  table.addEventListener("click", (e) => {
    const btn = e.target.closest('button[data-action="mon-remove"]');
    if (!btn) return;
    e.preventDefault();
    monRemove(btn.getAttribute("data-addr"), btn.getAttribute("data-net"));
  });
}


    function initDevUi(){
      const base = location.href.split("?")[0];
      const el = $("#bm-base");
      if (el) el.value = base;

      $("#bm-generate")?.addEventListener("click", bmGenerate);
      $("#bm-copy")?.addEventListener("click", bmCopy);

      $("#mon-add")?.addEventListener("click", monAdd);
      $("#mon-check")?.addEventListener("click", monCheckAll);
      $("#mon-export")?.addEventListener("click", monExport);

      renderBmHelp();
      renderMonitorTable();
      bindMonRemove();
      // Always enable the "drag to bookmarks" link (default bookmarklet)
try {
  const hubBase = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
  const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${hubBase}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

  const bmDefault = `javascript:${encodeURIComponent(js)}`;

  const drag = $("#bm-drag");
  if (drag) drag.href = bmDefault;
} catch {}

    }

    // =========================
// DNA â€” exports disabled (DNA features live in Firewall app)
// =========================
// try {
//   window.dnaScan = window.dnaScan || dnaScan;
//   window.dnaConnectWallet = window.dnaConnectWallet || dnaConnectWallet;
//   window.dnaRequestFullAccess = window.dnaRequestFullAccess || dnaRequestFullAccess;
//   window.dnaCheckCycxEligibility_BSC = window.dnaCheckCycxEligibility_BSC || dnaCheckCycxEligibility_BSC;
//   window.initWalletSecurityDNAUi = window.initWalletSecurityDNAUi || initWalletSecurityDNAUi;
//   window.initDnaCycxGate = window.initDnaCycxGate || initDnaCycxGate;
//   window.withRpcFallback = window.withRpcFallback || withRpcFallback;
//   window.E = window.E || E;
// } catch (e) { console.warn("DNA exports failed:", e); }

    // =========================
    // Boot
    // =========================
// =========================
// Boot
// =========================
function parseQuery() {
  const u = new URL(location.href);
  return {
    tool: (u.searchParams.get("tool") || "").toLowerCase(),
    net: (u.searchParams.get("net") || "").toLowerCase(),
    token: (u.searchParams.get("token") || ""),
    tx: (u.searchParams.get("tx") || "")
  };
}

function handleAutoRun() {
  const q = parseQuery();
  if (!q.tool) return;
  window.showPanel && window.showPanel(q.tool);
  if (q.tool === "quick" && q.net && q.token) {
    const selNet = document.querySelector("#qs-net");
    const inp = document.querySelector("#qs-token");
    if (selNet) selNet.value = q.net;
    if (inp) inp.value = q.token;
    setTimeout(() => document.querySelector("#qs-run")?.click(), 500);
  } else if (q.tool === "tx" && q.net && q.tx) {
    const selNet = document.querySelector("#tx-net");
    const inp = document.querySelector("#tx-hash");
    if (selNet) selNet.value = q.net;
    if (inp) inp.value = q.tx;
    setTimeout(() => document.querySelector("#tx-run")?.click(), 500);
  }
}

// â”€â”€ Diagnostic exports (safe, read-only) â”€â”€
window.CHAINS = (typeof CHAINS !== 'undefined') ? CHAINS : undefined;
window.applyI18n = (typeof applyI18n !== 'undefined') ? applyI18n : undefined;
window.buildRpcCandidates = (typeof buildRpcCandidates !== 'undefined') ? buildRpcCandidates : undefined;

function boot() {
  if (!window.E && window.ethers) { window.E = window.ethers; }
  setTimeout(() => { if (!window.E && window.ethers) window.E = window.ethers; }, 500);
  initLang();
  bindLangButtons();
  initPanels();
  initApiKeysUi();
  initQuickScanUi();
  initRpcUi();
  if (window.CX && typeof window.CX.initTxUi === "function") window.CX.initTxUi();
  initDevUi();
  applyI18n(currentLang);
  handleAutoRun();
  document.addEventListener("keydown", (e) => { if (e.key === "Escape") window.showPanel && window.showPanel(null); });
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", boot);
} else { boot(); }
</script>
</body>
</html>
