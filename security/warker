/**
 * CycleX — Wallet Security DNA API (Cloudflare Worker)
 * Route:  GET /api/getApprovals?net=bsc|eth|polygon&address=0x...
 *
 * v2-strict (improved) + FIX:
 * ✅ If verification is UNKNOWN (null) => do NOT penalize score.
 * ✅ "unverified" penalties apply ONLY when verified === false (known-unverified).
 * ✅ Risk from unverified_spender is High only when verified === false.
 *
 * v2-strict features kept:
 * - Stricter scoring model (less “easy 100”)
 * - Detects "very large" allowances (infinite-like patterns e.g. 1e27/1e30)
 * - Optional Moralis pagination (more approvals), with ETH-specific pages
 * - Verification enrichment (verified + ContractName) via Etherscan API V2 (chainid)
 * - Returns extra diagnostics: stats + scoreModel + allowanceKind + spenderName
 *
 * ENV Vars (Cloudflare):
 * - MORALIS_API_KEY                  (required)
 * - ETHERSCAN_KEY                    (optional but recommended; enables verify/name)
 * - BSCSCAN_KEY                      (optional; if missing, fallback to ETHERSCAN_KEY)
 * - POLYGONSCAN_KEY                  (optional; if missing, fallback to ETHERSCAN_KEY)
 * - VERIFY_KV (KV binding)           (optional; caches verification results)
 * - RATE_KV (KV binding)             (required if rate limit enabled)
 * - RATE_LIMIT_ENABLED               ("1" default)
 * - RATE_LIMIT_MAX_PER_HOUR          ("200" default)
 * - RATE_LIMIT_BYPASS_TOKEN          (optional)
 * - HIGH_RISK_SPENDERS               (CSV or JSON array of spender addresses)
 * - VERIFY_CONCURRENCY               ("3" default, max 6)
 * - MORALIS_MAX_PAGES                ("2" default for non-ETH)
 * - MORALIS_MAX_PAGES_ETH            ("4" default for ETH; set 3-6 if you want more)
 */

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // -------------------------
    // CORS
    // -------------------------
    const origin = request.headers.get("Origin") || "";
    const allowOrigin =
      origin === "https://cyclex.network" || origin === "https://www.cyclex.network"
        ? origin
        : "https://cyclex.network";

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders(allowOrigin) });
    }

        // -------------------------
    // Live Activity Counter (NEW)
    // Route:
    //   GET  /api/activity
    //   POST /api/activity  { t: "wallet_scan"|"risky_approvals"|"high_risk_contract", n: 1..50 }
    // -------------------------
    if (url.pathname === "/api/activity") {
      // must have ACTIVITY_KV binding
      if (!env.ACTIVITY_KV) {
        return json({ error: "Server missing ACTIVITY_KV binding" }, 500, allowOrigin);
      }

      // GET: return counters
      if (request.method === "GET") {
        const wallets = Number(await env.ACTIVITY_KV.get("wallets_scanned") || "0") || 0;
        const riskyApprovals = Number(await env.ACTIVITY_KV.get("risky_approvals") || "0") || 0;
        const highRiskContracts = Number(await env.ACTIVITY_KV.get("high_risk_contracts") || "0") || 0;

        return json(
          { wallets, riskyApprovals, highRiskContracts, updatedAt: Date.now() },
          200,
          allowOrigin
        );
      }

      // POST: increment counters
      if (request.method === "POST") {
        // basic origin check (anti-spam)
        const o = request.headers.get("Origin") || "";
        const okOrigin = (o === "" || o === "https://cyclex.network" || o === "https://www.cyclex.network");
        if (!okOrigin) return json({ error: "bad_origin" }, 403, allowOrigin);

        let body = null;
        try { body = await request.json(); } catch {}
        const t = String(body?.t || "");
        let n = parseInt(String(body?.n ?? "1"), 10);
        if (!Number.isFinite(n) || n < 1) n = 1;
        if (n > 50) n = 50;

        const map = {
          wallet_scan: "wallets_scanned",
          risky_approvals: "risky_approvals",
          high_risk_contract: "high_risk_contracts",
        };
        const key = map[t];
        if (!key) return json({ error: "bad_type" }, 400, allowOrigin);

        // (optional) tiny rate limit using RATE_KV (per IP / minute)
        const ip =
          request.headers.get("CF-Connecting-IP") ||
          (request.headers.get("X-Forwarded-For") || "").split(",")[0].trim() ||
          "unknown";
        const minute = Math.floor(Date.now() / 60000);
        const rlKey = `act:${minute}:${ip}`;

        if (env.RATE_KV) {
          const cur = Number(await env.RATE_KV.get(rlKey) || "0") || 0;
          if (cur >= 60) return json({ error: "rate_limited" }, 429, allowOrigin);
          await env.RATE_KV.put(rlKey, String(cur + 1), { expirationTtl: 120 });
        }

        // KV increment (MVP)
        const curVal = Number(await env.ACTIVITY_KV.get(key) || "0") || 0;
        const nextVal = curVal + n;
        await env.ACTIVITY_KV.put(key, String(nextVal));

        return json({ ok: true, key, next: nextVal }, 200, allowOrigin);
      }

      return json({ error: "Method not allowed" }, 405, allowOrigin);
    }


    // -------------------------
    // Routing
    // -------------------------
    if (url.pathname !== "/api/getApprovals") {
      return json({ error: "Not found" }, 404, allowOrigin);
    }

    // -------------------------
    // Rate Limit (per IP / per hour)
    // -------------------------
    const rateEnabled = (env.RATE_LIMIT_ENABLED || "1") !== "0";
    const maxPerHour = Number(env.RATE_LIMIT_MAX_PER_HOUR || "200");
    const bypassToken = (env.RATE_LIMIT_BYPASS_TOKEN || "").trim();
    const bypassHeader = (request.headers.get("x-cx-bypass") || "").trim();

    const ip =
      request.headers.get("CF-Connecting-IP") ||
      (request.headers.get("X-Forwarded-For") || "").split(",")[0].trim() ||
      "unknown";

    if (rateEnabled && maxPerHour > 0) {
      const bypassOk = bypassToken && bypassHeader && bypassHeader === bypassToken;

      if (!bypassOk) {
        if (!env.RATE_KV) {
          return json({ error: "Server missing RATE_KV binding" }, 500, allowOrigin);
        }

        const nowMs = Date.now();
        const hourBucket = Math.floor(nowMs / 3600000);
        const key = `rl:${hourBucket}:${ip}`;

        const nowSec = Math.floor(nowMs / 1000);
        const ttl = 3600 - (nowSec % 3600);

        const current = await env.RATE_KV.get(key);
        const count = current ? (parseInt(current, 10) || 0) : 0;

        if (count >= maxPerHour) {
          return json(
            { error: "Rate limit exceeded", detail: `Max ${maxPerHour} checks per hour per IP` },
            429,
            allowOrigin
          );
        }

        await env.RATE_KV.put(key, String(count + 1), { expirationTtl: ttl });
      }
    }

    // -------------------------
    // Inputs
    // -------------------------
    const net = (url.searchParams.get("net") || "bsc").toLowerCase();
    const address = (url.searchParams.get("address") || "").trim();

    if (!address || !/^0x[a-fA-F0-9]{40}$/.test(address)) {
      return json({ error: "Invalid address" }, 400, allowOrigin);
    }

    const MORALIS_API_KEY = (env.MORALIS_API_KEY || "").trim();
    if (!MORALIS_API_KEY) {
      return json({ error: "Server missing MORALIS_API_KEY" }, 500, allowOrigin);
    }

    const chain =
      net === "bsc" ? "0x38" :
      net === "eth" ? "0x1" :
      net === "polygon" ? "0x89" :
      "0x38";

    const CACHE_KV = env.VERIFY_KV || env.RATE_KV || null;
    const highRiskSpend = parseHighRiskList(env.HIGH_RISK_SPENDERS);

    // explorer verify (optional)
    const explorerKey = getExplorerKey(net, env);
    const shouldVerify = !!explorerKey;
    const verifyConc = Math.max(1, Math.min(6, Number(env.VERIFY_CONCURRENCY || "3")));

    // Moralis pagination (more data)
    const maxPages = (net === "eth")
      ? clampInt(env.MORALIS_MAX_PAGES_ETH || env.MORALIS_MAX_PAGES || "4", 1, 8)
      : clampInt(env.MORALIS_MAX_PAGES || "2", 1, 8);

    // -------------------------
    // Moralis: get approvals
    // -------------------------
    try {
      const items = await fetchMoralisApprovals(address, chain, MORALIS_API_KEY, maxPages);

      // Normalize
      const rows = items.map((it) => normalizeApprovalRow(it));

      // Verified enrichment (spender) + name
      if (shouldVerify && rows.length) {
        await mapWithConcurrency(rows, verifyConc, async (row) => {
          const info = await getContractVerifyAndName(net, row.spender, explorerKey, CACHE_KV);
          row.verified = info.verified;                // true/false/null
          row.spenderName = info.contractName || "";   // optional
          return row;
        });
      } else {
        rows.forEach((row) => {
          row.verified = null;
          row.spenderName = "";
        });
      }

      // Flags + risk (strict, but no penalty for unknown verification)
      for (const row of rows) {
        const flags = [];

        const kind = allowanceKind(row.allowance);
        row.allowanceKind = kind; // "infinite" | "very_large" | "finite"
        if (kind === "infinite") flags.push("infinite");
        if (kind === "very_large") flags.push("very_large_allowance");

        // ✅ Only flag as unverified_spender when we KNOW it's unverified
        if (row.verified === false) flags.push("unverified_spender");
        else if (row.verified === true) flags.push("verified_spender");
        else flags.push("verification_unknown");


        if (row.spender && highRiskSpend.has(row.spender.toLowerCase())) {
          flags.push("high_risk_spender");
        }

        row.flags = flags;
        row.risk = riskFromFlags(flags);
      }

      // Strict score model (✅ no penalty for unknown verification)
      const { score, riskLevel, tips, stats, model } = computeWalletScoreAndTipsStrict(rows);

      return json(
        {
          net,
          address,
          score,
          riskLevel,
          tips,
          stats,
          scoreModel: model,
          approvals: rows,
        },
        200,
        allowOrigin
      );
    } catch (e) {
      return json({ error: "Server error", detail: String(e?.message || e) }, 500, allowOrigin);
    }
  },
};

// ======================================================
// Helpers
// ======================================================

function corsHeaders(allowOrigin) {
  return {
    "Access-Control-Allow-Origin": allowOrigin,
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, x-cx-bypass",
    "Access-Control-Max-Age": "86400",
  };
}

function json(obj, status, allowOrigin) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: {
      "content-type": "application/json; charset=utf-8",
      ...corsHeaders(allowOrigin),
      "cache-control": "no-store",
    },
  });
}

function clampInt(v, lo, hi) {
  const n = parseInt(String(v || ""), 10);
  if (!Number.isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, n));
}

// --- Parse HIGH_RISK_SPENDERS from ENV (CSV or JSON) ---
function parseHighRiskList(v) {
  const set = new Set();
  const raw = (v || "").trim();
  if (!raw) return set;

  try {
    const arr = JSON.parse(raw);
    if (Array.isArray(arr)) {
      for (const x of arr) if (typeof x === "string") set.add(x.toLowerCase());
      return set;
    }
  } catch {}

  raw.split(",").map(s => s.trim()).filter(Boolean).forEach((x) => set.add(x.toLowerCase()));
  return set;
}

// -------------------------
// Moralis pagination (MORE DATA)
// -------------------------
async function fetchMoralisApprovals(address, chain, apiKey, maxPages) {
  const all = [];
  let cursor = "";

  for (let page = 0; page < maxPages; page++) {
    const u = new URL(`https://deep-index.moralis.io/api/v2.2/wallets/${address}/approvals`);
    u.searchParams.set("chain", chain);
    if (cursor) u.searchParams.set("cursor", cursor);

    const r = await fetch(u.toString(), {
      headers: { accept: "application/json", "X-API-Key": apiKey },
    });

    if (!r.ok) {
      const txt = await r.text().catch(() => "");
      throw new Error(`Moralis request failed (${r.status}): ${txt.slice(0, 200)}`);
    }

    const raw = await r.json();
    const items = extractArray(raw);
    if (items.length) all.push(...items);

    cursor = String(raw?.cursor || raw?.next_cursor || "").trim();
    if (!cursor || !items.length) break;
  }

  return all;
}

function extractArray(raw) {
  if (Array.isArray(raw)) return raw;
  if (Array.isArray(raw?.result)) return raw.result;
  if (Array.isArray(raw?.approvals)) return raw.approvals;
  if (Array.isArray(raw?.data)) return raw.data;
  if (Array.isArray(raw?.items)) return raw.items;
  return [];
}

// ---------- Normalization ----------
function normalizeApprovalRow(it) {
  const token = pickAddr(
    it?.token,
    it?.token_address,
    it?.tokenAddress,
    it?.contract_address,
    it?.contractAddress,
    it?.token?.address,
    it?.token?.contract_address,
    it?.asset?.address
  );

  const spender = pickAddr(
    it?.spender,
    it?.spender_address,
    it?.spenderAddress,
    it?.operator,
    it?.spender?.address
  );

  const symbol =
    it?.symbol ||
    it?.token_symbol ||
    it?.tokenSymbol ||
    it?.token?.symbol ||
    it?.token?.token_symbol ||
    it?.token?.ticker ||
    it?.token_name ||
    it?.token?.name ||
    "—";

  const allowanceRaw =
    it?.allowance ??
    it?.value ??
    it?.amount ??
    it?.approved_amount ??
    it?.approvedAmount ??
    it?.approval ??
    it?.approved ??
    "0";

  const allowance = normalizeAllowance(allowanceRaw);

  const lastUpdated =
    it?.lastUpdated ||
    it?.updatedAt ||
    it?.block_timestamp ||
    it?.transaction_timestamp ||
    it?.timestamp ||
    it?.blockTimestamp ||
    "—";

  return {
    token: token || "",
    spender: spender || "",
    symbol: symbol || "—",
    allowance,
    allowanceKind: "finite",
    verified: null,       // true/false/null
    spenderName: "",
    lastUpdated,
    flags: [],
    risk: "—",
  };
}

function pickAddr(...cands) {
  for (const c of cands) {
    if (typeof c === "string" && /^0x[a-fA-F0-9]{40}$/.test(c)) return c;
  }
  return "";
}

function normalizeAllowance(v) {
  if (v === null || v === undefined) return "0";
  if (typeof v === "bigint") return v.toString();

  const s = String(v).trim();
  if (!s) return "0";

  // MAX_UINT256 as decimal
  if (s === "115792089237316195423570985008687907853269984665640564039457584007913129639935") {
    return "infinite";
  }

  // hex max-like
  if (/^0x[fF]{20,}$/.test(s)) return "infinite";
  if (s.toLowerCase().includes("inf") || s === "∞") return "infinite";

  if (/^\d+$/.test(s)) return s;

  if (/^0x[0-9a-fA-F]+$/.test(s)) {
    try { return BigInt(s).toString(); } catch { return "0"; }
  }

  return s;
}

function isInfiniteAllowance(allowance) {
  const s = String(allowance || "").toLowerCase();
  return s === "infinite" || s === "∞" || s.includes("inf");
}

function isVeryLargeAllowance(allowance) {
  const s = String(allowance || "").trim();
  if (!/^\d+$/.test(s)) return false;
  return s.length >= 25; // heuristic: >= 1e24
}

function allowanceKind(allowance) {
  if (isInfiniteAllowance(allowance)) return "infinite";
  if (isVeryLargeAllowance(allowance)) return "very_large";
  return "finite";
}

// ---------- Risk ----------
function riskFromFlags(flags) {
  const f = new Set((flags || []).map(x => String(x).toLowerCase()));

  // ✅ High only for known-unverified or high-risk list
  if (f.has("high_risk_spender")) return "High";
  if (f.has("unverified_spender")) return "High";

  if (f.has("verification_unknown")) return "Medium";

  if (f.has("infinite")) return "Medium";
  if (f.has("very_large_allowance")) return "Medium";

  return "Low";
}

// ---------- Strict Scoring (no penalty for unknown verification) ----------
function computeWalletScoreAndTipsStrict(rows) {
  const total = rows.length;

  const infinite = rows.filter(r => r.allowanceKind === "infinite").length;
  const veryLarge = rows.filter(r => r.allowanceKind === "very_large").length;

  // ✅ Only count KNOWN unverified (verified === false)
  const unverified = rows.filter(r => r.verified === false).length;
  const unknownVer = rows.filter(r => r.verified === null).length;


  const highRisk = rows.filter(r => (r.flags || []).includes("high_risk_spender")).length;

  const highRows = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
  const medRows = rows.filter(r => String(r.risk).toLowerCase().includes("med")).length;
  const lowRows = rows.filter(r => String(r.risk).toLowerCase().includes("low")).length;

  const model = {
    version: "dna-v2-strict",
    penalties: {
      highRiskSpender_each: 30,
      unverifiedSpender_each: 18,
      infinite_each: 18,
      veryLarge_each: 12,
      approvals_10plus: 5,
      approvals_25plus: 12,
      approvals_50plus: 20,
      combo_highRisk_and_infinite: 6,
      combo_highRisk_and_unverified: 6,
    },
    thresholds: {
      low: ">=85",
      medium: "60..84",
      high: "<60",
    }
  };

  let score = 100;

  score -= highRisk * model.penalties.highRiskSpender_each;
  score -= unverified * model.penalties.unverifiedSpender_each;
  score -= infinite * model.penalties.infinite_each;
  score -= veryLarge * model.penalties.veryLarge_each;

  if (total >= 10) score -= model.penalties.approvals_10plus;
  if (total >= 25) score -= model.penalties.approvals_25plus;
  if (total >= 50) score -= model.penalties.approvals_50plus;

  if (highRisk > 0 && infinite > 0) score -= model.penalties.combo_highRisk_and_infinite;
  if (highRisk > 0 && unverified > 0) score -= model.penalties.combo_highRisk_and_unverified;

  score = Math.max(0, Math.min(100, score));

  const riskLevel = score >= 85 ? "Low" : score >= 60 ? "Medium" : "High";

  const tips = [];
  if (highRisk) tips.push(`Revoke approvals to HIGH-RISK spenders first (${highRisk}).`);

  // ✅ Only show this tip when we KNOW unverified exists
  if (unverified) tips.push(`Unverified spender contracts detected (${unverified}). Consider revoking unless essential.`);
  if (unknownVer) tips.push(`Verification unavailable for ${unknownVer} spender(s). Treat as unknown risk.`);


  if (infinite) tips.push(`Infinite approvals found (${infinite}). Prefer least-privilege allowances.`);
  if (veryLarge) tips.push(`Very large approvals found (${veryLarge}). Many dApps use “infinite-like” values — revoke if not needed.`);
  if (total >= 25) tips.push("You have many active approvals. Reducing them lowers your attack surface.");
  if (!tips.length) tips.push("No major red flags detected. Keep monitoring regularly.");

  const stats = {
    total,
    infinite,
    veryLarge,
    unverified,
    highRisk,
    riskRows: { high: highRows, medium: medRows, low: lowRows },
  };

  return { score, riskLevel, tips, stats, model };
}

// ---------- Explorer verification (Etherscan API V2) ----------
function getExplorerKey(net, env) {
  if (net === "eth") return (env.ETHERSCAN_KEY || "").trim();

  if (net === "bsc") {
    return (env.BSCSCAN_KEY || env.ETHERSCAN_KEY || "").trim();
  }
  if (net === "polygon") {
    return (env.POLYGONSCAN_KEY || env.ETHERSCAN_KEY || "").trim();
  }
  return "";
}

function chainIdForNet(net) {
  if (net === "eth") return "1";
  if (net === "bsc") return "56";
  if (net === "polygon") return "137";
  return "1";
}

/**
 * Returns { verified: true|false|null, contractName: string }
 * Caches in KV for 7d when KV available.
 */
async function getContractVerifyAndName(net, contractAddr, apiKey, KV) {
  if (!contractAddr) return { verified: null, contractName: "" };
  const addr = contractAddr.toLowerCase();
  const ck = `ver2:${net}:${addr}`;

  if (KV) {
    const cached = await KV.get(ck);
    if (cached) {
      const [v, name] = cached.split("|");
      if (v === "1") return { verified: true, contractName: name || "" };
      if (v === "0") return { verified: false, contractName: name || "" };
      if (v === "n") return { verified: null, contractName: name || "" };
    }
  }

  if (!apiKey) return { verified: null, contractName: "" };

  const u = new URL("https://api.etherscan.io/v2/api");
  u.searchParams.set("chainid", chainIdForNet(net));
  u.searchParams.set("module", "contract");
  u.searchParams.set("action", "getsourcecode");
  u.searchParams.set("address", contractAddr);
  u.searchParams.set("apikey", apiKey);

  try {
    const r = await fetch(u.toString(), { headers: { accept: "application/json" } });
    if (!r.ok) return { verified: null, contractName: "" };

    const j = await r.json().catch(() => null);
    const row = Array.isArray(j?.result) ? j.result[0] : null;
    if (!row) return { verified: null, contractName: "" };

    const abi = String(row?.ABI || "");
    const name = String(row?.ContractName || "").trim();

    const isUnverified = abi.includes("Contract source code not verified") || abi === "[]";
    const verified = !isUnverified;

    if (KV) {
      const tag = verified ? "1" : "0";
      await KV.put(ck, `${tag}|${name}`, { expirationTtl: 7 * 24 * 3600 });
    }

    return { verified, contractName: name };
  } catch {
    if (KV) {
      await KV.put(ck, `n|`, { expirationTtl: 6 * 3600 });
    }
    return { verified: null, contractName: "" };
  }
}

// ---------- Concurrency ----------
async function mapWithConcurrency(arr, limit, fn) {
  const out = new Array(arr.length);
  let i = 0;

  const workers = Array.from({ length: limit }, async () => {
    while (i < arr.length) {
      const idx = i++;
      out[idx] = await fn(arr[idx], idx);
    }
  });

  await Promise.all(workers);
  for (let k = 0; k < arr.length; k++) arr[k] = out[k] || arr[k];
}
