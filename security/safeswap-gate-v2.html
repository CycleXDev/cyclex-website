<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SafeSwap Gate V2</title>

  <style>
    :root{
      --bg0:#070712; --bg1:#0b1530; --bg2:#071b2a;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.04);
      --border: rgba(255,255,255,.12);
      --text:#eef2ff; --muted: rgba(238,242,255,.72);
      --good:#2dffb0; --warn:#ffd166; --bad:#ff4d6d;
      --btn:#1ee9ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 20%, #2a1b77 0%, transparent 55%),
        radial-gradient(1200px 800px at 80% 20%, #0a5b7d 0%, transparent 55%),
        radial-gradient(1000px 700px at 50% 90%, #0a2a3a 0%, transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
      padding:28px 18px 48px;
    }
    .wrap{max-width:1100px;margin:0 auto}
    .kicker{letter-spacing:.12em; font-size:13px; color:rgba(238,242,255,.55); text-align:center; margin-top:4px}
    h1{margin:10px 0 10px; text-align:center; font-weight:800; font-size:42px}
    .sub{max-width:820px; margin:0 auto 22px; text-align:center; color:var(--muted); line-height:1.5}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:18px}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} h1{font-size:34px} }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:22px;
      padding:18px;
      box-shadow: 0 18px 55px rgba(0,0,0,.35);
    }
    .card h2{margin:0 0 10px; font-size:20px}
    .label{font-size:12px; letter-spacing:.12em; color:rgba(238,242,255,.55); margin:10px 0 6px}
    input, select{
      width:100%;
      padding:14px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: var(--text);
      outline:none;
      font-size:15px;
    }
    .actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px}
    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:12px 14px;
      border-radius:999px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.06em;
      min-width: 160px;
    }
    .btn.primary{background: rgba(30,233,255,.18); border-color: rgba(30,233,255,.35)}
    .btn:hover{filter:brightness(1.06)}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      font-size:13px;
      margin-top:12px;
      width:100%;
    }
    .statusBox{
      border-radius:18px;
      border:1px solid rgba(255,77,109,.35);
      background: rgba(255,77,109,.08);
      padding:14px;
      margin-top:12px;
    }
    .statusTitle{font-weight:900; margin-bottom:8px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
    .muted{color:var(--muted)}
    ul{margin:10px 0 0 18px}
    li{margin:6px 0; color:rgba(238,242,255,.82)}
    .hr{height:1px; background:rgba(255,255,255,.12); margin:14px 0}
    table{width:100%; border-collapse:collapse; font-size:13px; overflow:hidden; border-radius:14px}
    th,td{padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.08); vertical-align:top}
    th{color:rgba(238,242,255,.72); font-weight:800; text-align:left}
    .tag{display:inline-block; padding:4px 9px; border-radius:999px; font-size:12px; font-weight:800}
    .g{background:rgba(45,255,176,.14); border:1px solid rgba(45,255,176,.25); color:rgba(45,255,176,.95)}
    .y{background:rgba(255,209,102,.14); border:1px solid rgba(255,209,102,.25); color:rgba(255,209,102,.95)}
    .r{background:rgba(255,77,109,.14); border:1px solid rgba(255,77,109,.25); color:rgba(255,77,109,.95)}
    .dexButtons{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .small{font-size:12px}
    .rightTop{display:flex; gap:10px; justify-content:space-between; align-items:center; flex-wrap:wrap}
  </style>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="kicker">SAFESWAP GATE • V2</div>
    <h1>Check token basics before you swap</h1>
    <div class="sub">
      Enter a BSC token address. We read on-chain metadata, owner hints, proxy hints, and scan liquidity across multiple DEX routers.
      This is <b>not</b> a honeypot guarantee — it’s hygiene checks you can verify on-chain.
    </div>

    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <h2>Token Address</h2>

        <div class="label">TOKEN CONTRACT (BSC)</div>
        <input id="tokenInput" class="mono" placeholder="0x..." />

        <div class="label">RPC</div>
        <select id="rpcSelect"></select>

        <div class="actions">
          <button class="btn primary" id="scanBtn">SCAN</button>
          <button class="btn" id="copyLinkBtn">COPY SHARE LINK</button>
          <button class="btn" id="bscscanBtn">BSCSCAN</button>
        </div>

        <div class="pill">
          <span class="muted">Tip:</span>
          <span class="muted">Open this page with <span class="mono">?token=0x...</span> and it will auto-run.</span>
        </div>

        <div class="statusBox" id="leftStatus" style="display:none;">
          <div class="statusTitle" id="leftStatusTitle">Done.</div>
          <div class="muted small" id="leftStatusText"></div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="rightTop">
          <h2 style="margin:0;">Results</h2>
          <div id="scoreTag" class="tag r">Score: –</div>
        </div>
        <div class="muted" style="margin-top:6px;">
          We score signals as Green / Yellow / Red. Lower score is better.
        </div>

        <div class="statusBox" id="resultBox" style="margin-top:12px;">
          <div class="statusTitle" id="resultTitle">Waiting…</div>
          <div class="muted small mono" id="resultTokenLine">Token: –</div>

          <div class="hr"></div>

          <div id="tokenMeta" class="muted small"></div>

          <div class="label" style="margin-top:10px;">Signals</div>
          <ul id="signalsList"></ul>

          <div class="label" style="margin-top:14px;">DEX Liquidity Scan</div>
          <div class="muted small">We try pairs vs WBNB/USDT/USDC/BUSD across multiple routers.</div>
          <div style="margin-top:10px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th>DEX</th>
                  <th>Pair Found</th>
                  <th>Best Pair</th>
                  <th>Est. Liquidity</th>
                  <th>LP Burn</th>
                </tr>
              </thead>
              <tbody id="dexTbody"></tbody>
            </table>
          </div>

          <div class="label" style="margin-top:14px;">Open Swap</div>
          <div class="dexButtons" id="dexButtons"></div>

          <div class="hr"></div>
          <div class="muted small">
            Next: If you’re unsure, verify owner/roles, read verified source (if available), and check community/audits.
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/** =======================
 *  CONFIG (BSC)
 *  ======================= */

const BSC = {
  chainId: 56,
  name: "BNB Smart Chain",
};

// Base tokens (BSC)
const BASES = [
  { sym: "WBNB",  addr: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", stable: false }, // WBNB 
  { sym: "USDT",  addr: "0x55d398326f99059fF775485246999027B3197955", stable: true  }, // USDT 
  { sym: "USDC",  addr: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", stable: true  }, // USDC 
  { sym: "BUSD",  addr: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", stable: true  }, // BUSD 
];

const DEAD = "0x000000000000000000000000000000000000dEaD";
const ZERO = "0x0000000000000000000000000000000000000000";

// Routers (V2 style)
const DEXES = [
  {
    key: "pancake_v2",
    name: "PancakeSwap V2",
    router: "0x10ED43C718714eb63d5aA57B78B54704E256024E", // 
    swapUrl: (token)=>`https://pancakeswap.finance/swap?outputCurrency=${token}`,
  },
  {
    key: "apeswap",
    name: "ApeSwap",
    router: "0x8634B5534c29cBD1ceeDdfD30721b95BFf31202d", // 
    swapUrl: (token)=>`https://apeswap.finance/swap?outputCurrency=${token}`,
  },
  {
    key: "biswap",
    name: "BiSwap",
    router: "0xa35e952f117b8f4aaca0dffd783a47c25b3f8090", // 
    swapUrl: (token)=>`https://biswap.org/#/swap?outputCurrency=${token}`,
  },
  {
    key: "mdex",
    name: "MDEX (BSC)",
    router: "0x302578786399a628ee8c250e74ee1da798d50442", // 
    swapUrl: (token)=>`https://bsc.mdex.com/#/swap?outputCurrency=${token}`,
  },
  {
    key: "bakeryswap",
    name: "BakerySwap",
    router: "0x84D218921bABECED3B2349A63421DD3cC406BE2a", // 
    swapUrl: (token)=>`https://www.bakeryswap.org/#/swap?outputCurrency=${token}`,
  },
  {
    key: "babyswap",
    name: "BabySwap",
    router: "0x72bb67690e861eabd8daa0e8b6608ca28a806f5a", // 
    swapUrl: (token)=>`https://exchange.babyswap.finance/#/swap?outputCurrency=${token}`,
  },
];

// Optional: PancakeSwap V3 smart router (link only, not scanned as V2 pairs here) 
const PANCAKE_V3_SWAP = (token)=>`https://pancakeswap.finance/swap?outputCurrency=${token}`;

// RPC list (public)
const RPCS = [
  "https://bsc-dataseed.binance.org",
  "https://bsc-dataseed1.bnbchain.org",
  "https://bsc-dataseed2.bnbchain.org",
  "https://bsc.publicnode.com",
  "https://bnb.rpc.subquery.network/public",
];

/** =======================
 *  ABIs
 *  ======================= */

const ERC20_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
];

const OWNABLE_ABI = [
  "function owner() view returns (address)",
  "function getOwner() view returns (address)",
];

const V2_ROUTER_ABI = [
  "function factory() view returns (address)",
];

const V2_FACTORY_ABI = [
  "function getPair(address tokenA, address tokenB) view returns (address)",
];

const V2_PAIR_ABI = [
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
];

// EIP-1967 implementation slot
const EIP1967_IMPL_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";

/** =======================
 *  UI Helpers
 *  ======================= */

const el = (id)=>document.getElementById(id);
const tokenInput = el("tokenInput");
const rpcSelect = el("rpcSelect");
const scanBtn = el("scanBtn");
const copyLinkBtn = el("copyLinkBtn");
const bscscanBtn = el("bscscanBtn");

const leftStatus = el("leftStatus");
const leftStatusTitle = el("leftStatusTitle");
const leftStatusText = el("leftStatusText");

const resultTitle = el("resultTitle");
const resultTokenLine = el("resultTokenLine");
const tokenMeta = el("tokenMeta");
const signalsList = el("signalsList");
const dexTbody = el("dexTbody");
const dexButtons = el("dexButtons");
const scoreTag = el("scoreTag");

function setLeftStatus(title, text, show=true){
  leftStatus.style.display = show ? "block" : "none";
  leftStatusTitle.textContent = title;
  leftStatusText.textContent = text || "";
}

function clearResults(){
  signalsList.innerHTML = "";
  dexTbody.innerHTML = "";
  dexButtons.innerHTML = "";
  tokenMeta.innerHTML = "";
  scoreTag.textContent = "Score: –";
  scoreTag.className = "tag r";
}

function addSignal(kind, text){
  const li = document.createElement("li");
  li.textContent = text;
  if(kind==="good") li.style.color = "rgba(45,255,176,.95)";
  if(kind==="warn") li.style.color = "rgba(255,209,102,.95)";
  if(kind==="bad")  li.style.color = "rgba(255,77,109,.95)";
  signalsList.appendChild(li);
}

function fmt(n, d=4){
  if(n === null || n === undefined) return "–";
  if(typeof n === "number") return n.toLocaleString(undefined, {maximumFractionDigits:d});
  return String(n);
}

function shortAddr(a){
  return a ? (a.slice(0,6)+"…"+a.slice(-4)) : "–";
}

function toTag(score){
  // Lower is better
  if(score <= 1) return {cls:"tag g", txt:`Score: ${score} (good)`};
  if(score <= 3) return {cls:"tag y", txt:`Score: ${score} (caution)`};
  return {cls:"tag r", txt:`Score: ${score} (high risk)`};
}

/** =======================
 *  Chain helpers
 *  ======================= */

function normalizeAddr(s){
  try { return ethers.getAddress(s.trim()); } catch(e){ return null; }
}

function makeProvider(rpcUrl){
  return new ethers.JsonRpcProvider(rpcUrl, BSC.chainId, { staticNetwork: true });
}

async function getCode(provider, addr){
  return await provider.getCode(addr);
}

async function getProxyImpl(provider, addr){
  try{
    const raw = await provider.getStorage(addr, EIP1967_IMPL_SLOT);
    // raw is 0x + 64 hex
    const impl = "0x" + raw.slice(26); // last 20 bytes
    if(/^0x0{40}$/i.test(impl)) return null;
    return ethers.getAddress(impl);
  }catch(e){
    return null;
  }
}

async function tryReadOwner(provider, token){
  const c = new ethers.Contract(token, OWNABLE_ABI, provider);
  // Try owner()
  try{
    const o = await c.owner();
    return ethers.getAddress(o);
  }catch(e){}
  // Try getOwner()
  try{
    const o = await c.getOwner();
    return ethers.getAddress(o);
  }catch(e){}
  return null;
}

function isRenounced(owner){
  if(!owner) return false;
  const o = owner.toLowerCase();
  return o === ZERO.toLowerCase() || o === DEAD.toLowerCase();
}

/** =======================
 *  DEX scan
 *  ======================= */

async function scanDex(provider, token, dex){
  const out = {
    dex: dex.name,
    found: false,
    bestPair: null,
    bestLiquidityUsd: null,
    lpBurnPct: null,
    error: null,
  };

  try{
    const router = new ethers.Contract(dex.router, V2_ROUTER_ABI, provider);
    const factoryAddr = await router.factory();
    const factory = new ethers.Contract(factoryAddr, V2_FACTORY_ABI, provider);

    let best = null;

    for(const base of BASES){
      const pairAddr = await factory.getPair(token, base.addr);
      if(pairAddr && pairAddr !== ZERO){
        const pair = new ethers.Contract(pairAddr, V2_PAIR_ABI, provider);
        const [t0, t1, reserves] = await Promise.all([pair.token0(), pair.token1(), pair.getReserves()]);
        const token0 = ethers.getAddress(t0);
        const token1 = ethers.getAddress(t1);

        const r0 = reserves.reserve0;
        const r1 = reserves.reserve1;

        // Identify which reserve is base
        let baseReserveRaw = null;
        if(token0.toLowerCase() === base.addr.toLowerCase()) baseReserveRaw = r0;
        if(token1.toLowerCase() === base.addr.toLowerCase()) baseReserveRaw = r1;

        // We only need base reserve to estimate liquidity
        if(baseReserveRaw === null) continue;

        // Convert base reserve to units
        // WBNB has 18, stables mostly 18 on BSC (USDT/USDC/BUSD are 18 here)
        const baseReserve = Number(ethers.formatUnits(baseReserveRaw, 18));

        // crude liquidity estimate:
        // - if stable: USD ~ 2 * baseReserve
        // - if WBNB: show in BNB (USD estimate left blank unless you add oracle)
        let liqUsd = null;
        if(base.stable){
          liqUsd = 2 * baseReserve;
        } else {
          // WBNB: keep null; you can plug BNB/USD feed later if you want
          liqUsd = null;
        }

        const candidate = {
          pair: pairAddr,
          base: base.sym,
          baseReserve,
          liqUsd,
        };

        if(!best) best = candidate;
        else{
          const a = best.liqUsd ?? (best.base === "WBNB" ? best.baseReserve : 0);
          const b = candidate.liqUsd ?? (candidate.base === "WBNB" ? candidate.baseReserve : 0);
          if(b > a) best = candidate;
        }
      }
    }

    if(best){
      out.found = true;
      out.bestPair = `${best.base} • ${shortAddr(best.pair)} (base reserve: ${fmt(best.baseReserve, 4)} ${best.base})`;
      out.bestLiquidityUsd = best.liqUsd;

      // LP burn (basic)
      try{
        const pair = new ethers.Contract(best.pair, V2_PAIR_ABI, provider);
        const [ts, b0, bd] = await Promise.all([
          pair.totalSupply(),
          pair.balanceOf(ZERO),
          pair.balanceOf(DEAD),
        ]);
        const burned = b0 + bd;
        const pct = ts > 0n ? Number((burned * 10000n) / ts) / 100 : 0;
        out.lpBurnPct = pct;
      }catch(e){}
    }

  }catch(e){
    out.error = (e && e.message) ? e.message : String(e);
  }

  return out;
}

/** =======================
 *  Main scan
 *  ======================= */

async function runScan(){
  clearResults();

  const token = normalizeAddr(tokenInput.value || "");
  if(!token){
    setLeftStatus("Error", "Invalid token address.");
    resultTitle.textContent = "Invalid address";
    resultTokenLine.textContent = "Token: –";
    return;
  }

  const rpcUrl = rpcSelect.value;
  localStorage.setItem("safeswap_rpc", rpcUrl);

  setLeftStatus("Scanning…", `RPC: ${rpcUrl}`);
  resultTitle.textContent = "Scanning…";
  resultTokenLine.textContent = `Token: ${token}`;

  const provider = makeProvider(rpcUrl);

  let score = 0;

  // 1) Contract code
  const code = await getCode(provider, token);
  if(!code || code === "0x"){
    score += 5;
    addSignal("bad", "No contract bytecode found at this address (not a token contract on BSC).");
    const tag = toTag(score);
    scoreTag.className = tag.cls; scoreTag.textContent = tag.txt;
    resultTitle.textContent = "High risk signals";
    setLeftStatus("Done.", `Score: ${score} (lower is better). RPC: ${rpcUrl}`);
    return;
  } else {
    addSignal("good", "Contract bytecode found.");
  }

  // 2) Proxy hint
  const impl = await getProxyImpl(provider, token);
  if(impl){
    score += 1;
    addSignal("warn", `Proxy pattern detected (EIP-1967). Implementation: ${shortAddr(impl)}.`);
  } else {
    addSignal("good", "No EIP-1967 implementation slot detected (likely not a standard proxy).");
  }

  // 3) ERC20 metadata
  let name=null, symbol=null, decimals=null, totalSupply=null;
  try{
    const erc20 = new ethers.Contract(token, ERC20_ABI, provider);
    [name, symbol, decimals, totalSupply] = await Promise.all([
      erc20.name(), erc20.symbol(), erc20.decimals(), erc20.totalSupply()
    ]);
    tokenMeta.innerHTML = `
      <div><b>Name:</b> ${name}</div>
      <div><b>Symbol:</b> ${symbol}</div>
      <div><b>Decimals:</b> ${decimals}</div>
      <div><b>Total supply:</b> ${fmt(Number(ethers.formatUnits(totalSupply, decimals)), 4)}</div>
    `;
  }catch(e){
    score += 2;
    addSignal("warn", "Could not read full ERC-20 metadata (name/symbol/decimals/totalSupply).");
  }

  // 4) Owner hint
  const owner = await tryReadOwner(provider, token);
  if(owner){
    if(isRenounced(owner)){
      addSignal("good", `Owner detected and looks renounced: ${shortAddr(owner)}.`);
    } else {
      score += 1;
      addSignal("warn", `Owner detected: ${shortAddr(owner)} (not renounced).`);
    }
  } else {
    addSignal("warn", "Owner function not detected (or not accessible). This can be normal for non-Ownable tokens.");
  }

  // 5) DEX scans
  const dexResults = [];
  for(const dex of DEXES){
    dexResults.push(await scanDex(provider, token, dex));
  }

  const anyFound = dexResults.some(x => x.found);
  if(!anyFound){
    // Not listed yet vs risky — we keep it mild by default
    score += 1;
    addSignal("warn", "No V2-style DEX pair found across scanned routers (could be not listed yet).");
  } else {
    addSignal("good", "At least one DEX pair found across scanned routers.");
  }

  // Table + buttons
  dexTbody.innerHTML = "";
  dexButtons.innerHTML = "";

  // Add Pancake V3 quick link always
  const v3Btn = document.createElement("button");
  v3Btn.className = "btn";
  v3Btn.textContent = "PancakeSwap (V3 link)";
  v3Btn.onclick = ()=>window.open(PANCAKE_V3_SWAP(token), "_blank");
  dexButtons.appendChild(v3Btn);

  let bestUsd = null;
  let bestUsdDex = null;

  for(const r of dexResults){
    const tr = document.createElement("tr");

    // Pair found
    const found = r.found ? `<span class="tag g">YES</span>` : `<span class="tag y">NO</span>`;

    // Liquidity
    let liqTxt = "–";
    if(r.bestLiquidityUsd !== null && r.bestLiquidityUsd !== undefined){
      liqTxt = `$${fmt(r.bestLiquidityUsd, 2)}`;
      if(bestUsd === null || r.bestLiquidityUsd > bestUsd){
        bestUsd = r.bestLiquidityUsd;
        bestUsdDex = r.dex;
      }
    } else if(r.found){
      liqTxt = `(non-stable base / WBNB)`;
    }

    // LP burn
    let burnTxt = "–";
    if(typeof r.lpBurnPct === "number"){
      burnTxt = `${fmt(r.lpBurnPct, 2)}%`;
      // low burn is mild warning
      if(r.lpBurnPct < 20) score += 1;
    }

    tr.innerHTML = `
      <td><b>${r.dex}</b><div class="muted small mono">${shortAddr(DEXES.find(d=>d.name===r.dex)?.router || "")}</div></td>
      <td>${found}</td>
      <td class="mono">${r.bestPair ? r.bestPair : (r.error ? "Error" : "–")}</td>
      <td>${liqTxt}</td>
      <td>${burnTxt}</td>
    `;
    dexTbody.appendChild(tr);

    // Open swap button (always available)
    const dexConf = DEXES.find(d => d.name === r.dex);
    if(dexConf){
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = r.found ? `Open ${dexConf.name}` : `${dexConf.name}`;
      b.onclick = ()=>window.open(dexConf.swapUrl(token), "_blank");
      dexButtons.appendChild(b);
    }
  }

  // Liquidity thresholds (only when we got stable USD estimate)
  if(bestUsd !== null){
    if(bestUsd < 2000){
      score += 3;
      addSignal("bad", `Very low estimated liquidity on best stable pair (~$${fmt(bestUsd,2)}) on ${bestUsdDex}.`);
    } else if(bestUsd < 20000){
      score += 1;
      addSignal("warn", `Low estimated liquidity on best stable pair (~$${fmt(bestUsd,2)}) on ${bestUsdDex}.`);
    } else {
      addSignal("good", `Best stable-pair liquidity looks decent (~$${fmt(bestUsd,2)}) on ${bestUsdDex}.`);
    }
  } else if(anyFound){
    addSignal("warn", "Pairs found, but best pair was not against a stablecoin (USD estimate not computed).");
  }

  // Final score
  const tag = toTag(score);
  scoreTag.className = tag.cls;
  scoreTag.textContent = tag.txt;

  resultTitle.textContent = (score >= 4) ? "High risk signals" : (score >= 2 ? "Caution signals" : "Looks OK (basic checks)");

  setLeftStatus("Done.", `Score: ${score} (lower is better). RPC: ${rpcUrl}`);
}

function initRpc(){
  const saved = localStorage.getItem("safeswap_rpc");
  rpcSelect.innerHTML = "";
  for(const url of RPCS){
    const opt = document.createElement("option");
    opt.value = url;
    opt.textContent = url;
    if(saved && saved === url) opt.selected = true;
    rpcSelect.appendChild(opt);
  }
}

function copyShareLink(){
  const token = normalizeAddr(tokenInput.value || "");
  if(!token) return alert("Invalid token address.");
  const u = new URL(window.location.href);
  u.searchParams.set("token", token);
  navigator.clipboard.writeText(u.toString());
  setLeftStatus("Copied.", "Share link copied to clipboard.");
}

function openBscScan(){
  const token = normalizeAddr(tokenInput.value || "");
  if(!token) return alert("Invalid token address.");
  window.open(`https://bscscan.com/address/${token}`, "_blank");
}

scanBtn.addEventListener("click", runScan);
copyLinkBtn.addEventListener("click", copyShareLink);
bscscanBtn.addEventListener("click", openBscScan);

(function boot(){
  initRpc();

  const qp = new URLSearchParams(window.location.search);
  const t = qp.get("token");
  if(t){
    tokenInput.value = t;
    // auto-run
    setTimeout(()=>runScan(), 150);
  }
})();
</script>
</body>
</html>
