<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/logo.png">
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">

  <meta charset="UTF-8" />
  <title>CycleX â€“ Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg-main: #05060a;
      --bg-gradient-start: #05060a;
      --bg-gradient-mid: #1a0d3a;
      --bg-gradient-end: #003a4c;

      --text-main: #f4f6ff;
      --text-muted: rgba(244, 246, 255, 0.7);

      --accent-cyan: #00e5ff;
      --accent-green: #5dffb2;
      --accent-purple: #7c5cff;

      --card-bg: rgba(255, 255, 255, 0.06);
      --border-subtle: rgba(255, 255, 255, 0.12);

      --shadow-soft: 0 30px 90px rgba(0, 0, 0, 0.75);
      --radius-xl: 24px;
      --radius-lg: 18px;
      --transition-fast: 0.18s ease-out;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      --maxw: 1160px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: var(--sans);
      background:
        radial-gradient(circle at top left, rgba(124, 92, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at top right, rgba(0, 229, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at bottom, rgba(0, 58, 76, 0.55) 0%, transparent 55%),
        linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
      color: var(--text-main);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      animation: fadeBody 0.7s ease-out forwards;
      opacity: 1;
      overflow-x: hidden;
    }
    @keyframes fadeBody { from { opacity: 0; } to { opacity: 1; } }
    a { color: inherit; text-decoration: none; }

    .page-shell { max-width: var(--maxw); margin: 0 auto; padding: 32px 20px 72px; }

    /* Top bar */
    .top-bar {
      position: sticky;
      top: 14px;
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 18px;
      margin-bottom: 26px;
      border-radius: 999px;
      background: rgba(8, 10, 22, 0.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }
    .brand { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .brand-logo {
      width: 44px; height: 44px; border-radius: 16px; object-fit: contain;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
      flex: 0 0 auto;
    }
    .brand-text { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .brand-title {
      font-weight: 800; letter-spacing: 0.05em; font-size: 18px; text-transform: uppercase;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .brand-sub {
      font-size: 11px; text-transform: uppercase; letter-spacing: 0.16em; color: var(--text-muted);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }

    .lang-switch {
      display: inline-flex;
      align-items: center;
      padding: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.55);
      gap: 2px;
      flex: 0 0 auto;
    }
    .lang-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      padding: 6px 9px;
      border-radius: 999px;
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast), transform var(--transition-fast);
      user-select: none;
      white-space: nowrap;
    }
    .lang-btn:hover { transform: translateY(-1px); }
    .lang-btn.active { background: rgba(0, 229, 255, 0.14); color: var(--accent-cyan); }

    body.lang-switching { animation: langFade 0.28s ease-out; }
    @keyframes langFade { from { opacity: 0.5; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* Hero */
    .hero {
      text-align: center;
      max-width: 980px;
      margin: 0 auto 18px auto;
      animation: fadeUp 0.8s ease-out forwards;
    }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

    .hero-kicker { font-size: 13px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-cyan); margin-bottom: 14px; }
    .hero-title { font-size: clamp(40px, 5vw, 60px); line-height: 1.05; font-weight: 900; margin-bottom: 14px; letter-spacing: -0.02em; }
    .hero-subtitle { max-width: 760px; margin: 0 auto 18px auto; font-size: 16px; line-height: 1.5; color: var(--text-muted); }

    .hero-actions { display: flex; justify-content: center; flex-wrap: wrap; gap: 14px; margin-bottom: 10px; }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 13px 26px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast);
      user-select: none;
      white-space: nowrap;
    }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), #7df2ff);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 229, 255, 0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 229, 255, 0.6); }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-green), #b9ffcf);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 230, 118, 0.4);
    }
    .btn-secondary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 230, 118, 0.7); }

    .btn-ghost {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--text-main);
      box-shadow: 0 12px 34px rgba(0,0,0,0.45);
    }
    .btn-ghost:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }

    .note-line {
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.45;
    }

    /* Tool cubes */
    .tool-grid-wrap { max-width: var(--maxw); margin: 0 auto 14px; }
    .tool-grid-title {
      text-align: center;
      margin: 14px 0 8px;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(244,246,255,0.72);
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 14px;
      margin-top: 10px;
    }
    .tool-card {
      grid-column: span 4;
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius-xl);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 16px 16px 14px;
      box-shadow: 0 24px 70px rgba(0,0,0,0.65), inset 0 1px 0 rgba(255,255,255,0.05);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: transform var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
      min-width: 0;
    }
    .tool-card::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(520px 160px at 18% -5%, rgba(0,229,255,.16), transparent 60%),
        radial-gradient(520px 160px at 85% 0%, rgba(124,92,255,.16), transparent 60%);
      pointer-events:none;
      opacity: .9;
    }
    .tool-card > * { position: relative; }

    .tool-card:hover { transform: translateY(-2px); border-color: rgba(0,229,255,0.26); background: rgba(255,255,255,0.06); }
    .tool-card.active { border-color: rgba(0,229,255,0.38); background: rgba(0,229,255,0.06); }

    .tool-head { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .tool-name { font-size: 15px; font-weight: 900; letter-spacing: 0.01em; line-height: 1.25; }
    .tool-desc { font-size: 13px; color: var(--text-muted); line-height: 1.45; }

    .badge-row { display:flex; flex-wrap:wrap; gap:8px; margin-top: 12px; }
    .badge {
      display:inline-flex; align-items:center; gap:8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
      user-select: none;
    }
    .badge strong { color: rgba(244,246,255,0.92); font-weight: 800; }
    .badge.beta { border-color: rgba(255,193,7,0.25); background: rgba(255,193,7,0.08); color: rgba(244,246,255,0.92); }

    /* Panels */
    .panel-shell {
      margin-top: 14px;
      padding: 22px 20px;
      border-radius: var(--radius-xl);
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    .panel-shell.hidden { display: none; }

    .panel-head {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .panel-kicker {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--accent-purple);
      margin-bottom: 8px;
    }
    .panel-title { font-size: 28px; font-weight: 900; letter-spacing: -0.01em; line-height: 1.12; }
    .panel-sub { margin-top: 8px; max-width: 900px; color: var(--text-muted); font-size: 14px; line-height: 1.6; }

    .panel-actions { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 14px; }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 16px;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
      min-width: 0;
    }
    .card h3 { font-size: 15px; letter-spacing: 0.02em; margin-bottom: 8px; color: var(--text-main); }
    .muted { color: var(--text-muted); font-size: 13px; line-height: 1.45; }

    .field { margin-top: 10px; }
    .label { font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); margin-bottom: 6px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(5, 7, 18, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    textarea { border-radius: 18px; min-height: 96px; resize: vertical; padding: 12px 12px; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent-cyan); }
    .mono { font-family: var(--mono); }

    .toggle{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      user-select:none;
      width: 100%;
    }
    .toggle input{ width:auto; accent-color: var(--accent-cyan); }

    .status {
      margin-top: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: var(--text-main);
      line-height: 1.5;
      font-size: 13px;
      display: none;
      overflow-wrap: anywhere;
    }
    .status.ok   { display:block; background: rgba(0, 230, 118, 0.10); border-color: rgba(0,230,118,0.35); color: #78ffbf; }
    .status.warn { display:block; background: rgba(255, 193, 7, 0.10); border-color: rgba(255,193,7,0.35); color: #ffd166; }
    .status.bad  { display:block; background: rgba(220, 53, 69, 0.10); border-color: rgba(220,53,69,0.35); color: #ff7a8a; }
    .status.info { display:block; background: rgba(0, 229, 255, 0.10); border-color: rgba(0,229,255,0.30); color: #7df2ff; }

    .small { font-size: 12px; color: var(--text-muted); line-height: 1.45; }

    .table {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      overflow: hidden;
    }
    .trow {
      display: grid;
      grid-template-columns: 1.3fr 1.1fr 0.9fr 0.9fr;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      align-items: center;
      font-size: 13px;
    }
    .trow.head {
      border-top: none;
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(244,246,255,0.75);
    }
    .trow .cell { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .trow .cell.wrap { white-space: normal; overflow: visible; }
    .trow .cell .mini { font-size: 12px; color: rgba(244,246,255,0.82); }
    .trow.highlight { background: rgba(0,230,118,0.10); border-top-color: rgba(0,230,118,0.20); }

    .chips { display:flex; flex-wrap:wrap; gap:10px; margin-top: 10px; }
    .chip {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: rgba(244,246,255,0.88);
      cursor: pointer;
      user-select: none;
      transition: transform var(--transition-fast), border-color var(--transition-fast);
      font-size: 12px;
    }
    .chip:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }
    .chip .x { opacity: .85; color: var(--text-muted); }

    .share-row { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }

    /* Footer */
    .footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      margin-top: 20px;
      padding-top: 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .footer-tagline { color: var(--accent-cyan); font-weight: 700; }

    /* RTL tweaks */
    html[dir="rtl"] body { direction: rtl; }
    html[dir="rtl"] .top-bar { flex-direction: row-reverse; }
    html[dir="rtl"] .brand { flex-direction: row-reverse; }
    html[dir="rtl"] .panel-head { flex-direction: row-reverse; }
    html[dir="rtl"] .row { flex-direction: row-reverse; }
    html[dir="rtl"] .panel-actions { justify-content: flex-start; }

    /* Responsiveness */
    @media (max-width: 980px) {
      .tool-card { grid-column: span 6; }
      .grid-2 { grid-template-columns: 1fr; }
      .trow { grid-template-columns: 1.2fr 1fr 0.9fr; }
      .trow .hide-sm { display: none; }
      .panel-title { font-size: 24px; }
    }
    @media (max-width: 640px) {
      .tool-card { grid-column: span 12; }
      .top-bar { top: 10px; padding: 10px 12px; }
      .brand-logo { width: 40px; height: 40px; border-radius: 14px; }
      .btn { padding: 12px 18px; font-size: 13px; }
    }
  </style>
</head>
<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector">
        <button class="lang-btn active" data-lang="en">ğŸ‡ºğŸ‡¸ EN</button>
        <button class="lang-btn" data-lang="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="ar">ğŸ‡¸ğŸ‡¦ Ø¹Ø±Ø¨ÙŠ</button>
        <button class="lang-btn" data-lang="ru">ğŸ‡·ğŸ‡º RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Tools</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          A lightweight, client-side toolkit for safer swaps, approvals hygiene, and RPC health checks across BSC + Ethereum.
        </p>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-quick" data-i18n="btn_quick">Run Quick Scan</button>
        </div>

        <div class="note-line" data-i18n="hero_note">
          Note: These checks are informational and do not guarantee safety. Always verify independently.
        </div>
      </section>

      <section class="tool-grid-wrap">
        <div class="tool-grid-title" data-i18n="tools_kicker">CHOOSE A TOOL</div>

        <div class="tool-grid" id="toolGrid">
          <!-- 1) QUICK -->
          <div class="tool-card active" data-tool="quick">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_quick_title">Quick Scan</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_quick_desc">
              Fast token sanity-check: contract, metadata, owner/proxy hints, and shareable report.
            </div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_fast">Fast</strong></div>
              <div class="badge"><strong data-i18n="badge_history">History</strong></div>
              <div class="badge"><strong data-i18n="badge_share">Share</strong></div>
            </div>
          </div>

          <!-- 2) APPROVALS -->
          <div class="tool-card" data-tool="approvals">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_approvals_title">Approval Guardian</div>
              <div class="badge"><strong data-i18n="badge_wallet">Wallet</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_approvals_desc">
              Check and revoke ERC-20 allowances safely (approve â†’ 0) with a clean, pro UX.
            </div>
            <div class="badge-row">
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
              <div class="badge"><strong data-i18n="badge_revoke">Revoke</strong></div>
            </div>
          </div>

          <!-- 3) RPC -->
          <div class="tool-card" data-tool="rpc">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_rpc_desc">
              Test endpoints, show latency + block height, then copy the best RPC instantly.
            </div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_table">Table</strong></div>
              <div class="badge"><strong data-i18n="badge_copy">Copy</strong></div>
            </div>
          </div>

          <!-- 4) MONITOR -->
          <div class="tool-card" data-tool="monitor">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_monitor_title">Contract Diff / Upgrade Monitor</div>
              <div class="badge"><strong data-i18n="badge_watch">Watch</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_monitor_desc">
              Save contracts locally, detect bytecode changes and proxy implementation upgrades over time.
            </div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_local">Local</strong></div>
              <div class="badge"><strong data-i18n="badge_changes">Changes</strong></div>
            </div>
          </div>
        </div>
      </section>

      <!-- PANELS -->
      <section class="panel-shell" id="panel-quick">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
            <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
            <div class="panel-sub" data-i18n="p_quick_sub">
              Paste a token address, choose network, run scan. We save history locally and generate shareable outputs.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="walletLabel">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseQuick" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="quick_input_title">Token Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="qs-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="qs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="qs_tip">
                Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="options_label">Options</div>
              <label class="toggle">
                <input type="checkbox" id="qs-require-liq">
                <span data-i18n="opt_require_liq">Require liquidity (stricter score)</span>
              </label>
              <label class="toggle" style="margin-top:10px">
                <input type="checkbox" id="qs-show-json" checked>
                <span data-i18n="opt_show_json">Enable JSON report (copy)</span>
              </label>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="qs-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="history_label">History</div>
              <div class="chips" id="qs-history"></div>
              <div class="small" style="margin-top:8px" data-i18n="history_tip">
                Click an item to re-run quickly. Stored locally only.
              </div>
            </div>

            <div class="share-row">
              <button class="btn btn-ghost" id="qs-share-x">Share to X</button>
              <button class="btn btn-ghost" id="qs-share-tg">Share to Telegram</button>
            </div>

            <div id="qs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="results_title">Results</h3>
            <div class="small" data-i18n="results_hint">
              Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.
            </div>

            <div id="qs-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="qs-pairsWrap" style="margin-top:12px;"></div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-approvals">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_app_kicker">Approval Guardian</div>
            <div class="panel-title" data-i18n="p_app_title">Check and revoke allowances</div>
            <div class="panel-sub" data-i18n="p_app_sub">
              Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="ap-wallet">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseApprovals" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="ap_settings_title">Settings</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="ap-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="row" style="justify-content:space-between">
                <div class="pill"><span data-i18n="ap_connected">Connected:</span> <span id="ap-address" class="mono">â€”</span></div>
                <button class="btn btn-secondary" id="ap-connect" data-i18n="ap_connect">Connect / Refresh</button>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_spender_label">Spender preset</div>
              <div class="row">
                <select id="ap-spender-preset">
                  <option value="pcs_router">PancakeSwap Router (BSC)</option>
                  <option value="uni_router">Uniswap V2 Router (ETH)</option>
                  <option value="custom">Customâ€¦</option>
                </select>
                <input id="ap-spender" class="mono" placeholder="0x spender..." />
              </div>
              <div class="small" style="margin-top:8px" data-i18n="ap_spender_tip">
                Start with a router preset, then add tokens you want to clean up.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_tokens_label">Token list (one per line)</div>
              <textarea id="ap-tokens" class="mono" placeholder="0x...\n0x...\n0x..."></textarea>
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="ap-seed-common" data-i18n="ap_seed">Seed common tokens</button>
                <button class="btn btn-ghost" id="ap-seed-history" data-i18n="ap_seed_history">Use scan history</button>
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="ap-check" data-i18n="ap_check">Check Allowances</button>
                <button class="btn btn-ghost" id="ap-revoke-all" data-i18n="ap_revoke_all">Revoke All (non-zero)</button>
              </div>
            </div>

            <div id="ap-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="ap_results">Allowances</h3>
            <div class="small" data-i18n="ap_results_hint">
              If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.
            </div>

            <div id="ap-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Token</div>
                <div class="cell">Allowance</div>
                <div class="cell hide-sm">Symbol</div>
                <div class="cell">Action</div>
              </div>
              <div class="trow">
                <div class="cell muted">â€”</div>
                <div class="cell muted">â€”</div>
                <div class="cell muted hide-sm">â€”</div>
                <div class="cell muted">â€”</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-rpc">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_rpc_kicker">RPC Health Checker</div>
            <div class="panel-title" data-i18n="p_rpc_title">Find the best endpoint</div>
            <div class="panel-sub" data-i18n="p_rpc_sub">
              We test RPC endpoints with eth_blockNumber and measure latency. Best result is highlighted and ready to copy.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseRpc" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_inputs">Inputs</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="rpc-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC (top priority)</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-copy-json">Copy JSON list</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
              <div class="trow head">
                <div class="cell">RPC</div>
                <div class="cell">Latency</div>
                <div class="cell hide-sm">Block</div>
                <div class="cell">Status</div>
              </div>
            </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-monitor">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_mon_kicker">Contract Monitor</div>
            <div class="panel-title" data-i18n="p_mon_title">Detect upgrades & bytecode changes</div>
            <div class="panel-sub" data-i18n="p_mon_sub">
              Save contracts locally. We store code hash + proxy implementation. Re-check later to detect changes.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseMonitor" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="mon_add_title">Add to watchlist</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="mon-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Contract address</div>
              <input id="mon-addr" class="mono" placeholder="0x..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
                <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
                <button class="btn btn-ghost" id="mon-export">Export JSON</button>
              </div>
            </div>

            <div id="mon-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="mon_list_title">Watchlist</h3>
            <div class="small" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>

            <div id="mon-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Contract</div>
                <div class="cell">Network</div>
                <div class="cell hide-sm">Last seen</div>
                <div class="cell">Status</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>
    </main>
  </div>

  <!-- Libraries (ORDER MATTERS) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <!-- Reown AppKit (WalletConnect modal) -->
  <script src="https://unpkg.com/@reown/appkit@1.6.3/dist/appkit.umd.js"></script>
  <script src="https://unpkg.com/@reown/appkit-adapter-ethers@1.6.3/dist/ethers.umd.js"></script>

  <!-- âœ… Paste Part 3 (JS) below -->
<script>
(() => {
  "use strict";

  // =========================
  // i18n
  // =========================
  const translations = {
    en: {
      brand_sub: "On-Chain Security & Rewards",
      hero_kicker: "Security Hub",
      hero_title: "CycleX Security Tools",
      hero_subtitle: "A lightweight, client-side toolkit for safer swaps, approvals hygiene, and RPC health checks across BSC + Ethereum.",
      btn_back: "Back to Site",
      btn_connect: "Connect Wallet (optional)",
      btn_quick: "Run Quick Scan",
      hero_note: "Note: These checks are informational and do not guarantee safety. Always verify independently.",
      tools_kicker: "CHOOSE A TOOL",

      cube_quick_title: "Quick Scan",
      cube_quick_desc: "Fast token sanity-check: contract, metadata, owner/proxy hints, and shareable report.",
      badge_fast: "Fast",
      badge_history: "History",
      badge_share: "Share",

      cube_approvals_title: "Approval Guardian",
      cube_approvals_desc: "Connect wallet, review allowances, and revoke approvals safely.",
      badge_wallet: "Wallet",
      badge_revoke: "Revoke",

      cube_rpc_title: "RPC Health Checker",
      cube_rpc_desc: "Test endpoints, measure latency + chain, and copy the best RPC.",
      badge_table: "Table",
      badge_copy: "Copy",

      cube_monitor_title: "Contract Diff / Upgrade Monitor",
      cube_monitor_desc: "Save contracts locally and detect bytecode changes over time.",
      badge_watch: "Watch",
      badge_local: "Local",
      badge_changes: "Changes",

      p_quick_kicker: "Quick Scan",
      p_quick_title: "Score a token in seconds",
      p_quick_sub: "Paste a token address, choose network, run scan. History is stored locally and you can share results.",
      pill_wallet: "Wallet",
      btn_close: "Close",
      quick_input_title: "Token Input",
      net_label: "Network",
      addr_label: "Token contract",
      qs_tip: "Tip: open with ?tool=quick&net=bsc&token=0x... to auto-run.",
      options_label: "Options",
      opt_require_liq: "Require liquidity (stricter score)",
      opt_show_json: "Enable JSON report (copy)",
      btn_scan: "Scan",
      btn_copy_link: "Copy Share Link",
      btn_copy_json: "Copy JSON",
      history_label: "History",
      history_tip: "Click an item to re-run quickly. Stored locally only.",
      results_title: "Results",
      results_hint: "Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.",

      p_app_kicker: "Approval Guardian",
      p_app_title: "Check and revoke allowances",
      p_app_sub: "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
      ap_settings_title: "Settings",
      ap_connected: "Connected:",
      ap_connect: "Connect / Refresh",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "Start with a router preset, then add tokens you want to clean up.",
      ap_tokens_label: "Token list (one per line)",
      ap_seed: "Seed common tokens",
      ap_seed_history: "Use scan history",
      ap_check: "Check Allowances",
      ap_revoke_all: "Revoke All (non-zero)",
      ap_results: "Allowances",
      ap_results_hint: "If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.",

      p_rpc_kicker: "RPC Health Checker",
      p_rpc_title: "Find the best endpoint",
      p_rpc_sub: "We test RPC endpoints with eth_blockNumber and measure latency. Best result is highlighted and ready to copy.",
      rpc_inputs: "Inputs",
      rpc_custom_label: "Optional custom RPC (top priority)",
      rpc_test: "Test RPCs",
      rpc_copy_best: "Copy Best RPC",
      rpc_results: "Results",
      rpc_tip: "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",

      p_mon_kicker: "Contract Monitor",
      p_mon_title: "Detect upgrades & bytecode changes",
      p_mon_sub: "Save contracts locally. We store code hash + proxy implementation. Re-check later to detect changes.",
      mon_add_title: "Add to watchlist",
      mon_add: "Add",
      mon_check: "Check all",
      mon_export: "Export JSON",
      mon_list_title: "Watchlist",
      mon_list_hint: "Stored locally only. No server tracking.",

      footer_left: "CycleX Security Hub runs client-side and reads public on-chain data.",
      footer_tagline: "Verify twice. Connect only when you trust the page."
    },

    zh: {
      brand_sub: "é“¾ä¸Šå®‰å…¨ä¸å¥–åŠ±",
      hero_kicker: "å®‰å…¨ä¸­å¿ƒ",
      hero_title: "CycleX å®‰å…¨å·¥å…·",
      hero_subtitle: "è½»é‡çº§å®¢æˆ·ç«¯å·¥å…·ï¼šæ›´å®‰å…¨çš„ Swapã€æˆæƒç®¡ç†ä¸ RPC å¥åº·æ£€æŸ¥ï¼ˆBSC + ä»¥å¤ªåŠï¼‰ã€‚",
      btn_back: "è¿”å›ä¸»ç«™",
      btn_connect: "è¿æ¥é’±åŒ…ï¼ˆå¯é€‰ï¼‰",
      btn_quick: "è¿è¡Œå¿«é€Ÿæ‰«æ",
      hero_note: "æç¤ºï¼šè¿™äº›æ£€æŸ¥ä»…ä¾›å‚è€ƒï¼Œä¸ä¿è¯å®‰å…¨ï¼Œè¯·åŠ¡å¿…è‡ªè¡ŒäºŒæ¬¡éªŒè¯ã€‚",
      tools_kicker: "é€‰æ‹©å·¥å…·",

      cube_quick_title: "å¿«é€Ÿæ‰«æ",
      cube_quick_desc: "å¿«é€ŸåŸºç¡€æ£€æŸ¥ï¼šåˆçº¦ã€å…ƒæ•°æ®ã€owner/proxy çº¿ç´¢ï¼Œå¯ç”Ÿæˆåˆ†äº«æŠ¥å‘Šã€‚",
      badge_fast: "å¿«é€Ÿ",
      badge_history: "å†å²",
      badge_share: "åˆ†äº«",

      cube_approvals_title: "æˆæƒå®ˆå«",
      cube_approvals_desc: "è¿æ¥é’±åŒ…ï¼ŒæŸ¥çœ‹ allowanceï¼Œå¹¶å®‰å…¨æ’¤é”€æˆæƒã€‚",
      badge_wallet: "é’±åŒ…",
      badge_revoke: "æ’¤é”€",

      cube_rpc_title: "RPC å¥åº·æ£€æŸ¥",
      cube_rpc_desc: "æµ‹è¯•èŠ‚ç‚¹ã€æµ‹å»¶è¿Ÿä¸é“¾ä¿¡æ¯ï¼Œä¸€é”®å¤åˆ¶æœ€ä½³ RPCã€‚",
      badge_table: "è¡¨æ ¼",
      badge_copy: "å¤åˆ¶",

      cube_monitor_title: "åˆçº¦å˜æ›´ç›‘æ§",
      cube_monitor_desc: "æœ¬åœ°ä¿å­˜å¹¶æ£€æµ‹å­—èŠ‚ç å˜åŒ–ï¼ˆä¿¡æ¯æ€§è´¨ï¼‰ã€‚",
      badge_watch: "ç›‘æ§",
      badge_local: "æœ¬åœ°",
      badge_changes: "å˜åŒ–",

      p_quick_kicker: "å¿«é€Ÿæ‰«æ",
      p_quick_title: "å‡ ç§’å†…ç»™ä»£å¸æ‰“åˆ†",
      p_quick_sub: "ç²˜è´´ä»£å¸åœ°å€ï¼Œé€‰æ‹©ç½‘ç»œï¼Œè¿è¡Œæ‰«æã€‚å†å²ä»…ä¿å­˜åœ¨æœ¬åœ°ï¼Œå¯åˆ†äº«ç»“æœã€‚",
      pill_wallet: "é’±åŒ…",
      btn_close: "å…³é—­",
      quick_input_title: "ä»£å¸è¾“å…¥",
      net_label: "ç½‘ç»œ",
      addr_label: "ä»£å¸åˆçº¦",
      qs_tip: "æç¤ºï¼šä½¿ç”¨ ?tool=quick&net=bsc&token=0x... æ‰“å¼€å¯è‡ªåŠ¨è¿è¡Œã€‚",
      options_label: "é€‰é¡¹",
      opt_require_liq: "è¦æ±‚æµåŠ¨æ€§ï¼ˆæ›´ä¸¥æ ¼ï¼‰",
      opt_show_json: "å¯ç”¨ JSON æŠ¥å‘Šï¼ˆå¤åˆ¶ï¼‰",
      btn_scan: "æ‰«æ",
      btn_copy_link: "å¤åˆ¶åˆ†äº«é“¾æ¥",
      btn_copy_json: "å¤åˆ¶ JSON",
      history_label: "å†å²",
      history_tip: "ç‚¹å‡»å³å¯å¿«é€Ÿé‡è·‘ã€‚ä»…æœ¬åœ°å­˜å‚¨ã€‚",
      results_title: "ç»“æœ",
      results_hint: "ç»¿/é»„/çº¢ä¿¡å·ã€‚éä¿è¯â€”ä»…å¯é“¾ä¸ŠéªŒè¯çš„æ£€æŸ¥ã€‚",

      p_app_kicker: "æˆæƒå®ˆå«",
      p_app_title: "æ£€æŸ¥å¹¶æ’¤é”€æˆæƒ",
      p_app_sub: "è¾“å…¥ spender + ä»£å¸ï¼ˆæˆ–ä¸€é”®å¡«å……å¸¸ç”¨ä»£å¸ï¼‰ã€‚è¯»å– allowance(owner, spender)ï¼Œå¹¶ç”¨ approve(spender, 0) æ’¤é”€ã€‚",
      ap_settings_title: "è®¾ç½®",
      ap_connected: "å·²è¿æ¥ï¼š",
      ap_connect: "è¿æ¥ / åˆ·æ–°",
      ap_spender_label: "Spender é¢„è®¾",
      ap_spender_tip: "å…ˆé€‰è·¯ç”±é¢„è®¾ï¼Œç„¶åæ·»åŠ è¦æ¸…ç†çš„ä»£å¸ã€‚",
      ap_tokens_label: "ä»£å¸åˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰",
      ap_seed: "å¡«å……å¸¸ç”¨ä»£å¸",
      ap_seed_history: "ä½¿ç”¨æ‰«æå†å²",
      ap_check: "æ£€æŸ¥æˆæƒ",
      ap_revoke_all: "æ’¤é”€å…¨éƒ¨ï¼ˆéé›¶ï¼‰",
      ap_results: "æˆæƒç»“æœ",
      ap_results_hint: "è‹¥æˆæƒä¸ºâ€œæ— é™â€ï¼Œé™¤éå®Œå…¨ä¿¡ä»»ï¼Œå¦åˆ™å»ºè®®æ’¤é”€ã€‚",

      p_rpc_kicker: "RPC å¥åº·æ£€æŸ¥",
      p_rpc_title: "æ‰¾åˆ°æœ€ä½³èŠ‚ç‚¹",
      p_rpc_sub: "ç”¨ eth_blockNumber æµ‹å»¶è¿Ÿã€‚æœ€ä½³ç»“æœä¼šé«˜äº®ï¼Œå¯ä¸€é”®å¤åˆ¶ã€‚",
      rpc_inputs: "è¾“å…¥",
      rpc_custom_label: "å¯é€‰ï¼šè‡ªå®šä¹‰ RPCï¼ˆä¼˜å…ˆï¼‰",
      rpc_test: "æµ‹è¯• RPC",
      rpc_copy_best: "å¤åˆ¶æœ€ä½³ RPC",
      rpc_results: "ç»“æœ",
      rpc_tip: "æç¤ºï¼šéƒ¨åˆ† RPC å¯èƒ½å›  CORS/è¶…æ—¶å¤±è´¥ã€‚æµ‹è¯•åé€‰æ‹©ç¨³å®šä¸”æœ€å¿«çš„ã€‚",

      p_mon_kicker: "åˆçº¦ç›‘æ§",
      p_mon_title: "æ£€æµ‹å‡çº§ä¸å­—èŠ‚ç å˜åŒ–",
      p_mon_sub: "æœ¬åœ°ä¿å­˜åˆçº¦å¹¶å®šæœŸå¤æŸ¥ä»¥å‘ç°å˜åŒ–ã€‚",
      mon_add_title: "æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨",
      mon_add: "æ·»åŠ ",
      mon_check: "æ£€æŸ¥å…¨éƒ¨",
      mon_export: "å¯¼å‡º JSON",
      mon_list_title: "ç›‘æ§åˆ—è¡¨",
      mon_list_hint: "ä»…æœ¬åœ°å­˜å‚¨ï¼Œä¸åšæœåŠ¡å™¨è·Ÿè¸ªã€‚",

      footer_left: "CycleX å®‰å…¨ä¸­å¿ƒåœ¨æœ¬åœ°è¿è¡Œï¼Œè¯»å–å…¬å¼€é“¾ä¸Šæ•°æ®ã€‚",
      footer_tagline: "å¤šéªŒè¯ä¸€æ¬¡ï¼Œåªåœ¨ä½ ä¿¡ä»»æ—¶è¿æ¥é’±åŒ…ã€‚"
    },

    ar: {
      brand_sub: "Ø£Ù…Ù† ÙˆÙ…ÙƒØ§ÙØ¢Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
      hero_kicker: "Ù…Ø±ÙƒØ² Ø§Ù„Ø£Ù…Ø§Ù†",
      hero_title: "Ø£Ø¯ÙˆØ§Øª Ø£Ù…Ø§Ù† CycleX",
      hero_subtitle: "Ø£Ø¯ÙˆØ§Øª Ø®ÙÙŠÙØ© Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ Ù„ÙØ­Øµ Ø£Ù…Ø§Ù† Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª ÙˆÙ‚ÙŠØ§Ø³ ØµØ­Ø© RPC (BSC + Ethereum).",
      btn_back: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆÙ‚Ø¹",
      btn_connect: "Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø­ÙØ¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
      btn_quick: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
      hero_note: "Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ù‡ Ø§Ù„ÙØ­ÙˆØµØ§Øª Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠØ© ÙˆÙ„Ø§ ØªØ¶Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù†. ØªØ­Ù‚Ù‚ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¨Ù†ÙØ³Ùƒ.",
      tools_kicker: "Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø©",

      cube_quick_title: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
      cube_quick_desc: "ÙØ­Øµ Ø£Ø³Ø§Ø³ÙŠ Ø³Ø±ÙŠØ¹: Ø§Ù„Ø¹Ù‚Ø¯ØŒ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø¥Ø´Ø§Ø±Ø§Øª owner/proxy ÙˆØªÙ‚Ø±ÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ©.",
      badge_fast: "Ø³Ø±ÙŠØ¹",
      badge_history: "Ø³Ø¬Ù„",
      badge_share: "Ù…Ø´Ø§Ø±ÙƒØ©",

      cube_approvals_title: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      cube_approvals_desc: "Ø§ØªØµÙ„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø© ÙˆØ±Ø§Ø¬Ø¹/Ø£Ù„ØºÙ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª Ø¨Ø£Ù…Ø§Ù†.",
      badge_wallet: "Ù…Ø­ÙØ¸Ø©",
      badge_revoke: "Ø¥Ù„ØºØ§Ø¡",

      cube_rpc_title: "ÙØ­Øµ RPC",
      cube_rpc_desc: "Ø§Ø®ØªØ¨Ø± Ø§Ù„Ù†Ù‚Ø§Ø·ØŒ Ù‚ÙØ³ Ø§Ù„ØªØ£Ø®ÙŠØ±ØŒ ÙˆØ§Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC.",
      badge_table: "Ø¬Ø¯ÙˆÙ„",
      badge_copy: "Ù†Ø³Ø®",

      cube_monitor_title: "Ù…Ø±Ø§Ù‚Ø¨Ø© ØªØºÙŠÙ‘Ø± Ø§Ù„Ø¹Ù‚Ø¯",
      cube_monitor_desc: "Ø­ÙØ¸ Ù…Ø­Ù„ÙŠ ÙˆÙƒØ´Ù ØªØºÙŠÙ‘Ø± Ø§Ù„Ø¨Ø§ÙŠØª ÙƒÙˆØ¯ Ù…Ø¹ Ø§Ù„ÙˆÙ‚Øª.",
      badge_watch: "Ù…Ø±Ø§Ù‚Ø¨Ø©",
      badge_local: "Ù…Ø­Ù„ÙŠ",
      badge_changes: "ØªØºÙŠÙŠØ±Ø§Øª",

      p_quick_kicker: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
      p_quick_title: "Ù‚ÙŠÙ‘Ù… Ø§Ù„ØªÙˆÙƒÙ† Ø®Ù„Ø§Ù„ Ø«ÙˆØ§Ù†Ù",
      p_quick_sub: "Ø§Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ†ØŒ Ø§Ø®ØªØ± Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ Ø´ØºÙ‘Ù„ Ø§Ù„ÙØ­Øµ. Ø§Ù„Ø³Ø¬Ù„ Ù…Ø­Ù„ÙŠ ÙˆÙŠÙ…ÙƒÙ† Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬.",
      pill_wallet: "Ù…Ø­ÙØ¸Ø©",
      btn_close: "Ø¥ØºÙ„Ø§Ù‚",
      quick_input_title: "Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†",
      net_label: "Ø§Ù„Ø´Ø¨ÙƒØ©",
      addr_label: "Ø¹Ù‚Ø¯ Ø§Ù„ØªÙˆÙƒÙ†",
      qs_tip: "Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ Ø¨Ù€ ?tool=quick&net=bsc&token=0x... Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.",
      options_label: "Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª",
      opt_require_liq: "Ø§Ø´ØªØ±Ø§Ø· Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (Ø£ÙƒØ«Ø± ØµØ±Ø§Ù…Ø©)",
      opt_show_json: "ØªÙØ¹ÙŠÙ„ ØªÙ‚Ø±ÙŠØ± JSON (Ù†Ø³Ø®)",
      btn_scan: "ÙØ­Øµ",
      btn_copy_link: "Ù†Ø³Ø® Ø±Ø§Ø¨Ø·",
      btn_copy_json: "Ù†Ø³Ø® JSON",
      history_label: "Ø§Ù„Ø³Ø¬Ù„",
      history_tip: "Ø§Ø¶ØºØ· Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙØ­Øµ Ø¨Ø³Ø±Ø¹Ø©. Ø§Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø­Ù„ÙŠ ÙÙ‚Ø·.",
      results_title: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
      results_hint: "Ø¥Ø´Ø§Ø±Ø§Øª Ø®Ø¶Ø±Ø§Ø¡/ØµÙØ±Ø§Ø¡/Ø­Ù…Ø±Ø§Ø¡. Ù„ÙŠØ³Øª Ø¶Ù…Ø§Ù†Ø§Ù‹ â€” ÙØ­ÙˆØµØ§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ on-chain.",

      p_app_kicker: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      p_app_title: "ÙØ­Øµ ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      p_app_sub: "Ø£Ø¯Ø®Ù„ spender + ØªÙˆÙƒÙ†Ø§Øª (Ø£Ùˆ Ø£Ø¶Ù Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©). Ù†Ù‚Ø±Ø£ allowance(owner, spender) ÙˆÙ†Ù„ØºÙŠ Ø¹Ø¨Ø± approve(spender, 0).",
      ap_settings_title: "Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
      ap_connected: "Ù…ØªØµÙ„:",
      ap_connect: "Ø§ØªØµØ§Ù„ / ØªØ­Ø¯ÙŠØ«",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "Ø§Ø¨Ø¯Ø£ Ø¨Ù…ÙØ³Ø¨Ù‚ Ø§Ù„Ø±Ø§ÙˆØªØ± Ø«Ù… Ø£Ø¶Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªÙ†Ø¸ÙŠÙÙ‡Ø§.",
      ap_tokens_label: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (ÙƒÙ„ Ø³Ø·Ø± ØªÙˆÙƒÙ†)",
      ap_seed: "Ø¥Ø¶Ø§ÙØ© ØªÙˆÙƒÙ†Ø§Øª Ø´Ø§Ø¦Ø¹Ø©",
      ap_seed_history: "Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø¬Ù„ Ø§Ù„ÙØ­Øµ",
      ap_check: "ÙØ­Øµ Allowances",
      ap_revoke_all: "Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„ (ØºÙŠØ± ØµÙØ±)",
      ap_results: "Allowances",
      ap_results_hint: "Ø¥Ø°Ø§ ÙƒØ§Ù†Øª â€œÙ„Ø§ Ù†Ù‡Ø§Ø¦ÙŠØ©â€ØŒ ÙŠÙˆØµÙ‰ Ø¨Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ«Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹.",

      p_rpc_kicker: "ÙØ­Øµ RPC",
      p_rpc_title: "Ø§Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ù†Ù‚Ø·Ø©",
      p_rpc_sub: "Ù†Ù‚ÙŠØ³ Ø§Ù„ØªØ£Ø®ÙŠØ± Ø¹Ø¨Ø± eth_blockNumber. Ø§Ù„Ø£ÙØ¶Ù„ Ø³ÙŠØ¸Ù‡Ø± Ù…Ù…ÙŠØ²Ø§Ù‹ ÙˆÙŠÙ…ÙƒÙ† Ù†Ø³Ø®Ù‡.",
      rpc_inputs: "Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª",
      rpc_custom_label: "Ø§Ø®ØªÙŠØ§Ø±ÙŠ: RPC Ù…Ø®ØµØµ (Ø£ÙˆÙ„ÙˆÙŠØ©)",
      rpc_test: "Ø§Ø®ØªØ¨Ø§Ø± RPC",
      rpc_copy_best: "Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC",
      rpc_results: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
      rpc_tip: "Ù‚Ø¯ ØªÙØ´Ù„ Ø¨Ø¹Ø¶ RPC Ø¨Ø³Ø¨Ø¨ CORS/timeout. Ø§Ø®ØªØ¨Ø± ÙˆØ§Ø®ØªØ± Ø§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªÙ‚Ø±Ø§Ø±Ø§Ù‹.",

      p_mon_kicker: "Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù‚Ø¯",
      p_mon_title: "ÙƒØ´Ù Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª ÙˆØªØºÙŠÙ‘Ø± Ø§Ù„Ø¨Ø§ÙŠØª ÙƒÙˆØ¯",
      p_mon_sub: "Ø§Ø­ÙØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙˆØ£Ø¹Ø¯ Ø§Ù„ÙØ­Øµ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª.",
      mon_add_title: "Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©",
      mon_add: "Ø¥Ø¶Ø§ÙØ©",
      mon_check: "ÙØ­Øµ Ø§Ù„ÙƒÙ„",
      mon_export: "ØªØµØ¯ÙŠØ± JSON",
      mon_list_title: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©",
      mon_list_hint: "Ù…Ø­Ù„ÙŠ ÙÙ‚Ø·. Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØªØ¨Ø¹ Ø³ÙŠØ±ÙØ±.",

      footer_left: "Ù…Ø±ÙƒØ² Ø£Ù…Ø§Ù† CycleX ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆÙŠÙ‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
      footer_tagline: "ØªØ­Ù‚Ù‚ Ù…Ø±ØªÙŠÙ†. Ù„Ø§ ØªØªØµÙ„ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ«Ù‚ Ø¨Ø§Ù„ØµÙØ­Ø©."
    },

    ru: {
      brand_sub: "ĞĞ½Ñ‡ĞµĞ¹Ğ½-Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ¸ Ğ²Ğ¾Ğ·Ğ½Ğ°Ğ³Ñ€Ğ°Ğ¶Ğ´ĞµĞ½Ğ¸Ñ",
      hero_kicker: "Ğ¦ĞµĞ½Ñ‚Ñ€ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸",
      hero_title: "Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ CycleX",
      hero_subtitle: "Ğ›Ñ‘Ğ³ĞºĞ¸Ğ¹ Ğ½Ğ°Ğ±Ğ¾Ñ€ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ², approvals Ğ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒĞµ RPC (BSC + Ethereum).",
      btn_back: "ĞĞ°Ğ·Ğ°Ğ´ Ğ½Ğ° ÑĞ°Ğ¹Ñ‚",
      btn_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
      btn_quick: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°",
      hero_note: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¸ Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒÑÑ‚ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿ĞµÑ€ĞµĞ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ.",
      tools_kicker: "Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞœĞ•ĞĞ¢",

      cube_quick_title: "Quick Scan",
      cube_quick_desc: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°: ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚, Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, owner/proxy Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ¸ Ğ¸ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ Ğ´Ğ»Ñ ÑˆĞ°Ñ€Ğ¸Ğ½Ğ³Ğ°.",
      badge_fast: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾",
      badge_history: "Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ",
      badge_share: "Ğ¨Ğ°Ñ€Ğ¸Ğ½Ğ³",

      cube_approvals_title: "Approvals Guardian",
      cube_approvals_desc: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ allowances Ğ¸ Ğ¾Ñ‚Ğ·Ğ¾Ğ²Ğ¸Ñ‚Ğµ approvals.",
      badge_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
      badge_revoke: "ĞÑ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ",

      cube_rpc_title: "RPC Health Checker",
      cube_rpc_desc: "Ğ¢ĞµÑÑ‚ RPC, Ğ·Ğ°Ğ¼ĞµÑ€ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ¸ Ğ¸ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ»ÑƒÑ‡ÑˆĞµĞ³Ğ¾ RPC.",
      badge_table: "Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°",
      badge_copy: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",

      cube_monitor_title: "ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ¾Ğ²",
      cube_monitor_desc: "Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞ¹Ñ‚Ğµ Ğ¸ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ¹Ñ‚ĞºĞ¾Ğ´Ğ° ÑĞ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½ĞµĞ¼.",
      badge_watch: "Ğ¡Ğ»ĞµĞ´Ğ¸Ñ‚ÑŒ",
      badge_local: "Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾",
      badge_changes: "Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ",

      p_quick_kicker: "Quick Scan",
      p_quick_title: "ĞÑ†ĞµĞ½Ğ¸Ñ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½ Ğ·Ğ° ÑĞµĞºÑƒĞ½Ğ´Ñ‹",
      p_quick_sub: "Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ°Ğ´Ñ€ĞµÑ Ñ‚Ğ¾ĞºĞµĞ½Ğ°, Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞµÑ‚ÑŒ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ. Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾; Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ğ¼Ğ¸.",
      pill_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
      btn_close: "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
      quick_input_title: "Ğ’Ğ²Ğ¾Ğ´ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
      net_label: "Ğ¡ĞµÑ‚ÑŒ",
      addr_label: "ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
      qs_tip: "Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ñ ?tool=quick&net=bsc&token=0x... Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾-Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°.",
      options_label: "ĞĞ¿Ñ†Ğ¸Ğ¸",
      opt_require_liq: "Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ (ÑÑ‚Ñ€Ğ¾Ğ¶Ğµ)",
      opt_show_json: "Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ JSON Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ (ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ)",
      btn_scan: "Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
      btn_copy_link: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
      btn_copy_json: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ JSON",
      history_label: "Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ",
      history_tip: "ĞšĞ»Ğ¸ĞºĞ½Ğ¸Ñ‚Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ. Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾.",
      results_title: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
      results_hint: "Ğ—ĞµĞ»Ñ‘Ğ½Ñ‹Ğµ/Ğ¶Ñ‘Ğ»Ñ‚Ñ‹Ğµ/ĞºÑ€Ğ°ÑĞ½Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹. ĞĞµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ â€” Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼Ñ‹Ğµ on-chain Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸.",

      p_app_kicker: "Approvals Guardian",
      p_app_title: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ² allowances",
      p_app_sub: "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ spender + Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ (Ğ¸Ğ»Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ). Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ allowance(owner, spender) Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ approve(spender, 0).",
      ap_settings_title: "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸",
      ap_connected: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾:",
      ap_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ / Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "ĞĞ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ñ Ğ¿Ñ€ĞµÑĞµÑ‚Ğ° Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ğ°, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ¸.",
      ap_tokens_label: "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² (Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ)",
      ap_seed: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹",
      ap_seed_history: "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ",
      ap_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ allowances",
      ap_revoke_all: "ĞÑ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ (Ğ½ĞµĞ½ÑƒĞ»ĞµĞ²Ñ‹Ğµ)",
      ap_results: "Allowances",
      ap_results_hint: "Ğ•ÑĞ»Ğ¸ allowance â€œĞ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹â€, Ğ¾Ñ‚Ğ·Ñ‹Ğ² Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ, ĞµÑĞ»Ğ¸ Ğ²Ñ‹ Ğ½Ğµ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ Ğ½Ğ° 100%.",

      p_rpc_kicker: "RPC Health Checker",
      p_rpc_title: "ĞĞ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC",
      p_rpc_sub: "Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ eth_blockNumber Ğ¸ Ğ·Ğ°Ğ¼ĞµÑ€ÑĞµĞ¼ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºÑƒ. Ğ›ÑƒÑ‡ÑˆĞ¸Ğ¹ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‡ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.",
      rpc_inputs: "Ğ’Ğ²Ğ¾Ğ´",
      rpc_custom_label: "ĞĞ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾: ÑĞ²Ğ¾Ğ¹ RPC (Ğ² Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ğµ)",
      rpc_test: "Ğ¢ĞµÑÑ‚ RPC",
      rpc_copy_best: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC",
      rpc_results: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
      rpc_tip: "ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ RPC Ğ¿Ğ°Ğ´Ğ°ÑÑ‚ Ğ¸Ğ·-Ğ·Ğ° CORS/Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ². Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ¸ Ğ²Ñ‹Ğ±Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğµ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹.",

      p_mon_kicker: "ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³",
      p_mon_title: "ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ² Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ±Ğ°Ğ¹Ñ‚ĞºĞ¾Ğ´Ğ°",
      p_mon_sub: "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞ¹Ñ‚Ğµ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ.",
      mon_add_title: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº",
      mon_add: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
      mon_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ",
      mon_export: "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ JSON",
      mon_list_title: "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº",
      mon_list_hint: "Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾. Ğ‘ĞµĞ· ÑĞµÑ€Ğ²ĞµÑ€Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ°.",

      footer_left: "CycleX Security Hub Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ½Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğµ Ğ¸ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ on-chain Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.",
      footer_tagline: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°Ğ¹Ñ‚Ğµ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ."
    }
  };

  function setLanguage(lang) {
    const dict = translations[lang] || translations.en;

    localStorage.setItem("cx_lang", lang);
    document.documentElement.lang = lang;
    document.documentElement.dir = (lang === "ar") ? "rtl" : "ltr";

    document.body.classList.add("lang-switching");

    document.querySelectorAll("[data-i18n]").forEach((el) => {
      const key = el.getAttribute("data-i18n");
      const val = (dict[key] !== undefined) ? dict[key] : translations.en[key];
      if (val !== undefined) el.innerHTML = val;
    });

    document.querySelectorAll(".lang-btn").forEach((btn) => {
      btn.classList.toggle("active", btn.getAttribute("data-lang") === lang);
    });

    setTimeout(() => document.body.classList.remove("lang-switching"), 250);
  }

  // Bind language buttons
  document.querySelectorAll(".lang-btn").forEach((btn) => {
    btn.addEventListener("click", () => setLanguage(btn.getAttribute("data-lang")));
  });

  // Init language
  setLanguage(localStorage.getItem("cx_lang") || "en");

  // ===============================
  // Shared helpers / state
  // ===============================
  const CX_DEBUG = false;
  function cxlog(...a){ if(CX_DEBUG) console.log(...a); }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  function isHexAddr(x){ return typeof x === "string" && /^0x[0-9a-fA-F]{40}$/.test(x.trim()); }
  function toChecksum(x){ return ethers.getAddress(x.trim()); }

  async function copyText(text){
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      return true;
    }
  }

  function setStatus(el, kind, html){
    if (!el) return;
    el.className = "status " + (kind || "info");
    el.innerHTML = html || "";
    el.style.display = "block";
  }

  function fmtAddr(a){
    try {
      const x = toChecksum(a);
      return x.slice(0, 6) + "â€¦" + x.slice(-4);
    } catch { return a; }
  }

  function fmtBigintUnits(v, decimals){
    try {
      const s = ethers.formatUnits(v, decimals);
      const [i, f=""] = s.split(".");
      const intWithCommas = i.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      const ff = f.slice(0, 6).replace(/0+$/, "");
      return intWithCommas + (ff ? "." + ff : "");
    } catch {
      return String(v);
    }
  }

  function fmtUsd(x){
    if (!Number.isFinite(x)) return "â€”";
    if (x >= 1_000_000_000) return "$" + (x/1_000_000_000).toFixed(2) + "B";
    if (x >= 1_000_000) return "$" + (x/1_000_000).toFixed(2) + "M";
    if (x >= 1_000) return "$" + (x/1_000).toFixed(2) + "K";
    return "$" + x.toFixed(2);
  }

  const CX = {
    reports: { quick: null },
    providers: { bsc: null, eth: null },
    rpc: { best: "", last: [] },
    wallet: { signer: null, address: null, provider: null },
    monitor: { list: [] }
  };

  // ===============================
  // WalletConnect (Reown AppKit) â€” init
  // ===============================
  const WALLETCONNECT_PROJECT_ID = "PASTE_YOUR_WC_PROJECT_ID_HERE"; // <-- ×ª×“×‘×™×§ ×¤×” ××ª ×”-Project ID

  function initAppKit(){
    try {
      const AppKit = window.AppKit || window.appKit || window.appkit;
      const AdapterPkg = window.AppKitAdapterEthers || window.AppKitAdapterEthers || window.appKitAdapterEthers;

      const createAppKit = AppKit?.createAppKit || AppKit?.default?.createAppKit;
      const EthersAdapter = AdapterPkg?.EthersAdapter || AdapterPkg?.default?.EthersAdapter;

      if (!createAppKit || !EthersAdapter) {
        console.warn("AppKit not available (scripts not loaded?)");
        return null;
      }

      // Prefer built-in networks if available
      const nets = [];
      if (AppKit?.networks?.bsc) nets.push(AppKit.networks.bsc);
      if (AppKit?.networks?.mainnet) nets.push(AppKit.networks.mainnet);

      // Fallback networks (wagmi-like shape)
      if (!nets.length) {
        nets.push({
          id: 56,
          name: "BNB Smart Chain",
          nativeCurrency: { name:"BNB", symbol:"BNB", decimals:18 },
          rpcUrls: { default: { http: ["https://bsc-dataseed.binance.org"] } },
          blockExplorers: { default: { name:"BscScan", url:"https://bscscan.com" } }
        });
        nets.push({
          id: 1,
          name: "Ethereum",
          nativeCurrency: { name:"Ether", symbol:"ETH", decimals:18 },
          rpcUrls: { default: { http: ["https://cloudflare-eth.com"] } },
          blockExplorers: { default: { name:"Etherscan", url:"https://etherscan.io" } }
        });
      }

      const metadata = {
        name: "CycleX Security Hub",
        description: "Client-side security tools + approvals guardian + RPC checker",
        url: window.location.origin,
        icons: [window.location.origin + "/logo.png"]
      };

      const modal = createAppKit({
        projectId: WALLETCONNECT_PROJECT_ID,
        metadata,
        networks: nets,
        adapters: [new EthersAdapter()],
      });

      window.cxAppKitModal = modal;
      return modal;
    } catch (e) {
      console.warn("initAppKit failed:", e);
      return null;
    }
  }

  // Create modal now (safe even if projectId is placeholder; connect will warn)
  initAppKit();

  // ===============================
  // RPC lists
  // ===============================
  const RPCS = {
    bsc: [
      "https://bsc-dataseed.binance.org",
      "https://bsc-dataseed1.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed1.defibit.io",
    ],
    eth: [
      "https://cloudflare-eth.com",
      "https://rpc.ankr.com/eth",
      "https://ethereum.publicnode.com"
    ]
  };

  async function pickProvider(net, customList){
    if (CX.providers[net]) return CX.providers[net];

    const list = (Array.isArray(customList) && customList.length) ? customList : (RPCS[net] || []);
    const expectChainId = (net === "bsc") ? 56 : 1;

    for (const url of list) {
      try {
        const p = new ethers.JsonRpcProvider(url);
        const bn = await p.getBlockNumber();
        const n = await p.getNetwork();
        if (Number(n.chainId) !== expectChainId) throw new Error("Wrong chainId");
        CX.providers[net] = p;
        cxlog("âœ… Provider", net, url, "block", bn);
        return p;
      } catch (e) {
        cxlog("âš ï¸ Provider fail", net, url, e?.message || e);
      }
    }
    throw new Error(`All ${net.toUpperCase()} RPCs failed (CORS/timeout/blocked)`);
  }

  // ===============================
  // DEX + bases (BSC only for liquidity checks)
  // ===============================
  const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
  const USDT = "0x55d398326f99059fF775485246999027B3197955";
  const USDC = "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d";
  const BUSD = "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56";

  const DEXES_BSC = [
    { key:"pancake",  name:"PancakeSwap V2", router:"0x10ED43C718714eb63d5aA57B78B54704E256024E", swap:(tin,tout)=>`https://pancakeswap.finance/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"apeswap",  name:"ApeSwap",        router:"0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607", swap:(tin,tout)=>`https://apeswap.finance/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"biswap",   name:"BiSwap",         router:"0xE97E2787C9C8d63bFF482Fa3fdc212BbD547aE98", swap:(tin,tout)=>`https://exchange.biswap.org/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"mdex",     name:"MDEX (BSC)",     router:"0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8", swap:(tin,tout)=>`https://bscr.mdex.com/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"bakery",   name:"BakerySwap",     router:"0x824C9364A6CF8f5EB542ad2ca8F5705561C8b1db", swap:(tin,tout)=>`https://www.bakeryswap.org/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"babyswap", name:"BabySwap",       router:"0xC085fDA7Dc3c1A1611f3Ae421e2BD3c75b3a6943", swap:(tin,tout)=>`https://exchange.babyswap.finance/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
  ];

  const BASES_BSC = [
    { key:"WBNB", name:"WBNB", addr:WBNB, kind:"bnb" },
    { key:"USDT", name:"USDT", addr:USDT, kind:"stable" },
    { key:"USDC", name:"USDC", addr:USDC, kind:"stable" },
    { key:"BUSD", name:"BUSD", addr:BUSD, kind:"stable" }
  ];

  // ===============================
  // ABIs
  // ===============================
  const ERC20_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)",
    "function owner() view returns (address)",
    "function getOwner() view returns (address)",
    "function admin() view returns (address)",
  ];

  const FACTORY_ABI = [ "function getPair(address tokenA, address tokenB) external view returns (address pair)" ];
  const ROUTER_ABI  = [ "function factory() view returns (address)" ];
  const PAIR_ABI    = [ "function token0() view returns (address)", "function token1() view returns (address)", "function getReserves() view returns (uint112,uint112,uint32)" ];
  const LP_ABI      = [ "function totalSupply() view returns (uint256)", "function balanceOf(address) view returns (uint256)" ];

  const CL_ABI = [
    "function decimals() view returns (uint8)",
    "function latestRoundData() view returns (uint80,int256,uint256,uint256,uint80)"
  ];

  // ===============================
  // Proxy detection (EIP-1967)
  // ===============================
  const EIP1967_IMPL_SLOT  = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
  const EIP1967_ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

  function slotToAddress(storageHex){
    if (!storageHex || storageHex === "0x") return null;
    const h = storageHex.toLowerCase().replace(/^0x/,"").padStart(64,"0");
    const addr = "0x" + h.slice(24);
    if (/^0x0{40}$/.test(addr)) return null;
    try { return toChecksum(addr); } catch { return null; }
  }

  async function detectProxy(provider, addr){
    try {
      const implRaw = await provider.getStorage(addr, EIP1967_IMPL_SLOT);
      const impl = slotToAddress(implRaw);
      const adminRaw = await provider.getStorage(addr, EIP1967_ADMIN_SLOT);
      const admin = slotToAddress(adminRaw);
      if (impl) return { isProxy: true, impl, admin };
      return { isProxy: false, impl: null, admin: admin || null };
    } catch {
      return { isProxy: false, impl: null, admin: null };
    }
  }

  // ===============================
  // BNB/USD oracle (BSC)
  // ===============================
  const PCS_FACTORY = "0xca143ce32fe78f1f7019d7d551a6402fc5350c73";
  const CHAINLINK_BNBUSD = "0x0567F2323251f0Aab15c8DfB1967E4e8A7D42aeE";
  let _bnbUsdCache = null;

  async function getBnbUsd(provider){
    if (_bnbUsdCache && (Date.now() - _bnbUsdCache.t) < 60_000) return _bnbUsdCache;

    // 1) Chainlink
    try {
      const feed = new ethers.Contract(CHAINLINK_BNBUSD, CL_ABI, provider);
      const dec = Number(await feed.decimals());
      const rd = await feed.latestRoundData();
      const ans = Number(rd[1]);
      if (Number.isFinite(ans) && ans > 0) {
        const px = ans / (10 ** dec);
        _bnbUsdCache = { px, source: "Chainlink", t: Date.now() };
        return _bnbUsdCache;
      }
    } catch {}

    // 2) Fallback: WBNB/USDT reserves on PCS
    try {
      const f = new ethers.Contract(PCS_FACTORY, FACTORY_ABI, provider);
      let pair = await f.getPair(WBNB, USDT);
      pair = toChecksum(String(pair));
      if (pair && !/^0x0{40}$/i.test(pair)) {
        const p = new ethers.Contract(pair, PAIR_ABI, provider);
        const t0 = toChecksum(await p.token0());
        const r = await p.getReserves();
        const r0 = BigInt(r[0]);
        const r1 = BigInt(r[1]);

        const wbnbRes = (t0 === toChecksum(WBNB)) ? r0 : r1;
        const usdtRes = (t0 === toChecksum(WBNB)) ? r1 : r0;

        const wbnbF = Number(ethers.formatUnits(wbnbRes, 18));
        const usdtF = Number(ethers.formatUnits(usdtRes, 18));
        if (wbnbF > 0 && usdtF > 0) {
          const px = usdtF / wbnbF;
          _bnbUsdCache = { px, source: "On-chain (WBNB/USDT)", t: Date.now() };
          return _bnbUsdCache;
        }
      }
    } catch {}

    _bnbUsdCache = { px: NaN, source: "Unavailable", t: Date.now() };
    return _bnbUsdCache;
  }

  async function getDexFactory(provider, dex){
    try {
      const r = new ethers.Contract(dex.router, ROUTER_ABI, provider);
      const f = await r.factory();
      return toChecksum(String(f));
    } catch {
      return null;
    }
  }

  async function scanOnePair(provider, token, base, dex, factoryAddr){
    if (!factoryAddr) return null;
    try {
      const f = new ethers.Contract(factoryAddr, FACTORY_ABI, provider);
      let pair = await f.getPair(token, base.addr);
      pair = toChecksum(String(pair));
      if (/^0x0{40}$/i.test(pair)) return null;

      const p = new ethers.Contract(pair, PAIR_ABI, provider);
      const t0 = toChecksum(await p.token0());
      const r = await p.getReserves();
      const r0 = BigInt(r[0]);
      const r1 = BigInt(r[1]);

      const baseRes  = (t0 === toChecksum(base.addr)) ? r0 : r1;
      const tokenRes = (t0 === toChecksum(base.addr)) ? r1 : r0;

      let burnPct = null;
      try {
        const lp = new ethers.Contract(pair, LP_ABI, provider);
        const ts = BigInt(await lp.totalSupply());
        if (ts > 0n) {
          const z = BigInt(await lp.balanceOf("0x0000000000000000000000000000000000000000"));
          const d = BigInt(await lp.balanceOf("0x000000000000000000000000000000000000dEaD"));
          const burned = z + d;
          burnPct = Number((burned * 10000n) / ts) / 100;
        }
      } catch {}

      return {
        dexKey: dex.key,
        dexName: dex.name,
        router: dex.router,
        factory: factoryAddr,
        baseKey: base.key,
        baseName: base.name,
        baseAddr: base.addr,
        pair,
        baseReserve: baseRes,
        tokenReserve: tokenRes,
        burnPct
      };
    } catch {
      return null;
    }
  }

  // ===============================
  // Core scan (Quick)
  // ===============================
  async function scanTokenCore({ net, token, requireLiquidity=false }){
    const provider = await pickProvider(net);

    const code = await provider.getCode(token);
    if (!code || code === "0x") {
      return {
        ok: false,
        badge: "bad",
        headline: "âŒ Not a contract",
        score: 999,
        notes: [`${token} has no bytecode on ${net.toUpperCase()}.`],
        data: null
      };
    }

    const c = new ethers.Contract(token, ERC20_ABI, provider);

    let name="â€”", symbol="â€”", decimals=18, supply=0n;
    try { name = await c.name(); } catch {}
    try { symbol = await c.symbol(); } catch {}
    try { decimals = Number(await c.decimals()); } catch {}
    try { supply = BigInt(await c.totalSupply()); } catch {}

    let owner = null;
    for (const fn of ["owner","getOwner","admin"]) {
      try {
        const o = await c[fn]();
        if (o && isHexAddr(String(o))) { owner = toChecksum(String(o)); break; }
      } catch {}
    }
    const ownerRenounced = owner ? (owner === "0x0000000000000000000000000000000000000000") : null;
    const proxy = await detectProxy(provider, token);

    // ETH: metadata-only
    if (net === "eth") {
      let score = 0;
      const notes = [];
      notes.push("âœ… Contract bytecode found");
      if (!name || name==="â€”") { score += 1; notes.push("âš ï¸ Token name unreadable (non-standard)"); }
      if (!symbol || symbol==="â€”") { score += 1; notes.push("âš ï¸ Symbol unreadable (non-standard)"); }
      if (proxy?.isProxy && proxy.impl) { score += 1; notes.push(`â„¹ï¸ Proxy detected. Impl: ${proxy.impl}`); }
      if (!owner) { score += 1; notes.push("âš ï¸ Owner not detectable"); }
      else if (ownerRenounced) { notes.push("âœ… Ownership appears renounced (owner=0x0)"); }
      else { score += 1; notes.push(`âš ï¸ Owner detected: ${owner} (not renounced)`); }

      let badge="info", headline="â„¹ï¸ Informational";
      if (score <= 1) { badge="ok"; headline="âœ… Looks OK (basic checks)"; }
      else if (score <= 3) { badge="warn"; headline="âš ï¸ Caution (some signals)"; }
      else { badge="bad"; headline="âŒ Higher risk signals"; }

      return {
        ok: true,
        badge,
        headline,
        score,
        notes,
        data: {
          net, token, name, symbol, decimals,
          totalSupply: supply ? supply.toString() : null,
          owner: owner || null,
          ownerRenounced: ownerRenounced === null ? null : ownerRenounced,
          proxy,
          requireLiquidity,
          pairs: [],
          generatedAt: new Date().toISOString()
        }
      };
    }

    // BSC liquidity scan
    const bnbUsd = await getBnbUsd(provider);
    const pairsFound = [];

    for (const dex of DEXES_BSC) {
      const factory = await getDexFactory(provider, dex);
      if (!factory) continue;

      for (const base of BASES_BSC) {
        const res = await scanOnePair(provider, token, base, dex, factory);
        if (!res) continue;

        let liqUsdApprox = null;
        try {
          const baseAmt = Number(ethers.formatUnits(res.baseReserve, 18));
          if (base.kind === "stable") liqUsdApprox = baseAmt * 2;
          else if (base.kind === "bnb") liqUsdApprox = (Number.isFinite(bnbUsd.px) ? baseAmt * bnbUsd.px * 2 : null);
        } catch {}

        pairsFound.push({ ...res, liqUsdApprox });
      }
    }

    pairsFound.sort((a,b) => (b.liqUsdApprox || 0) - (a.liqUsdApprox || 0));

    // scoring
    let score = 0;
    const notes = [];
    notes.push("âœ… Contract bytecode found");

    if (!name || name==="â€”") { score += 1; notes.push("âš ï¸ Token name unreadable (non-standard)"); }
    if (!symbol || symbol==="â€”") { score += 1; notes.push("âš ï¸ Symbol unreadable (non-standard)"); }

    if (proxy?.isProxy && proxy.impl) {
      notes.push(`â„¹ï¸ Proxy detected (EIP-1967). Impl: ${proxy.impl}`);
      if (proxy.admin) notes.push(`â„¹ï¸ Proxy admin slot: ${proxy.admin}`);
      score += 1;
    }

    if (!owner) {
      score += 1;
      notes.push("âš ï¸ Owner not detectable (may be fine, but less transparent)");
    } else if (ownerRenounced) {
      notes.push("âœ… Ownership appears renounced (owner=0x0)");
    } else {
      score += 1;
      notes.push(`âš ï¸ Owner detected: ${owner} (not renounced)`);
    }

    if (!pairsFound.length) {
      score += requireLiquidity ? 4 : 1;
      notes.push(requireLiquidity ? "âŒ No DEX pair found" : "â„¹ï¸ No DEX pair found (may be â€œNot listed yetâ€)");
    } else {
      const best = pairsFound[0];
      notes.push(`âœ… Best liquidity pair: ${best.dexName} â€¢ ${best.baseName} â€¢ ${best.pair}`);

      if (best.liqUsdApprox != null) {
        notes.push(`â„¹ï¸ Liquidity (approx): ${fmtUsd(best.liqUsdApprox)} (2Ã—base side)`);
        if (best.baseKey === "WBNB" && Number.isFinite(bnbUsd.px)) {
          notes.push(`â„¹ï¸ BNB/USD: ${bnbUsd.px.toFixed(2)} (${bnbUsd.source})`);
        }
        if (best.liqUsdApprox < 10_000) { score += 2; notes.push("âš ï¸ Very low liquidity (< $10k approx)"); }
        else if (best.liqUsdApprox < 25_000) { score += 2; notes.push("âš ï¸ Low liquidity (< $25k approx)"); }
      }

      if (best.burnPct != null) {
        if (best.burnPct >= 50) notes.push(`âœ… LP burn seems high: ${best.burnPct.toFixed(2)}%`);
        else { score += 1; notes.push(`âš ï¸ LP burn seems low/unknown: ${best.burnPct.toFixed(2)}%`); }
      }
    }

    let badge="info", headline="â„¹ï¸ Informational";
    if (score <= 1) { badge="ok"; headline="âœ… Looks OK (basic checks)"; }
    else if (score <= 4) { badge="warn"; headline="âš ï¸ Caution (some risk signals)"; }
    else { badge="bad"; headline="âŒ High risk signals"; }

    const report = {
      net, token, name, symbol, decimals,
      totalSupply: supply ? supply.toString() : null,
      owner: owner || null,
      ownerRenounced: ownerRenounced === null ? null : ownerRenounced,
      proxy,
      requireLiquidity,
      bnbUsd: Number.isFinite(bnbUsd.px) ? { price: bnbUsd.px, source: bnbUsd.source } : null,
      pairs: pairsFound.slice(0, 30).map(p => ({
        dex: p.dexName,
        router: p.router,
        factory: p.factory,
        base: p.baseName,
        baseAddr: p.baseAddr,
        pair: p.pair,
        liquidityUsdApprox: (p.liqUsdApprox != null) ? Number(p.liqUsdApprox) : null,
        lpBurnPct: (p.burnPct != null) ? Number(p.burnPct) : null
      })),
      score,
      headline,
      notes,
      generatedAt: new Date().toISOString()
    };

    return { ok:true, badge, headline, score, notes, data: report };
  }

  function renderPairsCards(containerId, pairs, token){
    const wrap = document.getElementById(containerId);
    if (!wrap) return;
    wrap.innerHTML = "";

    if (!pairs || !pairs.length) return;

    const top = pairs.slice(0, 6).map(p => {
      const dex = DEXES_BSC.find(d => d.name === p.dex || d.key === p.dexKey);
      const url = dex ? dex.swap(p.baseAddr, token) : "#";
      const liq = (p.liquidityUsdApprox != null) ? fmtUsd(p.liquidityUsdApprox) : "â€”";
      const burn = (p.lpBurnPct != null) ? `${p.lpBurnPct.toFixed(2)}%` : "â€”";

      return `
        <div class="card" style="padding:12px; margin-top:10px;">
          <div class="row" style="justify-content:space-between; gap:8px;">
            <div class="pill"><b>${p.dex}</b> â€¢ ${p.base}</div>
            <a class="btn btn-ghost" href="${url}" target="_blank" rel="noopener" style="padding:10px 14px; font-size:12px;">Open Swap</a>
          </div>
          <div class="small" style="margin-top:8px">
            <b>Pair:</b> <span class="mono">${p.pair}</span><br>
            <b>Liquidity (approx):</b> ${liq}<br>
            <b>LP Burn:</b> ${burn}
          </div>
        </div>
      `;
    }).join("");

    wrap.innerHTML = top;
  }

  // ===============================
  // Panels / cubes navigation
  // ===============================
  const TOOL_KEYS = ["quick","approvals","rpc","monitor"];

  function hideAllPanels(){
    document.querySelectorAll(".panel-shell").forEach(p => p.classList.add("hidden"));
    document.querySelectorAll(".tool-card").forEach(c => c.classList.remove("active"));
  }

  function showTool(toolKey, {scroll=true} = {}){
    if (!TOOL_KEYS.includes(toolKey)) return;

    document.querySelectorAll(".tool-card").forEach(c => {
      c.classList.toggle("active", c.getAttribute("data-tool") === toolKey);
    });

    document.querySelectorAll(".panel-shell").forEach(p => p.classList.add("hidden"));
    const panel = document.getElementById(`panel-${toolKey}`);
    if (panel) panel.classList.remove("hidden");

    if (scroll && panel) panel.scrollIntoView({ behavior:"smooth", block:"start" });
  }

  // ===============================
  // Quick Scan History
  // ===============================
  const QS_HISTORY_KEY = "cx_qs_history_v1";

  function qsLoadHistory(){
    try { return JSON.parse(localStorage.getItem(QS_HISTORY_KEY) || "[]"); }
    catch { return []; }
  }
  function qsSaveHistory(item){
    const arr = qsLoadHistory();
    const filtered = arr.filter(x => !(x.token === item.token && x.net === item.net));
    filtered.unshift(item);
    localStorage.setItem(QS_HISTORY_KEY, JSON.stringify(filtered.slice(0, 10)));
  }
  function qsRenderHistory(){
    const box = document.getElementById("qs-history");
    if (!box) return;
    const arr = qsLoadHistory();
    box.innerHTML = "";

    if (!arr.length) {
      box.innerHTML = `<div class="small muted">â€”</div>`;
      return;
    }

    for (const it of arr) {
      const el = document.createElement("div");
      el.className = "chip";
      el.innerHTML = `<span class="mono">${it.net.toUpperCase()}</span> ${fmtAddr(it.token)} <span class="x">â€¢</span> <span>${it.score}</span>`;
      el.addEventListener("click", () => {
        const netSel = document.getElementById("qs-net");
        const tokInp = document.getElementById("qs-token");
        if (netSel) netSel.value = it.net;
        if (tokInp) tokInp.value = it.token;
        qsRun();
      });
      box.appendChild(el);
    }
  }

  // ===============================
  // Quick Scan
  // ===============================
  async function qsRun(){
    const netSel = document.getElementById("qs-net");
    const tokInp = document.getElementById("qs-token");
    const out = document.getElementById("qs-out");
    const status = document.getElementById("qs-status");
    const requireLiqEl = document.getElementById("qs-require-liq");

    if (!netSel || !tokInp || !out || !status || !requireLiqEl) return;

    const net = netSel.value === "eth" ? "eth" : "bsc";
    const raw = (tokInp.value || "").trim();

    if (!raw) { setStatus(status,"warn","<strong>âš ï¸ Missing token address.</strong>"); return; }
    if (!isHexAddr(raw)) { setStatus(status,"bad","<strong>âŒ Invalid address.</strong> Expected 0x + 40 hex chars."); return; }

    const token = toChecksum(raw);
    const requireLiquidity = !!requireLiqEl.checked;

    setStatus(status,"info",`<strong>â³ Scanningâ€¦</strong><br>Network: <span class="mono">${net.toUpperCase()}</span>`);
    setStatus(out,"info","<strong>â³ Workingâ€¦</strong>");
    renderPairsCards("qs-pairsWrap", [], token);
    CX.reports.quick = null;

    try {
      const res = await scanTokenCore({ net, token, requireLiquidity });
      if (!res.ok) {
        setStatus(out, res.badge, `<strong>${res.headline}</strong><br>${res.notes.join("<br>")}`);
        setStatus(status, res.badge, `<strong>Done.</strong> Score: ${res.score}`);
        return;
      }

      CX.reports.quick = res.data;

      const supplyHuman = res.data.totalSupply ? fmtBigintUnits(BigInt(res.data.totalSupply), res.data.decimals) : "â€”";
      const html = `
        <strong>${res.headline}</strong><br><br>
        <div class="pill">Token: <span class="mono">${res.data.token}</span></div>
        <div style="margin-top:10px" class="small">
          <b>Name:</b> ${String(res.data.name).replace(/</g,"&lt;")}<br>
          <b>Symbol:</b> ${String(res.data.symbol).replace(/</g,"&lt;")}<br>
          <b>Decimals:</b> ${res.data.decimals}<br>
          <b>Total supply:</b> ${supplyHuman}
        </div>
        <div style="margin-top:12px" class="small">
          <b>Signals:</b><br>
          ${res.notes.map(n => "â€¢ " + n).join("<br>")}
        </div>
      `;
      setStatus(out, res.badge, html);
      setStatus(status, res.badge, `<strong>Done.</strong> Score: ${res.score} (lower is better).`);

      if (net === "bsc" && res.data.pairs?.length) {
        renderPairsCards("qs-pairsWrap", res.data.pairs, res.data.token);
      }

      qsSaveHistory({ net, token: res.data.token, score: res.score, t: Date.now() });
      qsRenderHistory();

    } catch (e) {
      console.error(e);
      setStatus(out, "bad", `<strong>âŒ Scan failed.</strong><br>${(e?.message || e).toString()}`);
      setStatus(status, "bad", "<strong>âŒ Scan failed.</strong> Try again or test RPCs.");
    }
  }

  function qsBuildShareLink(){
    const net = (document.getElementById("qs-net")?.value === "eth") ? "eth" : "bsc";
    const raw = (document.getElementById("qs-token")?.value || "").trim();
    if (!isHexAddr(raw)) return null;

    const token = toChecksum(raw);
    const requireLiquidity = !!document.getElementById("qs-require-liq")?.checked;

    const u = new URL(window.location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", net);
    u.searchParams.set("token", token);
    if (requireLiquidity) u.searchParams.set("requireLiq","1"); else u.searchParams.delete("requireLiq");
    return u.toString();
  }

  async function qsCopyLink(){
    const status = document.getElementById("qs-status");
    const link = qsBuildShareLink();
    if (!link) { setStatus(status,"warn","<strong>âš ï¸ Paste a valid token first.</strong>"); return; }
    await copyText(link);
    setStatus(status,"ok",`<strong>âœ… Link copied.</strong><br><span class="mono">${link}</span>`);
  }

  async function qsCopyJson(){
    const status = document.getElementById("qs-status");
    const enabled = !!document.getElementById("qs-show-json")?.checked;
    if (!enabled) { setStatus(status,"warn","<strong>âš ï¸ JSON report disabled.</strong> Enable it in Options."); return; }
    if (!CX.reports.quick) { setStatus(status,"warn","<strong>âš ï¸ No report yet.</strong> Run Scan first."); return; }
    await copyText(JSON.stringify(CX.reports.quick, null, 2));
    setStatus(status,"ok","<strong>âœ… JSON copied.</strong>");
  }

  function qsShareX(){
    const link = qsBuildShareLink() || window.location.href;
    const txt = `Quick Scan (CycleX Security Hub)\n${link}`;
    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(txt)}`, "_blank", "noopener");
  }
  function qsShareTG(){
    const link = qsBuildShareLink() || window.location.href;
    window.open(`https://t.me/share/url?url=${encodeURIComponent(link)}&text=${encodeURIComponent("Quick Scan (CycleX Security Hub)")}`, "_blank", "noopener");
  }

  // ===============================
  // Wallet connect helpers
  // ===============================
  async function waitForAppKitModal(timeoutMs=12000){
    const t0 = Date.now();
    while (Date.now() - t0 < timeoutMs) {
      if (window.cxAppKitModal?.open && window.cxAppKitModal?.getWalletProvider) return window.cxAppKitModal;
      await sleep(150);
    }
    return null;
  }

  async function ensureChain(net){
    const p = CX.wallet.provider;
    if (!p?.request) return true;

    const chainIdHex = (net === "bsc") ? "0x38" : "0x1";
    try {
      await p.request({ method: "wallet_switchEthereumChain", params: [{ chainId: chainIdHex }] });
      return true;
    } catch (e) {
      // Optional add chain (BSC) if missing
      if (net === "bsc") {
        try {
          await p.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: "0x38",
              chainName: "BNB Smart Chain",
              nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
              rpcUrls: ["https://bsc-dataseed.binance.org"],
              blockExplorerUrls: ["https://bscscan.com"]
            }]
          });
          return true;
        } catch {}
      }
      return false;
    }
  }

  async function ensureConnected(preferredNet="bsc"){
    const status = document.getElementById("ap-status");

    if (String(WALLETCONNECT_PROJECT_ID || "").includes("PASTE_YOUR_WC_PROJECT_ID_HERE")) {
      setStatus(status, "warn", "<strong>âš ï¸ WalletConnect Project ID ×—×¡×¨.</strong><br>×ª×“×‘×™×§ ××ª ×”-Project ID ×©×œ×š ×‘-JS (WALLETCONNECT_PROJECT_ID).");
      return false;
    }

    const modal = await waitForAppKitModal();
    if (!modal) {
      setStatus(status, "warn", "<strong>âš ï¸ Wallet modal not ready yet.</strong><br>Refresh page if this persists.");
      return false;
    }

    setStatus(status, "info", "<strong>â³ Connecting walletâ€¦</strong>");
    await modal.open({ view: "ConnectWallet" });

    const start = Date.now();
    while (Date.now() - start < 90000) {
      const p = modal.getWalletProvider?.();
      if (p) {
        CX.wallet.provider = p;

        const okChain = await ensureChain(preferredNet);
        if (!okChain) {
          setStatus(status, "warn", "<strong>âš ï¸ Please switch network in your wallet.</strong>");
          // continue anyway
        }

        const bp = new ethers.BrowserProvider(p);
        CX.wallet.signer = await bp.getSigner();
        CX.wallet.address = await CX.wallet.signer.getAddress();

        // update UI labels
        const addrEl = document.getElementById("ap-address");
        const pillEl = document.getElementById("ap-wallet");
        const wl = document.getElementById("walletLabel");
        if (addrEl) addrEl.textContent = CX.wallet.address;
        if (pillEl) pillEl.textContent = CX.wallet.address;
        if (wl) wl.textContent = CX.wallet.address;

        setStatus(status, "ok", "<strong>âœ… Wallet connected.</strong>");
        return true;
      }
      await sleep(250);
    }

    setStatus(status, "warn", "<strong>âš ï¸ Connection timeout.</strong><br>Please try again.");
    return false;
  }

  // ===============================
  // Approvals Guardian
  // ===============================
  const ALLOW_ABI = [
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 value) returns (bool)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)"
  ];
  const MAX_UINT = (1n << 256n) - 1n;

  const UNI_V2_ROUTER_ETH = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D";
  const PCS_V2_ROUTER_BSC = "0x10ED43C718714eb63d5aA57B78B54704E256024E";

  function apSetStatus(kind, html){ setStatus(document.getElementById("ap-status"), kind, html); }

  function apGetNet(){
    return (document.getElementById("ap-net")?.value === "eth") ? "eth" : "bsc";
  }

  function apGetSpender(){
    const preset = document.getElementById("ap-spender-preset")?.value;
    const input = (document.getElementById("ap-spender")?.value || "").trim();

    if (preset === "pcs_router") return PCS_V2_ROUTER_BSC;
    if (preset === "uni_router") return UNI_V2_ROUTER_ETH;
    if (preset === "custom") return input;
    return input;
  }

  function apParseTokens(){
    const raw = document.getElementById("ap-tokens")?.value || "";
    return raw.split(/\r?\n/).map(x=>x.trim()).filter(Boolean).filter(isHexAddr).map(toChecksum);
  }

  function apRenderRows(rows){
    const table = document.getElementById("ap-table");
    if (!table) return;

    const head = table.querySelector(".trow.head");
    table.innerHTML = "";
    if (head) table.appendChild(head);

    if (!rows.length) {
      const row = document.createElement("div");
      row.className = "trow";
      row.innerHTML = `<div class="cell muted">â€”</div><div class="cell muted">â€”</div><div class="cell muted hide-sm">â€”</div><div class="cell muted">â€”</div>`;
      table.appendChild(row);
      return;
    }

    for (const r of rows) {
      const row = document.createElement("div");
      row.className = "trow";
      const allowanceStr = r.allowanceInf ? "âˆ (infinite)" : r.allowanceHuman;

      row.innerHTML = `
        <div class="cell mono" title="${r.token}">${r.token}</div>
        <div class="cell">${allowanceStr}</div>
        <div class="cell hide-sm">${r.symbol || "â€”"}</div>
        <div class="cell">
          <button class="btn btn-ghost" data-token="${r.token}" ${(!r.canRevoke ? "disabled" : "")} style="padding:10px 14px; font-size:12px;">
            Revoke
          </button>
        </div>
      `;
      table.appendChild(row);
    }

    table.querySelectorAll("button[data-token]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        const token = btn.getAttribute("data-token");
        await apRevokeOne(token);
      });
    });
  }

  async function apCheck(){
    const net = apGetNet();
    const ok = CX.wallet.address ? true : await ensureConnected(net);
    if (!ok) return;

    await ensureChain(net);

    const spenderRaw = apGetSpender();
    if (!isHexAddr(spenderRaw)) { apSetStatus("bad","<strong>âŒ Invalid spender address.</strong>"); return; }
    const spender = toChecksum(spenderRaw);

    const tokens = apParseTokens();
    if (!tokens.length) { apSetStatus("warn","<strong>âš ï¸ No valid token addresses.</strong><br>One per line."); return; }

    apSetStatus("info", `<strong>â³ Checking allowancesâ€¦</strong><br>Owner: <span class="mono">${fmtAddr(CX.wallet.address)}</span> â€¢ Spender: <span class="mono">${fmtAddr(spender)}</span>`);

    const rows = [];
    for (const t of tokens) {
      try {
        const c = new ethers.Contract(t, ALLOW_ABI, CX.wallet.signer);
        let sym="â€”", dec=18;
        try { sym = await c.symbol(); } catch {}
        try { dec = Number(await c.decimals()); } catch {}
        const a = BigInt(await c.allowance(CX.wallet.address, spender));
        const isInf = (a > (MAX_UINT / 2n));
        const human = isInf ? "âˆ" : (a === 0n ? "0" : fmtBigintUnits(a, dec));
        rows.push({ token:t, symbol:sym, allowance:a, allowanceInf:isInf, allowanceHuman:human, canRevoke:(a>0n) });
      } catch {
        rows.push({ token:t, symbol:"â€”", allowance:0n, allowanceInf:false, allowanceHuman:"error", canRevoke:false });
      }
    }

    apRenderRows(rows);
    const nonZero = rows.filter(r=>r.allowance>0n).length;
    apSetStatus(nonZero ? "warn" : "ok", `<strong>Done.</strong><br>Checked ${rows.length}. Non-zero: ${nonZero}.`);
  }

  async function apRevokeOne(tokenAddr){
    const net = apGetNet();
    if (!CX.wallet.address || !CX.wallet.signer) { apSetStatus("warn","<strong>âš ï¸ Connect wallet first.</strong>"); return; }
    await ensureChain(net);

    const spenderRaw = apGetSpender();
    if (!isHexAddr(spenderRaw)) { apSetStatus("bad","<strong>âŒ Invalid spender address.</strong>"); return; }
    const spender = toChecksum(spenderRaw);
    const token = toChecksum(tokenAddr);

    apSetStatus("info", `<strong>â³ Revokingâ€¦</strong><br>Token: <span class="mono">${fmtAddr(token)}</span> â€¢ Spender: <span class="mono">${fmtAddr(spender)}</span>`);
    try {
      const c = new ethers.Contract(token, ALLOW_ABI, CX.wallet.signer);
      const tx = await c.approve(spender, 0);
      apSetStatus("info", `<strong>â³ Pendingâ€¦</strong><br><span class="mono">${tx.hash}</span>`);
      await tx.wait();
      apSetStatus("ok", "<strong>âœ… Revoke successful.</strong>");
      await apCheck();
    } catch (e) {
      console.error(e);
      apSetStatus("bad", `<strong>âŒ Revoke failed.</strong><br>${(e?.message || e).toString()}`);
    }
  }

  async function apRevokeAllNonZero(){
    const net = apGetNet();
    const ok = CX.wallet.address ? true : await ensureConnected(net);
    if (!ok) return;

    await apCheck();

    const toRevoke = [];
    document.querySelectorAll("#ap-table button[data-token]").forEach(btn => {
      if (!btn.disabled) toRevoke.push(btn.getAttribute("data-token"));
    });

    if (!toRevoke.length) { apSetStatus("ok","<strong>âœ… Nothing to revoke.</strong>"); return; }

    apSetStatus("warn", `<strong>â³ Revoking ${toRevoke.length} token(s)â€¦</strong><br>This will send multiple transactions.`);
    for (const t of toRevoke) { await apRevokeOne(t); await sleep(500); }
    apSetStatus("ok","<strong>âœ… Revoke batch finished.</strong>");
  }

  // Seed common tokens + history
  const COMMON_BSC = [
    WBNB,
    USDT,
    USDC,
    BUSD,
    "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" // CAKE
  ];
  const COMMON_ETH = [
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
    "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0x6B175474E89094C44Da98b954EedeAC495271d0F"  // DAI
  ];

  function apSeedCommon(){
    const net = apGetNet();
    const list = (net === "eth") ? COMMON_ETH : COMMON_BSC;
    const ta = document.getElementById("ap-tokens");
    if (!ta) return;
    ta.value = list.join("\n");
    apSetStatus("ok", "<strong>âœ… Seeded common tokens.</strong>");
  }

  function apSeedHistory(){
    const net = apGetNet();
    const arr = qsLoadHistory().filter(x => x.net === net).map(x => x.token);
    const unique = Array.from(new Set(arr)).slice(0, 15);
    const ta = document.getElementById("ap-tokens");
    if (!ta) return;

    if (!unique.length) {
      apSetStatus("warn", "<strong>âš ï¸ No scan history for this network yet.</strong>");
      return;
    }
    ta.value = unique.join("\n");
    apSetStatus("ok", "<strong>âœ… Seeded from scan history.</strong>");
  }

  function apApplyPreset(){
    const preset = document.getElementById("ap-spender-preset")?.value;
    const input  = document.getElementById("ap-spender");
    const netSel = document.getElementById("ap-net");
    if (!input) return;

    if (preset === "pcs_router") {
      input.value = PCS_V2_ROUTER_BSC;
      input.disabled = true;
      if (netSel) netSel.value = "bsc";
    } else if (preset === "uni_router") {
      input.value = UNI_V2_ROUTER_ETH;
      input.disabled = true;
      if (netSel) netSel.value = "eth";
    } else {
      input.disabled = false;
      if (!input.value || input.value === PCS_V2_ROUTER_BSC || input.value === UNI_V2_ROUTER_ETH) input.value = "";
    }
  }

  // ===============================
  // RPC Checker
  // ===============================
  function rpcRow(url, latency, block, ok){
    const table = document.getElementById("rpc-table");
    if (!table) return;

    const row = document.createElement("div");
    row.className = "trow";

    const tag = ok ? "âœ… OK" : "âŒ Fail";
    const lat = ok ? (latency.toFixed(0) + " ms") : "â€”";
    const blockStr = ok ? String(block) : "â€”";

    row.innerHTML = `
      <div class="cell mono" title="${url}">${url}</div>
      <div class="cell">${lat}</div>
      <div class="cell hide-sm">${blockStr}</div>
      <div class="cell">${tag}</div>
    `;

    if (ok && url === CX.rpc.best) {
      row.style.background = "rgba(0,230,118,0.10)";
      row.style.borderTopColor = "rgba(0,230,118,0.20)";
    }

    table.appendChild(row);
  }

  async function rpcTestAll(){
    const status = document.getElementById("rpc-status");
    const netSel = document.getElementById("rpc-net");
    const custom = (document.getElementById("rpc-custom")?.value || "").trim();

    const net = (netSel?.value === "eth") ? "eth" : "bsc";
    const expectChainId = (net === "bsc") ? 56 : 1;

    const list = [...(RPCS[net] || [])];
    if (custom) list.unshift(custom);

    const table = document.getElementById("rpc-table");
    if (!table) return;

    table.innerHTML = `
      <div class="trow head">
        <div class="cell">RPC</div>
        <div class="cell">Latency</div>
        <div class="cell hide-sm">Block</div>
        <div class="cell">Status</div>
      </div>
    `;

    setStatus(status, "info", `<strong>â³ Testing ${list.length} RPC(s)â€¦</strong> <span class="mono">${net.toUpperCase()}</span>`);
    CX.rpc.best = "";
    CX.rpc.last = [];
    let bestMs = Infinity;

    for (const url of list) {
      let ok = false, ms = 0, block = 0;

      try {
        const p = new ethers.JsonRpcProvider(url);
        const t0 = performance.now();
        block = await p.getBlockNumber();
        const n = await p.getNetwork();
        const t1 = performance.now();
        ms = (t1 - t0);
        if (Number(n.chainId) !== expectChainId) throw new Error("Wrong chainId");
        ok = true;

        if (ms < bestMs) { bestMs = ms; CX.rpc.best = url; }
      } catch { ok = false; }

      CX.rpc.last.push({ url, ok, latencyMs: ok ? ms : null, block: ok ? block : null, net });
      rpcRow(url, ms, block, ok);
      await sleep(120);
    }

    if (CX.rpc.best) setStatus(status, "ok", `<strong>âœ… Best RPC:</strong> <span class="mono">${CX.rpc.best}</span>`);
    else setStatus(status, "bad", "<strong>âŒ All RPC tests failed.</strong><br>Try a different custom RPC.");
  }

  async function rpcCopyBest(){
    const status = document.getElementById("rpc-status");
    if (!CX.rpc.best) { setStatus(status, "warn", "<strong>âš ï¸ No best RPC yet.</strong><br>Run Test RPCs first."); return; }
    await copyText(CX.rpc.best);
    setStatus(status, "ok", `<strong>âœ… Copied:</strong> <span class="mono">${CX.rpc.best}</span>`);
  }

  async function rpcCopyJson(){
    const status = document.getElementById("rpc-status");
    if (!CX.rpc.last?.length) { setStatus(status, "warn", "<strong>âš ï¸ No results yet.</strong> Run Test RPCs first."); return; }
    await copyText(JSON.stringify(CX.rpc.last, null, 2));
    setStatus(status, "ok", "<strong>âœ… JSON copied.</strong>");
  }

  // ===============================
  // Monitor
  // ===============================
  const MON_KEY = "cx_monitor_watchlist_v1";

  function monLoad(){
    try { CX.monitor.list = JSON.parse(localStorage.getItem(MON_KEY) || "[]"); }
    catch { CX.monitor.list = []; }
  }

  function monSave(){
    localStorage.setItem(MON_KEY, JSON.stringify(CX.monitor.list));
  }

  function monRender(){
    const table = document.getElementById("mon-table");
    if (!table) return;

    const head = table.querySelector(".trow.head");
    table.innerHTML = "";
    if (head) table.appendChild(head);

    if (!CX.monitor.list.length) {
      const row = document.createElement("div");
      row.className = "trow";
      row.innerHTML = `<div class="cell muted">â€”</div><div class="cell muted">â€”</div><div class="cell muted hide-sm">â€”</div><div class="cell muted">â€”</div>`;
      table.appendChild(row);
      return;
    }

    for (const it of CX.monitor.list) {
      const row = document.createElement("div");
      row.className = "trow" + (it.changed ? " highlight" : "");
      const last = it.lastSeen ? new Date(it.lastSeen).toLocaleString() : "â€”";
      const st = it.changed ? "âš ï¸ Changed" : "âœ… OK";
      row.innerHTML = `
        <div class="cell mono" title="${it.addr}">${fmtAddr(it.addr)} <span class="mini">(${it.addr.slice(0,10)}â€¦)</span></div>
        <div class="cell">${it.net.toUpperCase()}</div>
        <div class="cell hide-sm">${last}</div>
        <div class="cell">${st}</div>
      `;
      table.appendChild(row);
    }
  }

  async function monAdd(){
    const status = document.getElementById("mon-status");
    const netSel = document.getElementById("mon-net");
    const addrInp = document.getElementById("mon-addr");

    if (!netSel || !addrInp) return;

    const net = (netSel.value === "eth") ? "eth" : "bsc";
    const raw = (addrInp.value || "").trim();
    if (!isHexAddr(raw)) { setStatus(status,"bad","<strong>âŒ Invalid contract address.</strong>"); return; }

    const addr = toChecksum(raw);
    setStatus(status,"info","<strong>â³ Addingâ€¦</strong>");

    try {
      const provider = await pickProvider(net);
      const code = await provider.getCode(addr);
      if (!code || code === "0x") { setStatus(status,"bad","<strong>âŒ No bytecode.</strong> Not a contract."); return; }

      const codeHash = ethers.keccak256(code);
      const proxy = await detectProxy(provider, addr);
      const impl = proxy?.isProxy ? proxy.impl : null;

      const item = {
        addr, net,
        baseHash: codeHash,
        baseImpl: impl,
        lastSeen: Date.now(),
        changed: false
      };

      CX.monitor.list = CX.monitor.list.filter(x => !(x.addr === addr && x.net === net));
      CX.monitor.list.unshift(item);
      monSave();
      monRender();

      setStatus(status,"ok",`<strong>âœ… Added.</strong><br>Hash: <span class="mono">${codeHash.slice(0,14)}â€¦</span>${impl ? `<br>Proxy impl: <span class="mono">${impl}</span>` : ""}`);
    } catch (e) {
      console.error(e);
      setStatus(status,"bad",`<strong>âŒ Add failed.</strong><br>${(e?.message || e).toString()}`);
    }
  }

  async function monCheckAll(){
    const status = document.getElementById("mon-status");
    if (!CX.monitor.list.length) { setStatus(status,"warn","<strong>âš ï¸ Watchlist empty.</strong>"); return; }

    setStatus(status,"info",`<strong>â³ Checking ${CX.monitor.list.length} item(s)â€¦</strong>`);
    let changedCount = 0;

    for (const it of CX.monitor.list) {
      try {
        const provider = await pickProvider(it.net);
        const code = await provider.getCode(it.addr);
        if (!code || code === "0x") {
          it.changed = true;
          changedCount++;
          it.lastSeen = Date.now();
          continue;
        }
        const hash = ethers.keccak256(code);
        const proxy = await detectProxy(provider, it.addr);
        const impl = proxy?.isProxy ? proxy.impl : null;

        const hashChanged = (hash !== it.baseHash);
        const implChanged = ((impl || null) !== (it.baseImpl || null));

        it.changed = hashChanged || implChanged;
        if (it.changed) changedCount++;
        it.lastSeen = Date.now();
      } catch {
        it.changed = true;
        changedCount++;
        it.lastSeen = Date.now();
      }
    }

    monSave();
    monRender();

    if (changedCount) setStatus(status,"warn",`<strong>âš ï¸ Changes detected:</strong> ${changedCount}/${CX.monitor.list.length}`);
    else setStatus(status,"ok",`<strong>âœ… No changes detected.</strong> Checked ${CX.monitor.list.length}.`);
  }

  function monExport(){
    const status = document.getElementById("mon-status");
    const data = JSON.stringify(CX.monitor.list, null, 2);

    try {
      const blob = new Blob([data], { type:"application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "cyclex_monitor_watchlist.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus(status,"ok","<strong>âœ… Exported JSON.</strong> (Downloaded)");
    } catch {
      copyText(data);
      setStatus(status,"ok","<strong>âœ… Exported JSON.</strong> (Copied)");
    }
  }

  // ===============================
  // Wiring
  // ===============================
  (function initWiring(){
    // cubes -> panels
    document.querySelectorAll(".tool-card").forEach(card => {
      card.addEventListener("click", () => showTool(card.getAttribute("data-tool")));
    });

    // close buttons
    document.getElementById("btnCloseQuick")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });
    document.getElementById("btnCloseApprovals")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });
    document.getElementById("btnCloseRpc")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });
    document.getElementById("btnCloseMonitor")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });

    // hero buttons
    document.getElementById("btn-quick")?.addEventListener("click", async () => { showTool("quick"); });
    document.getElementById("btn-connect")?.addEventListener("click", async () => {
      showTool("approvals");
      await ensureConnected(apGetNet());
    });

    // quick scan buttons
    document.getElementById("qs-run")?.addEventListener("click", qsRun);
    document.getElementById("qs-copy-link")?.addEventListener("click", qsCopyLink);
    document.getElementById("qs-copy-json")?.addEventListener("click", qsCopyJson);
    document.getElementById("qs-share-x")?.addEventListener("click", qsShareX);
    document.getElementById("qs-share-tg")?.addEventListener("click", qsShareTG);

    // approvals
    document.getElementById("ap-connect")?.addEventListener("click", () => ensureConnected(apGetNet()));
    document.getElementById("ap-check")?.addEventListener("click", apCheck);
    document.getElementById("ap-revoke-all")?.addEventListener("click", apRevokeAllNonZero);
    document.getElementById("ap-seed-common")?.addEventListener("click", apSeedCommon);
    document.getElementById("ap-seed-history")?.addEventListener("click", apSeedHistory);
    document.getElementById("ap-spender-preset")?.addEventListener("change", apApplyPreset);

    // rpc
    document.getElementById("rpc-test")?.addEventListener("click", rpcTestAll);
    document.getElementById("rpc-copy-best")?.addEventListener("click", rpcCopyBest);
    document.getElementById("rpc-copy-json")?.addEventListener("click", rpcCopyJson);

    // monitor
    document.getElementById("mon-add")?.addEventListener("click", monAdd);
    document.getElementById("mon-check")?.addEventListener("click", monCheckAll);
    document.getElementById("mon-export")?.addEventListener("click", monExport);

    // init defaults
    qsRenderHistory();
    monLoad();
    monRender();
    apApplyPreset();

    // URL auto-run support
    const p = new URLSearchParams(window.location.search);
    const tool = p.get("tool");
    if (tool && TOOL_KEYS.includes(tool)) showTool(tool, {scroll:false});

    const token = p.get("token");
    const net = p.get("net");
    if (token && isHexAddr(token)) {
      showTool("quick", {scroll:false});
      const netSel = document.getElementById("qs-net");
      const tokInp = document.getElementById("qs-token");
      const req = document.getElementById("qs-require-liq");
      if (netSel) netSel.value = (net === "eth") ? "eth" : "bsc";
      if (tokInp) tokInp.value = toChecksum(token);
      if (req) req.checked = (p.get("requireLiq") === "1");
      qsRun();
    }
  })();

})();
</script>

</body>
</html>
