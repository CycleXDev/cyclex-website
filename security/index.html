<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#05060a">
  <meta name="application-name" content="CycleX">
  <meta name="apple-mobile-web-app-title" content="CycleX">

  <meta charset="UTF-8" />
  <title>CycleX â€“ Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
  :root{
    --bg-main:#05060a;
    --bg-gradient-start:#05060a;
    --bg-gradient-mid:#1a0d3a;
    --bg-gradient-end:#003a4c;

    --text-main:#f4f6ff;
    --text-muted:rgba(244,246,255,.7);

    --accent-cyan:#00e5ff;
    --accent-green:#5dffb2;
    --accent-purple:#7c5cff;

    --card-bg:rgba(255,255,255,.06);
    --border-subtle:rgba(255,255,255,.12);

    --shadow-soft:0 24px 70px rgba(0,0,0,.65);
    --radius-xl:24px;
    --radius-lg:18px;
    --transition-fast:.18s ease-out;

    --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    --sans:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;

    --container: 1160px;
    --container-wide: 1160px;

    /* âœ… single source of truth for grid/panel spacing */
    --tool-panel-gap: 18px;
    --tool-grid-gap: 18px;

    /* sticky bar offset for scrollIntoView (even if we later disable scroll) */
    --scroll-offset: 96px;
  }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{min-height:100%}
  html{
    font-size:16px;
    -webkit-text-size-adjust:100%;
    text-size-adjust:100%;
    background:
    radial-gradient(circle at top left, rgba(124,92,255,.35) 0%, transparent 45%),
    radial-gradient(circle at top right, rgba(0,229,255,.35) 0%, transparent 45%),
    radial-gradient(circle at bottom, rgba(0,58,76,.55) 0%, transparent 55%),
    linear-gradient(160deg,var(--bg-gradient-start),var(--bg-gradient-mid),var(--bg-gradient-end));
    background-repeat:no-repeat;
    background-attachment: fixed; /* âœ… makes it feel smooth while scrolling */
  }

  body{
    font-family:var(--sans);
    background:transparent;
    color:var(--text-main);
    min-height:100vh;
    -webkit-font-smoothing:antialiased;
    animation:fadeBody .7s ease-out forwards;
    opacity:1;
    overflow-x:hidden;
  }
  @keyframes fadeBody{from{opacity:0}to{opacity:1}}
  a{color:inherit;text-decoration:none}

  .page-shell{
    width:100%;
    max-width:1160px;
    margin:0 auto;
    padding:32px 20px 64px;
    transform:none !important;
  }

  /* helpers */
  .hide-sm{}
  .mono{font-family:var(--mono);font-variant-numeric:tabular-nums;direction:ltr;unicode-bidi:plaintext}
  .muted{color:var(--text-muted);font-size:13px;line-height:1.45}
  .small{font-size:12px;color:var(--text-muted);line-height:1.45}
  .cell{min-width:0}
  .wrap{white-space:normal;overflow-wrap:anywhere}

  /* Top bar */
  .top-bar{
    position:sticky; top:14px; z-index:999;
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding:12px 18px;
    margin:0 auto 32px;
    width:100%;
    max-width:1160px;
    border-radius:999px;
    background:rgba(8,10,22,.55);
    backdrop-filter:blur(18px);
    -webkit-backdrop-filter:blur(18px);
    border:1px solid rgba(255,255,255,.14);
    box-shadow:0 20px 70px rgba(0,0,0,.6), inset 0 1px 0 rgba(255,255,255,.06);
  }
  .brand{display:flex;align-items:center;gap:10px;min-width:0}
  .brand-logo{
    width:44px;height:44px;border-radius:16px;object-fit:contain;
    box-shadow:0 12px 32px rgba(0,0,0,.8);
    flex:0 0 auto;
  }
  .brand-text{display:flex;flex-direction:column;gap:2px;min-width:0}
  .brand-title{
    font-weight:800;letter-spacing:.05em;font-size:18px;text-transform:uppercase;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }
  .brand-sub{
    font-size:11px;text-transform:uppercase;letter-spacing:.16em;color:var(--text-muted);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }

  .lang-switch{
    display:inline-flex;align-items:center;padding:4px;border-radius:999px;gap:2px;
    background:rgba(255,255,255,.06);
    backdrop-filter:blur(10px);
    border:1px solid rgba(255,255,255,.16);
    box-shadow:0 12px 36px rgba(0,0,0,.55);
    flex:0 0 auto;
  }
  .lang-btn{
    border:none;background:transparent;color:var(--text-muted);
    font-size:11px;padding:6px 9px;border-radius:999px;cursor:pointer;
    transition:background var(--transition-fast),color var(--transition-fast),transform var(--transition-fast);
    user-select:none;white-space:nowrap;
  }
  .lang-btn:hover{transform:translateY(-1px)}
  .lang-btn.active{background:rgba(0,229,255,.14);color:var(--accent-cyan)}

  body.lang-switching{animation:langFade .28s ease-out}
  @keyframes langFade{from{opacity:.5;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}

  /* Hero */
  .hero{text-align:center;max-width:980px;margin:0 auto 16px;animation:fadeUp .8s ease-out forwards}
  @keyframes fadeUp{from{opacity:0;transform:translateY(14px)}to{opacity:1;transform:translateY(0)}}
  .hero-kicker{font-size:13px;letter-spacing:.16em;text-transform:uppercase;color:var(--accent-cyan);margin-bottom:12px}
  .hero-title{font-size:clamp(36px,4.7vw,56px);line-height:1.05;font-weight:900;margin-bottom:12px;letter-spacing:-.02em}
  .hero-subtitle{max-width:760px;margin:0 auto 16px;font-size:15px;line-height:1.5;color:var(--text-muted)}
  .hero-actions{display:flex;justify-content:center;flex-wrap:wrap;gap:12px;margin-bottom:10px}

  .btn{
    border-radius:999px;border:none;
    padding:12px 22px;
    font-size:13px;font-weight:700;
    letter-spacing:.04em;text-transform:uppercase;
    cursor:pointer;
    display:inline-flex;align-items:center;justify-content:center;gap:8px;
    transition:transform var(--transition-fast),box-shadow var(--transition-fast),background var(--transition-fast),color var(--transition-fast),border-color var(--transition-fast);
    user-select:none;white-space:nowrap;max-width:100%;min-width:0;
  }
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .btn-primary{
    background:linear-gradient(135deg,var(--accent-cyan),#7df2ff);
    color:#020308;
    box-shadow:0 14px 40px rgba(0,229,255,.35);
  }
  .btn-primary:hover{transform:translateY(-1px);box-shadow:0 18px 60px rgba(0,229,255,.55)}
  .btn-secondary{
    background:linear-gradient(135deg,var(--accent-green),#b9ffcf);
    color:#020308;
    box-shadow:0 14px 40px rgba(0,230,118,.35);
  }
  .btn-secondary:hover{transform:translateY(-1px);box-shadow:0 18px 60px rgba(0,230,118,.6)}
  .btn-ghost{
    background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.16);
    color:var(--text-main);
    box-shadow:0 12px 34px rgba(0,0,0,.45);
  }
  .btn-ghost:hover{transform:translateY(-1px);border-color:rgba(0,229,255,.26)}
  .note-line{margin-top:10px;font-size:12px;color:var(--text-muted);line-height:1.45}

  /* =========================
     Tool grid (single source of truth)
     ========================= */
  .tool-grid-wrap{
    width:100%;
    max-width:1160px;
    margin:0 auto;
  }
  .tool-grid-title{
    text-align:center;
    margin:12px 0 6px;
    font-size:12px;letter-spacing:.16em;text-transform:uppercase;
    color:rgba(244,246,255,.72);
  }

  .tool-grid{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:var(--tool-grid-gap);
    margin-top:12px;
    align-items:stretch;
  }

  .tool-card{
    background:rgba(255,255,255,.05);
    border-radius:var(--radius-xl);
    border:1px solid rgba(255,255,255,.12);
    padding:22px 22px 18px;
    box-shadow:0 20px 55px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.05);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    transition:transform var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
    min-width:0;
    min-height:178px;
  }
    /* ALL tool cards â€” subtle frame like Quick Scan (safe, no layout change) */


  .tool-card::before{
    content:"";
    position:absolute; inset:-2px;
    background:
      radial-gradient(520px 180px at 18% -5%, rgba(0,229,255,.18), transparent 60%),
      radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.18), transparent 60%);
    pointer-events:none;
    opacity:.95;
  }
/* Wallet Security DNA: keep badges aligned with other cards */
a.tool-card[data-tool="approvals"]{
  display:flex;
  flex-direction:column;
}

a.tool-card[data-tool="approvals"] .badge-row{
  margin-top:auto;
  margin-bottom:14px; 
}


  .tool-card > *{position:relative}
  .tool-card:hover{transform:translateY(-2px);border-color:rgba(0,229,255,.28);background:rgba(255,255,255,.06)}
  .tool-card.active{border-color:rgba(0,229,255,.42);background:rgba(0,229,255,.06)}

  .tool-head{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;margin-bottom:10px}
  .tool-name{font-size:17px;font-weight:900;letter-spacing:.01em;line-height:1.22}
  .tool-desc{font-size:14px;color:var(--text-muted);line-height:1.5}

  .badge-row{display:flex;flex-wrap:wrap;gap:8px;margin-top:14px}
  .badge{
    display:inline-flex;align-items:center;gap:8px;
    font-size:12px;padding:7px 11px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:var(--text-muted);
    white-space:nowrap;user-select:none;
  }
  .badge strong{color:rgba(244,246,255,.92);font-weight:800}
  .badge.beta{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08);color:rgba(244,246,255,.92)}

  /* Risk badges */
  .risk-badges{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .risk{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;font-size:12px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.88);
    user-select:none;
  }
  .risk .dot{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.25);box-shadow:0 0 0 3px rgba(255,255,255,.06);flex:0 0 auto}
  .risk.ok{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .risk.ok .dot{background:rgba(0,230,118,.95)}
  .risk.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .risk.warn .dot{background:rgba(255,193,7,.95)}
  .risk.bad{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}
  .risk.bad .dot{background:rgba(220,53,69,.95)}

  /* =========================
     Panels (same width as cubes)
     ========================= */
  .panel-shell{
    width:100%;
    max-width:1160px;
    margin:var(--tool-panel-gap) auto 0;
    padding:18px 18px;
    border-radius:var(--radius-xl);
    background:rgba(255,255,255,.04);
    backdrop-filter:blur(20px);
    border:1px solid rgba(255,255,255,.12);
    box-shadow:0 26px 70px rgba(0,0,0,.60), inset 0 1px 0 rgba(255,255,255,.05);
    scroll-margin-top: var(--scroll-offset);
  }
  .panel-shell.hidden{display:none}

  .panel-head{
    display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
    margin-bottom:12px;
  }
  .panel-kicker{
    font-size:12px;letter-spacing:.16em;text-transform:uppercase;
    color:var(--accent-purple);margin-bottom:8px;
  }
  .panel-title{
    font-size:clamp(22px,2.2vw,28px);
    font-weight:900;letter-spacing:-.01em;line-height:1.12;
  }
  .panel-sub{margin-top:8px;max-width:900px;color:var(--text-muted);font-size:14px;line-height:1.6}

  .panel-actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;align-items:center}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    font-size:12px;padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:var(--text-muted);
    white-space:nowrap;
  }

  .grid-2{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1fr);gap:12px;margin-top:14px}

  .card{
    background:var(--card-bg);
    border-radius:var(--radius-lg);
    border:1px solid var(--border-subtle);
    padding:14px;
    box-shadow:var(--shadow-soft);
    backdrop-filter:blur(18px);
    min-width:0;
  }
    /* TX Events: make event rows look like premium pills */
#panel-tx #tx-events .card .mono{
  display:block;
  padding:8px 10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
  margin-top:12px;

  white-space:normal;          /* allow wrap */
  overflow-wrap:anywhere;
  line-height:1.25;
}

/* Slightly dim the "raw" part so it doesn't dominate */
#panel-tx #tx-events .card .mono .muted{
  opacity:.85;
}

/* Mobile: keep pills readable */
@media (max-width:640px){
  #panel-tx #tx-events .card .mono{
    padding:9px 11px;
  }
}

  .card h3{font-size:14px;letter-spacing:.02em;margin-bottom:8px;color:var(--text-main)}

  .field{margin-top:10px}
  .label{font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:rgba(244,246,255,.75);margin-bottom:6px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

  input,textarea,select{
    width:100%;
    padding:10px 12px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(5,7,18,.9);
    color:var(--text-main);
    font-size:13px;
    outline:none;
  }
  textarea{border-radius:18px;min-height:96px;resize:vertical;padding:12px 12px}
  input:focus,textarea:focus,select:focus{border-color:var(--accent-cyan)}

  .toggle{
    display:flex;align-items:center;gap:10px;
    padding:10px 12px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04);
    border-radius:14px;
    user-select:none;
    width:100%;
  }
  .toggle input{width:auto;accent-color:var(--accent-cyan)}

  .status{
    margin-top:10px;
    padding:12px 14px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    color:var(--text-main);
    line-height:1.5;
    font-size:13px;
    display:none;
    overflow-wrap:anywhere;
  }
  .status.ok{display:block;background:rgba(0,230,118,.10);border-color:rgba(0,230,118,.35);color:#78ffbf}
  .status.warn{display:block;background:rgba(255,193,7,.10);border-color:rgba(255,193,7,.35);color:#ffd166}
  .status.bad{display:block;background:rgba(220,53,69,.10);border-color:rgba(220,53,69,.35);color:#ff7a8a}
  .status.info{display:block;background:rgba(0,229,255,.10);border-color:rgba(0,229,255,.30);color:#7df2ff}
/* =========================
   TX DECODER â€” 4-line Security Summary (BADGES)  [FINAL ALIGN]
   ========================= */

#panel-tx .tx-sum{
  display:grid;
  grid-template-columns: 1fr;
  gap:10px;
  padding:12px;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.04);
  box-shadow:0 18px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
  backdrop-filter:blur(16px);
}

/* line layout: label | value-column (value-column is capped so it sits closer to label) */
#panel-tx .tx-sum-line{
  display:grid;
  grid-template-columns: 85px minmax(0, clamp(240px, 42vw, 480px)) !important;
  justify-content:start;   
  align-items:center;
  column-gap:10px;
  row-gap:6px;

  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  min-width:0;
}
#panel-tx .tx-sum .tx-sum-line:first-child .v{
  white-space:normal !important;
  overflow-wrap:anywhere;
  word-break:break-word;

  max-width:100%;
  overflow:hidden;          
  text-overflow:clip;      
  line-height:1.15;
}


#panel-tx .tx-sum-line .k{
  font-size:12px;
  letter-spacing:.10em;
  text-transform:uppercase;
  color:rgba(244,246,255,.72);
  white-space:nowrap;
}

/* âœ… The badge: stays inside the capped column, aligned right, and never paints the whole row */
#panel-tx .tx-sum-line .v{
  justify-self:end;        
  max-width:100%;
  min-width:0;
  box-sizing:border-box;

  display:inline-flex;
  align-items:center;
  gap:8px;

  font-size:12px;
  font-weight:800;
  letter-spacing:.02em;

  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  color:rgba(244,246,255,.92);

  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* Dot inside badge */
#panel-tx .tx-sum-line .v .dot{
  width:10px;
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,.25);
  box-shadow:0 0 0 3px rgba(255,255,255,.06);
  flex:0 0 auto;
}

/* States (ONLY the badge is colored) */
#panel-tx .tx-sum-line .v.ok{
  border-color:rgba(0,230,118,.28);
  background:rgba(0,230,118,.10);
}
#panel-tx .tx-sum-line .v.ok .dot{ background:rgba(0,230,118,.95); }

#panel-tx .tx-sum-line .v.warn{
  border-color:rgba(255,193,7,.30);
  background:rgba(255,193,7,.10);
}
#panel-tx .tx-sum-line .v.warn .dot{ background:rgba(255,193,7,.95); }

#panel-tx .tx-sum-line .v.bad{
  border-color:rgba(220,53,69,.30);
  background:rgba(220,53,69,.12);
}
#panel-tx .tx-sum-line .v.bad .dot{ background:rgba(220,53,69,.95); }

#panel-tx .tx-sum-line .v.unk{
  border-color:rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  color:rgba(244,246,255,.78);
}
#panel-tx .tx-sum-line .v.unk .dot{ background:rgba(255,255,255,.25); }

/* Subline under the badge (aligned with badge column) */
#panel-tx .tx-sum-line .tx-sum-sub{
  grid-column:2;
  justify-self:end;
  max-width:100%;
  min-width:0;

  margin-top:2px;
  text-align:right;

  font-size:12px;
  line-height:1.25;
  color:rgba(244,246,255,.62);

  white-space:normal;
  overflow-wrap:anywhere;
  word-break:break-word;
}

/* Action: keep LTR so it truncates nicely (no weird left-cut) */
#tx-sum-action .v{
  direction:ltr;
  unicode-bidi:plaintext;
}

/* Mobile */
@media (max-width:640px){
  #panel-tx .tx-sum-line{
    grid-template-columns: 1fr;
    justify-content:stretch;
    row-gap:8px;
    align-items:start;
  }
  #panel-tx .tx-sum-line .v{
    justify-self:start !important;
    max-width:100%;
  }
  #panel-tx .tx-sum-line .tx-sum-sub{
    grid-column:1;
    justify-self:start;
    text-align:left;
  }
}


    /* Bookmarklet tip under the green status */
.bm-tip{
  margin-top:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  color:rgba(244,246,255,.78);
  font-size:13px;
  line-height:1.45;
}
    /* Drag-to-bookmarks bookmarklet link */
.bm-drag{
  display:flex;
  align-items:center;
  gap:10px;
  padding:12px 14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.05);
  box-shadow:0 14px 40px rgba(0,0,0,.35);
  cursor:grab;
  user-select:none;
  margin-top:10px;
  font-weight:900;
  letter-spacing:.04em;
  text-transform:none;
  width:100%;
}
    /* icon inside the drag-to-bookmarks button */
.bm-drag-icon{
  width:28px;
  height:28px;
  border-radius:10px;
  object-fit:contain;
  flex:0 0 auto;
  box-shadow:0 10px 26px rgba(0,0,0,.35);
}

/* keep the label clean */
.bm-drag span{
  line-height:1;
  min-width:0;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* make sure link doesn't look like a normal link */
#bm-drag{
  text-decoration:none;
  color:inherit;
}

/* optional: nicer hover */
#bm-drag:hover{
  border-color:rgba(0,229,255,.22);
  background:rgba(255,255,255,.07);
  transform:translateY(-1px);
}

.bm-drag:active{ cursor:grabbing; }
.bm-drag.hidden{ display:none; }

  /* =========================
     TABLES â€” merged in from the "old code" that fixed spacing/readability
     What you asked to carry over:
     âœ… proper cell ellipsis
     âœ… RPC table special grid + 2-line clamp (URL + status)
     âœ… numeric/icon columns centered
     âœ… highlight row style
     ========================= */

  /* generic table shell (keep your look) */
  .table{
    margin-top:10px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    overflow: hidden;                 /* from old code (clean corners) */
    background:rgba(255,255,255,.03);
  }
    /* =========================
   QuickScan â€” Liquidity table (FORCE wrap + compact rows)
   Target: table rendered inside #qs-liq-tablewrap
   ========================= */

#qs-liq-tablewrap .table .trow.head,
#qs-liq-tablewrap .table .trow{
  /* give RESULT more room */
  grid-template-columns: 1.15fr .75fr .75fr 2.6fr;
  gap: 10px;
}

/* reduce row height a bit */
#qs-liq-tablewrap .table .trow{
  padding: 8px 10px;
}

/* âœ… IMPORTANT: override your global "nowrap + ellipsis" for RESULT column only */
#qs-liq-tablewrap .table .trow .cell:nth-child(4){
  white-space: normal !important;
  overflow: hidden !important;
  text-overflow: clip !important;
  overflow-wrap: anywhere !important;
  line-height: 1.15;
  font-size: 12px;

  /* optional: clamp to 3 lines so it doesn't get tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
}

/* if result uses .sig (your pill), it forces nowrap â€” cancel it here */
#qs-liq-tablewrap .table .trow .cell:nth-child(4) .sig{
  white-space: normal !important;
  display: block !important;   /* lets it wrap nicely */
}

/* if result uses .mono inside, cancel nowrap too */
#qs-liq-tablewrap .table .trow .cell:nth-child(4) .mono{
  white-space: normal !important;
}

/* on medium screens, your global .trow min-width can break layout â€” disable for this table */
@media (max-width:980px){
  #qs-liq-tablewrap .table .trow{ min-width: 0 !important; }
}


/* keep head centered, rows top-aligned like your earlier fix */
#qsLiqTable .trow{ align-items: start; }
#qsLiqTable .trow.head{ align-items: center; }

/* result column: allow wrap + compact typography so it stays inside */
#qsLiqTable .trow .cell:nth-child(4),
#qs-liq-tablewrap .table .trow .cell:nth-child(4){
  white-space: normal;
  overflow: hidden;
  text-overflow: clip;
  overflow-wrap: anywhere;
  line-height: 1.18;
  font-size: 12px;
  font-family: var(--mono);
  font-variant-numeric: tabular-nums;

  /* keep it from becoming too tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4;
}

/* Pair/Pool column stays mono + tidy */
#qsLiqTable .trow .cell:nth-child(1){
  font-family: var(--mono);
}

/* on medium screens your global .trow gets min-width:560px (causes weird layout)
   cancel it only for this table */
@media (max-width:980px){
  #qsLiqTable .trow{ min-width: 0 !important; }
}

    /* ===== DNA approvals table: stronger frame + clearer row separation ===== */
#ap-table.table{
  border-color: rgba(242,211,138,.30) !important;            /* gold-ish like DNA */
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08),         /* inner frame */
              0 18px 40px rgba(0,0,0,.25) !important;        /* soft lift */
}

#ap-table .trow{
  border-top: 1px solid rgba(255,255,255,.14) !important;    /* clearer separators */
}

#ap-table .trow.head{
  background: rgba(255,255,255,.06) !important;              /* stronger header bar */
  border-bottom: 1px solid rgba(255,255,255,.14) !important; /* makes it feel â€œone tableâ€ */
}


  /* generic rows */
  .trow{
    display:grid;
    grid-template-columns:1.3fr 1.1fr .9fr .9fr;
    gap:10px;
    padding:10px 12px;
    border-top:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
    align-items:center;
    font-size:13px;
  }
  .trow.head{
    border-top:none;
    background:rgba(255,255,255,.05);
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:rgba(244,246,255,.75);
  }

  /* generic cells (from old code) */
  .trow .cell{
    min-width:0;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  /* optional wrapping cell */
  .trow .cell.wrap{
    white-space:normal;
    text-overflow:clip;
    overflow:hidden;
    overflow-wrap:anywhere;
  }
    /* =========================
   Wallet Security DNA â€” Approvals table (A)
   Flags go to a second full-width row
   ========================= */

/* Desktop: 7 columns (Token, Spender, Allowance, Verified, Last Updated, Risk, Action) */
#ap-table .trow.head,
#ap-table .trow.ap-main{
  grid-template-columns: 1.15fr 1.15fr 1.35fr .95fr 1.25fr .75fr .75fr;
}

/* Mobile/Tablet: hide-sm disappears => 4 columns (Token, Allowance, Risk, Action) */
@media (max-width: 980px){
  #ap-table .trow.head,
  #ap-table .trow.ap-main{
    grid-template-columns: 1.25fr 1.35fr .75fr .75fr;
  }
}

/* Flags row: single column full-width, nice wrapping */
#ap-table .trow.ap-flags-row{
  grid-template-columns: 1fr;
  padding-top: 8px;
  padding-bottom: 12px;
  background: rgba(255,255,255,.02);
}

#ap-table .ap-flags-cell{
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.25;
  font-size: 12px;
  color: rgba(244,246,255,.78);
}


    /* =========================
   Contract Monitor (mon-table) â€” add inline X button column
   No "Remove" header text, just an empty last cell like screenshot
   ========================= */

/* Desktop / default: 5th column reserved for X */
#mon-table .trow,
#mon-table .trow.head{
  grid-template-columns: 1.35fr 1fr 1.05fr 1fr 44px;
}
    /* âœ… MON: Last seen should wrap to 2 lines (no ellipsis) */
#mon-table .trow .cell:nth-child(3){
  white-space: normal;
  text-overflow: clip;
  overflow: hidden;
  overflow-wrap: anywhere;
  line-height: 1.15;

  /* optional: limit to 2 lines so row doesn't get too tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}


#mon-table .trow.head .cell:last-child{
  visibility:hidden;  /* stays in layout, but truly invisible */
}
    
/* Small clean X (no weird circle) */
.mon-remove{
  width:22px;
  height:22px;
  padding:0;
  margin:0;

  border:none;
  background:transparent;
  box-shadow:none;

  color:rgba(244,246,255,.70);
  cursor:pointer;
  user-select:none;

  line-height:1;
  font-size:18px;
  font-weight:900;

  display:inline-flex;
  align-items:center;
  justify-content:center;

  transition:transform var(--transition-fast), color var(--transition-fast), opacity var(--transition-fast);
  opacity:.9;
}

.mon-remove:hover{
  opacity:1;
  color:rgba(255,120,138,.95);  /* red-ish but subtle */
  transform:translateY(-1px);
}

.mon-remove:active{
  transform:translateY(0);
}


.mon-remove:focus-visible{
  outline:2px solid rgba(0,229,255,.55);
  outline-offset:2px;
}
/* =========================
   RPC Results â€” Card rows (B)
   No horizontal scroll. Domain on top, metrics in one compact line.
   ========================= */

#rpc-table{
  overflow-x:hidden;   /* âœ… no swipe */
  overflow-y:hidden;
}

/* header */
#rpc-table .trow.head.rpc{
  display:grid;
  grid-template-columns: 1fr 240px 120px; /* RPC | Metrics | Status */
  gap:12px;
  align-items:center;
}

/* each result row becomes a 2-line "card" */
#rpc-table .trow.rpc{
  display:grid;
  grid-template-columns: 1fr auto; /* top row: RPC left, status right */
  grid-template-rows: auto auto;   /* row 1: rpc+status | row 2: meta */
  gap:10px 12px;
  align-items:center;

  padding:12px 12px;
  border-top:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
}

/* RPC cell (top-left) */
#rpc-table .rpc-url{
  grid-column:1;
  grid-row:1;
  min-width:0;
}

#rpc-table .rpc-url .rpc-host{
  font-weight:900;
  letter-spacing:.01em;
  color:rgba(244,246,255,.92);
  line-height:1.15;
}

#rpc-table .rpc-url .rpc-full{
  margin-top:6px;
  color:rgba(244,246,255,.62);
  line-height:1.15;

  /* allow up to 3 lines */
  display:-webkit-box;
  -webkit-box-orient:vertical;
  -webkit-line-clamp:3;
  overflow:hidden;
  overflow-wrap:anywhere;

  direction:ltr;
  unicode-bidi:plaintext;
}

/* STATUS (top-right) */
#rpc-table .rpc-status{
  grid-column:2;
  grid-row:1;
  justify-self:end;
  white-space:nowrap;
}

/* META line (bottom full width) */
#rpc-table .rpc-meta{
  grid-column:1 / -1;
  grid-row:2;

  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:center;

  color:rgba(244,246,255,.85);
  font-size:12px;
}

/* compact metric pills */
#rpc-table .m{
  display:inline-flex;
  align-items:center;
  gap:8px;

  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);

  white-space:nowrap;
}

#rpc-table .m b{
  font-weight:900;
  color:rgba(244,246,255,.92);
}



/* Responsive: tighter header */
@media (max-width:980px){
  #rpc-table .trow.head.rpc{
    grid-template-columns: 1fr 140px; /* RPC | Status */
  }
  #rpc-table .trow.head.rpc .cell:nth-child(2){ display:none; } /* hide "Metrics" header label */
}

/* Small screens: status under host if needed */
@media (max-width:640px){
  #rpc-table .trow.rpc{
    grid-template-columns: 1fr; /* stack */
  }
  #rpc-table .rpc-status{
    grid-column:1;
    justify-self:start;
  }
}
  /* keep highlight style */
  .trow.highlight{
    background:rgba(0,230,118,.10);
    border-top-color:rgba(0,230,118,.20);
  }

  /* chips */
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.88);
    cursor:pointer;user-select:none;
    transition:transform var(--transition-fast), border-color var(--transition-fast);
    font-size:12px;
  }
  .chip:hover{transform:translateY(-1px);border-color:rgba(0,229,255,.26)}
  .chip-danger{border-color:rgba(255,80,80,.25);background:rgba(255,80,80,.08)}
  .chip-danger:hover{border-color:rgba(255,80,80,.45);transform:translateY(-1px)}
  .share-row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}

  /* QuickScan actions */
  #panel-quick .row.qs-actions,
  #panel-quick .qs-share{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:10px;
    align-items:stretch;
  }
  #panel-quick .qs-share{margin-top:12px}
  #panel-quick .qs-actions .btn,
  #panel-quick .qs-share .btn{
    width:100%;
    min-width:0;
    padding:12px 14px;
    font-size:12px;
    letter-spacing:.03em;
    white-space:normal;
    line-height:1.15;
    min-height:44px;
    overflow:hidden;text-overflow:ellipsis;
  }
  #panel-quick .qs-actions #qs-run{grid-column:1/-1}
  #panel-quick .qs-actions #qs-copy-md{grid-column:1/-1}
  #panel-quick .qs-share #qs-copy-xtext{grid-column:1/-1}

  @media (min-width:1280px){
    #panel-quick .row.qs-actions{grid-template-columns:repeat(4,minmax(0,1fr))}
    #panel-quick .qs-actions #qs-run,
    #panel-quick .qs-actions #qs-copy-md{grid-column:auto}
    #panel-quick .qs-share{grid-template-columns:repeat(3,minmax(0,1fr))}
    #panel-quick .qs-share #qs-copy-xtext{grid-column:auto}
  }
   
  /* QuickScan risk table */
  #qs-riskTable{margin-top:12px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}
  #qs-riskTable .trow.head.risk,
  #qs-riskTable .trow.risk{
    display:grid;
    grid-template-columns:.95fr .95fr .95fr .95fr .95fr .95fr .85fr 1.5fr;
    gap:10px;padding:10px 12px;align-items:center;min-width:980px;
  }
  #qs-riskTable .trow.head.risk{
    background:rgba(255,255,255,.05);
    font-size:12px;letter-spacing:.08em;text-transform:uppercase;
    color:rgba(244,246,255,.75);
    border-top:none;
  }
  #qs-riskTable .trow.risk{background:rgba(255,255,255,.03);border-top:1px solid rgba(255,255,255,.10)}
  #qs-riskTable .cell{min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  #qs-riskTable .cell:not(:last-child){text-align:center;justify-self:center}
  #qs-riskTable .cell:last-child{
    text-align:left;white-space:normal;overflow-wrap:anywhere;line-height:1.15;
    display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3;
  }

  /* signals (QuickScan top row UI) */
  .sig{
    display:inline-flex;align-items:center;justify-content:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.92);
    font-size:12px;white-space:nowrap;
  }
  .sig .dot{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.25);box-shadow:0 0 0 3px rgba(255,255,255,.06)}
  .sig.ok{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .sig.ok .dot{background:rgba(0,230,118,.95)}
  .sig.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .sig.warn .dot{background:rgba(255,193,7,.95)}
  .sig.bad{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}
  .sig.bad .dot{background:rgba(220,53,69,.95)}
  .sig.unk{border-color:rgba(255,255,255,.10);background:rgba(255,255,255,.04);color:rgba(244,246,255,.75)}
  .sig.unk .dot{background:rgba(255,255,255,.25)}

  .qs-scoreRow{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:10px}
  .score-pill{
    display:inline-flex;align-items:center;gap:10px;
    padding:8px 12px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    font-size:12px;color:rgba(244,246,255,.92);
  }
  .score-pill strong{font-weight:900;letter-spacing:.02em}
  .score-pill.low{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .score-pill.med{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .score-pill.high{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}

  .flags-box{
    margin-top:10px;padding:12px 14px;border-radius:16px;
    border:1px solid rgba(255,193,7,.25);
    background:rgba(255,193,7,.08);
    color:#ffd166;font-size:13px;line-height:1.45;display:none;
  }
  .flags-box ul{margin-top:8px;padding-left:18px}
  .flags-box li{margin:4px 0}
  .qs-disclaimer{margin-top:10px;font-size:12px;color:var(--text-muted);line-height:1.45}

  /* Bookmarklet help */
  .h3-row{display:flex;align-items:center;gap:10px}
  .h3-row img{width:22px;height:22px;border-radius:8px;box-shadow:0 10px 24px rgba(0,0,0,.6)}
  .help-box{
    margin-top:10px;padding:12px 14px;border-radius:16px;
    border:1px solid rgba(0,229,255,.20);
    background:rgba(0,229,255,.08);
    color:#7df2ff;font-size:13px;line-height:1.45;display:none;
  }
  .help-box ol{margin-top:8px;padding-left:18px}
  .help-box li{margin:4px 0}

  /* Footer */
  .footer{
    border-top:1px solid rgba(255,255,255,.06);
    margin-top:20px;padding-top:16px;
    display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:10px;
    font-size:12px;color:var(--text-muted);
  }
  .footer-tagline{color:var(--accent-cyan);font-weight:700}

  /* RTL */
  html[dir="rtl"] body{direction:rtl}
  html[dir="rtl"] .top-bar{flex-direction:row-reverse}
  html[dir="rtl"] .brand{flex-direction:row-reverse}
  html[dir="rtl"] .panel-head{flex-direction:row-reverse}
  html[dir="rtl"] .row{flex-direction:row-reverse}
  html[dir="rtl"] .panel-actions{justify-content:flex-start}

  /* âœ… responsive */
  @media (max-width:980px){
    .grid-2{grid-template-columns:1fr}
    .hide-sm{display:none!important}

    .tool-grid{grid-template-columns:repeat(2, minmax(0, 1fr))}

    /* generic table swipe width on medium screens */
    #qs-riskTable .trow{ min-width:560px; }

    #mon-table .trow,
#mon-table .trow.head{
  grid-template-columns:1.7fr 1fr 1fr 44px; /* contract | net | status | X */
  min-width:520px;
}

  }

  @media (max-width:640px){
    .top-bar{top:10px;padding:10px 12px}
    .brand-logo{width:40px;height:40px;border-radius:14px}
    .btn{padding:12px 18px;font-size:13px}

    .tool-grid{grid-template-columns:1fr; gap:14px}
  }
    /* ===== CycleX â€” Wallet Security DNA (SAFE PATCH) ===== */

/* DNA cube: subtle gold frame + glow */
a.tool-card[data-tool="approvals"]{
  border-color: rgba(242,211,138,.42) !important;
  background: linear-gradient(165deg, rgba(242,211,138,.06), rgba(255,255,255,.04)) !important;
  box-shadow:
    0 20px 55px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 0 2px rgba(242,211,138,.22),
    0 0 28px rgba(242,211,138,.20) !important;
}
/* Wallet DNA cube â€” make subtitle a bit more prominent (ONLY this cube) */
a.tool-card[data-tool="approvals"] .tool-desc{
  font-size: 15px !important;
  font-weight: 700 !important;
  color: rgba(244,246,255,.86) !important;
  letter-spacing: .01em !important;
  text-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
  margin-top: 2px !important;
}
    /* ===== DNA table: Verified / Unverified colors (ONLY in approvals table) ===== */
#ap-table .chip.chip-ok{
  border-color: rgba(0,230,118,.32) !important;
  background: rgba(0,230,118,.12) !important;
  color: #a8ffd5 !important;
}

/* In DNA you currently output Unverified as chip-warn â†’ make it RED only here */
#ap-table .chip.chip-warn{
  border-color: rgba(220,53,69,.34) !important;
  background: rgba(220,53,69,.14) !important;
  color: #ffb3bd !important;
}



/* Optional: tiny spacing so it breathes under the title */
.tool-card[data-tool="approvals"] .tool-desc{
  margin-top: 2px !important;
}

a.tool-card[data-tool="approvals"]::before{
  background:
    radial-gradient(520px 180px at 18% -5%, rgba(242,211,138,.16), transparent 62%),
    radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.14), transparent 62%) !important;
}
    /* DNA cube â€” top light hit (premium highlight) */
a.tool-card[data-tool="approvals"]{
  position: relative; /* safe, for ::after */
}

a.tool-card[data-tool="approvals"]::after{
  content:"";
  position:absolute;
  left:10px;
  right:10px;
  top:10px;
  height:46px;
  border-radius:18px;
  pointer-events:none;

  /* subtle "light hit" only on top */
  background: linear-gradient(
    180deg,
    rgba(255,255,255,.14),
    rgba(242,211,138,.10) 45%,
    rgba(255,255,255,0) 100%
  );

  /* keeps it premium, not loud */
  opacity:.75;
  mix-blend-mode: screen;
}



/* DNA panel: subtle gold outline */
#panel-approvals.panel-shell,
#panel-approvals{
  border-color: rgba(242,211,138,.30) !important;
  box-shadow:
    0 26px 70px rgba(0,0,0,.60),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 0 1px rgba(242,211,138,.16),
    0 0 34px rgba(242,211,138,.14) !important;
}

/* Score/Risk pills (hooks) */
#dna-score,
#dna-risk{
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  padding: 7px 11px !important;
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.05) !important;
  color: rgba(244,246,255,.92) !important;
  font-size: 12px !important;
  font-weight: 800 !important;
  letter-spacing: .02em !important;
  white-space: nowrap !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05) !important;
}


/* Color states (only if classes exist) */
#dna-score.score-low,  #dna-score.score-ok,
#dna-risk.risk-low,    #dna-risk.risk-ok{
  border-color: rgba(0,230,118,.28) !important;
  background: rgba(0,230,118,.10) !important;
  color: #a8ffd5 !important;
}

#dna-score.score-med,  #dna-score.score-warn,
#dna-risk.risk-med,    #dna-risk.risk-warn{
  border-color: rgba(255,193,7,.30) !important;
  background: rgba(255,193,7,.10) !important;
  color: #ffe29a !important;
}

#dna-score.score-high, #dna-score.score-bad,
#dna-risk.risk-high,   #dna-risk.risk-bad{
  border-color: rgba(220,53,69,.30) !important;
  background: rgba(220,53,69,.12) !important;
  color: #ffb3bd !important;
}

#dna-score.score-unk,
#dna-risk.risk-unk{
  opacity: .88 !important;
}

/* DNA approvals table: card rows */
#ap-table .trow{
  display: grid !important;
  grid-template-columns: 1fr auto !important;
  grid-template-rows: auto auto !important;
  gap: 10px 12px !important;
  align-items: center !important;
  padding: 12px 12px !important;
  min-width: 0 !important;
}

#ap-table .trow.head{
  display: grid !important;
  grid-template-columns: 1fr auto !important;
  padding: 10px 12px !important;
  min-width: 0 !important;
}

#ap-table .ap-main{ grid-column: 1; grid-row: 1; min-width: 0; }
#ap-table .ap-actions{
  grid-column: 2; grid-row: 1;
  justify-self: end;
  display: flex;
  gap: 10px;
  align-items: center;
  white-space: nowrap;
}
#ap-table .ap-meta{
  grid-column: 1 / -1; grid-row: 2;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  color: rgba(244,246,255,.78);
  font-size: 12px;
}

#ap-table .ap-sub{
  margin-top: 6px;
  color: rgba(244,246,255,.62);
  line-height: 1.15;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}
#ap-table .ap-sub .m{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  white-space: nowrap;
}


/* ===== DNA: lock Score/Risk position (no wrap jump) ===== */
#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child{
  flex-wrap: nowrap !important;
  align-items: flex-start !important;
}

#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row{
  margin-left: auto !important;
  flex-wrap: nowrap !important;
  justify-content: flex-end !important;
  align-items: center !important;
}

#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row .pill{
  flex: 0 0 auto !important;
}
    /* Mobile fix: long connected address shouldn't shift layout */
#dna-address,
#dna-wallet,
#dna-status .mono{
  max-width:100%;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

</style>
   
</head>
<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX" data-i18n-title="title_back_to_cyclex">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector" data-i18n-aria-label="aria_lang_selector">
        <button class="lang-btn active" data-lang="en">ðŸ‡ºðŸ‡¸ EN</button>
        <button class="lang-btn" data-lang="zh">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="ar">ðŸ‡¸ðŸ‡¦ Ø¹Ø±Ø¨ÙŠ</button>
        <button class="lang-btn" data-lang="ru">ðŸ‡·ðŸ‡º RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Tools</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          A lightweight, client-side toolkit for safer swaps, approvals hygiene, liquidity checks, RPC health, and transaction decoding across BSC + Ethereum.
        </p>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-quick" data-i18n="btn_quick">Run Quick Scan</button>
        </div>

        <div class="note-line" data-i18n="hero_note">
          Note: These checks are informational and do not guarantee safety. Always verify independently.
        </div>
      </section>

      <section class="tool-grid-wrap">
        <div class="tool-grid-title" data-i18n="tools_kicker">CHOOSE A TOOL</div>

        <div class="tool-grid" id="toolGrid">
          <a class="tool-card active" data-tool="quick" href="#panel-quick">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_quick_title">Quick Scan</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_quick_desc">Fast token sanity-check + shareable report + cache.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_fast">Fast</strong></div>
              <div class="badge"><strong data-i18n="badge_share">Share</strong></div>
              <div class="badge"><strong data-i18n="badge_cache">Cache</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="approvals" href="#panel-approvals">
  <div class="tool-head">
    <div class="tool-name" data-i18n="cube_walletdna_title">Wallet Security DNA</div>
    <div class="badge"><strong data-i18n="badge_wallet">Wallet</strong></div>
  </div>

  <div class="tool-desc" data-i18n="cube_walletdna_desc">
    Approval &amp; Permission Risk Snapshot
  </div>

  <div class="badge-row">
    <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
    <div class="badge"><strong data-i18n="badge_safe">Safe</strong></div>
  </div>
</a>

          <a class="tool-card" data-tool="liq" href="#panel-liq">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_liq_title">Token + Liquidity Scan</div>
              <div class="badge"><strong>V2</strong> + <strong>V3</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_liq_desc">DEX Registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_dex">DEX</strong></div>
              <div class="badge"><strong>USDT</strong></div>
              <div class="badge"><strong data-i18n="badge_pairs">Pairs</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="rpc" href="#panel-rpc">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
              <div class="badge"><strong>âœ…</strong> <span data-i18n="badge_table">Table</span></div>
            </div>
            <div class="tool-desc" data-i18n="cube_rpc_desc">Latency + chainId + block + eth_call + read logs + dev custom test.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_copy">Copy</strong></div>
              <div class="badge"><strong data-i18n="badge_dev">Dev</strong></div>
              <div class="badge"><strong>X</strong> <span data-i18n="badge_share">Share</span></div>
            </div>
          </a>

          <a class="tool-card" data-tool="tx" href="#panel-tx">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_tx_title">Tx Decoder</div>
              <div class="badge"><strong data-i18n="badge_decode">Decode</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_tx_desc">Decode inputs + common events (Transfer/Approval) from a tx hash.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_receipt">Receipt</strong></div>
              <div class="badge"><strong data-i18n="badge_events">Events</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="dev" href="#panel-dev">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_dev_title">Dev Tools</div>
              <div class="badge"><strong data-i18n="badge_tools">Tools</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_dev_desc">Bookmarklet generator + local contract monitor (no server).</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_bookmarklet">Bookmarklet</strong></div>
              <div class="badge"><strong data-i18n="badge_local">Local</strong></div>
            </div>
          </a>
        </div>
      </section>

      <!-- PANELS -->
      <section class="panel-shell" id="panel-quick">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
            <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
            <div class="panel-sub" data-i18n="p_quick_sub">
              Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="walletLabel" data-i18n="wallet_not_connected">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseQuick" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="quick_input_title">Token Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="qs-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="qs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="qs_tip">
                Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="options_label">Options</div>
              <label class="toggle">
                <input type="checkbox" id="qs-require-liq">
                <span data-i18n="opt_require_liq">Require liquidity (stricter score)</span>
              </label>
              <label class="toggle" style="margin-top:10px">
                <input type="checkbox" id="qs-show-json" checked>
                <span data-i18n="opt_show_json">Enable JSON report (copy)</span>
              </label>
            </div>

            <div class="field" style="margin-top:14px">
              <div class="label" data-i18n="api_keys_label">Explorer API keys (optional)</div>
              <label class="toggle">
                <input type="checkbox" id="api-use">
                <span data-i18n="opt_use_explorer_apis">Use BscScan/Etherscan (adds Verified + ABI heuristics)</span>
              </label>

              <div class="row" style="margin-top:10px">
                <input id="api-bscscan" class="mono" placeholder="BscScan API key (stored locally)" data-i18n-placeholder="ph_bscscan_key" />
                <input id="api-etherscan" class="mono" placeholder="Etherscan API key (stored locally)" data-i18n-placeholder="ph_etherscan_key" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="api-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="api-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>

              <div class="small" style="margin-top:8px" data-i18n="api_keys_tip">
                Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.
              </div>
            </div>

            <div class="field">
              <div class="row qs-actions">
                <button class="btn btn-primary" id="qs-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
                <button class="btn btn-ghost" id="qs-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
              </div>
            </div>

            <div class="qs-share">
              <button class="btn btn-ghost" id="qs-share-x">Share to X</button>
              <button class="btn btn-ghost" id="qs-share-tg">Share to Telegram</button>
              <button class="btn btn-ghost" id="qs-copy-xtext" data-i18n="btn_copy_xtext">Copy X text</button>
            </div>

            <div id="qs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="results_title">Results</h3>
            <div class="small" data-i18n="results_hint">
              Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.
            </div>

            <div id="qs-out" class="status info" style="display:block; margin-top:10px;" data-i18n="qs_ready_html">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="qs-risk" class="risk-badges"></div>
            <div id="qs-pairsWrap" style="margin-top:12px;"></div>
          </div>
        </div>
        
      </section>
     <section class="panel-shell hidden" id="panel-approvals">
  <div class="panel-head">
    <div>
      <div class="panel-kicker" data-i18n="p_dna_kicker">WALLET SECURITY DNA</div>
      <div class="panel-title" data-i18n="p_dna_title">Wallet Security DNA</div>
      <div class="panel-sub" data-i18n="p_dna_sub">
        Approval &amp; Permission Risk Snapshot
      </div>
    </div>

    <div class="panel-actions">
      <div class="pill">
        <span data-i18n="pill_wallet">Wallet</span>:
        <span class="mono" id="dna-wallet" data-i18n="wallet_not_connected">not connected</span>
      </div>
      <button class="btn btn-ghost" id="btnCloseApprovals" data-i18n="btn_close">Close</button>
    </div>
  </div>

  <div class="grid-2">
    <!-- LEFT -->
    <div class="card">
      <h3 data-i18n="dna_controls_title">DNA Scan</h3>

      <div class="field">
        <div class="label" data-i18n="dna_wallet_address_label">Wallet Address</div>
        <input
          id="dna-walletAddress"
          class="mono"
          placeholder="0x... (optional if you connect)"
          data-i18n-placeholder="dna_wallet_address_ph"
        />
        <div class="small" style="margin-top:8px" data-i18n="dna_wallet_address_tip">
          You can scan by address first. Connect a wallet only when you want to revoke.
        </div>
      </div>

      <div class="field">
        <div class="label" data-i18n="net_label">Network</div>
        <select id="dna-net">
          <option value="bsc" data-i18n="net_bsc">BSC (BNB Chain)</option>
          <option value="eth" data-i18n="net_eth">Ethereum</option>
          <option value="polygon" data-i18n="net_polygon">Polygon</option>
        </select>
      </div>

      <div class="field">
        <div class="row" style="justify-content:space-between; gap:10px; flex-wrap:wrap">
          <div class="pill">
            <span data-i18n="dna_connected">Connected:</span>
            <span id="dna-address" class="mono">â€”</span>
          </div>
          <button class="btn btn-secondary" id="dna-connect" data-i18n="dna_connect">Connect Wallet</button>
        </div>
      </div>

      <div class="field">
        <div class="row" style="gap:10px; flex-wrap:wrap">
          <button class="btn btn-primary" id="dna-run" data-i18n="dna_run">Scan</button>
          <button class="btn btn-ghost" id="dna-reset" data-i18n="dna_reset">Reset</button>
        </div>
        <div class="small" style="margin-top:8px" data-i18n="safe_mode_note">
          Safe mode: revoke actions require a connected wallet.
        </div>
      </div>

      <div id="dna-status" class="status info"></div>

      <div class="field" style="margin-top:14px">
        <div class="label" data-i18n="dna_tokens_label">Token list (optional)</div>
        <textarea
          id="dna-tokens"
          class="mono"
          placeholder="0x...\n0x...\n0x..."
          data-i18n-placeholder="ph_token_list"
        ></textarea>
        <div class="row" style="margin-top:10px">
          <button class="btn btn-ghost" id="dna-seed-common" data-i18n="ap_seed">Seed common tokens</button>
          <button class="btn btn-ghost" id="dna-seed-history" data-i18n="ap_seed_history">Use scan history</button>
        </div>
      </div>

      <!-- Compatibility hooks (hidden) -->
      <div style="display:none">
        <select id="ap-net"></select>
        <button id="ap-connect"></button>
        <button id="ap-revoke-all"></button>
        <div id="ap-status"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap">
        <div>
          <h3 data-i18n="dna_results_title">Wallet Security DNA</h3>
          <div class="small" data-i18n="dna_results_hint">
            Score is a snapshot. Always verify before signing.
          </div>
        </div>

        <div class="row dna-metrics">
          <div class="pill">
            <span data-i18n="dna_score">Score</span>:
            <span class="mono" id="dna-score">â€”</span>
          </div>
          <div class="pill">
            <span data-i18n="dna_risk_level">Risk</span>:
            <span class="mono" id="dna-risk">â€”</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px; padding:12px">
        <div class="small" style="margin-bottom:8px" data-i18n="dna_tips_title">Tips</div>
        <ul id="dna-tips" class="small" style="margin:0; padding-left:18px">
          <li class="muted" data-i18n="dna_tips_placeholder">â€”</li>
        </ul>

        <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap">
          <button class="btn btn-ghost" id="dna-share" data-i18n="dna_share">Share score</button>
        </div>
      </div>

      <div style="margin-top:14px">
        <div class="row" style="justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap">
          <h3 style="margin:0" data-i18n="dna_allowances_title">Approvals</h3>
          <button class="btn btn-ghost" id="dna-revoke-all" data-i18n="ap_revoke_all">
            Revoke All (non-zero)
          </button>
        </div>

        <div id="ap-table" class="table" style="margin-top:10px;">
          <div class="trow head">
            <div class="cell">Token</div>
            <div class="cell hide-sm">Spender</div>
            <div class="cell">Allowance</div>
            <div class="cell hide-sm">Verified</div>
            <div class="cell hide-sm">Last Updated</div>
            <div class="cell">Risk</div>
            <div class="cell">Action</div>
          </div>

          <div class="trow">
            <div class="cell muted">â€”</div>
            <div class="cell muted hide-sm">â€”</div>
            <div class="cell muted">â€”</div>
            <div class="cell muted hide-sm">â€”</div>
            <div class="cell muted hide-sm">â€”</div>
            <div class="cell muted hide-sm">â€”</div>
            <div class="cell muted">â€”</div>
            <div class="cell muted">â€”</div>
          </div>
        </div>

        <div class="small" style="margin-top:8px" data-i18n="dna_table_note">
          Tip: revoke â€œinfiniteâ€ approvals you donâ€™t fully trust. Verified status and flags are informational only.
        </div>
      </div>
    </div>
  </div>
</section>


      <section class="panel-shell hidden" id="panel-liq">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_liq_kicker">Token + Liquidity Scan</div>
            <div class="panel-title" data-i18n="p_liq_title">DEX Registry liquidity checks</div>
            <div class="panel-sub" data-i18n="p_liq_sub">
              We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="liq-wallet" data-i18n="wallet_not_connected">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseLiq" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="liq_input_title">Token + Network</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="liq-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="liq-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="liq_tip">
                Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="liq_dex_label">DEX registry (checked)</div>
              <div class="small" id="liq-dex-note" style="margin-top:6px;"></div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="liq-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="liq-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="liq-share-x" data-i18n="btn_share_x">Share to X</button>
              </div>
            </div>

            <div id="liq-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="liq_results_title">Liquidity Results</h3>
            <div class="small" data-i18n="liq_results_hint">
              V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.
            </div>

            <div id="liq-out" class="status info" style="display:block; margin-top:10px;" data-i18n="liq_ready_html">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="liq-risk" class="risk-badges"></div>
            <div id="liq-tablewrap" style="margin-top:10px;"></div>
          </div>
        </div>
      </section>
      <section class="panel-shell hidden" id="panel-rpc">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_rpc_kicker">RPC Health Checker</div>
            <div class="panel-title" data-i18n="p_rpc_title">Find the best endpoint</div>
            <div class="panel-sub" data-i18n="p_rpc_sub">
              We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseRpc" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_inputs">Inputs</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="rpc-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_private_label">Private RPC (saved locally)</div>
              <input id="rpc-private" class="mono" placeholder="https://... (stored locally only)" data-i18n-placeholder="ph_rpc_private" />
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-private-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="rpc-private-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>
              <div class="small" style="margin-top:8px" data-i18n="rpc_private_tip">
                Not embedded in HTML. Stored in your browser only (localStorage).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC (top priority)</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." data-i18n-placeholder="ph_rpc_custom" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-share-x" data-i18n="btn_share_x">Share to X</button>
              </div>
            </div>

            <div class="field" style="margin-top:14px">
              <h3 data-i18n="rpc_dev_title">Developer custom logs test</h3>
              <div class="small" data-i18n="rpc_dev_hint">
                Optional: test logs for a contract. This helps developers verify their own RPC stability.
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_addr">Contract address (optional)</div>
                <input id="rpc-dev-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_topic">Topic0 (optional)</div>
                <input id="rpc-dev-topic" class="mono" placeholder="0xddf252ad... (Transfer) or leave empty" data-i18n-placeholder="ph_rpc_dev_topic" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-dev-run" style="padding:10px 14px; font-size:12px;" data-i18n="rpc_dev_run">Run custom test</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
             <div class="trow head rpc">
             <div class="cell">RPC</div>
             <div class="cell">Metrics</div>
             <div class="cell">Status</div>
             </div>
           </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-tx">
  <div class="panel-head">
    <div>
      <div class="panel-kicker" data-i18n="p_tx_kicker">Tx Decoder</div>
      <div class="panel-title" data-i18n="p_tx_title">Decode a transaction</div>
      <div class="panel-sub" data-i18n="p_tx_sub">
        Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).
      </div>
    </div>
    <div class="panel-actions">
      <button class="btn btn-ghost" id="btnCloseTx" data-i18n="btn_close">Close</button>
    </div>
  </div>

  <div class="grid-2">
    <!-- LEFT: INPUT -->
    <div class="card">
      <h3 data-i18n="tx_input_title">Tx Input</h3>

      <div class="field">
        <div class="label" data-i18n="net_label">Network</div>
        <select id="tx-net">
          <option value="bsc">BSC (BNB Chain)</option>
          <option value="eth">Ethereum</option>
        </select>
      </div>

      <div class="field">
        <div class="label" data-i18n="tx_hash_label">Transaction hash</div>
        <input id="tx-hash" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
        <div class="small" style="margin-top:8px" data-i18n="tx_tip">
          Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.
        </div>
      </div>

      <div class="field">
        <div class="row">
          <button class="btn btn-primary" id="tx-run" data-i18n="btn_decode">Decode</button>
          <button class="btn btn-ghost" id="tx-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
        </div>
      </div>

      <div id="tx-status" class="status info"></div>
    </div>

    <!-- RIGHT: OUTPUT -->
    <div class="card">
      <h3 data-i18n="tx_results_title">Decoded Output</h3>
      
<!-- 4-line Security Summary (always visible) -->
<div id="tx-sum" class="tx-sum" style="margin-top:10px;">
  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_action_k">Action</span>
    <span class="tx-sum-v" id="tx-sum-action">â€”</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_risk_k">Risk</span>
    <span class="tx-sum-v" id="tx-sum-risk">â€”</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_target_k">Target</span>
    <span class="tx-sum-v mono" id="tx-sum-target">â€”</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_impact_k">Max impact</span>
    <span class="tx-sum-v" id="tx-sum-impact">â€”</span>
  </div>
</div>
      <!-- Main decoded text / ready state -->
      <div id="tx-out" class="status info" style="display:block; margin-top:10px;" data-i18n="tx_ready_html">
        <strong>Ready.</strong><br>
        Paste a tx hash and click <b>Decode</b>.
      </div>

      <!-- Parsed events / extra cards -->
      <div id="tx-events" style="margin-top:10px;"></div>
    </div>
  </div>
</section>
            <section class="panel-shell hidden" id="panel-dev">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_dev_kicker">Dev Tools</div>
            <div class="panel-title" data-i18n="p_dev_title">Bookmarklet + Local Monitor</div>
            <div class="panel-sub" data-i18n="p_dev_sub">
              Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseDev" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="bm_title">Bookmarklet Generator</h3>
            <div class="small" data-i18n="bm_hint">
              Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.
            </div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="bm_base_label">Hub URL (this page)</div>
              <input id="bm-base" class="mono" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="bm-generate" data-i18n="bm_generate">Generate</button>
                <button class="btn btn-ghost" id="bm-copy" data-i18n="bm_copy">Copy Bookmarklet</button>
              </div>
            </div>
            <a id="bm-drag" class="bm-drag" href="#">
  <img class="bm-drag-icon" src="/logo.png" alt="CycleX">
  <span data-i18n="bm_drag_label">CycleX â€“ Security Hub</span>
</a>

            <div id="bm-out" class="status info"></div>
            <div id="bm-tip" class="bm-tip" data-i18n="bm_tip">
  Add the bookmarklet to your browser, then check any contract from any site with one click.
</div>
          </div>

          <div class="card">
            <h3 data-i18n="mon_list_title">Contract Monitor (local)</h3>
            <div class="small" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="mon-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Contract address</div>
              <input id="mon-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
                <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
                <button class="btn btn-ghost" id="mon-export" data-i18n="mon_export">Copy JSON</button>
              </div>
            </div>

            <div id="mon-status" class="status info"></div>

            <div id="mon-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell" data-i18n="th_contract">Contract</div>
                <div class="cell" data-i18n="th_network">Network</div>
                <div class="cell hide-sm" data-i18n="th_last_seen">Last seen</div>
                <div class="cell" data-i18n="th_status">Status</div>
                <div class="cell" aria-hidden="true"></div>
              </div>

              <!-- âœ… placeholder row (JS will replace/append real rows) -->
              <div class="trow">
                <div class="cell muted">â€”</div>
                <div class="cell muted">â€”</div>
                <div class="cell muted hide-sm">â€”</div>
                <div class="cell muted">â€”</div>
                <div class="cell">
                  <button class="mon-remove" type="button"
                          data-action="mon-remove"
                          data-addr=""
                          data-i18n-title="remove"
                          data-i18n-aria-label="remove"
                          title="Remove"
                          aria-label="Remove">Ã—</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>

    </main>
  </div>
</body>

  <!-- ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <!-- AppKit + App logic -->
  <script type="module">
    "use strict";

    const E = window.ethers;

    // =========================
    // AppKit (Reown)
    // =========================
    import { createAppKit } from "https://esm.sh/@reown/appkit@1.8.15";
    import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@1.8.15";
    import { bsc, mainnet } from "https://esm.sh/@reown/appkit/networks";

    const APPKIT_PROJECT_ID = "7886bcb95105e9e47337cec481d5de75";

    const appkit = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc, mainnet],
      defaultNetwork: bsc,
      projectId: APPKIT_PROJECT_ID,
      analytics: false,
      metadata: {
        name: "CycleX",
        description: "CycleX Security Hub",
        url: window.location.origin,
        icons: [`${window.location.origin}/logo.png`]
      }
    });

    window.CxAppKitModal = appkit;

    async function waitForWalletProvider(timeoutMs = 12000) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const p = window.CxAppKitModal?.getWalletProvider?.();
          if (p) return p;
        } catch {}
        await new Promise(r => setTimeout(r, 250));
      }
      return null;
    }

   // =========================
// i18n (4 languages)
// =========================
const translations = {
  en: {
    // header / hero
    brand_sub: "On-Chain Security & Rewards",
    hero_kicker: "Security Hub",
    hero_title: "CycleX Security Tools",
    hero_subtitle:
      "A lightweight, client-side toolkit for safer swaps, approvals hygiene, liquidity checks, RPC health, and transaction decoding across BSC + Ethereum.",
    btn_back: "Back to Site",
    btn_connect: "Connect Wallet (optional)",
    wallet_not_connected: "not connected",
    btn_quick: "Run Quick Scan",
    hero_note:
      "Note: These checks are informational and do not guarantee safety. Always verify independently.",
    tools_kicker: "CHOOSE A TOOL",

    // tiles
    cube_quick_title: "Quick Scan",
    cube_quick_desc: "Fast token sanity-check + shareable report + cache.",
    cube_liq_title: "Token + Liquidity Scan",
    cube_liq_desc: "DEX registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc: "Check and revoke ERC-20 allowances safely (approve â†’ 0).",
    cube_rpc_title: "RPC Health Checker",
    cube_rpc_desc: "Latency + chainId + block + eth_call + read logs + dev custom test.",
    cube_tx_title: "Tx Decoder",
    cube_tx_desc: "Decode inputs + common events (Transfer/Approval) from a tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc: "Bookmarklet generator + local contract monitor (no server).",

    // tile badges
    badge_fast: "Fast",
    badge_share: "Share",
    badge_cache: "Cache",
    badge_dex: "DEX",
    badge_pairs: "Pairs",
    badge_wallet: "Wallet",
    badge_safe: "Safe",
    badge_copy: "Copy",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",

    // generic
    pill_wallet: "Wallet",
    btn_close: "Close",
    btn_save: "Save",
    btn_clear: "Clear",
    btn_scan: "Scan",
    btn_decode: "Decode",
    btn_copy_md: "Copy Markdown",
    btn_copy_link: "Copy Share Link",
    btn_copy_json: "Copy JSON",
    btn_copy_xtext: "Copy X text",

    // quick panel
    p_quick_kicker: "Quick Scan",
    p_quick_title: "Score a token in seconds",
    p_quick_sub:
      "Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.",
    quick_input_title: "Token Input",
    net_label: "Network",
    addr_label: "Token contract",
    qs_tip:
      'Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).',
    options_label: "Options",
    opt_require_liq: "Require liquidity (stricter score)",
    opt_show_json: "Enable JSON report (copy)",
    api_keys_label: "Explorer API keys (optional)",
    opt_use_explorer_apis: "Use BscScan/Etherscan (adds Verified + ABI heuristics)",
    api_keys_tip:
      "Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.",
    results_title: "Results",
    results_hint:
      "Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.",

    // liquidity panel
    p_liq_kicker: "Token + Liquidity Scan",
    p_liq_title: "DEX registry liquidity checks",
    p_liq_sub:
      "We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.",
    liq_input_title: "Token + Network",
    liq_tip:
      'Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.',
    liq_dex_label: "DEX registry (checked)",
    liq_results_title: "Liquidity Results",
    liq_results_hint:
      "V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.",

    
    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "Check and revoke allowances",
    p_app_sub:
      "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
    ap_settings_title: "Settings",
    ap_connected: "Connected:",
    ap_connect: "Connect / Refresh",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "Start with a router preset, then add tokens you want to clean up.",
    ap_tokens_label: "Token list (one per line)",
    ap_seed: "Seed common tokens",
    ap_seed_history: "Use scan history",
    ap_check: "Check Allowances",
    ap_revoke_all: "Revoke All (non-zero)",
    ap_results: "Allowances",
    ap_results_hint:
      "If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.",
    safe_mode_note:
      "Safe mode: actions that require a signature are disabled until you connect a wallet.",
    // DNA (Wallet Security DNA)
p_dna_kicker: "WALLET SECURITY DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Approval & Permission Risk Snapshot",

pill_wallet: "Wallet",
wallet_not_connected: "not connected",
btn_close: "Close",

dna_controls_title: "DNA Scan",
dna_wallet_address_label: "Wallet Address",
dna_wallet_address_ph: "0x... (optional if you connect)",
dna_wallet_address_tip: "You can scan by address first. Connect a wallet only when you want to revoke.",

net_label: "Network",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Connected:",
dna_connect: "Connect Wallet",
dna_run: "Scan",
dna_reset: "Reset",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "Score is a snapshot. Always verify before signing.",

dna_score: "Score",
dna_risk_level: "Risk",

dna_tips_title: "Tips",
dna_tips_placeholder: "â€”",
dna_share: "Share score",

dna_allowances_title: "Approvals",
dna_table_note: "Tip: revoke â€œinfiniteâ€ approvals you donâ€™t fully trust. Verified status and flags are informational only.",


    // rpc panel
    p_rpc_kicker: "RPC Health Checker",
    p_rpc_title: "Find the best endpoint",
    p_rpc_sub:
      "We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.",
    rpc_inputs: "Inputs",
    rpc_private_label: "Private RPC (saved locally)",
    rpc_private_tip:
      "Not embedded in HTML. Stored in your browser only (localStorage).",
    rpc_custom_label: "Optional custom RPC (top priority)",
    rpc_test: "Test RPCs",
    rpc_copy_best: "Copy Best RPC",
    rpc_results: "Results",
    rpc_tip:
      "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",
    rpc_dev_title: "Developer custom logs test",
    rpc_dev_hint:
      "Optional: test logs for a contract. This helps developers verify their own RPC stability.",
    rpc_dev_addr: "Contract address (optional)",
    rpc_dev_topic: "Topic0 (optional)",
    rpc_dev_run: "Run custom test",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Decode a transaction",
    p_tx_sub:
      "Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).",
    tx_input_title: "Tx Input",
    tx_hash_label: "Transaction hash",
    tx_tip:
      'Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.',
    tx_results_title: "Decoded Output",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + Local Monitor",
    p_dev_sub:
      "Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).",
    bm_title: "Bookmarklet Generator",
    bm_hint:
      "Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.",
    bm_base_label: "Hub URL (this page)",
    bm_generate: "Generate",
    bm_copy: "Copy Bookmarklet",

    mon_add_title: "Add to watchlist",
    mon_list_title: "Contract Monitor (local)",
    mon_list_hint: "Stored locally only. No server tracking.",
    mon_add: "Add",
    mon_check: "Check all",
    mon_export: "Copy JSON",

    // footer
    footer_left:
      "CycleX Security Hub runs client-side and reads public on-chain data.",
    footer_tagline: "Verify twice. Connect only when you trust the page.",
    // --- ADD THESE KEYS (EN) ---
title_back_to_cyclex: "Back to CycleX",
aria_lang_selector: "Language selector",
badge_table: "Table",
btn_share_x: "Share to X",
btn_share_tg: "Share to Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "Customâ€¦",

th_token: "Token",
th_allowance: "Allowance",
th_symbol: "Symbol",
th_action: "Action",
th_rpc: "RPC",
th_ms: "ms",
th_chain: "chain",
th_block: "block",
th_call: "call",
th_logs: "logs",
th_status: "status",
th_contract: "Contract",
th_network: "Network",
th_last_seen: "Last seen",
    th_remove: "Remove",
    bm_tip: "Add the bookmarklet to your browser, then check any contract from any site with one click.",
bm_drag_label: "CycleX â€“ Security Hub",

qs_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
liq_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
tx_ready_html: "<strong>Ready.</strong><br>Paste a tx hash and click <b>Decode</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (stored locally)",
ph_etherscan_key: "Etherscan API key (stored locally)",
ph_rpc_private: "https://... (stored locally only)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) or leave empty"

    
  },

  zh: {
    // header / hero
    brand_sub: "é“¾ä¸Šå®‰å…¨ä¸Žå¥–åŠ±",
    hero_kicker: "å®‰å…¨ä¸­å¿ƒ",
    hero_title: "CycleX å®‰å…¨å·¥å…·",
    hero_subtitle:
      "è½»é‡çº§å®¢æˆ·ç«¯å·¥å…·ï¼šæ›´å®‰å…¨çš„äº¤æ¢ã€æŽˆæƒç®¡ç†ã€æµåŠ¨æ€§æ£€æŸ¥ã€RPC å¥åº·æ£€æµ‹ä¸Žäº¤æ˜“è§£ç ï¼ˆBSC + ä»¥å¤ªåŠï¼‰ã€‚",
    btn_back: "è¿”å›žä¸»ç«™",
    btn_connect: "è¿žæŽ¥é’±åŒ…ï¼ˆå¯é€‰ï¼‰",
    wallet_not_connected: "æœªè¿žæŽ¥",
    btn_quick: "è¿è¡Œå¿«é€Ÿæ‰«æ",
    hero_note:
      "æç¤ºï¼šè¿™äº›æ£€æŸ¥ä»…ä¾›å‚è€ƒï¼Œä¸ä¿è¯å®‰å…¨ã€‚è¯·åŠ¡å¿…è‡ªè¡ŒéªŒè¯ã€‚",
    tools_kicker: "é€‰æ‹©å·¥å…·",

    // tiles
    cube_quick_title: "å¿«é€Ÿæ‰«æ",
    cube_quick_desc: "å¿«é€Ÿä»£å¸ä½“æ£€ + å¯åˆ†äº«æŠ¥å‘Š + ç¼“å­˜ã€‚",
    cube_liq_title: "ä»£å¸ + æµåŠ¨æ€§æ‰«æ",
    cube_liq_desc: "DEX æ£€æŸ¥ï¼ˆPancake/Uniï¼‰ï¼šä»£å¸ vs WBNB/WETH ä¸Ž USDTã€‚",
    cube_approvals_title: "æŽˆæƒå«å£«",
    cube_approvals_desc: "æ£€æŸ¥å¹¶å®‰å…¨æ’¤é”€ ERC-20 æŽˆæƒï¼ˆapprove â†’ 0ï¼‰ã€‚",
    cube_rpc_title: "RPC å¥åº·æ£€æµ‹",
    cube_rpc_desc: "å»¶è¿Ÿ + chainId + åŒºå— + eth_call + è¯»å– logs + å¼€å‘è‡ªå®šä¹‰æµ‹è¯•ã€‚",
    cube_tx_title: "äº¤æ˜“è§£ç ",
    cube_tx_desc: "ä»Žäº¤æ˜“å“ˆå¸Œè§£ç è¾“å…¥ä¸Žå¸¸è§äº‹ä»¶ï¼ˆTransfer/Approvalï¼‰ã€‚",
    cube_dev_title: "å¼€å‘å·¥å…·",
    cube_dev_desc: "ä¹¦ç­¾è„šæœ¬ç”Ÿæˆå™¨ + æœ¬åœ°åˆçº¦ç›‘æŽ§ï¼ˆæ— æœåŠ¡å™¨ï¼‰ã€‚",

    // tile badges
    badge_fast: "å¿«é€Ÿ",
    badge_share: "åˆ†äº«",
    badge_cache: "ç¼“å­˜",
    badge_dex: "DEX",
    badge_pairs: "äº¤æ˜“å¯¹",
    badge_wallet: "é’±åŒ…",
    badge_safe: "å®‰å…¨",
    badge_copy: "å¤åˆ¶",
    badge_dev: "å¼€å‘",
    badge_decode: "è§£ç ",
    badge_receipt: "å›žæ‰§",
    badge_events: "äº‹ä»¶",
    badge_tools: "å·¥å…·",
    badge_bookmarklet: "ä¹¦ç­¾è„šæœ¬",
    badge_local: "æœ¬åœ°",

    // generic
    pill_wallet: "é’±åŒ…",
    btn_close: "å…³é—­",
    btn_save: "ä¿å­˜",
    btn_clear: "æ¸…é™¤",
    btn_scan: "æ‰«æ",
    btn_decode: "è§£ç ",
    btn_copy_md: "å¤åˆ¶ Markdown",
    btn_copy_link: "å¤åˆ¶åˆ†äº«é“¾æŽ¥",
    btn_copy_json: "å¤åˆ¶ JSON",
    btn_copy_xtext: "å¤åˆ¶ X æ–‡æ¡ˆ",

    // quick panel
    p_quick_kicker: "å¿«é€Ÿæ‰«æ",
    p_quick_title: "å‡ ç§’å†…ç»™ä»£å¸æ‰“åˆ†",
    p_quick_sub:
      "ç²˜è´´ä»£å¸åœ°å€ï¼Œé€‰æ‹©ç½‘ç»œå¹¶æ‰«æã€‚ç¼“å­˜ 10 åˆ†é’Ÿã€‚å¯ç”Ÿæˆå¯åˆ†äº«æ–‡æœ¬ + JSON + Markdownã€‚",
    quick_input_title: "ä»£å¸è¾“å…¥",
    net_label: "ç½‘ç»œ",
    addr_label: "ä»£å¸åˆçº¦",
    qs_tip:
      'æç¤ºï¼šå¯ç”¨ <span class="mono">?tool=quick&net=bsc&token=0x...</span> æ‰“å¼€è‡ªåŠ¨è¿è¡Œï¼ˆé™é€Ÿï¼‰ã€‚',
    options_label: "é€‰é¡¹",
    opt_require_liq: "è¦æ±‚æœ‰æµåŠ¨æ€§ï¼ˆæ›´ä¸¥æ ¼è¯„åˆ†ï¼‰",
    opt_show_json: "å¯ç”¨ JSON æŠ¥å‘Šï¼ˆå¯å¤åˆ¶ï¼‰",
    api_keys_label: "åŒºå—æµè§ˆå™¨ API Keyï¼ˆå¯é€‰ï¼‰",
    opt_use_explorer_apis: "ä½¿ç”¨ BscScan/Etherscanï¼ˆå¢žåŠ  Verified + ABI è§„åˆ™ï¼‰",
    api_keys_tip:
      "Key ä»…ä¿å­˜åœ¨æµè§ˆå™¨æœ¬åœ°ï¼ˆlocalStorageï¼‰ã€‚ä¸è¦æŠŠ Key å†™è¿›å…¬å¼€ HTMLã€‚",
    results_title: "ç»“æžœ",
    results_hint:
      "ç»¿è‰² / é»„è‰² / çº¢è‰²ä¿¡å·ã€‚ä¸æ˜¯ä¿è¯â€”â€”åªæ˜¯å¯éªŒè¯çš„é“¾ä¸Šæ£€æŸ¥ã€‚",

    // liquidity panel
    p_liq_kicker: "ä»£å¸ + æµåŠ¨æ€§æ‰«æ",
    p_liq_title: "DEX æ³¨å†Œè¡¨æµåŠ¨æ€§æ£€æŸ¥",
    p_liq_sub:
      "æ£€æŸ¥ PancakeSwapï¼ˆBSCï¼‰/ Uniswapï¼ˆETHï¼‰V2 + V3 å·¥åŽ‚ã€‚æµ‹è¯•äº¤æ˜“å¯¹ï¼šä»£å¸ vs WBNB/WETH ä¸Žä»£å¸ vs USDTã€‚",
    liq_input_title: "ä»£å¸ + ç½‘ç»œ",
    liq_tip:
      'æç¤ºï¼šå¯ç”¨ <span class="mono">?tool=liq&net=bsc&token=0x...</span> æ‰“å¼€è‡ªåŠ¨è¿è¡Œã€‚',
    liq_dex_label: "DEX æ³¨å†Œè¡¨ï¼ˆå·²æ£€æŸ¥ï¼‰",
    liq_results_title: "æµåŠ¨æ€§ç»“æžœ",
    liq_results_hint:
      "V2ï¼šäº¤æ˜“å¯¹ + å‚¨å¤‡å¿«ç…§ã€‚V3ï¼šæ± å­å­˜åœ¨æ€§ + liquidity() + slot0 tick å¿«ç…§ã€‚",

    // approvals panel
    p_app_kicker: "æŽˆæƒå«å£«",
    p_app_title: "æ£€æŸ¥å¹¶æ’¤é”€æŽˆæƒ",
    p_app_sub:
      "å¡«å†™ spender + ä»£å¸åˆ—è¡¨ï¼ˆæˆ–ä¸€é”®å¡«å…¥å¸¸ç”¨ä»£å¸ï¼‰ã€‚è¯»å– allowance(owner, spender)ï¼Œå¹¶ç”¨ approve(spender, 0) æ’¤é”€ã€‚",
    ap_settings_title: "è®¾ç½®",
    ap_connected: "å·²è¿žæŽ¥ï¼š",
    ap_connect: "è¿žæŽ¥ / åˆ·æ–°",
    ap_spender_label: "Spender é¢„è®¾",
    ap_spender_tip: "å…ˆé€‰è·¯ç”±é¢„è®¾ï¼Œå†æ·»åŠ ä½ æƒ³æ¸…ç†çš„ä»£å¸ã€‚",
    ap_tokens_label: "ä»£å¸åˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰",
    ap_seed: "å¡«å…¥å¸¸ç”¨ä»£å¸",
    ap_seed_history: "ä½¿ç”¨æ‰«æåŽ†å²",
    ap_check: "æ£€æŸ¥æŽˆæƒ",
    ap_revoke_all: "æ’¤é”€å…¨éƒ¨ï¼ˆéžé›¶ï¼‰",
    ap_results: "æŽˆæƒåˆ—è¡¨",
    ap_results_hint:
      "è‹¥æŽˆæƒä¸ºâ€œæ— é™â€ï¼Œé™¤éžä½ å®Œå…¨ä¿¡ä»»è¯¥ spenderï¼Œå¦åˆ™å»ºè®®æ’¤é”€ã€‚",
    safe_mode_note:
      "å®‰å…¨æ¨¡å¼ï¼šéœ€è¦ç­¾åçš„æ“ä½œä¼šåœ¨è¿žæŽ¥é’±åŒ…å‰è¢«ç¦ç”¨ã€‚",
    // DNAï¼ˆé’±åŒ…å®‰å…¨ DNAï¼‰
p_dna_kicker: "é’±åŒ…å®‰å…¨ DNA",
p_dna_title: "é’±åŒ…å®‰å…¨ DNA",
p_dna_sub: "æŽˆæƒä¸Žæƒé™é£Žé™©å¿«ç…§",

pill_wallet: "é’±åŒ…",
wallet_not_connected: "æœªè¿žæŽ¥",
btn_close: "å…³é—­",

dna_controls_title: "DNA æ‰«æ",
dna_wallet_address_label: "é’±åŒ…åœ°å€",
dna_wallet_address_ph: "0x...ï¼ˆå¯é€‰ï¼Œè¿žæŽ¥é’±åŒ…åŽå¯è‡ªåŠ¨å¡«å…¥ï¼‰",
dna_wallet_address_tip: "å¯å…ˆç”¨åœ°å€æ‰«æã€‚ä»…åœ¨éœ€è¦æ’¤é”€æ—¶å†è¿žæŽ¥é’±åŒ…ã€‚",

net_label: "ç½‘ç»œ",
net_bsc: "BSCï¼ˆBNB Chainï¼‰",
net_eth: "ä»¥å¤ªåŠ",
net_polygon: "Polygon",

dna_connected: "å·²è¿žæŽ¥ï¼š",
dna_connect: "è¿žæŽ¥é’±åŒ…",
dna_run: "æ‰«æ",
dna_reset: "é‡ç½®",

dna_results_title: "é’±åŒ…å®‰å…¨ DNA",
dna_results_hint: "è¯„åˆ†æ˜¯å¿«ç…§ã€‚ç­¾åå‰è¯·åŠ¡å¿…è‡ªè¡Œæ ¸å®žã€‚",

dna_score: "è¯„åˆ†",
dna_risk_level: "é£Žé™©",

dna_tips_title: "æç¤º",
dna_tips_placeholder: "â€”",
dna_share: "åˆ†äº«è¯„åˆ†",

dna_allowances_title: "æŽˆæƒ",
dna_table_note: "æç¤ºï¼šä¸å®Œå…¨ä¿¡ä»»çš„â€œæ— é™â€æŽˆæƒå»ºè®®æ’¤é”€ã€‚Verified ä¸Ž Flags ä»…ä¾›å‚è€ƒã€‚",


    // rpc panel
    p_rpc_kicker: "RPC å¥åº·æ£€æµ‹",
    p_rpc_title: "æ‰¾åˆ°æœ€ä½³èŠ‚ç‚¹",
    p_rpc_sub:
      "æµ‹è¯• RPCï¼šå»¶è¿Ÿ + chainId + åŒºå— + eth_call + è¯»å– logsã€‚åŒ…å«å¼€å‘è€…è‡ªå®šä¹‰ logs æµ‹è¯•ï¼Œå¹¶æŠŠæœ€ä½³ RPC å­˜åˆ°æœ¬åœ°ã€‚",
    rpc_inputs: "è¾“å…¥",
    rpc_private_label: "ç§æœ‰ RPCï¼ˆæœ¬åœ°ä¿å­˜ï¼‰",
    rpc_private_tip:
      "ä¸ä¼šå†™è¿› HTMLï¼Œåªä¿å­˜åœ¨ä½ çš„æµè§ˆå™¨ï¼ˆlocalStorageï¼‰ã€‚",
    rpc_custom_label: "å¯é€‰è‡ªå®šä¹‰ RPCï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰",
    rpc_test: "æµ‹è¯• RPC",
    rpc_copy_best: "å¤åˆ¶æœ€ä½³ RPC",
    rpc_results: "ç»“æžœ",
    rpc_tip:
      "æç¤ºï¼šéƒ¨åˆ† RPC ä¼šå›  CORS/è¶…æ—¶å¤±è´¥ã€‚è¿è¡Œæµ‹è¯•å¹¶é€‰æ‹©ç¨³å®šä¸”æœ€å¿«çš„ã€‚",
    rpc_dev_title: "å¼€å‘è€…è‡ªå®šä¹‰ logs æµ‹è¯•",
    rpc_dev_hint:
      "å¯é€‰ï¼šå¯¹æŸåˆçº¦æµ‹è¯• logsï¼Œå¸®åŠ©å¼€å‘è€…éªŒè¯ RPC çš„ç¨³å®šæ€§ã€‚",
    rpc_dev_addr: "åˆçº¦åœ°å€ï¼ˆå¯é€‰ï¼‰",
    rpc_dev_topic: "Topic0ï¼ˆå¯é€‰ï¼‰",
    rpc_dev_run: "è¿è¡Œè‡ªå®šä¹‰æµ‹è¯•",

    // tx panel
    p_tx_kicker: "äº¤æ˜“è§£ç ",
    p_tx_title: "è§£ç ä¸€ç¬”äº¤æ˜“",
    p_tx_sub:
      "ç²˜è´´äº¤æ˜“å“ˆå¸Œã€‚èŽ·å– tx + receiptï¼Œå¹¶è§£ç å¸¸è§è¾“å…¥ä¸Žäº‹ä»¶ï¼ˆTransfer / Approval + å¸¸è§ swap è°ƒç”¨ï¼‰ã€‚",
    tx_input_title: "äº¤æ˜“è¾“å…¥",
    tx_hash_label: "äº¤æ˜“å“ˆå¸Œ",
    tx_tip:
      'æç¤ºï¼šå¯ç”¨ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> æ‰“å¼€è‡ªåŠ¨è¿è¡Œã€‚',
    tx_results_title: "è§£ç è¾“å‡º",

    // dev panel
    p_dev_kicker: "å¼€å‘å·¥å…·",
    p_dev_title: "ä¹¦ç­¾è„šæœ¬ + æœ¬åœ°ç›‘æŽ§",
    p_dev_sub:
      "ç”Ÿæˆä¹¦ç­¾è„šæœ¬ï¼ŒæŠŠæµè§ˆå™¨é¡µé¢ä¸Šçš„ä»£å¸/äº¤æ˜“ä¸€é”®å‘é€åˆ° CycleX Hubã€‚ä¹ŸåŒ…å«æœ¬åœ°åˆçº¦ç›‘æŽ§ï¼ˆåˆ—è¡¨ä¿å­˜åœ¨æµè§ˆå™¨ï¼‰ã€‚",
    bm_title: "ä¹¦ç­¾è„šæœ¬ç”Ÿæˆå™¨",
    bm_hint:
      "æ‹–åˆ°ä¹¦ç­¾æ æˆ–å¤åˆ¶ç”Ÿæˆçš„ä¹¦ç­¾è„šæœ¬ã€‚åœ¨ BscScan/Etherscan é¡µé¢ä½¿ç”¨ã€‚",
    bm_base_label: "Hub URLï¼ˆå½“å‰é¡µé¢ï¼‰",
    bm_generate: "ç”Ÿæˆ",
    bm_copy: "å¤åˆ¶ä¹¦ç­¾è„šæœ¬",

    mon_add_title: "åŠ å…¥ç›‘æŽ§åˆ—è¡¨",
    mon_list_title: "åˆçº¦ç›‘æŽ§ï¼ˆæœ¬åœ°ï¼‰",
    mon_list_hint: "ä»…æœ¬åœ°ä¿å­˜ã€‚æ— æœåŠ¡å™¨è·Ÿè¸ªã€‚",
    mon_add: "æ·»åŠ ",
    mon_check: "å…¨éƒ¨æ£€æŸ¥",
    mon_export: "å¤åˆ¶ JSON",

    // footer
    footer_left: "CycleX å®‰å…¨ä¸­å¿ƒåœ¨æœ¬åœ°è¿è¡Œï¼Œè¯»å–å…¬å¼€é“¾ä¸Šæ•°æ®ã€‚",
    footer_tagline: "å¤šéªŒè¯ä¸€æ¬¡ã€‚åªåœ¨ä¿¡ä»»é¡µé¢æ—¶è¿žæŽ¥é’±åŒ…ã€‚",
    // --- ADD THESE KEYS (ZH) ---
title_back_to_cyclex: "è¿”å›ž CycleX",
aria_lang_selector: "è¯­è¨€é€‰æ‹©",
badge_table: "è¡¨æ ¼",
btn_share_x: "åˆ†äº«åˆ° X",
btn_share_tg: "åˆ†äº«åˆ° Telegram",
net_bsc: "BSCï¼ˆBNB Chainï¼‰",
net_eth: "ä»¥å¤ªåŠ",
spender_pcs_router: "PancakeSwap è·¯ç”±å™¨ï¼ˆBSCï¼‰",
spender_uni_router: "Uniswap V2 è·¯ç”±å™¨ï¼ˆETHï¼‰",
spender_custom: "è‡ªå®šä¹‰â€¦",

th_token: "ä»£å¸",
th_allowance: "æŽˆæƒé¢åº¦",
th_symbol: "ç¬¦å·",
th_action: "æ“ä½œ",
th_rpc: "RPC",
th_ms: "æ¯«ç§’",
th_chain: "é“¾",
th_block: "åŒºå—",
th_call: "è°ƒç”¨",
th_logs: "æ—¥å¿—",
th_status: "çŠ¶æ€",
th_contract: "åˆçº¦",
th_network: "ç½‘ç»œ",
th_last_seen: "ä¸Šæ¬¡å‡ºçŽ°",
    th_remove: "ç§»é™¤",
    bm_tip: "å°†ä¹¦ç­¾å°å·¥å…·æ·»åŠ åˆ°æµè§ˆå™¨ï¼Œç„¶åŽä¸€é”®ä»Žä»»ä½•ç½‘ç«™æ£€æŸ¥ä»»ä½•åˆçº¦ã€‚",
bm_drag_label: "CycleX â€“ å®‰å…¨ä¸­å¿ƒ",

qs_ready_html: "<strong>å‡†å¤‡å°±ç»ªã€‚</strong><br>ç²˜è´´ä»£å¸åœ°å€å¹¶ç‚¹å‡» <b>æ‰«æ</b>ã€‚",
liq_ready_html: "<strong>å‡†å¤‡å°±ç»ªã€‚</strong><br>ç²˜è´´ä»£å¸åœ°å€å¹¶ç‚¹å‡» <b>æ‰«æ</b>ã€‚",
tx_ready_html: "<strong>å‡†å¤‡å°±ç»ªã€‚</strong><br>ç²˜è´´äº¤æ˜“å“ˆå¸Œå¹¶ç‚¹å‡» <b>è§£ç </b>ã€‚",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API Keyï¼ˆæœ¬åœ°ä¿å­˜ï¼‰",
ph_etherscan_key: "Etherscan API Keyï¼ˆæœ¬åœ°ä¿å­˜ï¼‰",
ph_rpc_private: "https://...ï¼ˆä»…æœ¬åœ°ä¿å­˜ï¼‰",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad...ï¼ˆTransferï¼‰æˆ–ç•™ç©º"

  },

  ar: {
    // header / hero
    brand_sub: "Ø£Ù…Ø§Ù† ÙˆÙ…ÙƒØ§ÙØ¢Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
    hero_kicker: "Ù…Ø±ÙƒØ² Ø§Ù„Ø£Ù…Ø§Ù†",
    hero_title: "Ø£Ø¯ÙˆØ§Øª CycleX Ø§Ù„Ø£Ù…Ù†ÙŠØ©",
    hero_subtitle:
      "Ù…Ø¬Ù…ÙˆØ¹Ø© Ø®ÙÙŠÙØ© ØªØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­: swaps Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹ØŒ Ø¥Ø¯Ø§Ø±Ø© approvalsØŒ ÙØ­Øµ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©ØŒ ØµØ­Ø© RPCØŒ ÙˆÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¹Ø¨Ø± BSC + Ethereum.",
    btn_back: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆÙ‚Ø¹",
    btn_connect: "Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø­ÙØ¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    wallet_not_connected: "ØºÙŠØ± Ù…ØªØµÙ„",
    btn_quick: "ØªØ´ØºÙŠÙ„ ÙØ­Øµ Ø³Ø±ÙŠØ¹",
    hero_note:
      "Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ù‡ Ø§Ù„ÙØ­ÙˆØµØ§Øª Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠØ© ÙˆÙ„Ø§ ØªØ¶Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù†. ØªØ­Ù‚Ù‚ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¨Ù†ÙØ³Ùƒ.",
    tools_kicker: "Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø©",

    // tiles
    cube_quick_title: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
    cube_quick_desc: "ÙØ­Øµ Ø³Ø±ÙŠØ¹ Ù„Ù„ØªÙˆÙƒÙ† + ØªÙ‚Ø±ÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© + ÙƒØ§Ø´.",
    cube_liq_title: "ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ† + Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
    cube_liq_desc: "ÙØ­Øµ DEX (Pancake/Uni): Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù‚Ø§Ø¨Ù„ WBNB/WETH Ùˆ USDT.",
    cube_approvals_title: "Ø­Ø§Ø±Ø³ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    cube_approvals_desc: "ØªØ­Ù‚Ù‚ ÙˆØ£Ù„ØºÙ ØµÙ„Ø§Ø­ÙŠØ§Øª ERC-20 Ø¨Ø£Ù…Ø§Ù† (approve â†’ 0).",
    cube_rpc_title: "ÙØ­Øµ ØµØ­Ø© RPC",
    cube_rpc_desc: "Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© + chainId + Ø¨Ù„ÙˆÙƒ + eth_call + Ù‚Ø±Ø§Ø¡Ø© logs + Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø·ÙˆÙ‘Ø±.",
    cube_tx_title: "ÙÙƒ ØªØ´ÙÙŠØ± Tx",
    cube_tx_desc: "ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª + Ø£Ø­Ø¯Ø§Ø« Ø´Ø§Ø¦Ø¹Ø© (Transfer/Approval) Ù…Ù† tx hash.",
    cube_dev_title: "Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·ÙˆÙ‘Ø±",
    cube_dev_desc: "Ù…ÙˆÙ„Ù‘Ø¯ Bookmarklet + Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ù‚Ø¯ Ù…Ø­Ù„ÙŠØ© (Ø¨Ø¯ÙˆÙ† Ø³ÙŠØ±ÙØ±).",

    // tile badges
    badge_fast: "Ø³Ø±ÙŠØ¹",
    badge_share: "Ù…Ø´Ø§Ø±ÙƒØ©",
    badge_cache: "ÙƒØ§Ø´",
    badge_dex: "DEX",
    badge_pairs: "Ø£Ø²ÙˆØ§Ø¬",
    badge_wallet: "Ù…Ø­ÙØ¸Ø©",
    badge_safe: "Ø¢Ù…Ù†",
    badge_copy: "Ù†Ø³Ø®",
    badge_dev: "Ù…Ø·ÙˆÙ‘Ø±",
    badge_decode: "ÙÙƒ",
    badge_receipt: "Ø¥ÙŠØµØ§Ù„",
    badge_events: "Ø£Ø­Ø¯Ø§Ø«",
    badge_tools: "Ø£Ø¯ÙˆØ§Øª",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Ù…Ø­Ù„ÙŠ",

    // generic
    pill_wallet: "Ù…Ø­ÙØ¸Ø©",
    btn_close: "Ø¥ØºÙ„Ø§Ù‚",
    btn_save: "Ø­ÙØ¸",
    btn_clear: "Ù…Ø³Ø­",
    btn_scan: "ÙØ­Øµ",
    btn_decode: "ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±",
    btn_copy_md: "Ù†Ø³Ø® Markdown",
    btn_copy_link: "Ù†Ø³Ø® Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©",
    btn_copy_json: "Ù†Ø³Ø® JSON",
    btn_copy_xtext: "Ù†Ø³Ø® Ù†Øµ X",

    // quick panel
    p_quick_kicker: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
    p_quick_title: "Ù‚ÙŠÙ‘Ù… ØªÙˆÙƒÙ† Ø®Ù„Ø§Ù„ Ø«ÙˆØ§Ù†Ù",
    p_quick_sub:
      "Ø£Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ†ØŒ Ø§Ø®ØªØ± Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ Ø´ØºÙ‘Ù„ Ø§Ù„ÙØ­Øµ. ÙŠÙØ­ÙØ¸ Ø¨Ø§Ù„ÙƒØ§Ø´ Ù„Ù…Ø¯Ø© 10 Ø¯Ù‚Ø§Ø¦Ù‚. Ø£Ù†Ø´Ø¦ Ù†ØµØ§Ù‹ Ù‚Ø§Ø¨Ù„Ø§Ù‹ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© + JSON + Markdown.",
    quick_input_title: "Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†",
    net_label: "Ø§Ù„Ø´Ø¨ÙƒØ©",
    addr_label: "Ø¹Ù‚Ø¯ Ø§Ù„ØªÙˆÙƒÙ†",
    qs_tip:
      'Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ <span class="mono">?tool=quick&net=bsc&token=0x...</span> Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ (Ù…Ø­Ø¯ÙˆØ¯).',
    options_label: "Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª",
    opt_require_liq: "ÙŠØªØ·Ù„Ø¨ Ø³ÙŠÙˆÙ„Ø© (ØªÙ‚ÙŠÙŠÙ… Ø£ÙƒØ«Ø± ØµØ±Ø§Ù…Ø©)",
    opt_show_json: "ØªÙØ¹ÙŠÙ„ ØªÙ‚Ø±ÙŠØ± JSON (Ù†Ø³Ø®)",
    api_keys_label: "Ù…ÙØ§ØªÙŠØ­ API Ù„Ù„Ù…Ø³ØªÙƒØ´Ù (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    opt_use_explorer_apis: "Ø§Ø³ØªØ®Ø¯Ø§Ù… BscScan/Etherscan (ÙŠØ²ÙŠØ¯ Verified + Ù‚ÙˆØ§Ø¹Ø¯ ABI)",
    api_keys_tip:
      "Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ØªÙØ­ÙØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ (localStorage) ÙÙ‚Ø·. Ù„Ø§ ØªØ¶Ø¹Ù‡Ø§ Ø¯Ø§Ø®Ù„ HTML Ø¹Ø§Ù….",
    results_title: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
    results_hint:
      "Ø¥Ø´Ø§Ø±Ø§Øª Ø®Ø¶Ø±Ø§Ø¡/ØµÙØ±Ø§Ø¡/Ø­Ù…Ø±Ø§Ø¡. Ù„ÙŠØ³Øª Ø¶Ù…Ø§Ù†Ø§Ù‹ â€” Ù…Ø¬Ø±Ø¯ ÙØ­ÙˆØµØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚.",

    // liquidity panel
    p_liq_kicker: "ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ† + Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
    p_liq_title: "ÙØ­Øµ Ø³ÙŠÙˆÙ„Ø© DEX",
    p_liq_sub:
      "Ù†ÙØ¬Ø±ÙŠ ÙØ­Øµ PancakeSwap (BSC) / Uniswap (ETH) V2 + V3. Ø§Ù„Ø£Ø²ÙˆØ§Ø¬: Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù‚Ø§Ø¨Ù„ WBNB/WETH Ùˆ USDT.",
    liq_input_title: "ØªÙˆÙƒÙ† + Ø´Ø¨ÙƒØ©",
    liq_tip:
      'Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ <span class="mono">?tool=liq&net=bsc&token=0x...</span> Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.',
    liq_dex_label: "Ø³Ø¬Ù„ DEX (Ù…ÙØ­ÙˆØµ)",
    liq_results_title: "Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
    liq_results_hint:
      "V2: Ø²ÙˆØ¬ + Ù„Ù‚Ø·Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ. V3: ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø­ÙˆØ¶ + liquidity() + Ù„Ù‚Ø·Ø© slot0/tick.",

    // approvals panel
    p_app_kicker: "Ø­Ø§Ø±Ø³ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    p_app_title: "ØªØ­Ù‚Ù‚ ÙˆØ£Ù„ØºÙ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    p_app_sub:
      "Ø£Ø¯Ø®Ù„ spender + Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (Ø£Ùˆ Ø£Ø¶Ù Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©). Ù†Ù‚Ø±Ø£ allowance(owner, spender) ÙˆÙ†Ù„ØºÙŠ Ø¹Ø¨Ø± approve(spender, 0).",
    ap_settings_title: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
    ap_connected: "Ù…ØªØµÙ„:",
    ap_connect: "Ø§ØªØµØ§Ù„ / ØªØ­Ø¯ÙŠØ«",
    ap_spender_label: "Ø¥Ø¹Ø¯Ø§Ø¯ spender",
    ap_spender_tip:
      "Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø®ØªÙŠØ§Ø± Ø±Ø§ÙˆØªØ± Ø¬Ø§Ù‡Ø²ØŒ Ø«Ù… Ø£Ø¶Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªÙ†Ø¸ÙŠÙÙ‡Ø§.",
    ap_tokens_label: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (ÙƒÙ„ Ø³Ø·Ø± Ø¹Ù†ÙˆØ§Ù†)",
    ap_seed: "Ø¥Ø¶Ø§ÙØ© ØªÙˆÙƒÙ†Ø§Øª Ø´Ø§Ø¦Ø¹Ø©",
    ap_seed_history: "Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø¬Ù„ Ø§Ù„ÙØ­Øµ",
    ap_check: "ÙØ­Øµ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    ap_revoke_all: "Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„ (ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ©)",
    ap_results: "Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
    ap_results_hint:
      "Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© â€œØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©â€ØŒ ÙŠÙÙ†ØµØ­ Ø¨Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ù…Ø§ Ù„Ù… ØªÙƒÙ† ØªØ«Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹ Ø¨Ø§Ù„Ù€ spender.",
    safe_mode_note:
      "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¢Ù…Ù†: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØªØ·Ù„Ø¨ ØªÙˆÙ‚ÙŠØ¹Ø§Ù‹ Ù…Ø¹Ø·Ù„Ø© Ø­ØªÙ‰ ØªØªØµÙ„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø©.",
    // DNA (Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©)
p_dna_kicker: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
p_dna_title: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
p_dna_sub: "Ù„Ù‚Ø·Ø© Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª ÙˆØ§Ù„Ø£Ø°ÙˆÙ†Ø§Øª",

pill_wallet: "Ø§Ù„Ù…Ø­ÙØ¸Ø©",
wallet_not_connected: "ØºÙŠØ± Ù…ØªØµÙ„",
btn_close: "Ø¥ØºÙ„Ø§Ù‚",

dna_controls_title: "ÙØ­Øµ DNA",
dna_wallet_address_label: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
dna_wallet_address_ph: "0x... (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ø¥Ø°Ø§ Ù‚Ù…Øª Ø¨Ø§Ù„Ø§ØªØµØ§Ù„)",
dna_wallet_address_tip: "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ÙØ­Øµ Ø¨Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø£ÙˆÙ„Ø§Ù‹. Ø§ØªØµÙ„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø© ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø±ØºØ¨ØªÙƒ ÙÙŠ Ø§Ù„Ø¥Ù„ØºØ§Ø¡.",

net_label: "Ø§Ù„Ø´Ø¨ÙƒØ©",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Ù…ØªØµÙ„:",
dna_connect: "Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø©",
dna_run: "ÙØ­Øµ",
dna_reset: "Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·",

dna_results_title: "Ø¨ØµÙ…Ø© Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø­ÙØ¸Ø©",
dna_results_hint: "Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù‚Ø·Ø© Ø³Ø±ÙŠØ¹Ø©. ØªØ­Ù‚Ù‘Ù‚ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„ØªÙˆÙ‚ÙŠØ¹.",

dna_score: "Ø§Ù„Ù†ØªÙŠØ¬Ø©",
dna_risk_level: "Ø§Ù„Ù…Ø®Ø§Ø·Ø±",

dna_tips_title: "Ù†ØµØ§Ø¦Ø­",
dna_tips_placeholder: "â€”",
dna_share: "Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù†ØªÙŠØ¬Ø©",

dna_allowances_title: "Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª",
dna_table_note: "Ù†ØµÙŠØ­Ø©: Ø£Ù„ØºÙ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª â€œØºÙŠØ± Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯Ø©â€ Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ«Ù‚ Ø¨Ù‡Ø§ ØªÙ…Ø§Ù…Ø§Ù‹. Ø­Ø§Ù„Ø© Verified Ùˆ Flags Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠØ© ÙÙ‚Ø·.",


    // rpc panel
    p_rpc_kicker: "ÙØ­Øµ ØµØ­Ø© RPC",
    p_rpc_title: "Ø§Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Endpoint",
    p_rpc_sub:
      "Ù†Ø®ØªØ¨Ø± RPC: Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© + chainId + Ø¨Ù„ÙˆÙƒ + eth_call + Ù‚Ø±Ø§Ø¡Ø© logs. ÙŠØªØ¶Ù…Ù† Ø§Ø®ØªØ¨Ø§Ø± logs Ù„Ù„Ù…Ø·ÙˆØ± ÙˆÙŠØ­ÙØ¸ Ø£ÙØ¶Ù„ RPC Ù…Ø­Ù„ÙŠØ§Ù‹.",
    rpc_inputs: "Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª",
    rpc_private_label: "RPC Ø®Ø§Øµ (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
    rpc_private_tip:
      "ØºÙŠØ± Ù…Ø¯Ù…Ø¬ ÙÙŠ HTML. Ù…Ø­ÙÙˆØ¸ ÙÙŠ Ù…ØªØµÙØ­Ùƒ ÙÙ‚Ø· (localStorage).",
    rpc_custom_label: "RPC Ù…Ø®ØµØµ (Ø£ÙˆÙ„ÙˆÙŠØ© Ø£Ø¹Ù„Ù‰)",
    rpc_test: "Ø§Ø®ØªØ¨Ø§Ø± RPCs",
    rpc_copy_best: "Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC",
    rpc_results: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
    rpc_tip:
      "Ù†ØµÙŠØ­Ø©: Ø¨Ø¹Ø¶ RPCs ØªÙØ´Ù„ Ø¨Ø³Ø¨Ø¨ CORS/Ù…Ù‡Ù„Ø©. Ø´ØºÙ‘Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ø®ØªØ± Ø§Ù„Ø£Ø³Ø±Ø¹ ÙˆØ§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªÙ‚Ø±Ø§Ø±Ø§Ù‹.",
    rpc_dev_title: "Ø§Ø®ØªØ¨Ø§Ø± logs Ù…Ø®ØµØµ Ù„Ù„Ù…Ø·ÙˆØ±",
    rpc_dev_hint:
      "Ø§Ø®ØªÙŠØ§Ø±ÙŠ: Ø§Ø®ØªØ¨Ø± logs Ù„Ø¹Ù‚Ø¯ Ù…Ø­Ø¯Ø¯ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ù€ RPC.",
    rpc_dev_addr: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¹Ù‚Ø¯ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    rpc_dev_topic: "Topic0 (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
    rpc_dev_run: "ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±",

    // tx panel
    p_tx_kicker: "ÙÙƒ ØªØ´ÙÙŠØ± Tx",
    p_tx_title: "ÙÙƒ ØªØ´ÙÙŠØ± Ù…Ø¹Ø§Ù…Ù„Ø©",
    p_tx_sub:
      "Ø£Ù„ØµÙ‚ tx hash. Ù†Ø¬Ù„Ø¨ tx + receipt ÙˆÙ†ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© (Transfer / Approval + Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª swap).",
    tx_input_title: "Ø¥Ø¯Ø®Ø§Ù„ Tx",
    tx_hash_label: "Ù‡Ø§Ø´ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©",
    tx_tip:
      'Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.',
    tx_results_title: "Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª",

    // dev panel
    p_dev_kicker: "Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·ÙˆÙ‘Ø±",
    p_dev_title: "Bookmarklet + Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø­Ù„ÙŠØ©",
    p_dev_sub:
      "Ø£Ù†Ø´Ø¦ Bookmarklet ÙŠØ±Ø³Ù„ Ø§Ù„ØªÙˆÙƒÙ†/Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªÙƒØ´Ù Ø¥Ù„Ù‰ CycleX Hub. ÙˆÙŠØªØ¶Ù…Ù† Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ù‚Ø¯ Ù…Ø­Ù„ÙŠØ© (Ù‚Ø§Ø¦Ù…Ø© Ù…Ø­ÙÙˆØ¸Ø© ÙÙŠ Ù…ØªØµÙØ­Ùƒ).",
    bm_title: "Ù…ÙˆÙ„Ù‘Ø¯ Bookmarklet",
    bm_hint:
      "Ø§Ø³Ø­Ø¨ Ø¥Ù„Ù‰ Ø´Ø±ÙŠØ· Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø£Ùˆ Ø§Ù†Ø³Ø® Ø§Ù„Ù€ Bookmarklet. Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙŠ ØµÙØ­Ø§Øª BscScan/Etherscan.",
    bm_base_label: "Ø±Ø§Ø¨Ø· Hub (Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©)",
    bm_generate: "Ø¥Ù†Ø´Ø§Ø¡",
    bm_copy: "Ù†Ø³Ø® Bookmarklet",

    mon_add_title: "Ø¥Ø¶Ø§ÙØ© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©",
    mon_list_title: "Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù‚ÙˆØ¯ (Ù…Ø­Ù„ÙŠ)",
    mon_list_hint: "Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙ‚Ø·. Ø¨Ø¯ÙˆÙ† ØªØªØ¨Ø¹ Ø³ÙŠØ±ÙØ±.",
    mon_add: "Ø¥Ø¶Ø§ÙØ©",
    mon_check: "ÙØ­Øµ Ø§Ù„ÙƒÙ„",
    mon_export: "Ù†Ø³Ø® JSON",

    // footer
    footer_left:
      "CycleX Security Hub ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆÙŠÙ‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
    footer_tagline: "ØªØ­Ù‚Ù‚ Ù…Ø±ØªÙŠÙ†. Ù„Ø§ ØªØªØµÙ„ Ø¥Ù„Ø§ Ø¹Ù†Ø¯Ù…Ø§ ØªØ«Ù‚ Ø¨Ø§Ù„ØµÙØ­Ø©.",
    // --- ADD THESE KEYS (AR) ---
title_back_to_cyclex: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ CycleX",
aria_lang_selector: "Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©",
badge_table: "Ø¬Ø¯ÙˆÙ„",
btn_share_x: "Ù…Ø´Ø§Ø±ÙƒØ© Ø¹Ù„Ù‰ X",
btn_share_tg: "Ù…Ø´Ø§Ø±ÙƒØ© Ø¹Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ø¥ÙŠØ«Ø±ÙŠÙˆÙ…",
spender_pcs_router: "Ø±Ø§ÙˆØªØ± PancakeSwap (BSC)",
spender_uni_router: "Ø±Ø§ÙˆØªØ± Uniswap V2 (ETH)",
spender_custom: "Ù…Ø®ØµØµâ€¦",

th_token: "Ø§Ù„ØªÙˆÙƒÙ†",
th_allowance: "Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©",
th_symbol: "Ø§Ù„Ø±Ù…Ø²",
th_action: "Ø¥Ø¬Ø±Ø§Ø¡",
th_rpc: "RPC",
th_ms: "Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©",
th_chain: "Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
th_block: "Ø¨Ù„ÙˆÙƒ",
th_call: "Ø§Ø³ØªØ¯Ø¹Ø§Ø¡",
th_logs: "Ø³Ø¬Ù„Ø§Øª",
th_status: "Ø§Ù„Ø­Ø§Ù„Ø©",
th_contract: "Ø§Ù„Ø¹Ù‚Ø¯",
th_network: "Ø§Ù„Ø´Ø¨ÙƒØ©",
th_last_seen: "Ø¢Ø®Ø± Ø¸Ù‡ÙˆØ±",
    th_remove: "Ø¥Ø²Ø§Ù„Ø©",
    bm_tip: "Ø£Ø¶ÙÙ Ø£Ø¯Ø§Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ù…Ø±Ø¬Ø¹ÙŠØ© Ø¥Ù„Ù‰ Ù…ØªØµÙØ­ÙƒØŒ Ø«Ù… Ø§ÙØ­Øµ Ø£ÙŠ Ø¹Ù‚Ø¯ Ù…Ù† Ø£ÙŠ Ù…ÙˆÙ‚Ø¹ Ø¨Ù†Ù‚Ø±Ø© ÙˆØ§Ø­Ø¯Ø©.",
bm_drag_label: "CycleX â€“ Ù…Ø±ÙƒØ² Ø§Ù„Ø£Ù…Ø§Ù†",

qs_ready_html: "<strong>Ø¬Ø§Ù‡Ø².</strong><br>Ø£Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ† Ø«Ù… Ø§Ø¶ØºØ· <b>ÙØ­Øµ</b>.",
liq_ready_html: "<strong>Ø¬Ø§Ù‡Ø².</strong><br>Ø£Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ† Ø«Ù… Ø§Ø¶ØºØ· <b>ÙØ­Øµ</b>.",
tx_ready_html: "<strong>Ø¬Ø§Ù‡Ø².</strong><br>Ø£Ù„ØµÙ‚ tx hash Ø«Ù… Ø§Ø¶ØºØ· <b>ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "Ù…ÙØªØ§Ø­ BscScan API (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
ph_etherscan_key: "Ù…ÙØªØ§Ø­ Etherscan API (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹)",
ph_rpc_private: "https://... (Ù…Ø­ÙÙˆØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙ‚Ø·)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) Ø£Ùˆ Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹"

  },

  ru: {
    // header / hero
    brand_sub: "ÐžÐ½Ñ‡ÐµÐ¹Ð½ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚ÑŒ Ð¸ Ð½Ð°Ð³Ñ€Ð°Ð´Ñ‹",
    hero_kicker: "Security Hub",
    hero_title: "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸ CycleX",
    hero_subtitle:
      "Ð›Ñ‘Ð³ÐºÐ¸Ð¹ ÐºÐ»Ð¸ÐµÐ½Ñ‚ÑÐºÐ¸Ð¹ Ð½Ð°Ð±Ð¾Ñ€: Ð±Ð¾Ð»ÐµÐµ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ñ‹Ðµ swaps, Ð³Ð¸Ð³Ð¸ÐµÐ½Ð° approvals, Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð»Ð¸ÐºÐ²Ð¸Ð´Ð½Ð¾ÑÑ‚Ð¸, Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ RPC Ð¸ Ð´ÐµÐºÐ¾Ð´ÐµÑ€ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹ Ð´Ð»Ñ BSC + Ethereum.",
    btn_back: "ÐÐ°Ð·Ð°Ð´ Ð½Ð° ÑÐ°Ð¹Ñ‚",
    btn_connect: "ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº (Ð¾Ð¿Ñ†.)",
    wallet_not_connected: "Ð½Ðµ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½",
    btn_quick: "Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ ÑÐºÐ°Ð½",
    hero_note:
      "Ð’Ð°Ð¶Ð½Ð¾: Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð¾ÑÑÑ‚ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ð¹ Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€ Ð¸ Ð½Ðµ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ñ€ÑƒÑŽÑ‚ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚ÑŒ. Ð’ÑÐµÐ³Ð´Ð° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ ÑÐ°Ð¼Ð¾ÑÑ‚Ð¾ÑÑ‚ÐµÐ»ÑŒÐ½Ð¾.",
    tools_kicker: "Ð’Ð«Ð‘Ð•Ð Ð˜Ð¢Ð• Ð˜ÐÐ¡Ð¢Ð Ð£ÐœÐ•ÐÐ¢",

    // tiles
    cube_quick_title: "Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ ÑÐºÐ°Ð½",
    cube_quick_desc: "Ð‘Ñ‹ÑÑ‚Ñ€Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ‚Ð¾ÐºÐµÐ½Ð° + ÑˆÐ°Ñ€Ð¸Ð¼Ñ‹Ð¹ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚ + ÐºÑÑˆ.",
    cube_liq_title: "Ð¢Ð¾ÐºÐµÐ½ + Ð»Ð¸ÐºÐ²Ð¸Ð´Ð½Ð¾ÑÑ‚ÑŒ",
    cube_liq_desc: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° DEX (Pancake/Uni): Ñ‚Ð¾ÐºÐµÐ½ vs WBNB/WETH Ð¸ USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc:
      "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¸ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ñ‹Ð¹ Ð¾Ñ‚Ð·Ñ‹Ð² ERC-20 allowance (approve â†’ 0).",
    cube_rpc_title: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° RPC",
    cube_rpc_desc:
      "Latency + chainId + block + eth_call + Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ logs + dev custom test.",
    cube_tx_title: "Ð”ÐµÐºÐ¾Ð´ÐµÑ€ Tx",
    cube_tx_desc:
      "Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€ÑƒÐµÑ‚ input Ð¸ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ (Transfer/Approval) Ð¿Ð¾ tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc:
      "Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ bookmarklet + Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ð¾Ð² (Ð±ÐµÐ· ÑÐµÑ€Ð²ÐµÑ€Ð°).",

    // tile badges
    badge_fast: "Ð‘Ñ‹ÑÑ‚Ñ€Ð¾",
    badge_share: "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ",
    badge_cache: "ÐšÑÑˆ",
    badge_dex: "DEX",
    badge_pairs: "ÐŸÐ°Ñ€Ñ‹",
    badge_wallet: "ÐšÐ¾ÑˆÐµÐ»Ñ‘Ðº",
    badge_safe: "Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾",
    badge_copy: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",

    // generic
    pill_wallet: "ÐšÐ¾ÑˆÐµÐ»Ñ‘Ðº",
    btn_close: "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ",
    btn_save: "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ",
    btn_clear: "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ",
    btn_scan: "Ð¡ÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
    btn_decode: "Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
    btn_copy_md: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Markdown",
    btn_copy_link: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÑÑ‹Ð»ÐºÑƒ",
    btn_copy_json: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ JSON",
    btn_copy_xtext: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚ Ð´Ð»Ñ X",

    // quick panel
    p_quick_kicker: "Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ ÑÐºÐ°Ð½",
    p_quick_title: "ÐžÑ†ÐµÐ½Ð¸Ñ‚Ðµ Ñ‚Ð¾ÐºÐµÐ½ Ð·Ð° ÑÐµÐºÑƒÐ½Ð´Ñ‹",
    p_quick_sub:
      "Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð°Ð´Ñ€ÐµÑ Ñ‚Ð¾ÐºÐµÐ½Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐµÑ‚ÑŒ Ð¸ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ ÑÐºÐ°Ð½. ÐšÑÑˆ Ð½Ð° 10 Ð¼Ð¸Ð½ÑƒÑ‚. Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ñ‚ÐµÐºÑÑ‚Ð° Ð´Ð»Ñ ÑˆÐ°Ñ€Ð¸Ð½Ð³Ð° + JSON + Markdown.",
    quick_input_title: "Ð’Ð²Ð¾Ð´ Ñ‚Ð¾ÐºÐµÐ½Ð°",
    net_label: "Ð¡ÐµÑ‚ÑŒ",
    addr_label: "ÐšÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚ Ñ‚Ð¾ÐºÐµÐ½Ð°",
    qs_tip:
      'Ð¡Ð¾Ð²ÐµÑ‚: Ð¾Ñ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ <span class="mono">?tool=quick&net=bsc&token=0x...</span> Ð´Ð»Ñ Ð°Ð²Ñ‚Ð¾-ÑÑ‚Ð°Ñ€Ñ‚Ð° (Ð»Ð¸Ð¼Ð¸Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾).',
    options_label: "ÐžÐ¿Ñ†Ð¸Ð¸",
    opt_require_liq: "Ð¢Ñ€ÐµÐ±Ð¾Ð²Ð°Ñ‚ÑŒ Ð»Ð¸ÐºÐ²Ð¸Ð´Ð½Ð¾ÑÑ‚ÑŒ (ÑÑ‚Ñ€Ð¾Ð¶Ðµ)",
    opt_show_json: "Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ JSON Ð¾Ñ‚Ñ‡Ñ‘Ñ‚ (ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ)",
    api_keys_label: "API ÐºÐ»ÑŽÑ‡Ð¸ Explorer (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
    opt_use_explorer_apis:
      "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ BscScan/Etherscan (Verified + ABI ÑÐ²Ñ€Ð¸ÑÑ‚Ð¸ÐºÐ¸)",
    api_keys_tip:
      "ÐšÐ»ÑŽÑ‡Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÑŽÑ‚ÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² Ð²Ð°ÑˆÐµÐ¼ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ðµ (localStorage). ÐÐµ Ð²ÑÑ‚Ð°Ð²Ð»ÑÐ¹Ñ‚Ðµ ÐºÐ»ÑŽÑ‡Ð¸ Ð² Ð¿ÑƒÐ±Ð»Ð¸Ñ‡Ð½Ñ‹Ð¹ HTML.",
    results_title: "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹",
    results_hint:
      "Ð—ÐµÐ»Ñ‘Ð½Ñ‹Ðµ / Ð¶Ñ‘Ð»Ñ‚Ñ‹Ðµ / ÐºÑ€Ð°ÑÐ½Ñ‹Ðµ ÑÐ¸Ð³Ð½Ð°Ð»Ñ‹. Ð­Ñ‚Ð¾ Ð½Ðµ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ñ â€” Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼Ñ‹Ðµ Ð¾Ð½Ñ‡ÐµÐ¹Ð½-Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸.",

    // liquidity panel
    p_liq_kicker: "Ð¢Ð¾ÐºÐµÐ½ + Ð»Ð¸ÐºÐ²Ð¸Ð´Ð½Ð¾ÑÑ‚ÑŒ",
    p_liq_title: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð»Ð¸ÐºÐ²Ð¸Ð´Ð½Ð¾ÑÑ‚Ð¸ DEX",
    p_liq_sub:
      "ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 Ñ„Ð°Ð±Ñ€Ð¸ÐºÐ¸. ÐŸÐ°Ñ€Ñ‹: Ñ‚Ð¾ÐºÐµÐ½ vs WBNB/WETH Ð¸ Ñ‚Ð¾ÐºÐµÐ½ vs USDT.",
    liq_input_title: "Ð¢Ð¾ÐºÐµÐ½ + ÑÐµÑ‚ÑŒ",
    liq_tip:
      'Ð¡Ð¾Ð²ÐµÑ‚: Ð¾Ñ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ <span class="mono">?tool=liq&net=bsc&token=0x...</span> Ð´Ð»Ñ Ð°Ð²Ñ‚Ð¾-ÑÑ‚Ð°Ñ€Ñ‚Ð°.',
    liq_dex_label: "DEX Ñ€ÐµÐµÑÑ‚Ñ€ (Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ÑÑ)",
    liq_results_title: "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð»Ð¸ÐºÐ²Ð¸Ð´Ð½Ð¾ÑÑ‚Ð¸",
    liq_results_hint:
      "V2: Ð¿Ð°Ñ€Ð° + snapshot Ñ€ÐµÐ·ÐµÑ€Ð²Ð¾Ð². V3: Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð¿ÑƒÐ»Ð° + liquidity() + slot0/tick snapshot.",

    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¸ Ð¾Ñ‚Ð·Ñ‹Ð² allowance",
    p_app_sub:
      "Ð£ÐºÐ°Ð¶Ð¸Ñ‚Ðµ spender + Ñ‚Ð¾ÐºÐµÐ½Ñ‹ (Ð¸Ð»Ð¸ Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð¿Ð¾Ð¿ÑƒÐ»ÑÑ€Ð½Ñ‹Ðµ). Ð§Ð¸Ñ‚Ð°ÐµÐ¼ allowance(owner, spender) Ð¸ Ð¾Ñ‚Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ñ‡ÐµÑ€ÐµÐ· approve(spender, 0).",
    ap_settings_title: "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸",
    ap_connected: "ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾:",
    ap_connect: "ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ / ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "ÐÐ°Ñ‡Ð½Ð¸Ñ‚Ðµ Ñ Ñ€Ð¾ÑƒÑ‚ÐµÑ€Ð°, Ð·Ð°Ñ‚ÐµÐ¼ Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ñ‚Ð¾ÐºÐµÐ½Ñ‹ Ð´Ð»Ñ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ¸.",
    ap_tokens_label: "Ð¡Ð¿Ð¸ÑÐ¾Ðº Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð² (Ð¿Ð¾ Ð¾Ð´Ð½Ð¾Ð¼Ñƒ Ð² ÑÑ‚Ñ€Ð¾ÐºÐµ)",
    ap_seed: "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð¿ÑƒÐ»ÑÑ€Ð½Ñ‹Ðµ Ñ‚Ð¾ÐºÐµÐ½Ñ‹",
    ap_seed_history: "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ ÑÐºÐ°Ð½Ð¾Ð²",
    ap_check: "ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ allowance",
    ap_revoke_all: "ÐžÑ‚Ð¾Ð·Ð²Ð°Ñ‚ÑŒ Ð²ÑÐµ (Ð½ÐµÐ½ÑƒÐ»ÐµÐ²Ñ‹Ðµ)",
    ap_results: "Allowances",
    ap_results_hint:
      "Ð•ÑÐ»Ð¸ allowance â€œÐ±ÐµÑÐºÐ¾Ð½ÐµÑ‡Ð½Ñ‹Ð¹â€, Ð»ÑƒÑ‡ÑˆÐµ Ð¾Ñ‚Ð¾Ð·Ð²Ð°Ñ‚ÑŒ, ÐµÑÐ»Ð¸ Ð²Ñ‹ Ð½Ðµ Ð¿Ð¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð´Ð¾Ð²ÐµÑ€ÑÐµÑ‚Ðµ spender.",
    safe_mode_note:
      "Safe mode: Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ, Ñ‚Ñ€ÐµÐ±ÑƒÑŽÑ‰Ð¸Ðµ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑŒ, Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‹ Ð´Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ ÐºÐ¾ÑˆÐµÐ»ÑŒÐºÐ°.",
    // DNA (Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚ÑŒ ÐºÐ¾ÑˆÐµÐ»ÑŒÐºÐ°)
p_dna_kicker: "Ð‘Ð•Ð—ÐžÐŸÐÐ¡ÐÐžÐ¡Ð¢Ð¬ ÐšÐžÐ¨Ð•Ð›Ð¬ÐšÐ DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Ð¡Ð½Ð¸Ð¼Ð¾Ðº Ñ€Ð¸ÑÐºÐ¾Ð² Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ð¹ Ð¸ Ð¿Ñ€Ð°Ð²",

pill_wallet: "ÐšÐ¾ÑˆÐµÐ»Ñ‘Ðº",
wallet_not_connected: "Ð½Ðµ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½",
btn_close: "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ",

dna_controls_title: "DNA-ÑÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ",
dna_wallet_address_label: "ÐÐ´Ñ€ÐµÑ ÐºÐ¾ÑˆÐµÐ»ÑŒÐºÐ°",
dna_wallet_address_ph: "0x... (Ð½ÐµÐ¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾, ÐµÑÐ»Ð¸ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº)",
dna_wallet_address_tip: "ÐœÐ¾Ð¶Ð½Ð¾ ÑÐ½Ð°Ñ‡Ð°Ð»Ð° ÑÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ð¾ Ð°Ð´Ñ€ÐµÑÑƒ. ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°Ð¹Ñ‚Ðµ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐºÐ¾Ð³Ð´Ð° Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¾Ñ‚Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ñ.",

net_label: "Ð¡ÐµÑ‚ÑŒ",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾:",
dna_connect: "ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº",
dna_run: "Ð¡ÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
dna_reset: "Ð¡Ð±Ñ€Ð¾Ñ",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "ÐžÑ†ÐµÐ½ÐºÐ° â€” ÑÑ‚Ð¾ ÑÐ½Ð¸Ð¼Ð¾Ðº. Ð’ÑÐµÐ³Ð´Ð° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ Ð¿ÐµÑ€ÐµÐ´ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑŒÑŽ.",

dna_score: "ÐžÑ†ÐµÐ½ÐºÐ°",
dna_risk_level: "Ð Ð¸ÑÐº",

dna_tips_title: "Ð¡Ð¾Ð²ÐµÑ‚Ñ‹",
dna_tips_placeholder: "â€”",
dna_share: "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð¾Ñ†ÐµÐ½ÐºÐ¾Ð¹",

dna_allowances_title: "Ð Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ñ",
dna_table_note: "Ð¡Ð¾Ð²ÐµÑ‚: Ð¾Ñ‚Ð·Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ â€œÐ±ÐµÑÐºÐ¾Ð½ÐµÑ‡Ð½Ñ‹Ðµâ€ approvals, ÐµÑÐ»Ð¸ Ð½Ðµ Ð´Ð¾Ð²ÐµÑ€ÑÐµÑ‚Ðµ Ð¸Ð¼ Ð¿Ð¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ. Verified Ð¸ Flags â€” Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÐ¿Ñ€Ð°Ð²Ð¾Ñ‡Ð½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ.",


    // rpc panel
    p_rpc_kicker: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° RPC",
    p_rpc_title: "ÐÐ°Ð¹Ð´Ð¸Ñ‚Ðµ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ endpoint",
    p_rpc_sub:
      "Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÐµÐ¼ RPC: latency + chainId + block + eth_call + Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ logs. Ð•ÑÑ‚ÑŒ dev custom logs test, Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ RPC ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ÑÑ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾.",
    rpc_inputs: "Ð’Ð²Ð¾Ð´",
    rpc_private_label: "ÐŸÑ€Ð¸Ð²Ð°Ñ‚Ð½Ñ‹Ð¹ RPC (Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾)",
    rpc_private_tip:
      "ÐÐµ Ð²ÑÑ‚Ñ€Ð°Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð² HTML. Ð¥Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² Ð²Ð°ÑˆÐµÐ¼ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ðµ (localStorage).",
    rpc_custom_label: "ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ RPC (Ð²Ñ‹ÑÑˆÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚)",
    rpc_test: "Ð¢ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ RPC",
    rpc_copy_best: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ RPC",
    rpc_results: "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹",
    rpc_tip:
      "Ð¡Ð¾Ð²ÐµÑ‚: Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ RPC Ð¿Ð°Ð´Ð°ÑŽÑ‚ Ð¸Ð·-Ð·Ð° CORS/timeout. Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ Ñ‚ÐµÑÑ‚ Ð¸ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸ Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹.",
    rpc_dev_title: "Dev custom logs test",
    rpc_dev_hint:
      "ÐžÐ¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾: Ñ‚ÐµÑÑ‚ logs Ð¿Ð¾ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ñƒ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ RPC.",
    rpc_dev_addr: "ÐÐ´Ñ€ÐµÑ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
    rpc_dev_topic: "Topic0 (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
    rpc_dev_run: "Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ñ‚ÐµÑÑ‚",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸ÑŽ",
    p_tx_sub:
      "Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ tx hash. ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ð¼ tx + receipt Ð¸ Ð´ÐµÐºÐ¾Ð´Ð¸Ñ€ÑƒÐµÐ¼ input Ð¸ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ (Transfer / Approval + Ð¿Ð¾Ð¿ÑƒÐ»ÑÑ€Ð½Ñ‹Ðµ swap Ð²Ñ‹Ð·Ð¾Ð²Ñ‹).",
    tx_input_title: "Ð’Ð²Ð¾Ð´ Tx",
    tx_hash_label: "Ð¥ÑÑˆ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸",
    tx_tip:
      'Ð¡Ð¾Ð²ÐµÑ‚: Ð¾Ñ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> Ð´Ð»Ñ Ð°Ð²Ñ‚Ð¾-ÑÑ‚Ð°Ñ€Ñ‚Ð°.',
    tx_results_title: "Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð²Ñ‹Ð²Ð¾Ð´",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€",
    p_dev_sub:
      "Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ bookmarklet, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ token/tx ÑÐ¾ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ† explorer Ð² CycleX Hub. Ð¢Ð°ÐºÐ¶Ðµ ÐµÑÑ‚ÑŒ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ð¾Ð² (ÑÐ¿Ð¸ÑÐ¾Ðº Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ Ð² Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ðµ).",
    bm_title: "Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Bookmarklet",
    bm_hint:
      "ÐŸÐµÑ€ÐµÑ‚Ð°Ñ‰Ð¸Ñ‚Ðµ Ð² Ð¿Ð°Ð½ÐµÐ»ÑŒ Ð·Ð°ÐºÐ»Ð°Ð´Ð¾Ðº Ð¸Ð»Ð¸ ÑÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ bookmarklet. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð½Ð° BscScan/Etherscan.",
    bm_base_label: "Hub URL (ÑÑ‚Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°)",
    bm_generate: "Ð¡Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
    bm_copy: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Bookmarklet",

    mon_add_title: "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð² ÑÐ¿Ð¸ÑÐ¾Ðº",
    mon_list_title: "ÐœÐ¾Ð½Ð¸Ñ‚Ð¾Ñ€ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ð¾Ð² (Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾)",
    mon_list_hint: "Ð¥Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾. Ð‘ÐµÐ· ÑÐµÑ€Ð²ÐµÑ€Ð½Ð¾Ð³Ð¾ Ñ‚Ñ€ÐµÐºÐ¸Ð½Ð³Ð°.",
    mon_add: "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ",
    mon_check: "ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð²ÑÐµ",
    mon_export: "ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ JSON",

    // footer
    footer_left:
      "CycleX Security Hub Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð½Ð° ÐºÐ»Ð¸ÐµÐ½Ñ‚Ðµ Ð¸ Ñ‡Ð¸Ñ‚Ð°ÐµÑ‚ Ð¿ÑƒÐ±Ð»Ð¸Ñ‡Ð½Ñ‹Ðµ Ð¾Ð½Ñ‡ÐµÐ¹Ð½-Ð´Ð°Ð½Ð½Ñ‹Ðµ.",
    footer_tagline: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ Ð´Ð²Ð°Ð¶Ð´Ñ‹. ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°Ð¹Ñ‚ÐµÑÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐµÑÐ»Ð¸ Ð´Ð¾Ð²ÐµÑ€ÑÐµÑ‚Ðµ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ðµ.",
    // --- ADD THESE KEYS (RU) ---
title_back_to_cyclex: "ÐÐ°Ð·Ð°Ð´ Ðº CycleX",
aria_lang_selector: "Ð’Ñ‹Ð±Ð¾Ñ€ ÑÐ·Ñ‹ÐºÐ°",
badge_table: "Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð°",
btn_share_x: "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð² X",
btn_share_tg: "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð² Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ð­Ñ„Ð¸Ñ€Ð¸ÑƒÐ¼",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ð¹â€¦",

th_token: "Ð¢Ð¾ÐºÐµÐ½",
th_allowance: "Ð›Ð¸Ð¼Ð¸Ñ‚",
th_symbol: "Ð¡Ð¸Ð¼Ð²Ð¾Ð»",
th_action: "Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ",
th_rpc: "RPC",
th_ms: "Ð¼Ñ",
th_chain: "ÑÐµÑ‚ÑŒ",
th_block: "Ð±Ð»Ð¾Ðº",
th_call: "call",
th_logs: "Ð»Ð¾Ð³Ð¸",
th_status: "ÑÑ‚Ð°Ñ‚ÑƒÑ",
th_contract: "ÐšÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚",
th_network: "Ð¡ÐµÑ‚ÑŒ",
th_last_seen: "ÐŸÐ¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð·",
th_remove: "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ",
    bm_tip: "Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð±ÑƒÐºÐ¼Ð°Ñ€ÐºÐ»ÐµÑ‚ Ð² Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€ Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ Ð»ÑŽÐ±Ð¾Ð¹ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚ Ñ Ð»ÑŽÐ±Ð¾Ð³Ð¾ ÑÐ°Ð¹Ñ‚Ð° Ð¾Ð´Ð½Ð¸Ð¼ ÐºÐ»Ð¸ÐºÐ¾Ð¼.",
bm_drag_label: "CycleX â€“ Security Hub",

qs_ready_html: "<strong>Ð“Ð¾Ñ‚Ð¾Ð²Ð¾.</strong><br>Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð°Ð´Ñ€ÐµÑ Ñ‚Ð¾ÐºÐµÐ½Ð° Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ <b>Ð¡ÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ</b>.",
liq_ready_html: "<strong>Ð“Ð¾Ñ‚Ð¾Ð²Ð¾.</strong><br>Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð°Ð´Ñ€ÐµÑ Ñ‚Ð¾ÐºÐµÐ½Ð° Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ <b>Ð¡ÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ</b>.",
tx_ready_html: "<strong>Ð“Ð¾Ñ‚Ð¾Ð²Ð¾.</strong><br>Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ tx hash Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ <b>Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾)",
ph_etherscan_key: "Etherscan API key (Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾)",
ph_rpc_private: "https://... (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) Ð¸Ð»Ð¸ Ð¾ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð¿ÑƒÑÑ‚Ñ‹Ð¼"

  }
};
// =========================
// i18n (after translations)
// =========================
let currentLang = "en";
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

function normalizeLang(x){
  const v = String(x || "").trim().toLowerCase();
  const map = { "cn":"zh", "zh-cn":"zh", "zh-hans":"zh" };
  return map[v] || v;
}

function setDirForLang(lang) {
  const html = document.documentElement;
  html.setAttribute("lang", lang === "zh" ? "zh" : lang);
  html.setAttribute("dir", lang === "ar" ? "rtl" : "ltr");
}

// âœ… t(lang,key) with EN fallback
function t(lang, key) {
  return (translations?.[lang]?.[key] ?? translations?.en?.[key] ?? "");
}

function applyI18n(lang) {
  const L = normalizeLang(lang || currentLang);
  currentLang = translations?.[L] ? L : "en";

  if (document.body) {
    document.body.classList.add("lang-switching");
    setTimeout(() => document.body && document.body.classList.remove("lang-switching"), 260);
  }

  // normal text/HTML
  $$("[data-i18n]").forEach((el) => {
    const key = el.getAttribute("data-i18n");
    const val = t(currentLang, key);
    if (val) el.innerHTML = val;
  });

  // placeholders
  $$("[data-i18n-placeholder]").forEach((el) => {
    const key = el.getAttribute("data-i18n-placeholder");
    const val = t(currentLang, key);
    if (val) el.setAttribute("placeholder", val);
  });

  // title attr
  $$("[data-i18n-title]").forEach((el) => {
    const key = el.getAttribute("data-i18n-title");
    const val = t(currentLang, key);
    if (val) el.setAttribute("title", val);
  });

  // aria-label attr
  $$("[data-i18n-aria-label]").forEach((el) => {
    const key = el.getAttribute("data-i18n-aria-label");
    const val = t(currentLang, key);
    if (val) el.setAttribute("aria-label", val);
  });

  setDirForLang(currentLang);

  // keep your existing behavior
  try { renderWalletLabels && renderWalletLabels(); } catch {}
}

function setLang(lang) {
  const picked = normalizeLang(lang);
  currentLang = translations?.[picked] ? picked : "en";

  try { localStorage.setItem("cx_sec_lang", currentLang); } catch {}

  $$(".lang-btn").forEach((b) => {
    const bl = normalizeLang(b.dataset?.lang || b.getAttribute("data-lang") || "");
    b.classList.toggle("active", bl === currentLang);
  });

  applyI18n(currentLang);
}

function initLang() {
  let saved = null;
  try { saved = localStorage.getItem("cx_sec_lang"); } catch {}

  const s = normalizeLang(saved);
  setLang(translations?.[s] ? s : "en");
}

// =========================
// i18n buttons wiring (FIX)
// =========================
function bindLangButtons(){
  $$(".lang-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      try { e.preventDefault(); } catch {}

      const raw = btn.dataset?.lang || btn.getAttribute("data-lang") || "";
      const lang = normalizeLang(raw);

      setLang(lang);
      try { gtagEvent && gtagEvent("sec_lang_change", { lang }); } catch {}
    }, { passive: false });
  });
}
    // =========================
    // Utils (dedup, single source of truth)
    // =========================
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const nowTs = () => Math.floor(Date.now() / 1000);

    const DEAD = "0x000000000000000000000000000000000000dEaD";
    const ZERO = "0x0000000000000000000000000000000000000000";

    function shortAddr(a) {
      return (!a || typeof a !== "string") ? "â€”" : `${a.slice(0, 6)}â€¦${a.slice(-4)}`;
    }
    function safeJson(obj) {
      try { return JSON.stringify(obj, null, 2); } catch { return "{}"; }
    }
    function isAddr(x){
      try { return E.isAddress(String(x||"").trim()); } catch { return false; }
    }
    function normAddr(x){
      return E.getAddress(String(x||"").trim());
    }
    function isBurnAddr(a){
      if (!a) return false;
      const z = String(a).toLowerCase();
      return z === ZERO.toLowerCase() || z === DEAD.toLowerCase();
    }

    async function copyText(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
          return true;
        } catch {
          return false;
        }
      }
    }

    function setStatus(el, type, html) {
      if (!el) return;
      el.classList.remove("ok", "warn", "bad", "info");
      el.classList.add(type);
      el.style.display = "block";
      el.innerHTML = html;
    }
    function clearStatus(el) {
      if (!el) return;
      el.style.display = "none";
      el.innerHTML = "";
      el.classList.remove("ok", "warn", "bad", "info");
    }

    function gtagEvent(name, params = {}) {
      try { if (typeof window.gtag === "function") window.gtag("event", name, params); } catch {}
    }

    function parseQuery() {
      const u = new URL(location.href);
      return {
        tool: (u.searchParams.get("tool") || "").toLowerCase(),
        net: (u.searchParams.get("net") || "").toLowerCase(),
        token: (u.searchParams.get("token") || ""),
        tx: (u.searchParams.get("tx") || "")
      };
    }

    // =========================
    // Panels / Tiles
    // =========================
    let toolCards = [];
    let panels = {};

    function initPanels() {
      toolCards = $$("#toolGrid .tool-card");
      panels = {
        quick: $("#panel-quick"),
        liq: $("#panel-liq"),
        approvals: $("#panel-approvals"),
        rpc: $("#panel-rpc"),
        tx: $("#panel-tx"),
        dev: $("#panel-dev")
      };

      function showPanel(key) {
        Object.entries(panels).forEach(([k, el]) => {
          if (el) el.classList.toggle("hidden", k !== key);
        });
        toolCards.forEach((c) => c.classList.toggle("active", c.dataset.tool === key));
        if (key) gtagEvent("sec_tool_open", { tool: key });
      }
      window.showPanel = showPanel;

      toolCards.forEach((card) => card.addEventListener("click", () => showPanel(card.dataset.tool)));

      $("#btnCloseQuick")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseLiq")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseApprovals")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseRpc")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseTx")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseDev")?.addEventListener("click", () => showPanel(null));

      $("#btn-quick")?.addEventListener("click", () => {
        showPanel("quick");
        $("#qs-token")?.focus();
        gtagEvent("sec_quick_btn");
      });
    }

    // =========================
    // Wallet (AppKit) â€” single global state
    // =========================
    const wallet = {
      providerRaw: null,     // EIP-1193
      browserProvider: null, // ethers BrowserProvider
      signer: null,
      address: "",
      chainId: 0
    };

    function renderWalletLabels() {
      const notConn = t(currentLang, "wallet_not_connected") || "not connected";
      const labelTxt = wallet.address ? wallet.address : notConn;

      const w1 = $("#walletLabel");
      if (w1) w1.textContent = labelTxt;

      const w2 = $("#ap-wallet");
      if (w2) w2.textContent = labelTxt;

      const w3 = $("#liq-wallet");
      if (w3) w3.textContent = labelTxt;

      const w4 = $("#ap-address");
      if (w4) w4.textContent = wallet.address ? shortAddr(wallet.address) : "â€”";
    }

    function attachProviderListeners(p) {
      try {
        if (!p || typeof p.on !== "function") return;
        p.removeAllListeners?.("accountsChanged");
        p.removeAllListeners?.("chainChanged");

        p.on("accountsChanged", async (accs) => {
          const a = (accs && accs[0]) ? E.getAddress(accs[0]) : "";
          wallet.address = a;
          renderWalletLabels();
        });

        p.on("chainChanged", async (hex) => {
          try { wallet.chainId = Number(hex); } catch { wallet.chainId = 0; }
          renderWalletLabels();
        });
      } catch {}
    }

    async function cxConnectWallet({ silent = false } = {}) {
      const stQuick = $("#qs-status");
      try {
        await window.CxAppKitModal?.open?.({ view: "ConnectWallet" });

        const providerRaw = await waitForWalletProvider(12000);
        if (!providerRaw) {
          if (!silent) setStatus(stQuick, "warn", "Wallet provider not ready (timeout). Try again.");
          return false;
        }

        wallet.providerRaw = providerRaw;
        attachProviderListeners(providerRaw);

        const bp = new E.BrowserProvider(providerRaw);
        wallet.browserProvider = bp;

        const signer = await bp.getSigner();
        wallet.signer = signer;

        const addr = await signer.getAddress();
        const net = await bp.getNetwork();

        wallet.address = E.getAddress(addr);
        wallet.chainId = Number(net.chainId || 0);

        renderWalletLabels();
        if (!silent) setStatus(stQuick, "ok", `Wallet connected: <span class="mono">${wallet.address}</span>`);
        gtagEvent("sec_wallet_connected", { chainId: wallet.chainId });

        return true;
      } catch (e) {
        if (!silent) setStatus(stQuick, "bad", `Wallet connect failed: ${String(e?.message || e)}`);
        return false;
      }
    }
window.cxConnectWallet = cxConnectWallet;
window.connectWallet = cxConnectWallet;


    async function ensureChain(targetChainId) {
      const p = wallet.providerRaw;
      if (!p?.request) return false;
      try {
        await p.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: "0x" + Number(targetChainId).toString(16) }]
        });
        await cxConnectWallet({ silent: true });
        return true;
      } catch {
        return false;
      }
    }

    function initWalletButtons() {
      $("#btn-connect")?.addEventListener("click", async () => { await cxConnectWallet(); });
      $("#ap-connect")?.addEventListener("click", async () => { await cxConnectWallet(); });
    }

    // =========================
    // Explorer API keys (local)
    // =========================
    const LS_KEYS = "cx_sec_explorer_keys";
    function loadApiKeys() {
      try {
        const raw = localStorage.getItem(LS_KEYS);
        if (!raw) return { bscscan: "", etherscan: "", use: false };
        const o = JSON.parse(raw);
        return { bscscan: o?.bscscan || "", etherscan: o?.etherscan || "", use: !!o?.use };
      } catch { return { bscscan: "", etherscan: "", use: false }; }
    }
    function saveApiKeys(keys) {
      try { localStorage.setItem(LS_KEYS, JSON.stringify(keys)); } catch {}
    }
    function explorerKeyFor(net) {
      const keys = loadApiKeys();
      if (!keys.use) return "";
      if (net === "bsc") return (keys.bscscan || "").trim();
      return (keys.etherscan || "").trim();
    }
    function initApiKeysUi() {
      const keys = loadApiKeys();
      const useEl = $("#api-use"); if (useEl) useEl.checked = keys.use;
      const b1 = $("#api-bscscan"); if (b1) b1.value = keys.bscscan;
      const b2 = $("#api-etherscan"); if (b2) b2.value = keys.etherscan;

      $("#api-save")?.addEventListener("click", () => {
        const nk = {
          use: !!$("#api-use")?.checked,
          bscscan: ($("#api-bscscan")?.value || "").trim(),
          etherscan: ($("#api-etherscan")?.value || "").trim()
        };
        saveApiKeys(nk);
        setStatus($("#qs-status"), "ok", "Saved keys to localStorage.");
        gtagEvent("sec_keys_saved", { use: nk.use ? 1 : 0 });
      });

      $("#api-clear")?.addEventListener("click", () => {
        saveApiKeys({ use: false, bscscan: "", etherscan: "" });
        const u = $("#api-use"); if (u) u.checked = false;
        const i1 = $("#api-bscscan"); if (i1) i1.value = "";
        const i2 = $("#api-etherscan"); if (i2) i2.value = "";
        setStatus($("#qs-status"), "ok", "Cleared keys.");
        gtagEvent("sec_keys_cleared");
      });
    }

    // =========================
    // Network config (âœ… fix ETH everywhere)
    // =========================
    const CHAINS = {
      bsc: {
        chainId: 56,
        name: "BSC",
        wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
        usdt: "0x55d398326f99059ff775485246999027b3197955",
        explorer: "https://bscscan.com",
        addressUrl: (a) => `https://bscscan.com/address/${a}`,
        txUrl: (h) => `https://bscscan.com/tx/${h}`,
        publicRpcs: [
  "https://bsc-rpc.publicnode.com",
  "https://bsc.publicnode.com",
  "https://bsc-dataseed1.bnbchain.org",
  "https://bsc-dataseed2.bnbchain.org",
          "https://bsc-rpc.publicnode.com",
          "https://1rpc.io/bnb",
          "https://endpoints.omniatech.io/v1/bsc/mainnet/",
          "https://api-bsc-mainnet-full.dwellir.com/",
          "https://binance.llamarpc.com",
          "https://bsc.meowrpc.com",
  "https://bsc-dataseed3.bnbchain.org",
  "https://bsc-dataseed4.bnbchain.org",
  "https://bsc-dataseed1.ninicoin.io",
  "https://bsc-dataseed2.ninicoin.io",
  "https://bsc-dataseed3.ninicoin.io",
  "https://bsc-dataseed4.ninicoin.io",
  "https://bsc-mainnet.gateway.pokt.network/v1/lb/6136201a7bad1500343e248d",
  "https://binance.nodereal.io",
  "https://rpc.ankr.com/bsc",
  "https://bsc.rpc.blxrbdn.com"
]

      },

      eth: {
        chainId: 1,
        name: "Ethereum",
        wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        usdt: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        explorer: "https://etherscan.io",
        addressUrl: (a) => `https://etherscan.io/address/${a}`,
        txUrl: (h) => `https://etherscan.io/tx/${h}`,
        publicRpcs: [
          "https://cloudflare-eth.com",
          "https://rpc.ankr.com/eth",
          "https://ethereum.publicnode.com",
          "https://eth.llamarpc.com"
        ]
      }
    };

    const DEX = {
      bsc: {
        v2Factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73",
        v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865",
        routerV2: "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        label: "PancakeSwap"
      },
      eth: {
        v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
        v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
        routerV2: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
        label: "Uniswap"
      }
    };

    // =========================
    // ABIs (minimal) â€” âœ… V3 token0/token1 added
    // =========================
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)"
    ];

    const V2_FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];
    const V2_PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const V3_FACTORY_ABI = [
      "function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)"
    ];
    const V3_POOL_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function liquidity() view returns (uint128)",
      "function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked)"
    ];

    const TRANSFER_TOPIC0 = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
    const APPROVAL_TOPIC0 = "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";

    // =========================
    // Local storage keys
    // =========================
    const LS_BEST_RPC = (net) => `cx_sec_best_rpc_${net}`;
    const LS_PRIV_RPC = (net) => `cx_sec_private_rpc_${net}`;
    const LS_QS_CACHE = "cx_sec_qs_cache_v2";
    const LS_QS_HISTORY = "cx_sec_qs_history_v1";
    const LS_MON = "cx_sec_monitor_v1";

    // =========================
    // Unified RPC layer (âœ… item #1 + #2)
    // =========================
    function uniq(arr) {
      const s = new Set();
      const out = [];
      for (const x of arr) {
        const k = String(x || "").trim();
        if (!k) continue;
        if (s.has(k)) continue;
        s.add(k);
        out.push(k);
      }
      return out;
    }

    function getSavedBestRpc(net) {
      try { return localStorage.getItem(LS_BEST_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedBestRpc(net, url) {
      try { localStorage.setItem(LS_BEST_RPC(net), url); } catch {}
    }

    function getSavedPrivateRpc(net) {
      try { return localStorage.getItem(LS_PRIV_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedPrivateRpc(net, url) {
      try { localStorage.setItem(LS_PRIV_RPC(net), url); } catch {}
    }

    async function rpcRequest(url, method, params = [], timeoutMs = 9000) {
      const ctrl = new AbortController();
      const tmr = setTimeout(() => ctrl.abort(), timeoutMs);
      const body = JSON.stringify({ jsonrpc: "2.0", id: 1, method, params });

      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body,
          signal: ctrl.signal
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const j = await res.json();
        if (j.error) throw new Error(j.error.message || "RPC error");
        return j.result;
      } finally {
        clearTimeout(tmr);
      }
    }

    function buildRpcCandidates(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const privSaved = getSavedPrivateRpc(net);
      const privInput = ($("#rpc-private")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      return uniq([custom, privInput, privSaved, bestSaved, ...(chain?.publicRpcs || [])]);
    }

    const _providerCache = new Map(); // key: net|url
    function getProviderForUrl(net, url){
  const key = `${net}|${url}`;
  if (_providerCache.has(key)) return _providerCache.get(key);

  const n = E.Network.from({
  name: CHAINS[net].name.toLowerCase(),
  chainId: CHAINS[net].chainId
});
const p = new E.JsonRpcProvider(url, n, { staticNetwork: n });


  _providerCache.set(key, p);
  return p;
}


    async function withRpcFallback(net, fn, { timeoutMs = 9500, preferUrls = null } = {}) {
      const urls = preferUrls && preferUrls.length ? preferUrls : buildRpcCandidates(net);
      let lastErr = null;
      for (const url of urls) {
        try {
          const provider = getProviderForUrl(net, url);
          const res = await Promise.race([
            fn(provider, url),
            new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), timeoutMs))
          ]);
          return { ok: true, url, res };
        } catch (e) {
          lastErr = e;
          continue;
        }
      }
      return { ok: false, url: "", err: lastErr || new Error("All RPCs failed") };
    }

    async function getCodeSafe(net, addr){
      const a = normAddr(addr);
      // Use raw eth_getCode (faster + abortable) with fallback
      const urls = buildRpcCandidates(net);
      let last = null;
      for (const url of urls) {
        try {
          const code = await rpcRequest(url, "eth_getCode", [a, "latest"], 9000);
          if (typeof code === "string") {
            // mark as â€œbestâ€ if it works well
            return { ok: true, url, code };
          }
        } catch (e) { last = e; }
      }
      return { ok: false, url: "", err: last || new Error("eth_getCode failed"), code: "0x" };
    }

    function getReadProvider(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      const privSaved = getSavedPrivateRpc(net);
      const url = custom || privSaved || bestSaved || (chain?.publicRpcs?.[0] || "");
      if (!url) return null;
      try { return new E.JsonRpcProvider(url, chain.chainId); } catch { return null; }
    }
    // --- Debug exports (safe) ---
window.CX = window.CX || {};
window.CX.getReadProvider = getReadProvider;


    function netFromSelect(selId) {
      const v = ($(selId)?.value || "bsc").toLowerCase();
      return (v === "eth") ? "eth" : "bsc";
    }

    // =========================
    // Explorer API (optional)
    // =========================
    function explorerApiBase(net) {
      return net === "bsc" ? "https://api.bscscan.com/api" : "https://api.etherscan.io/api";
    }

    async function explorerGetSource(net, addr, apiKey) {
      const base = explorerApiBase(net);
      const u = new URL(base);
      u.searchParams.set("module", "contract");
      u.searchParams.set("action", "getsourcecode");
      u.searchParams.set("address", addr);
      if (apiKey) u.searchParams.set("apikey", apiKey);

      const r = await fetch(u.toString());
      const j = await r.json();
      if (!j || j.status !== "1" || !j.result || !j.result[0]) return { ok: false, raw: j };

      const row = j.result[0];
      const abiRaw = row.ABI || "";
      const abiRaw = String(row.ABI || "").trim();
      }

      // âœ… robust verified check without JSON.parse
      const isVerified =
      !!abiRaw &&
      abiRaw !== "Contract source code not verified" &&
      abiRaw !== "[]" &&
      abiRaw.startsWith("[");

      let abiJson = null;
      try { abiJson = isVerified ? JSON.parse(abiRaw) : null; } catch { abiJson = null; }


      // Heuristics (BscScan/Etherscan fields differ but usually include these)
      const isProxy = String(row.Proxy || row.proxy || "").toLowerCase() === "1" || /proxy/i.test(String(row.ContractName || "")) && /proxy/i.test(String(row.SourceCode || ""));
      const impl = (row.Implementation || row.implementation || "").trim();
      const contractName = (row.ContractName || row.contractName || "").trim();

      return {
        ok: true,
        verified: isVerified,
        abi: abiJson,
        isProxy,
        implementation: impl,
        contractName,
        raw: row
      };
    }

    // =========================
    // Formatting helpers
    // =========================
    function fmtNum(x, digits = 2){
      const n = Number(x);
      if (!Number.isFinite(n)) return "â€”";
      const d = clamp(digits, 0, 8);
      return n.toLocaleString(undefined, { maximumFractionDigits: d });
    }
    function fmtBig(bn, decimals = 18, digits = 4){
      try {
        const v = Number(E.formatUnits(bn, decimals));
        if (!Number.isFinite(v)) return "â€”";
        return fmtNum(v, digits);
      } catch { return "â€”"; }
    }
    function looksInfiniteAllowance(v){
      try {
        // ethers v6 returns bigint
        const x = BigInt(v);
        return x > (BigInt(2) ** BigInt(255)); // "practically infinite"
      } catch { return false; }
    }
    function safeLower(x){ return String(x || "").toLowerCase(); }

// =========================
// Quick Scan (client-only) âœ… FIXED: no collisions, no TDZ, clean table
// =========================
(function () {
  "use strict";

  // âœ… Unique LS keys (avoid collisions with other features)
  const QS_LS_CACHE    = "cx_sec_qs_cache_safe_v6";
  const QS_LS_HISTORY  = "cx_sec_qs_history_safe_v6";
  const QS_LS_API_KEYS = "cx_sec_explorer_keys"; // {use,bscscan,etherscan} if exists

  // EIP-1967 implementation slot
  const EIP1967_IMPL_SLOT =
    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";

  // Minimal ABIs (self-contained â€” does NOT depend on Liquidity Scan script)
  const ERC20_MIN_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)"
  ];
  const OWNER_ABI = ["function owner() view returns (address)"];
  const PAUSABLE_ABI = ["function paused() view returns (bool)"];

  // V2/V3 minimal ABIs for the small liquidity table
  const QS_V2_FACTORY_ABI = ["function getPair(address,address) view returns (address)"];
  const QS_V2_PAIR_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function getReserves() view returns (uint112,uint112,uint32)"
  ];
  const QS_V3_FACTORY_ABI = ["function getPool(address,address,uint24) view returns (address)"];
  const QS_V3_POOL_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function liquidity() view returns (uint128)",
    "function slot0() view returns (uint160,int24,uint16,uint16,uint16,uint8,bool)"
  ];

  // PUSH4 selector scan (bytecode heuristic)
  const SEL = {
    mint: ["40c10f19", "a0712d68"],         // mint(address,uint256), mint(uint256)
    pause: ["8456cb59"],                   // pause()
    unpause: ["3f4ba83a"],                 // unpause()
    paused: ["5c975abb"],                  // paused()
    owner: ["8da5cb5b"],                   // owner()
    transferOwnership: ["f2fde38b"]         // transferOwnership(address)
  };

  const DEAD_ADDRESSES = new Set([
    "0x0000000000000000000000000000000000000000",
    "0x000000000000000000000000000000000000dead"
  ]);

  // QuickScan DEX targets (single â€œmainâ€ DEX for the compact table)
  const QS_NET = {
    bsc: {
      name: "BSC (BNB Chain)",
      wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // WBNB
      usdt:    "0x55d398326f99059fF775485246999027B3197955", // USDT (BSC)
      v2Factory: "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73", // Pancake V2
      v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865", // Pancake V3
      addressUrl: (a)=> `https://bscscan.com/address/${a}`
    },
    eth: {
      name: "Ethereum",
      wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
      usdt:    "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT (ETH)
      v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", // Uniswap V2
      v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984", // Uniswap V3
      addressUrl: (a)=> `https://etherscan.io/address/${a}`
    }
  };

  // -------------------------
  // Tiny safe helpers (local)
  // -------------------------
  function qsLower(x) { return String(x || "").toLowerCase(); }
  function qsClamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function qsNowTs() { return Math.floor(Date.now() / 1000); }

  function qsEscapeHtml(s){
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function qsIsAddr(a){
    try {
      if (typeof isAddr === "function") return !!isAddr(a);
      if (typeof E !== "undefined" && E?.isAddress) return E.isAddress(a);
    } catch {}
    return false;
  }
  function qsNormAddr(a){
    try {
      if (typeof normAddr === "function") return normAddr(a);
      if (typeof E !== "undefined" && E?.getAddress) return E.getAddress(a);
    } catch {}
    return String(a || "");
  }
  function qsShortAddr(a){
    try { if (typeof shortAddr === "function") return shortAddr(a); } catch {}
    const s = String(a || "");
    return s.length > 12 ? (s.slice(0, 6) + "â€¦" + s.slice(-4)) : s;
  }

  function qsFmtNum(x, digits = 2){
    const n = Number(x);
    if (!Number.isFinite(n)) return "â€”";
    const d = qsClamp(digits, 0, 8);
    try { return n.toLocaleString(undefined, { maximumFractionDigits: d }); } catch { return String(n); }
  }
  function qsFmtBig(bn, decimals = 18, digits = 4){
    try {
      if (typeof E === "undefined" || !E?.formatUnits) return "â€”";
      const v = Number(E.formatUnits(bn, decimals));
      if (!Number.isFinite(v)) return "â€”";
      return qsFmtNum(v, digits);
    } catch { return "â€”"; }
  }

  function loadQsCache(){
    try { return JSON.parse(localStorage.getItem(QS_LS_CACHE) || "{}"); } catch { return {}; }
  }
  function saveQsCache(obj){
    try { localStorage.setItem(QS_LS_CACHE, JSON.stringify(obj || {})); } catch {}
  }
  function loadQsHistory(){
    try { return JSON.parse(localStorage.getItem(QS_LS_HISTORY) || "[]"); } catch { return []; }
  }
  function saveQsHistory(arr){
    try { localStorage.setItem(QS_LS_HISTORY, JSON.stringify(arr || [])); } catch {}
  }

  function qsCacheKey(net, token, requireLiq, useApis){
    return `${net}:${qsLower(token)}:${requireLiq ? 1 : 0}:${useApis ? 1 : 0}`;
  }
  function addQsHistory(net, token){
    try{
      const arr = loadQsHistory();
      const key = `${net}:${qsLower(token)}`;
      const filtered = arr.filter(x => x?.key !== key);
      filtered.unshift({ key, net, token: qsNormAddr(token), ts: qsNowTs() });
      saveQsHistory(filtered.slice(0, 80));
    } catch {}
  }
  function qsBuildShareLink(net, token){
    const u = new URL(location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", net);
    u.searchParams.set("token", token);
    return u.toString();
  }

  // âœ… safe explorer key read
  function qsExplorerKeyFor(net){
    try{
  if (typeof explorerKeyFor === "function") {
    const k = String(explorerKeyFor(net) || "").trim();
    if (k) return k;
  }
} catch {}

    try{
      const raw = localStorage.getItem(QS_LS_API_KEYS) || "";
      if (!raw) return "";
      const o = JSON.parse(raw);
      if (o && typeof o.use === "boolean" && o.use === false) return "";
      if (net === "bsc") return String(o?.bscscan || "");
      if (net === "eth") return String(o?.etherscan || "");
      return "";
    } catch { return ""; }
  }

  function qsExplorerApiBase(net){
  if (net === "bsc") return "https://api.bscscan.com/api";
  if (net === "eth") return "https://api.etherscan.io/api";
  return "";
}

// direct call fallback
async function qsExplorerGetSourceDirect(net, addr, apiKey){
  const base = qsExplorerApiBase(net);
  if (!base) return { ok:false };

  const u = new URL(base);
  u.searchParams.set("module", "contract");
  u.searchParams.set("action", "getsourcecode");
  u.searchParams.set("address", addr);
  if (apiKey) u.searchParams.set("apikey", apiKey);

  const r = await fetch(u.toString());
  const j = await r.json();

  if (!j || j.status !== "1" || !j.result || !j.result[0]) {
    return { ok:false, raw:j };
  }

  const row = j.result[0];
  const abiRaw = row.ABI || "";
  let verified = false;

  try {
    if (abiRaw && abiRaw !== "Contract source code not verified" && abiRaw !== "[]") {
      const abiJson = JSON.parse(abiRaw);
      verified = Array.isArray(abiJson) && abiJson.length > 0;
    }
  } catch {
    verified = false;
  }

  // safer proxy detection (no regex)
  const isProxy = String(row.Proxy || row.proxy || "").trim() === "1";
  const implementation = (row.Implementation || row.implementation || "").trim();

  return {
    ok: true,
    verified,
    isProxy,
    implementation,
    raw: row
  };
}


  // Chip UI
  function qsMiniChip(type, title, value){
    const map = { ok:"ok", warn:"warn", bad:"bad", info:"warn" };
    const cls = map[type] || "warn";
    return `<div class="risk ${cls}"><span class="dot"></span><span><b>${qsEscapeHtml(title)}</b> â€” ${qsEscapeHtml(value)}</span></div>`;
  }

  function codeHasSelector(bytecode, selHex){
    try{
      const code = qsLower(bytecode || "");
      const sel = qsLower(selHex || "").replace(/^0x/,"");
      if (!sel || sel.length !== 8) return false;
      return code.includes("63" + sel); // PUSH4 <selector>
    } catch { return false; }
  }
  function anySelector(bytecode, sels){
    for (const s of (sels || [])) if (codeHasSelector(bytecode, s)) return true;
    return false;
  }

  async function tryReadOwner(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return "";
    try{
      const c = new E.Contract(token, OWNER_ABI, read);
      const o = await c.owner();
      return qsIsAddr(o) ? qsNormAddr(o) : "";
    } catch { return ""; }
  }

  async function tryReadPaused(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return null;
    try{
      const c = new E.Contract(token, PAUSABLE_ABI, read);
      const p = await c.paused();
      return !!p;
    } catch { return null; }
  }

  async function tryEip1967Impl(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return "";
    try{
      const raw = await read.getStorage(token, EIP1967_IMPL_SLOT);
      const hex = String(raw || "0x");
      if (!hex || hex === "0x") return "";
      const addr = "0x" + hex.slice(-40);
      if (!qsIsAddr(addr)) return "";
      const norm = qsNormAddr(addr);
      if (qsLower(norm) === "0x0000000000000000000000000000000000000000") return "";
      return norm;

    } catch { return ""; }
  }

  // =========================
  // Compact Liquidity table (ONLY QuickScan)
  // - shows ONLY existing pairs/pools (reduces rows)
  // - does NOT touch Liquidity Scan panel
  // =========================
  const QS_ERC20_META_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)"
  ];
  const _qsErc20MetaCache = new Map();

  function _qsToBI(x){
    try { return (typeof x === "bigint") ? x : BigInt(x); } catch { return 0n; }
  }
  async function _qsGetErc20Meta(addr, provider){
    const key = String(addr || "").toLowerCase();
    if (_qsErc20MetaCache.has(key)) return _qsErc20MetaCache.get(key);

    const c = new E.Contract(addr, QS_ERC20_META_ABI, provider);
    let decimals = 18;
    let symbol = qsShortAddr(addr);

    try { decimals = Number(await c.decimals()); } catch {}
    try {
      const s = await c.symbol();
      if (s && String(s).trim()) symbol = String(s).trim();
    } catch {}

    const meta = { decimals, symbol };
    _qsErc20MetaCache.set(key, meta);
    return meta;
  }

  function _qsCompactDecimalString(str, dp = 2){
    if (str == null) return "0";
    let s = String(str).trim();
    if (!s) return "0";

    let neg = false;
    if (s[0] === "-") { neg = true; s = s.slice(1); }

    const parts = s.split(".");
    let intp = (parts[0] || "0").replace(/^0+(?=\d)/, "");
    const frac = parts[1] || "";

    const len = intp.length;
    let pow = 0, suf = "";
    if (len >= 16) { pow = 15; suf = "Q"; }
    else if (len >= 13) { pow = 12; suf = "T"; }
    else if (len >= 10) { pow = 9;  suf = "B"; }
    else if (len >= 7)  { pow = 6;  suf = "M"; }
    else if (len >= 4)  { pow = 3;  suf = "K"; }

    if (pow === 0){
      const frac6 = frac.slice(0, 6).replace(/0+$/,"");
      const out = frac6 ? `${intp}.${frac6}` : intp;
      return (neg ? "-" : "") + out;
    }

    const wholeLen = len - pow;
    const whole = intp.slice(0, wholeLen) || "0";
    const rest = intp.slice(wholeLen);

    const dec = (rest + "0".repeat(dp)).slice(0, dp).replace(/0+$/,"");
    const out = dec ? `${whole}.${dec}${suf}` : `${whole}${suf}`;
    return (neg ? "-" : "") + out;
  }

  function _qsFmtUnits(amount, decimals, dp = 2){
    try {
      const s = E.formatUnits(amount, decimals);
      return _qsCompactDecimalString(s, dp);
    } catch {
      return "0";
    }
  }

  async function qsLiqCheckBasic(net, token, provider) {
    const cfg = QS_NET?.[net];
    if (!cfg || !provider) return { any:false, hint:"none", rows:[] };

    const rows = [];
    let any = false;
    const ZERO = "0x0000000000000000000000000000000000000000";

    const targets = [
      { label: "Wrapped", addr: cfg.wrapped },
      { label: "USDT", addr: cfg.usdt }
    ];

    // ---------- V2 ----------
    try {
      const fac = new E.Contract(cfg.v2Factory, QS_V2_FACTORY_ABI, provider);
      for (const t of targets) {
        const pair = await fac.getPair(token, t.addr).catch(()=> ZERO);
if (!pair || pair === ZERO) {
  rows.push({
    type: "V2",
    target: t.label,
    addr: "â€”",
    ok: false,
    note: "pair not found"
  });
  continue;
}


        const p = new E.Contract(pair, QS_V2_PAIR_ABI, provider);

        let token0 = token, token1 = t.addr;
        try { token0 = await p.token0(); } catch {}
        try { token1 = await p.token1(); } catch {}

        const [r0Raw, r1Raw] = await p.getReserves().catch(()=> [0n,0n,0n]);
        const r0 = _qsToBI(r0Raw), r1 = _qsToBI(r1Raw);

        const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
        const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

        const ok = (r0 > 0n || r1 > 0n);
        any = any || ok;

        const a0 = _qsFmtUnits(r0, m0.decimals, 2);
        const a1 = _qsFmtUnits(r1, m1.decimals, 2);

        rows.push({
          type: "V2",
          target: t.label,
          addr: pair,
          ok,
          note: ok ? `reserves: ${a0} ${m0.symbol} / ${a1} ${m1.symbol}` : "reserves: 0"
        });
      }
    } catch {
      // ignore (donâ€™t spam rows)
    }

    // ---------- V3 ----------
    try {
      const fac3 = new E.Contract(cfg.v3Factory, QS_V3_FACTORY_ABI, provider);
      const feeTiers = [500, 3000, 10000];

      for (const t of targets) {
        for (const fee of feeTiers) {
          const pool = await fac3.getPool(token, t.addr, fee).catch(()=> ZERO);
if (!pool || pool === ZERO) {
  rows.push({
    type: `V3 ${fee}`,
    target: t.label,
    addr: "â€”",
    ok: false,
    note: "pool not found"
  });
  continue;
}


          const p = new E.Contract(pool, QS_V3_POOL_ABI, provider);

          let token0 = token, token1 = t.addr;
          try { token0 = await p.token0(); } catch {}
          try { token1 = await p.token1(); } catch {}

          const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
          const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

          const c0 = new E.Contract(token0, QS_ERC20_META_ABI, provider);
          const c1 = new E.Contract(token1, QS_ERC20_META_ABI, provider);

          let b0 = 0n, b1 = 0n;
          try { b0 = _qsToBI(await c0.balanceOf(pool)); } catch {}
          try { b1 = _qsToBI(await c1.balanceOf(pool)); } catch {}

          let liq = 0n;
          try { liq = _qsToBI(await p.liquidity()); } catch {}

          const ok = (b0 > 0n || b1 > 0n || liq > 0n);
          any = any || ok;

          const fb0 = _qsFmtUnits(b0, m0.decimals, 2);
          const fb1 = _qsFmtUnits(b1, m1.decimals, 2);

          rows.push({
            type: `V3 ${fee}`,
            target: t.label,
            addr: pool,
            ok,
            note: ok ? `balances: ${fb0} ${m0.symbol} / ${fb1} ${m1.symbol}` : "balances: 0"
          });
        }
      }
    } catch {
      // ignore
    }

    return { any, hint: any ? "V2/V3 pairs exist" : "none", rows };
  }

  function qsRenderLiquidityTable(container, liqRes){
    if (!container) return;

    const rows = (liqRes?.rows || []);
    const body = rows.length ? rows.map(r => `
      <div class="trow ${r.ok ? "highlight" : ""}">
        <div class="cell wrap"><span class="mono">${r.addr ? qsEscapeHtml(qsShortAddr(r.addr)) : "â€”"}</span></div>
        <div class="cell">${qsEscapeHtml(r.type)}</div>
        <div class="cell">${qsEscapeHtml(r.target)}</div>
        <div class="cell">${r.ok ? "âœ…" : "â€”"} ${qsEscapeHtml(r.note || "")}</div>
      </div>
    `).join("") : `
      <div class="trow">
        <div class="cell muted">â€”</div>
        <div class="cell muted">â€”</div>
        <div class="cell muted">â€”</div>
        <div class="cell muted">No pairs/pools detected</div>
      </div>
    `;

    container.innerHTML = `
      <div id="qsLiqTable" class="table">
        <div class="trow head">
          <div class="cell">PAIR/POOL</div>
          <div class="cell">TYPE</div>
          <div class="cell">TARGET</div>
          <div class="cell">RESULT</div>
        </div>
        ${body}
      </div>
    `;
  }

  function qsBuildMarkdownReport(rep){
    const lines = [];
    lines.push(`## Quick Scan â€” ${rep.chainName || rep.net}`);
    lines.push(`Token: \`${rep.token}\``);
    lines.push(`Explorer: ${rep.explorer}`);
    lines.push(`Score: **${rep.score}/100** (${rep.overallText})`);
    lines.push("");
    lines.push(`### Signals`);
    for (const c of (rep.mini || [])) lines.push(`- ${c.title}: ${c.value}`);
    if (rep.redFlags?.length) {
      lines.push("");
      lines.push(`### Red Flags`);
      for (const f of rep.redFlags) lines.push(`- â— ${f}`);
    }
    lines.push("");
    lines.push(`> ${rep.disclaimer}`);
    return lines.join("\n");
  }

  function qsBuildXText(rep){
    const base = `Quick Scan (${rep.chainName || rep.net})\nToken: ${qsShortAddr(rep.token)}\nScore: ${rep.score}/100 (${rep.overallText})\n`;
    return `${base}${rep.shareLink || ""}`.trim();
  }

  async function runQuickScan(){
    const st = $("#qs-status");
    const out = $("#qs-out");
    const chipsWrap = $("#qs-risk");
    const pairsWrap = $("#qs-pairsWrap");

    clearStatus(st);

    const net = netFromSelect("#qs-net");
    const tokenRaw = ($("#qs-token")?.value || "").trim();
    const requireLiq = !!$("#qs-require-liq")?.checked;
    const useApis = !!$("#api-use")?.checked;

    if (!tokenRaw || !qsIsAddr(tokenRaw)) {
      setStatus(st, "warn", "Please paste a valid token address.");
      return;
    }
    const token = qsNormAddr(tokenRaw);

    if (typeof E === "undefined" || !E?.Contract) {
      setStatus(st, "bad", "Ethers not loaded.");
      return;
    }
    if (typeof getReadProvider !== "function") {
      setStatus(st, "bad", "RPC provider missing (getReadProvider not found).");
      return;
    }

    setStatus(st, "info", "Scanningâ€¦");

    const cache = loadQsCache();
    const ckey = qsCacheKey(net, token, requireLiq, useApis);
    const cached = cache?.[ckey];

    // âœ… Render is SAFE now (no TDZ vars)
    if (cached?.rep && cached?.ts && (qsNowTs() - cached.ts) < 600) {
      setStatus(st, "ok", "Loaded cached result (â‰¤10 min).");
      render(cached.rep);
      return;
    }

    const cfg = QS_NET?.[net];
    const read = getReadProvider(net);
    if (!cfg || !read) {
      setStatus(st, "bad", "No network config / RPC available.");
      return;
    }

    const rep = {
      ts: qsNowTs(),
      net,
      chainName: cfg.name,
      token,
      explorer: cfg.addressUrl(token),
      shareLink: qsBuildShareLink(net, token),
      disclaimer: "Informational checks only. Not an audit. No safety guarantee.",
      score: 0,
      overallText: "Unknown",
      meta: {},
      liq: { any:false, hint:"none", rows:[] },
      mini: [],
      redFlags: [],
      json: ""
    };

    // 1) Bytecode exists
    let code = "0x";
    try {
      if (typeof getCodeSafe === "function") {
        const codeRes = await getCodeSafe(net, token);
        code = codeRes?.code || "0x";
      } else {
        code = await read.getCode(token);
      }
    } catch {}

    const hasCode = !!(code && code !== "0x");
    if (!hasCode) {
      rep.score = 0;
      rep.overallText = "Invalid";
      rep.redFlags.push("No contract code (EOA or invalid address).");
      rep.json = safeJson(rep);
      cache[ckey] = { ts: qsNowTs(), rep };
      saveQsCache(cache);
      addQsHistory(net, token);
      setStatus(st, "bad", "No contract code detected.");
      render(rep);
      return;
    }

    // 2) ERC-20 basics
    let name = "", symbol = "", decimals = 18, totalSupply = 0n;
    try {
      const c = new E.Contract(token, ERC20_MIN_ABI, read);
      const r = await Promise.all([
        c.name().catch(()=> ""),
        c.symbol().catch(()=> ""),
        c.decimals().catch(()=> 18),
        c.totalSupply().catch(()=> 0n)
      ]);
      name = String(r[0] || "");
      symbol = String(r[1] || "");
      decimals = Number(r[2] ?? 18);
      totalSupply = BigInt(r[3] ?? 0n);
      rep.meta = { name, symbol, decimals, totalSupply: totalSupply.toString() };
    } catch {}

    // 3) Liquidity rows (compact table)
    try {
      rep.liq = await qsLiqCheckBasic(net, token, read);
    } catch {}

    // 4) Proxy
    let impl = await tryEip1967Impl(net, token);
    let isProxy = !!impl;

    // 5) Owner
    const owner = await tryReadOwner(net, token);
    const ownerIsRenounced = owner && DEAD_ADDRESSES.has(qsLower(owner));
    const ownerShown = owner ? qsShortAddr(owner) : "No/Unknown";

    // 6) Pause (INFO)
    const pausedState = await tryReadPaused(net, token);
    const pauseDetected =
      (pausedState !== null) ||
      anySelector(code, SEL.pause) ||
      anySelector(code, SEL.unpause) ||
      anySelector(code, SEL.paused);
    const pauseText = pausedState === true ? "Detected (paused)" : pauseDetected ? "Detected" : "No/Unknown";

    // 7) Mint
    const mintDetected = anySelector(code, SEL.mint);

    // 8) Verified (optional)
let verified = null;

if (useApis) {
  const apiKey = qsExplorerKeyFor(net);

  // A) try existing helper first (if present)
  if (typeof explorerGetSource === "function") {
    try {
      const src = await explorerGetSource(net, token, apiKey);
      if (src?.ok) {
        verified = (src.verified === true) ? true : (src.verified === false) ? false : null;
        if (!isProxy && src.isProxy) isProxy = true;
        if (!impl && src.implementation) impl = String(src.implementation || "");
      }
    } catch {}
  }

  // B) fallback: direct explorer call (ONLY if still unknown)
  if (verified === null && typeof qsExplorerGetSourceDirect === "function") {
    try {
      const src2 = await qsExplorerGetSourceDirect(net, token, apiKey);
      if (src2?.ok) {
        verified = (src2.verified === true) ? true : (src2.verified === false) ? false : null;
        if (!isProxy && src2.isProxy) isProxy = true;
        if (!impl && src2.implementation) impl = String(src2.implementation || "");
      }
    } catch {}
  }
}


    // Score model
    let score = 75;

    if (rep.liq?.any) score += 10;
    else score -= (requireLiq ? 30 : 20);

    if (mintDetected) score -= 22;

    if (isProxy) score -= 12;
    else score += 3;

    if (!owner) score += 0;
    else if (ownerIsRenounced) score += 5;
    else score -= 6;

    if (verified === true) score += 8;
    if (verified === false) score -= 6;

    if (!symbol && !name) score -= 5;

    score = qsClamp(score, 0, 100);

    const overallText =
      score >= 85 ? "Good" :
      score >= 70 ? "Mixed signals" :
      score >= 50 ? "Caution" :
      "High risk";

    rep.score = score;
    rep.overallText = overallText;

    rep.mini = [
      { type: score >= 85 ? "ok" : score >= 70 ? "warn" : score >= 50 ? "warn" : "bad", title: "Overall", value: overallText },
      { type: verified === true ? "ok" : "warn", title: "Verified", value: verified === true ? "Yes" : "No/Unknown" },
      { type: isProxy ? "warn" : "ok", title: "Proxy", value: isProxy ? "Detected" : "No/Unknown" },
      { type: owner ? (ownerIsRenounced ? "ok" : "warn") : "warn", title: "Owner", value: ownerShown },
      { type: rep.liq?.any ? "ok" : "warn", title: "Liquidity", value: rep.liq?.any ? "V2/V3 pairs exist" : "No/Unknown" },
      { type: mintDetected ? "bad" : "ok", title: "Mint", value: mintDetected ? "Detected" : "No/Unknown" },
      { type: pauseDetected ? "warn" : "ok", title: "Pause", value: pauseText }
    ];

    if (mintDetected) rep.redFlags.push("Mint surface detected (supply risk).");
    if (isProxy) rep.redFlags.push("Proxy detected (upgrade risk).");
    if (!rep.liq?.any) rep.redFlags.push("No clear DEX liquidity signal detected.");

    rep.json = safeJson(rep);

    cache[ckey] = { ts: qsNowTs(), rep };
    saveQsCache(cache);
    addQsHistory(net, token);

    setStatus(st, score >= 70 ? "ok" : score >= 50 ? "warn" : "bad", `Done. Score: <b>${score}/100</b> (${overallText}).`);
    render(rep);

    function render(rep){
      const sym = rep.meta?.symbol || "Token";
      const nm = rep.meta?.name ? ` â€” ${rep.meta.name}` : "";

      // âœ… compute supply inside render (no TDZ, safe for cached rep)
      let supplyTxt = "â€”";
      try {
        const ts = rep?.meta?.totalSupply;
        const dec = Number(rep?.meta?.decimals ?? 18);
        if (ts != null) supplyTxt = qsFmtBig(BigInt(ts), dec, 4);
      } catch {}

      out.className = "status info";
      out.style.display = "block";
      out.innerHTML = `
        <div style="font-size:18px;font-weight:900;letter-spacing:-0.01em;">
          ${qsEscapeHtml(sym)}${qsEscapeHtml(nm)}
        </div>
        <div class="small" style="margin-top:6px;">
          Network: <b>${qsEscapeHtml(rep.chainName || rep.net)}</b> â€¢ Score: <b>${rep.score}/100</b> (${qsEscapeHtml(rep.overallText)})
        </div>
        <div class="small" style="margin-top:8px;">
          Token: <span class="mono">${qsEscapeHtml(rep.token)}</span>
        </div>
        <div class="small" style="margin-top:8px;">
          Supply: <span class="mono">${qsEscapeHtml(supplyTxt)}</span>
        </div>
        <div class="small" style="margin-top:8px;">
          Explorer: <a href="${qsEscapeHtml(rep.explorer)}" target="_blank" rel="noopener">open</a>
        </div>
      `;

      if (chipsWrap){
        chipsWrap.innerHTML = (rep.mini || []).map(x => qsMiniChip(x.type, x.title, x.value)).join("");
      }

      if (pairsWrap){
        qsRenderLiquidityTable(pairsWrap, rep.liq);
      }
    }
  }

  function initQuickScanUi(){
    if (window.__cx_qs_bound_v6) return;
    window.__cx_qs_bound_v6 = true;

    $("#qs-run")?.addEventListener("click", () => {
      runQuickScan();
      try { gtagEvent("sec_qs_run"); } catch {}
    });

    $("#qs-copy-link")?.addEventListener("click", async () => {
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");
      const link = qsBuildShareLink(net, qsNormAddr(token));
      const ok = await copyText(link);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_link"); } catch {}
    });

    $("#qs-copy-json")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const ok = await copyText(rep.json || safeJson(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_json"); } catch {}
    });

    $("#qs-copy-md")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const md = qsBuildMarkdownReport(rep);
      const ok = await copyText(md);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied Markdown report." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_md"); } catch {}
    });

    $("#qs-share-x")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const text = qsBuildXText(rep);
      const u = new URL("https://twitter.com/intent/tweet");
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_x"); } catch {}
    });

    $("#qs-share-tg")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const link = rep.shareLink || qsBuildShareLink(net, qsNormAddr(token));
      const text = qsBuildXText(rep);
      const u = new URL("https://t.me/share/url");
      u.searchParams.set("url", link);
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_tg"); } catch {}
    });

    $("#qs-copy-xtext")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const ok = await copyText(qsBuildXText(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied X text." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_xtext"); } catch {}
    });
  }

  // expose safely
  window.CX_QS_V6 = window.CX_QS_V6 || {};
  window.CX_QS_V6.initQuickScanUi = initQuickScanUi;
  window.CX_QS_V6.runQuickScan = runQuickScan;

  // keep compatibility
  window.initQuickScanUi = initQuickScanUi;
  window.runQuickScan = window.runQuickScan || runQuickScan;


})();


// âœ… Compatibility helper (do NOT remove) â€” used by Liquidity Scan
window.qsRiskChip = window.qsRiskChip || function(type, text){
  const cls = (type === "ok" ? "ok" : type === "bad" ? "bad" : "warn");
  const esc = (s)=> String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  return `<div class="risk ${cls}"><span class="dot"></span><span>${esc(text)}</span></div>`;
};
 // =========================
// Liquidity Scan panel (Multi-DEX Sources) â€” FINAL DROP-IN
// =========================

/**
 * DEX_SOURCES:
 * - v2Factory: UniswapV2-style factory (getPair)
 * - v3Type:
 *    - "univ3"   => UniswapV3-style factory (getPool(tokenA, tokenB, fee))
 *    - "algebra" => Algebra-style factory (poolByPair(tokenA, tokenB))
 *    - "registry"=> not checked (Curve/Balancer style)
 */
const DEX_SOURCES = {
  bsc: [
    { id: "pancake", label: "PancakeSwap", v2Factory: "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73", v3Type: "univ3",  v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865" },
    { id: "apeswap", label: "ApeSwap",      v2Factory: "0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6", v3Type: null,     v3Factory: null },
    { id: "biswap",  label: "BiSwap",       v2Factory: "0x858E3312ed3A876947EA49d572A7C42DE08af7EE", v3Type: null,     v3Factory: null },
    { id: "bakery",  label: "BakerySwap",   v2Factory: "0x01bF7C66c6BD861915CdaaE475042d3c4BaE16A7", v3Type: null,     v3Factory: null },
    { id: "sushi",   label: "SushiSwap",    v2Factory: "0xc35DADB65012eC5796536bD9864eD8773aBc74C4", v3Type: "univ3",  v3Factory: "0x126555dd55a39328F69400d6aE4F782Bd4C34ABb" },
    { id: "thena",   label: "THENA V3 (Algebra)", v2Factory: null, v3Type: "algebra", v3Factory: "0x306F06C147f064A010530292A1EB6737c3e378e4" }
  ],

  eth: [
    { id: "uniswap", label: "Uniswap",     v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", v3Type: "univ3",  v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984" },
    { id: "sushi",   label: "SushiSwap",   v2Factory: "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac", v3Type: "univ3",  v3Factory: "0xbACEB8eC6b9355Dfc0269C18bac9d6E2Bdc29C4F" },
    { id: "pancake", label: "PancakeSwap", v2Factory: "0x1097053Fd2ea711dad45caCcc45EfF7548fCB362", v3Type: "univ3",  v3Factory: "0x13f4EA83D0bd40E75C8222255bc855a974568Dd4" },

    { id: "curve",   label: "Curve",       v2Factory: null, v3Type: "registry", v3Factory: null, infoUrl: "https://curve.fi" },
    { id: "balancer",label: "Balancer",    v2Factory: null, v3Type: "registry", v3Factory: null, infoUrl: "https://balancer.fi" }
  ]
};

// --- Minimal ABIs (safe even if unused) ---
const ALG_FACTORY_ABI = [
  "function poolByPair(address tokenA, address tokenB) view returns (address pool)"
];
const ALG_POOL_ABI = [
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function liquidity() view returns (uint128)"
];

// ---- stability helpers ----
function liqWithTimeout(promise, ms, label){
  let t;
  const timeout = new Promise((_, rej) => {
    t = setTimeout(() => rej(new Error(`timeout:${label||"call"}`)), ms);
  });
  return Promise.race([promise, timeout]).finally(() => clearTimeout(t));
}

async function liqPoolMap(items, limit, fn){
  const out = new Array(items.length);
  let i = 0;
  const workers = new Array(Math.max(1, limit)).fill(0).map(async () => {
    while (true) {
      const idx = i++;
      if (idx >= items.length) break;
      out[idx] = await fn(items[idx], idx);
    }
  });
  await Promise.all(workers);
  return out;
}

function liqBuildShareLink(net, token){
  const u = new URL(location.href);
  u.searchParams.set("tool", "liq");
  u.searchParams.set("net", net);
  u.searchParams.set("token", token);
  return u.toString();
}

function liqGetSources(net){
  const src = Array.isArray(DEX_SOURCES?.[net]) ? DEX_SOURCES[net] : [];
  // Dedup by id/label to avoid duplicate checks
  const seen = new Set();
  const out = [];
  for (const s of src) {
    const key = String(s.id || s.label || "").toLowerCase();
    if (!key || seen.has(key)) continue;
    seen.add(key);
    out.push(s);
  }
  return out;
}

async function runLiqScan(){
  const st = $("#liq-status");
  const out = $("#liq-out");
  const risk = $("#liq-risk");
  const wrap = $("#liq-tablewrap");

  clearStatus(st);
  risk.innerHTML = "";

  const net = netFromSelect("#liq-net");
  const tokenRaw = ($("#liq-token")?.value || "").trim();
  if (!isAddr(tokenRaw)) {
    setStatus(st, "warn", "Please paste a valid token address.");
    return;
  }
  const token = normAddr(tokenRaw);

  setStatus(st, "info", "Scanning liquidityâ€¦");
  const chain = CHAINS[net];
  const read = getReadProvider(net);
  if (!read) {
    setStatus(st, "bad", "No RPC available.");
    return;
  }

  const sources = liqGetSources(net);
  const res = {
    net, token,
    sources: sources.map(s => s.label),
    v2: [],
    v3: [],
    unknown: [],
    ts: nowTs()
  };

  // Config (safe defaults for public RPC)
  const CALL_TIMEOUT_MS = 6500;   // prevents hanging
  const V3_CONCURRENCY  = 3;      // avoid rate limit
  const v2PairsToCheck = [
    { other: chain.wrapped, label: "Wrapped" },
    { other: chain.usdt,    label: "USDT" }
  ];
  const v3Fees = [500, 3000, 10000];

  const pushUnknown = (s, kind, detail, link) => {
    res.unknown.push({
      source: s.label || s.id || "Source",
      kind,
      detail,
      link: link || ""
    });
  };

  for (const s of sources) {
    // Registry DEXes => explicit not checked
    if (s.v3Type === "registry") {
      pushUnknown(s, "Registry", "Not checked (registry model not supported in this scanner yet).", s.infoUrl || "");
      continue;
    }

    // ---------- V2 ----------
    if (s.v2Factory && isAddr(s.v2Factory)) {
      try {
        const f = new E.Contract(s.v2Factory, V2_FACTORY_ABI, read);

        // Only 2 getPair calls; add timeout
        const pairAddrs = await Promise.all(
          v2PairsToCheck.map(p =>
            liqWithTimeout(f.getPair(token, p.other).catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.getPair")
          )
        );

        for (let i = 0; i < v2PairsToCheck.length; i++) {
          const p = v2PairsToCheck[i];
          const pair = pairAddrs[i];

          if (pair && pair !== ZERO) {
            const pairC = new E.Contract(pair, V2_PAIR_ABI, read);
            const [t0, t1, r] = await Promise.all([
              liqWithTimeout(pairC.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.token0"),
              liqWithTimeout(pairC.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.token1"),
              liqWithTimeout(pairC.getReserves().catch(()=>[0n,0n,0n]), CALL_TIMEOUT_MS, "v2.reserves")
            ]);

            res.v2.push({
              source: s.label,
              pair,
              token0: t0,
              token1: t1,
              reserve0: String(r[0]),
              reserve1: String(r[1]),
              otherLabel: p.label,
              other: p.other
            });
          }
        }
      } catch (e) {
        pushUnknown(s, "V2", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v2Factory));
      }
    } else if (s.v2Factory === null) {
      // intentionally no V2
    } else {
      pushUnknown(s, "V2", "Not checked (no V2 factory configured).", "");
    }

    // ---------- V3 UniswapV3 style ----------
    if (s.v3Type === "univ3") {
      if (s.v3Factory && isAddr(s.v3Factory)) {
        try {
          const vf = new E.Contract(s.v3Factory, V3_FACTORY_ABI, read);

          // Build (pair x fee) tasks
          const tasks = [];
          for (const p of v2PairsToCheck) {
            for (const fee of v3Fees) tasks.push({ p, fee });
          }

          const pools = await liqPoolMap(tasks, V3_CONCURRENCY, async ({p, fee}) => {
            const pool = await liqWithTimeout(
              vf.getPool(token, p.other, fee).catch(()=>ZERO),
              CALL_TIMEOUT_MS,
              "v3.getPool"
            );
            return { p, fee, pool };
          });

          for (const x of pools) {
            if (!x.pool || x.pool === ZERO) continue;

            const vp = new E.Contract(x.pool, V3_POOL_ABI, read);
            const [t0, t1, liq, slot0] = await Promise.all([
              liqWithTimeout(vp.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "v3.token0"),
              liqWithTimeout(vp.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "v3.token1"),
              liqWithTimeout(vp.liquidity().catch(()=>0n), CALL_TIMEOUT_MS, "v3.liquidity"),
              liqWithTimeout(vp.slot0().catch(()=>null), CALL_TIMEOUT_MS, "v3.slot0")
            ]);

            res.v3.push({
              source: s.label,
              fee: x.fee,
              otherLabel: x.p.label,
              other: x.p.other,
              pool: x.pool,
              token0: t0,
              token1: t1,
              liquidity: String(liq),
              tick: slot0 ? String(slot0[1]) : "â€”"
            });
          }
        } catch (e) {
          pushUnknown(s, "V3", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v3Factory));
        }
      } else {
        pushUnknown(s, "V3", "Not checked (no V3 factory configured).", "");
      }
    }

    // ---------- V3 Algebra style (THENA) ----------
    if (s.v3Type === "algebra") {
      if (s.v3Factory && isAddr(s.v3Factory)) {
        try {
          const af = new E.Contract(s.v3Factory, ALG_FACTORY_ABI, read);

          const poolAddrs = await Promise.all(
            v2PairsToCheck.map(p =>
              liqWithTimeout(af.poolByPair(token, p.other).catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.poolByPair")
            )
          );

          for (let i = 0; i < v2PairsToCheck.length; i++) {
            const p = v2PairsToCheck[i];
            const pool = poolAddrs[i];
            if (!pool || pool === ZERO) continue;

            const ap = new E.Contract(pool, ALG_POOL_ABI, read);
            const [t0, t1, liq] = await Promise.all([
              liqWithTimeout(ap.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.token0"),
              liqWithTimeout(ap.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.token1"),
              liqWithTimeout(ap.liquidity().catch(()=>0n), CALL_TIMEOUT_MS, "alg.liquidity")
            ]);

            res.v3.push({
              source: s.label,
              fee: "â€”",
              otherLabel: p.label,
              other: p.other,
              pool,
              token0: t0,
              token1: t1,
              liquidity: String(liq),
              tick: "â€”"
            });
          }
        } catch (e) {
          pushUnknown(s, "V3", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v3Factory));
        }
      } else {
        pushUnknown(s, "V3", "Not checked (no Algebra factory configured).", "");
      }
    }
  }

  // Render chips (avoid false green)
  const chips = [];
  const v2n = res.v2.length;
  const v3n = res.v3.length;
  const un = res.unknown.length;

  if (v2n) chips.push(qsRiskChip("ok", `V2 pairs found: ${v2n}`));
  else chips.push(qsRiskChip("warn", "No V2 pairs found (wrapped/USDT)."));

  if (v3n) chips.push(qsRiskChip("ok", `V3 pools found: ${v3n}`));
  else chips.push(qsRiskChip("warn", "No V3 pools found (wrapped/USDT, fee tiers)."));

  if (un) chips.push(qsRiskChip("warn", `Unknown / not checked: ${un}`));
  risk.innerHTML = chips.join("");

  const rows = [];
  rows.push(`
    <div class="trow head">
      <div class="cell">Pool / Pair</div>
      <div class="cell">Type</div>
      <div class="cell">Detail</div>
      <div class="cell">Link</div>
    </div>
  `);

  // V2 rows
  for (const v of res.v2) {
    const hasRes = (BigInt(v.reserve0) > 0n && BigInt(v.reserve1) > 0n);
    rows.push(`
      <div class="trow ${hasRes ? "highlight" : ""}">
        <div class="cell mono">${shortAddr(v.pair)}</div>
        <div class="cell">V2</div>
        <div class="cell">${escapeHtml(v.source)} â€¢ Reserves: ${hasRes ? "âœ…" : "â€”"} â€¢ ${escapeHtml(v.otherLabel)}</div>
        <div class="cell"><a href="${chain.addressUrl(v.pair)}" target="_blank" rel="noopener">Explorer</a></div>
      </div>
    `);
  }

  // V3 rows
  for (const v of res.v3) {
    const liqOk = (() => { try { return BigInt(v.liquidity) > 0n; } catch { return false; } })();
    const feeTxt = (v.fee === "â€”") ? "Fee: â€”" : `Fee: ${v.fee}`;
    rows.push(`
      <div class="trow ${liqOk ? "highlight" : ""}">
        <div class="cell mono">${shortAddr(v.pool)}</div>
        <div class="cell">V3</div>
        <div class="cell">${escapeHtml(v.source)} â€¢ ${escapeHtml(v.otherLabel)} â€¢ ${feeTxt} â€¢ Liquidity: ${liqOk ? "âœ…" : "â€”"}${v.tick ? ` â€¢ Tick: ${escapeHtml(v.tick)}` : ""}</div>
        <div class="cell"><a href="${chain.addressUrl(v.pool)}" target="_blank" rel="noopener">Explorer</a></div>
      </div>
    `);
  }

  // Unknown / Not checked rows
  for (const u of res.unknown) {
    const link = u.link ? `<a href="${u.link}" target="_blank" rel="noopener">Link</a>` : "â€”";
    rows.push(`
      <div class="trow">
        <div class="cell mono">â€”</div>
        <div class="cell">${escapeHtml(u.kind)}</div>
        <div class="cell">${escapeHtml(u.source)} â€¢ ${escapeHtml(u.detail)}</div>
        <div class="cell">${link}</div>
      </div>
    `);
  }

  wrap.innerHTML = `<div class="table">${rows.join("")}</div>`;

  out.innerHTML = `
    <b>Multi-source liquidity scan</b> completed.<br>
    Network: ${escapeHtml(chain.name)}<br>
    Token: <span class="mono">${token}</span><br>
    Sources: ${escapeHtml(res.sources.join(", "))}<br>
    Share: <span class="mono">${liqBuildShareLink(net, token)}</span>
  `;
  out.style.display = "block";

  setStatus(st, (v2n || v3n) ? "ok" : "warn", "Done.");
  gtagEvent("sec_liq_run", { net, sources: sources.length, unknown: un });
}

function initLiqUi(){
  const updateDexNote = () => {
    const net = netFromSelect("#liq-net");
    const src = liqGetSources(net).map(s => s.label);
    const el = $("#liq-dex-note");
    if (el) el.textContent = `Sources: ${src.join(", ")} (V2: wrapped+USDT â€¢ V3: wrapped+USDT + fee tiers â€¢ Algebra supported â€¢ Registry DEXes shown as not checked)`;
  };
  $("#liq-net")?.addEventListener("change", updateDexNote);
  updateDexNote();

  $("#liq-run")?.addEventListener("click", runLiqScan);

  $("#liq-copy-link")?.addEventListener("click", async () => {
    const net = netFromSelect("#liq-net");
    const token = ($("#liq-token")?.value || "").trim();
    if (!isAddr(token)) return setStatus($("#liq-status"), "warn", "Enter token address first.");
    const link = liqBuildShareLink(net, normAddr(token));
    const ok = await copyText(link);
    setStatus($("#liq-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
  });

  $("#liq-share-x")?.addEventListener("click", () => {
    const net = netFromSelect("#liq-net");
    const token = ($("#liq-token")?.value || "").trim();
    if (!isAddr(token)) return setStatus($("#liq-status"), "warn", "Enter token address first.");
    const link = liqBuildShareLink(net, normAddr(token));
    const u = new URL("https://twitter.com/intent/tweet");
    u.searchParams.set("text", `Liquidity scan (${CHAINS[net].name})\nToken: ${shortAddr(token)}\n${link}`);
    window.open(u.toString(), "_blank", "noopener,noreferrer");
  });
}

// ---- Safe HTML escape (global) ----
window.escapeHtml = window.escapeHtml || function (s) {
  if (s === null || s === undefined) return "";
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
};



  // =========================
// Wallet Security DNA (replaces Approval Guardian)
// =========================

function dnaNet() {
  // dna-net is the new select; fallback to ap-net if exists
  return netFromSelect("#dna-net") || netFromSelect("#ap-net") || "bsc";
}

function dnaInputAddress() {
  const raw = ($("#dna-walletAddress")?.value || "").trim();
  if (raw && isAddr(raw)) return normAddr(raw);
  if (wallet?.address && isAddr(wallet.address)) return normAddr(wallet.address);
  return "";
}

function dnaSetWalletBadges() {
  const w = wallet?.address ? shortAddr(wallet.address) : "not connected";
  const addr = wallet?.address ? shortAddr(wallet.address) : "â€”";
  const net = dnaNet();

  const elWallet = $("#dna-wallet");
  const elAddr = $("#dna-address");

  if (elWallet) elWallet.textContent = w;
  if (elAddr) elAddr.textContent = addr;

  // optional: keep legacy ap-wallet/ap-address if you still have them somewhere
  if ($("#ap-wallet")) $("#ap-wallet").textContent = w;
  if ($("#ap-address")) $("#ap-address").textContent = addr;

  gtagEvent?.("sec_dna_wallet_badge", { net, connected: !!wallet?.address });
}

function dnaClearOutputs() {
  dnaApplyPills(null, "â€”");

  const tips = $("#dna-tips");
  if (tips) tips.innerHTML = `<li class="muted" data-i18n="dna_tips_placeholder">â€”</li>`;

  // clear approvals table but keep header
  const table = $("#ap-table");
  const head = table?.querySelector(".trow.head");
  if (table) table.innerHTML = "";
  if (table && head) table.appendChild(head);

  clearStatus?.($("#dna-status"));
  clearStatus?.($("#ap-status"));
}

function dnaRiskLevelFromScore(score) {
  const s = Number(score);
  if (!Number.isFinite(s)) return "â€”";
  if (s >= 80) return "Low";
  if (s >= 50) return "Medium";
  return "High";
}
// Score tier -> ok (green) | warn (orange) | bad (red) | unk
function dnaScoreTierFromScore(score){
  const s = Number(score);
  if (!Number.isFinite(s)) return "unk";
  if (s >= 80) return "ok";
  if (s >= 50) return "warn";
  return "bad";
}

// Apply text + color classes to the pills
function dnaApplyPills(score, riskText){
  const scoreEl = $("#dna-score");
  const riskEl  = $("#dna-risk");

  // --- SCORE ---
  if (scoreEl){
    const s = Number(score);
    scoreEl.textContent = Number.isFinite(s) ? String(Math.round(s)) : "â€”";

    scoreEl.classList.remove("score-ok","score-warn","score-bad","score-unk");
    scoreEl.classList.add("score-" + dnaScoreTierFromScore(s));
  }

  // --- RISK ---
  if (riskEl){
    const txt = (riskText == null ? "â€”" : String(riskText));
    riskEl.textContent = txt;

    riskEl.classList.remove("risk-low","risk-med","risk-high","risk-unk");
    const t = txt.toLowerCase();
    let lvl = "unk";
    if (t.includes("low")) lvl = "low";
    else if (t.includes("med")) lvl = "med";
    else if (t.includes("high")) lvl = "high";
    riskEl.classList.add("risk-" + lvl);
  }
}


function dnaNormalizeApiRow(row) {
  // Moralis-like keys (common)
  const tokenRaw =
    row?.token || row?.token_address || row?.tokenAddress || row?.contract_address || row?.contractAddress || "";
  const spenderRaw =
    row?.spender || row?.spender_address || row?.spenderAddress || row?.operator || "";

  const token = isAddr(tokenRaw) ? normAddr(tokenRaw) : "";
  const spender = isAddr(spenderRaw) ? normAddr(spenderRaw) : "";

  const symbol = row?.symbol || row?.token_symbol || row?.tokenSymbol || row?.token_name || "â€”";

  const allowanceRaw =
    row?.allowance ?? row?.value ?? row?.amount ?? row?.approved_amount ?? row?.approvedAmount ?? "0";
  const allowanceStr = String(allowanceRaw);

  const verified =
    row?.verified === true ? "Verified" :
    row?.verified === false ? "Unverified" :
    row?.verifiedStatus || row?.verification || row?.verified || "â€”";

  const lastUpdated =
    row?.lastUpdated || row?.updatedAt || row?.block_timestamp || row?.blockTimestamp || "â€”";

  let flags = row?.flags ?? row?.suspicious ?? row?.risk_flags ?? "â€”";
  if (Array.isArray(flags)) flags = flags.length ? flags.join(", ") : "â€”";

  const risk = row?.risk || row?.riskLevel || "â€”";

  return { token, spender, symbol, allowanceStr, verified, lastUpdated, flags, risk };
}


function dnaFormatAllowance(allowanceStr) {
  if (!allowanceStr) return "â€”";
  const v = String(allowanceStr).toLowerCase();
  if (v === "infinite" || v === "âˆž" || v.includes("inf")) return "âˆž";
  return allowanceStr;
}

function dnaRowRiskChip(risk) {
  const r = String(risk || "â€”").toLowerCase();
  if (r.includes("high")) return `<span class="chip chip-danger">High</span>`;
  if (r.includes("med")) return `<span class="chip chip-warn">Medium</span>`;
  if (r.includes("low")) return `<span class="chip chip-ok">Low</span>`;
  if (r === "â€”") return `<span class="muted">â€”</span>`;
  return `<span class="chip">${window.escapeHtml(String(risk))}</span>`;
}

// âœ… FIX: "unverified" includes "verif" so must check UNVERIFIED first
function dnaVerifiedChip(verified) {
  const v = String(verified || "â€”").toLowerCase();
  if (v.includes("unver")) return `<span class="chip chip-warn">Unverified</span>`;
  if (v.includes("verif")) return `<span class="chip chip-ok">Verified</span>`;
  return `<span class="muted">â€”</span>`;
}

function dnaBindRevokeButtons(net) {
  $$("#ap-table [data-revoke]").forEach((btn) => {
    btn.addEventListener("click", async () => {
      const tk = btn.getAttribute("data-token");
      const sp = btn.getAttribute("data-spender");
      await dnaRevokeOne(net, tk, sp);
    });
  });
}

// -------------------------
// API fetch (handles 429 + JSON error bodies) âœ…
// -------------------------
const DNA_API_BASE =
  (window.CYCLEX_API_BASE && String(window.CYCLEX_API_BASE).trim()) || location.origin;

async function dnaFetchApprovals(net, address) {
  const u = new URL("/api/getApprovals", DNA_API_BASE);
  u.searchParams.set("net", net);
  u.searchParams.set("address", address);

  // optional timeout (keeps UI responsive)
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), 15000);

  let res;
  try {
    res = await fetch(u.toString(), { method: "GET", signal: ctrl.signal });
  } finally {
    clearTimeout(t);
  }

  // Try read json, else text
  const ct = (res.headers.get("content-type") || "").toLowerCase();
  const readBody = async () => {
    if (ct.includes("application/json")) {
      try { return await res.json(); } catch { /* ignore */ }
    }
    const txt = await res.text().catch(() => "");
    return txt;
  };

  if (res.status === 429) {
    const body = await readBody();
    const err = new Error("RATE_LIMIT");
    err.status = 429;
    err.body = body;
    return Promise.reject(err);
  }

  if (!res.ok) {
    const body = await readBody();
    const err = new Error(`API_ERROR_${res.status}`);
    err.status = res.status;
    err.body = body;
    return Promise.reject(err);
  }

  return await res.json();
}

function dnaRenderTips(list) {
  const tips = $("#dna-tips");
  if (!tips) return;
  if (!Array.isArray(list) || !list.length) {
    tips.innerHTML = `<li class="muted">â€”</li>`;
    return;
  }
  tips.innerHTML = list.map(t => `<li>${window.escapeHtml(String(t))}</li>`).join("");
}

function dnaRenderTable(rows) {
  const table = $("#ap-table");
  const head = table?.querySelector(".trow.head");
  if (table) table.innerHTML = "";
  if (table && head) table.appendChild(head);

  if (!table) return;

  if (!rows.length) {
  table.insertAdjacentHTML("beforeend", `
    <div class="trow ap-main">
      <div class="cell muted">â€”</div>
      <div class="cell muted hide-sm">â€”</div>
      <div class="cell muted">â€”</div>
      <div class="cell muted hide-sm">â€”</div>
      <div class="cell muted hide-sm">â€”</div>
      <div class="cell muted">â€”</div>
      <div class="cell muted">â€”</div>
    </div>
  `);
  return;
}




    const html = rows.map(r => {
    const tkTxt = r.token ? shortAddr(r.token) : "â€”";
    const spTxt = r.spender ? shortAddr(r.spender) : "â€”";
    const alwTxt = dnaFormatAllowance(r.allowanceStr);
    const verTxt = dnaVerifiedChip(r.verified);
    const riskChip = dnaRowRiskChip(r.risk);

    const flagsTxtRaw = (r.flags && r.flags !== "â€”") ? String(r.flags) : "";
    const flagsTxt = flagsTxtRaw ? window.escapeHtml(flagsTxtRaw) : "â€”";

    const canRevoke =
      r.token && r.spender &&
      alwTxt !== "â€”" &&
      alwTxt !== "0";

    const actionHtml = canRevoke
      ? `<button class="chip chip-danger" data-revoke="1" data-token="${r.token}" data-spender="${r.spender}">Revoke</button>`
      : `<span class="muted">â€”</span>`;

    return `
      <!-- MAIN ROW (no Flags column) -->
      <div class="trow ap-main">
        <div class="cell mono">${tkTxt}</div>
        <div class="cell mono hide-sm">${spTxt}</div>
        <div class="cell">${window.escapeHtml(String(alwTxt))}</div>
        <div class="cell hide-sm">${verTxt}</div>
        <div class="cell hide-sm">${window.escapeHtml(String(r.lastUpdated || "â€”"))}</div>
        <div class="cell">${riskChip}</div>
        <div class="cell">${actionHtml}</div>
      </div>

      <!-- FLAGS ROW (full width; only visible on desktop where flags exist in head) -->
      <div class="trow ap-flags-row hide-sm">
        <div class="cell ap-flags-cell">
          <span class="muted" style="margin-right:10px;">Flags:</span>
          <span class="mono">${flagsTxt}</span>
        </div>
      </div>
    `;
  }).join("");

  table.insertAdjacentHTML("beforeend", html);

}

function dnaComputeFallbackTips(rows) {
  const tips = [];
  const high = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
  const unverified = rows.filter(r => String(r.verified).toLowerCase().includes("unver")).length;
  const flagged = rows.filter(r => r.flags && r.flags !== "â€”").length;
  const infinite = rows.filter(r => String(r.allowanceStr).toLowerCase().includes("inf") || String(r.allowanceStr) === "âˆž").length;

  if (high) tips.push(`Revoke high-risk approvals first (${high}).`);
  if (infinite) tips.push(`Consider revoking infinite approvals you donâ€™t fully trust (${infinite}).`);
  if (unverified) tips.push(`Review unverified spender contracts before keeping approvals (${unverified}).`);
  if (flagged) tips.push(`Check flagged interactions and bridges before signing again (${flagged}).`);
  if (!tips.length) tips.push("No major red flags detected. Keep monitoring regularly.");

  return tips;
}

async function dnaScan() {
  const st = $("#dna-status");
  clearStatus?.(st);

  const net = dnaNet();
  const address = dnaInputAddress();

  if (!address) return setStatus(st, "warn", "Enter a valid wallet address or connect a wallet.");

  setStatus(st, "info", "Scanning approvalsâ€¦");

  try {
    const data = await dnaFetchApprovals(net, address);

    const approvals =
  Array.isArray(data) ? data :
  Array.isArray(data?.approvals) ? data.approvals :
  Array.isArray(data?.result) ? data.result :
  Array.isArray(data?.data) ? data.data :
  [];

    const rows = approvals.map(dnaNormalizeApiRow);

    dnaRenderTable(rows);
    dnaBindRevokeButtons(net);

    const score = (Array.isArray(data) ? null : data?.score);
    const riskLevel = (Array.isArray(data) ? null : data?.riskLevel);

    if (score != null || riskLevel) {
  dnaApplyPills(score, riskLevel || dnaRiskLevelFromScore(score));
}

    if (score == null) {
      let s = 100;
      const high = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
      const unverified = rows.filter(r => String(r.verified).toLowerCase().includes("unver")).length;
      const flagged = rows.filter(r => r.flags && r.flags !== "â€”").length;
      const infinite = rows.filter(r => String(r.allowanceStr).toLowerCase().includes("inf") || String(r.allowanceStr) === "âˆž").length;

      s -= high * 20;
      s -= unverified * 10;
      s -= flagged * 8;
      s -= infinite * 12;
      s = Math.max(0, Math.min(100, s));

      dnaApplyPills(s, dnaRiskLevelFromScore(s));

    }
    //try {
  //const scoreNow = Number(($("#dna-score")?.textContent || "0").trim());
  //const u = new URL("/api/saveScore", DNA_API_BASE);
  //await fetch(u.toString(), {
    //method: "POST",
    //headers: { "content-type": "application/json" },
    //body: JSON.stringify({ net, score: scoreNow })
  //});
//} catch {}

    try {
  const scoreNow = Number(($("#dna-score")?.textContent || "0").trim());
  const u = new URL("/api/saveScore", DNA_API_BASE);
  const resp = await fetch(u.toString(), {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ net, score: scoreNow })
  });
  if (!resp.ok) throw new Error(`saveScore ${resp.status}`);
} catch {}



    const tips = (Array.isArray(data) ? null : data?.tips);
    dnaRenderTips(Array.isArray(tips) ? tips : dnaComputeFallbackTips(rows));

    setStatus(st, "ok", "Done.");
    gtagEvent?.("sec_dna_scan", { net });

  } catch (e) {
    // âœ… Friendly 429 handling
    if (e?.status === 429) {
      return setStatus(
        st,
        "warn",
        "Rate limit: max 2 checks per hour per IP. Please try again later."
      );
    }

    // other errors
    const msg = e?.status
      ? `Scan failed (${e.status}). Make sure /api/getApprovals works.`
      : `Scan failed: ${String(e?.message || e)}`;

    setStatus(st, "bad", msg);
    // optional debug
    // console.log("dnaScan error:", e);
  }
}

async function dnaConnectWallet() {
  const st = $("#dna-status");
  clearStatus?.(st);

  try {
    // 1) Use your existing CycleX wallet connect (AppKit/Web3Modal)
    if (typeof window.cxConnectWallet === "function") {
      const ok = await window.cxConnectWallet({ silent: true });
      if (!ok) {
        setStatus(st, "warn", "Wallet connect cancelled or timed out. Try again.");
        return;
      }
    }
    // 2) fallback if you ever add a generic connectWallet()
    else if (typeof window.connectWallet === "function") {
      await window.connectWallet();
    }
    // 3) last fallback (if you ever expose wallet.connect)
    else if (wallet?.connect) {
      await wallet.connect();
    } else {
      setStatus(st, "warn", "No wallet connect function found.");
      return;
    }

    // wallet object should now be populated by cxConnectWallet:
    dnaSetWalletBadges();

    setStatus(
      st,
      "ok",
      wallet?.address
        ? `Wallet connected: <span class="mono">${shortAddr(wallet.address)}</span>`
        : "Wallet connected."
    );

    gtagEvent?.("sec_dna_connect", { net: dnaNet(), chainId: wallet?.chainId || 0 });
  } catch (e) {
    setStatus(st, "bad", `Connect failed: ${String(e?.message || e)}`);
  }
}


async function dnaRevokeOne(net, token, spender) {
  const st = $("#dna-status");

  if (!wallet?.signer || !wallet?.address) {
    setStatus(st, "warn", "Connect a wallet first to revoke.");
    return;
  }

  const typed = ($("#dna-walletAddress")?.value || "").trim();
  if (typed && isAddr(typed) && normAddr(typed) !== normAddr(wallet.address)) {
    setStatus(st, "warn", "You are connected with a different wallet than the address you scanned. Revoke affects ONLY the connected wallet.");
    return;
  }

  const chainId = CHAINS[net]?.chainId;
  if (chainId && wallet.chainId && wallet.chainId !== chainId) {
    const ok = await ensureChain(chainId);
    if (!ok) return setStatus(st, "warn", `Please switch network to ${CHAINS[net].name}.`);
  }

  try {
    setStatus(st, "info", "Sending revoke tx (approve â†’ 0)â€¦");
    const c = new E.Contract(normAddr(token), ERC20_ABI, wallet.signer);
    const tx = await c.approve(normAddr(spender), 0n);
    setStatus(st, "info", `Pending: <span class="mono">${tx.hash}</span>`);
    await tx.wait();
    setStatus(st, "ok", "Revoke confirmed.");

    gtagEvent?.("sec_dna_revoke_one", { net });

    await dnaScan();

  } catch (e) {
    setStatus(st, "bad", `Revoke failed: ${String(e?.message || e)}`);
  }
}

async function dnaRevokeAll() {
  const st = $("#dna-status");
  const net = dnaNet();

  if (!wallet?.signer || !wallet?.address) return setStatus(st, "warn", "Connect a wallet first to revoke.");

  const typed = ($("#dna-walletAddress")?.value || "").trim();
  if (typed && isAddr(typed) && normAddr(typed) !== normAddr(wallet.address)) {
    return setStatus(st, "warn", "You are connected with a different wallet than the address you scanned. Revoke affects ONLY the connected wallet.");
  }

  const btns = $$("#ap-table [data-revoke]");
  if (!btns.length) return setStatus(st, "ok", "Nothing to revoke.");

  const chainId = CHAINS[net]?.chainId;
  if (chainId && wallet.chainId && wallet.chainId !== chainId) {
    const ok = await ensureChain(chainId);
    if (!ok) return setStatus(st, "warn", `Please switch network to ${CHAINS[net].name}.`);
  }

  setStatus(st, "info", `Revoking ${btns.length} approval(s)â€¦`);

  for (let i = 0; i < btns.length; i++) {
    const tk = btns[i].getAttribute("data-token");
    const sp = btns[i].getAttribute("data-spender");
    try {
      const c = new E.Contract(normAddr(tk), ERC20_ABI, wallet.signer);
      const tx = await c.approve(normAddr(sp), 0n);
      setStatus(st, "info", `(${i + 1}/${btns.length}) Pending: <span class="mono">${tx.hash}</span>`);
      await tx.wait();
    } catch (e) {
      setStatus(st, "warn", `(${i + 1}/${btns.length}) Failed: ${shortAddr(tk)} â€” ${String(e?.message || e)}`);
    }
  }
 
  setStatus(st, "ok", "Revoke-all finished.");
  gtagEvent?.("sec_dna_revoke_all", { net });

  await dnaScan();
}

function dnaSeedCommon() {
  const net = dnaNet();
  const chain = CHAINS[net];
  const list = [chain?.wrapped, chain?.usdt].filter(Boolean);
  const ta = $("#dna-tokens");
  if (ta) ta.value = list.join("\n");
  setStatus($("#dna-status"), "ok", "Seeded common tokens (wrapped + USDT).");
}

function dnaSeedHistory() {
  const hist = loadQsHistory?.() || [];
  const net = dnaNet();
  const tokens = hist.filter(x => x?.net === net).slice(0, 20).map(x => x.token).filter(Boolean);
  const ta = $("#dna-tokens");
  if (ta) ta.value = tokens.join("\n");
  setStatus($("#dna-status"), tokens.length ? "ok" : "warn", tokens.length ? "Seeded from scan history." : "No scan history found for this network.");
}

function dnaShareScore() {
  const score = ($("#dna-score")?.textContent || "â€”").trim();
  const risk = ($("#dna-risk")?.textContent || "â€”").trim();
  const net = dnaNet();
  const addr = dnaInputAddress() ? shortAddr(dnaInputAddress()) : "wallet";

  const text = `Wallet Security DNA (${net.toUpperCase()}): ${addr} â€” Score: ${score}/100, Risk: ${risk}.`;
  const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(location.href)}`;
  window.open(shareUrl, "_blank", "noopener,noreferrer");
  gtagEvent?.("sec_dna_share", { net });
}

//async function dnaShowLeaderboard() {
  //const st = $("#dna-status");
  //const net = dnaNet();
  //setStatus(st, "info", "Loading leaderboardâ€¦");

  //try {
    //const u = new URL("/api/leaderboard", DNA_API_BASE);
//u.searchParams.set("net", net);
//const res = await fetch(u.toString());

  //  if (!res.ok) throw new Error(`API error: ${res.status}`);
   // const data = await res.json();

    //const top = Array.isArray(data) ? data : (data?.top || []);
    //if (!top.length) return setStatus(st, "warn", "Leaderboard is empty.");

    //const lines = top.slice(0, 10).map((x, i) => {
      //const s = x?.score ?? "â€”";
      //return `${i + 1}) ${s}`;
    //}).join(" Â· ");

    //setStatus(st, "ok", `Leaderboard: ${lines}`);
    //gtagEvent?.("sec_dna_leaderboard", { net });

  //} catch (e) {
    //setStatus(st, "warn", `Leaderboard unavailable: ${String(e?.message || e)}`);
  //}
//}

function initWalletSecurityDNAUi() {
  dnaSetWalletBadges();

  $("#dna-run")?.addEventListener("click", dnaScan);
  $("#dna-reset")?.addEventListener("click", dnaClearOutputs);
  $("#dna-connect")?.addEventListener("click", dnaConnectWallet);

  $("#dna-revoke-all")?.addEventListener("click", dnaRevokeAll);

  $("#dna-seed-common")?.addEventListener("click", dnaSeedCommon);
  $("#dna-seed-history")?.addEventListener("click", dnaSeedHistory);

  $("#dna-share")?.addEventListener("click", dnaShareScore);
  //$("#dna-leaderboard")?.addEventListener("click", dnaShowLeaderboard);

  $("#dna-net")?.addEventListener("change", () => {
    dnaClearOutputs();
    dnaSetWalletBadges();
  });

  window.initApprovalsUi = initWalletSecurityDNAUi;
}


    // =========================
    // RPC Health Checker
    // =========================
    function rpcRowHtml(url, ms, chain, block, callOk, logsOk, status){
  const ok = status === "ok";
  const cls = ok ? "highlight" : "";

  // Host label
  let host = url;
  try { host = new URL(url).host; } catch {}

  const msTxt    = (ms ?? "â€”");
  const blockTxt = (block ?? "â€”");
  const callTxt  = (callOk ?? "â€”");
  const logsTxt  = (logsOk ?? "â€”");

  return `
    <div class="trow rpc ${cls}">
      <div class="cell rpc-url">
        <div class="rpc-host mono">${host}</div>
        <div class="rpc-full mono" title="${url}">${url}</div>
      </div>

      <div class="cell rpc-status">
        <span class="sig ${ok ? "ok" : "unk"}">
          <span class="dot"></span>
          ${ok ? "ok" : "fail"}
        </span>
      </div>

      <div class="cell rpc-meta">
        <span class="m"><b>MS</b> ${msTxt}</span>
        <span class="m"><b>Block</b> ${blockTxt}</span>
        <span class="m"><b>Call</b> ${callTxt}</span>
        <span class="m"><b>Logs</b> ${logsTxt}</span>
      </div>
    </div>
  `;
}


    async function rpcTestOne(net, url){
      const chainIdExpected = CHAINS[net].chainId;

      const t0 = performance.now();
      let chainId = null;
      let block = null;
      let callOk = "â€”";
      let logsOk = "â€”";

      try{
        const cid = await rpcRequest(url, "eth_chainId", [], 8000);
        chainId = parseInt(cid, 16);
        if (chainId !== chainIdExpected) throw new Error(`wrong chainId ${chainId}`);
      } catch (e){
        const ms = Math.round(performance.now() - t0);
        return { ok: false, url, ms, chainId: chainId ?? "â€”", block: "â€”", callOk: "â€”", logsOk: "â€”", err: e };
      }

      try{
        const bn = await rpcRequest(url, "eth_blockNumber", [], 8000);
        block = parseInt(bn, 16);
      } catch {}

      try{
        // simple eth_call to get WETH/WBNB decimals (cheap)
        const wrapped = CHAINS[net].wrapped;
        const dataDecimals = "0x313ce567"; // decimals()
        const res = await rpcRequest(url, "eth_call", [{ to: wrapped, data: dataDecimals }, "latest"], 8000);
        callOk = (res && res !== "0x") ? "âœ…" : "â€”";
      } catch {
        callOk = "â€”";
      }

      try{
        // lightweight logs read: last 200 blocks, Transfer topic on wrapped
        const latest = block || (parseInt(await rpcRequest(url, "eth_blockNumber", [], 8000), 16));
        const from = Math.max(0, latest - 200);
        const filter = {
          address: CHAINS[net].wrapped,
          fromBlock: "0x" + from.toString(16),
          toBlock: "0x" + latest.toString(16),
          topics: [TRANSFER_TOPIC0]
        };
        const logs = await rpcRequest(url, "eth_getLogs", [filter], 8500);
        logsOk = Array.isArray(logs) ? "âœ…" : "â€”";
      } catch {
        logsOk = "â€”";
      }

      const ms = Math.round(performance.now() - t0);
      return { ok: true, url, ms, chainId, block, callOk, logsOk };
    }

    async function runRpcTest(){
      const st = $("#rpc-status");
      clearStatus(st);

      const net = netFromSelect("#rpc-net");
      const table = $("#rpc-table");

      // reset table head
      if (table) {
        const head = table.querySelector(".trow.head.rpc");
        table.innerHTML = "";
        if (head) table.appendChild(head);
      }

      const urls = buildRpcCandidates(net);
      if (!urls.length) return setStatus(st, "warn", "No RPCs available.");

      setStatus(st, "info", `Testing ${urls.length} RPC(s)â€¦`);

      let best = null;
      for (const url of urls) {
        const r = await rpcTestOne(net, url);
        if (table) {
          table.insertAdjacentHTML("beforeend", rpcRowHtml(
            url,
            r.ms ?? "â€”",
            r.chainId ?? "â€”",
            r.block ?? "â€”",
            r.callOk ?? "â€”",
            r.logsOk ?? "â€”",
            r.ok ? "ok" : "fail"
          ));
        }
        if (r.ok) {
          if (!best || (r.ms < best.ms)) best = r;
        }
      }

      if (best) {
        setSavedBestRpc(net, best.url);
        setStatus(st, "ok", `Best RPC saved: <span class="mono">${best.url}</span>`);
        gtagEvent("sec_rpc_best_saved", { net });
      } else {
        setStatus(st, "bad", "All RPCs failed (CORS/timeout/blocked). Try adding a custom RPC.");
      }
      gtagEvent("sec_rpc_test", { net });
    }

    async function rpcCopyBest(){
      const net = netFromSelect("#rpc-net");
      const best = getSavedBestRpc(net);
      if (!best) return setStatus($("#rpc-status"), "warn", "No saved best RPC yet. Run test first.");
      const ok = await copyText(best);
      setStatus($("#rpc-status"), ok ? "ok" : "warn", ok ? "Copied best RPC." : "Copy failed.");
    }

    function initRpcUi(){
      const netSel = $("#rpc-net");
      const privInput = $("#rpc-private");

      const loadPrivToInput = () => {
        const net = netFromSelect("#rpc-net");
        const saved = getSavedPrivateRpc(net);
        if (privInput) privInput.value = saved;
      };

      netSel?.addEventListener("change", loadPrivToInput);
      loadPrivToInput();

      $("#rpc-private-save")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const v = ($("#rpc-private")?.value || "").trim();
        if (v) setSavedPrivateRpc(net, v);
        setStatus($("#rpc-status"), "ok", "Saved private RPC locally.");
      });

      $("#rpc-private-clear")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        setSavedPrivateRpc(net, "");
        if ($("#rpc-private")) $("#rpc-private").value = "";
        setStatus($("#rpc-status"), "ok", "Cleared private RPC.");
      });

      $("#rpc-test")?.addEventListener("click", runRpcTest);
      $("#rpc-copy-best")?.addEventListener("click", rpcCopyBest);

      $("#rpc-share-x")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const best = getSavedBestRpc(net) || "â€”";
        const u = new URL("https://twitter.com/intent/tweet");
        u.searchParams.set("text", `RPC Health (${CHAINS[net].name})\nBest: ${best}\nCycleX Security Hub`);
        window.open(u.toString(), "_blank", "noopener,noreferrer");
      });

      // Dev custom logs test
      $("#rpc-dev-run")?.addEventListener("click", async () => {
        const net = netFromSelect("#rpc-net");
        const addrRaw = ($("#rpc-dev-addr")?.value || "").trim();
        const topic0 = ($("#rpc-dev-topic")?.value || "").trim() || TRANSFER_TOPIC0;
        if (!addrRaw) return setStatus($("#rpc-status"), "warn", "Enter a contract address for the dev test.");
        if (!isAddr(addrRaw)) return setStatus($("#rpc-status"), "warn", "Invalid contract address.");

        const addr = normAddr(addrRaw);
        const urls = buildRpcCandidates(net);
        if (!urls.length) return setStatus($("#rpc-status"), "warn", "No RPCs available.");

        setStatus($("#rpc-status"), "info", "Running custom logs testâ€¦");
        const latest = await withRpcFallback(net, async (provider, url) => {
          const bn = await provider.getBlockNumber();
          return { url, bn };
        }, { timeoutMs: 9500 });

        if (!latest.ok) return setStatus($("#rpc-status"), "bad", `Failed to read block number: ${String(latest.err?.message || latest.err)}`);

        const bn = latest.res.bn;
        const from = Math.max(0, bn - 2000);

        const r = await withRpcFallback(net, async (provider, url) => {
          const logs = await provider.getLogs({
            address: addr,
            fromBlock: from,
            toBlock: bn,
            topics: [topic0]
          });
          return { url, count: logs.length };
        }, { timeoutMs: 10500 });

        if (r.ok) {
          setStatus($("#rpc-status"), "ok", `Custom logs test OK (${r.res.count} logs) â€” RPC: <span class="mono">${r.url}</span>`);
        } else {
          setStatus($("#rpc-status"), "bad", `Custom logs test failed: ${String(r.err?.message || r.err)}`);
        }
        gtagEvent("sec_rpc_dev_logs", { net });
      });
    }

// =========================
// Tx Decoder (4-line fixed DOM + Allowance line + MethodId + Tokens touched)
// Drop-in replacement for your whole Tx Decoder block.
// =========================

(() => {
  // ---- Minimal ABIs ----
  const tx_ROUTER_ABI_MIN = [
    "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETH(uint256,uint256,address[],address,uint256)",
    "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)"
  ];

  const tx_ERC20_ABI_MIN = [
    "function symbol() view returns (string)",
    "function name() view returns (string)",
    "function decimals() view returns (uint8)"
  ];

  // ---- Constants ----
  const tx_U256_MAX = (1n << 256n) - 1n;

  // Known routers (lowercase keys)
  const tx_KNOWN_ROUTERS = {
    bsc: {
      "0x10ed43c718714eb63d5aa57b78b54704e256024e": "PancakeSwap Router",
      "0x13f4ea83d0bd40e75c8222255bc855a974568dd4": "PancakeSwap V3 Router"
    },
    eth: {
      "0x7a250d5630b4cf539739df2c5dacb4c659f2488d": "Uniswap V2 Router",
      "0xef1c6e67703c7bd7107eed8303fbe6ec2554bf6b": "Uniswap Universal Router"
    }
  };

  // ---- Token meta cache ----
  const tx_TOKEN_META_CACHE = {}; // key: `${net}:${addr}` -> {symbol,name,decimals}

  // ---- Helpers ----
  function tx_esc(s){
    try{
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    } catch { return ""; }
  }

  function tx_badge(kind, label) {
    const k = (kind === "ok" || kind === "warn" || kind === "bad" || kind === "unk") ? kind : "unk";
    return `<span class="v ${k}"><span class="dot"></span>${tx_esc(label)}</span>`;
  }

  function tx_setSum(sel, html) {
    const el = document.querySelector(sel);
    if (el) el.innerHTML = html;
  }

  // Titles already exist in HTML on the left; we only set the value HTML.
  function tx_setLine(sel, _title, badgeHtml) {
    tx_setSum(sel, badgeHtml);
  }

  // Impact line supports a subline (Allowance)
  function tx_setImpactLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-impact", `${badgeHtml}${sub}`);
  }

  // NEW: Target line supports a subline (Tokens touched)
  function tx_setTargetLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-target", `${badgeHtml}${sub}`);
  }

  function tx_resetSummary() {
    tx_setLine("#tx-sum-action", "Action", tx_badge("unk", "â€”"));
    tx_setLine("#tx-sum-risk", "Risk", tx_badge("unk", "â€”"));
    // use Target line with empty subline (keeps same DOM, just value HTML)
    tx_setTargetLine(tx_badge("unk", "â€”"), "");
    tx_setImpactLine(tx_badge("unk", "â€”"), "");
  }

  function tx_isUnlimitedApprove(vBigInt) {
    try { return typeof vBigInt === "bigint" && vBigInt === tx_U256_MAX; } catch { return false; }
  }

  function tx_getKnownRouterName(net, addr) {
    const m = (tx_KNOWN_ROUTERS && tx_KNOWN_ROUTERS[net]) ? tx_KNOWN_ROUTERS[net] : {};
    if (!addr) return "";
    const k = isAddr(addr) ? normAddr(addr) : String(addr).toLowerCase();
    return m[k] || "";
  }

  function tx_decodeTransferLog(log) {
    try {
      const from = "0x" + log.topics[1].slice(26);
      const to   = "0x" + log.topics[2].slice(26);
      const val  = BigInt(log.data);
      return { token: normAddr(log.address), from: normAddr(from), to: normAddr(to), value: val };
    } catch { return null; }
  }

  function tx_decodeApprovalLog(log) {
    try {
      const owner   = "0x" + log.topics[1].slice(26);
      const spender = "0x" + log.topics[2].slice(26);
      const val     = BigInt(log.data);
      return { token: normAddr(log.address), owner: normAddr(owner), spender: normAddr(spender), value: val };
    } catch { return null; }
  }

  // Method selector (4 bytes)
  function tx_callSelector(txData) {
    try {
      const d = String(txData || "");
      if (d && d.startsWith("0x") && d.length >= 10) return d.slice(0, 10);
      return "";
    } catch { return ""; }
  }

  async function tx_getTokenMeta(readProvider, net, tokenAddr) {
    try {
      if (!tokenAddr || !isAddr(tokenAddr)) return null;
      const a = normAddr(tokenAddr);
      const key = `${net}:${a}`;
      if (tx_TOKEN_META_CACHE[key]) return tx_TOKEN_META_CACHE[key];

      const c = new E.Contract(a, tx_ERC20_ABI_MIN, readProvider);
      const [symbol, name, decimals] = await Promise.allSettled([c.symbol(), c.name(), c.decimals()]);

      const meta = {
        symbol: symbol.status === "fulfilled" ? String(symbol.value || "") : "",
        name: name.status === "fulfilled" ? String(name.value || "") : "",
        decimals: decimals.status === "fulfilled" ? Number(decimals.value) : null
      };

      tx_TOKEN_META_CACHE[key] = meta; // cache even partial
      return meta;
    } catch {
      return null;
    }
  }

  function tx_formatUnitsSafe(valueBigInt, decimals) {
    try {
      if (decimals == null || Number.isNaN(decimals)) return null;
      return E.formatUnits(valueBigInt, decimals);
    } catch {
      return null;
    }
  }

  function tx_pickPrimaryToken(approvals, transfers) {
    return (approvals[0]?.token) || (transfers[0]?.token) || "";
  }

  function tx_pickPrimaryApproval(approvals, net){
    // Prefer: unlimited > known-router > larger value > first
    let best = null;
    let bestIsUnlimited = false;
    let bestHasRouter = false;

    for (const a of approvals) {
      if (!a) continue;
      if (!best) { best = a; bestIsUnlimited = tx_isUnlimitedApprove(a.value); bestHasRouter = !!tx_getKnownRouterName(net, a.spender); continue; }

      const aUnlimited = tx_isUnlimitedApprove(a.value);
      const aHasRouter = !!tx_getKnownRouterName(net, a.spender);

      if (!bestIsUnlimited && aUnlimited) { best = a; bestIsUnlimited = true; bestHasRouter = aHasRouter; continue; }
      if (bestIsUnlimited && aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
      }
      if (!bestIsUnlimited && !aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
        if (typeof a.value === "bigint" && typeof best.value === "bigint" && a.value > best.value) { best = a; continue; }
      }
    }
    return best;
  }

  // =========================
  // Main
  // =========================
  async function runTxDecode() {
    const st = $("#tx-status");
    const out = $("#tx-out");
    const evWrap = $("#tx-events");
    clearStatus(st);

    tx_resetSummary();

    const net = netFromSelect("#tx-net");
    const hash = ($("#tx-hash")?.value || "").trim();
    if (!hash || !/^0x([A-Fa-f0-9]{64})$/.test(hash)) {
      setStatus(st, "warn", "Please paste a valid tx hash.");
      return;
    }

    const urls = buildRpcCandidates(net);
if (!urls.length) return setStatus(st, "bad", "No RPC available.");

setStatus(st, "info", "Fetching tx + receiptâ€¦");

try {
  const r = await withRpcFallback(net, async (provider, url) => {
    const [tx, rc] = await Promise.all([
      provider.getTransaction(hash),
      provider.getTransactionReceipt(hash)
    ]);

    if (!tx) throw new Error("tx_null");
    return { provider, tx, rc };
  }, { timeoutMs: 12000 });

  if (!r.ok) {
    const msg = String(r.err?.message || r.err || "");
    if (msg.includes("tx_null")) return setStatus(st, "bad", "Tx not found (wrong network / unsynced RPC).");
    return setStatus(st, "bad", `RPC failed: ${msg}`);
  }

  const read = r.res.provider;
  const tx = r.res.tx;
  const rc = r.res.rc;


      const chain = CHAINS[net];
      const txLink = chain.txUrl(hash);

      // best-effort decode (router calls)
      let decoded = null;
      try {
        const iface = new E.Interface(tx_ROUTER_ABI_MIN);
        decoded = iface.parseTransaction({ data: tx.data, value: tx.value });
      } catch {}

      const logs = rc?.logs || [];
      const transfersRaw = logs.filter(l => l.topics?.[0] === TRANSFER_TOPIC0).slice(0, 50);
      const approvalsRaw = logs.filter(l => l.topics?.[0] === APPROVAL_TOPIC0).slice(0, 50);

      const transfers = transfersRaw.map(tx_decodeTransferLog).filter(Boolean);
      const approvals = approvalsRaw.map(tx_decodeApprovalLog).filter(Boolean);

      const decodedName = decoded?.name || "";
      const hasRouterSwap = decodedName.toLowerCase().includes("swap");
      const hasApproval = approvals.length > 0;
      const hasTransfers = transfers.length > 0;

      const rcStatus = (rc && typeof rc.status !== "undefined") ? rc.status : undefined;
      const reverted = (rcStatus === 0 || rcStatus === 0n);

      // --- MethodId (selector) for unknown calls ---
      const methodId = (!decodedName && tx?.to) ? tx_callSelector(tx.data) : "";

      // -------------------------
      // Token meta preload (1â€“3 tokens touched)
      // Keep it fast and stable: prefer primary token first.
      // -------------------------
      const primaryToken = tx_pickPrimaryToken(approvals, transfers);

      const tokenSet = new Set();
      if (primaryToken) tokenSet.add(primaryToken);
      for (const t of transfers) if (t?.token) tokenSet.add(t.token);
      for (const a of approvals) if (a?.token) tokenSet.add(a.token);

      const tokenList = Array.from(tokenSet).slice(0, 3);
      const metaMap = {};

      await Promise.all(tokenList.map(async (addr) => {
        const meta = await tx_getTokenMeta(read, net, addr);
        metaMap[addr] = meta || null;
      }));

      const tokensTouched = tokenList
        .map(addr => (metaMap[addr]?.symbol || metaMap[addr]?.name || "").trim())
        .filter(Boolean)
        .slice(0, 3);

      // -------------------------
      // Action
      // -------------------------
      let actionLabel = "Unknown";
      let actionKind  = "unk";

      if (!tx.to && rc?.contractAddress) {
        actionLabel = "Contract creation";
        actionKind = reverted ? "warn" : "ok";
      } else if (decodedName) {
        actionLabel = decodedName;
        actionKind  = hasRouterSwap ? "ok" : "warn";
      } else if ((tx.data === "0x" || !tx.data) && tx.value && BigInt(tx.value) > 0n) {
        actionLabel = "Native transfer";
        actionKind = "warn";
      } else if (tx.to) {
        actionLabel = methodId ? `Contract call (unknown â€¢ ${methodId})` : "Contract call (unknown)";
        actionKind = "warn";
      }

      // -------------------------
      // Approval analysis
      // -------------------------
      let sawUnlimited = false;
      let sawKnownRouterUnlimited = false;
      let sawFiniteApprove = false;
      let sawRevoke = false;

      const knownRouterNames = new Set();

      for (const a of approvals) {
        if (!a) continue;

        const rn = tx_getKnownRouterName(net, a.spender);
        if (rn) knownRouterNames.add(rn);

        if (tx_isUnlimitedApprove(a.value)) {
          sawUnlimited = true;
          if (rn) sawKnownRouterUnlimited = true;
        } else {
          if (a.value === 0n) sawRevoke = true;
          else sawFiniteApprove = true;
        }
      }

      // -------------------------
      // Allowance subline (ONLY when approvals exist)
      // Allowance: TOKEN â†’ SPENDER (Unlimited / Limited / Revoked)
      // -------------------------
      let allowanceSub = "";
      if (hasApproval) {
        const bestAppr = tx_pickPrimaryApproval(approvals, net);
        if (bestAppr) {
          const tokenAddr = bestAppr.token;
          const spenderAddr = bestAppr.spender;

          const tokenMeta = metaMap[tokenAddr] || null;
          const tokName = (tokenMeta?.symbol || tokenMeta?.name || shortAddr(tokenAddr)).trim();

          const spenderRouter = tx_getKnownRouterName(net, spenderAddr);
          const spenderName = spenderRouter ? spenderRouter : shortAddr(spenderAddr);

          let status = "";
          if (tx_isUnlimitedApprove(bestAppr.value)) {
            status = "Unlimited";
          } else if (bestAppr.value === 0n) {
            status = "Revoked";
          } else {
            // show amount if decimals known
            const dec = tokenMeta?.decimals;
            const pretty = (dec != null) ? tx_formatUnitsSafe(bestAppr.value, dec) : null;
            status = pretty ? `Limited: ${pretty}` : "Limited";
          }

          allowanceSub = `Allowance: ${tokName} \u2192 ${spenderName} (${status})`;
        }
      }

      // -------------------------
      // Target (Token/Asset + creation support)
      // -------------------------
      let targetKind = "unk";
      let targetLabel = "â€”";

      if (!tx.to && rc?.contractAddress) {
        targetLabel = `New contract (${shortAddr(rc.contractAddress)})`;
        targetKind = reverted ? "warn" : "ok";
      } else if (tx.to) {
        const toRouterName = tx_getKnownRouterName(net, tx.to);
        if (toRouterName) {
          targetLabel = `${toRouterName} (${shortAddr(tx.to)})`;
          targetKind = "warn";
        } else if (primaryToken) {
          const meta = metaMap[primaryToken] || null;
          const nm = (meta?.symbol || meta?.name || "").trim();
          targetLabel = nm ? `${nm} (${shortAddr(primaryToken)})` : shortAddr(primaryToken);
          targetKind = "ok";
        } else {
          targetLabel = shortAddr(tx.to);
          targetKind = "ok";
        }
      }

      // NEW: Tokens touched subline for Summary (only when we have 1â€“3)
      const touchedSub = tokensTouched.length ? `Tokens touched: ${tokensTouched.join(", ")}` : "";

      // -------------------------
      // Risk (heuristics)
      // -------------------------
      let riskLabel = "Unknown";
      let riskKind  = "unk";

      if (reverted) {
        riskLabel = "Tx reverted (failed)";
        riskKind = "warn";
      } else if (hasRouterSwap) {
        riskLabel = "Likely DEX swap";
        riskKind = "ok";
      } else if (sawUnlimited && !sawKnownRouterUnlimited) {
        riskLabel = "High risk: unlimited approval (unknown spender)";
        riskKind = "bad";
      } else if (sawUnlimited && sawKnownRouterUnlimited) {
        const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
        riskLabel = `Unlimited approval (known router${names ? ": " + names : ""})`;
        riskKind = "warn";
      } else if (hasApproval && !decodedName) {
        riskLabel = "Approval without decoded call";
        riskKind = "warn";
      } else if (!decodedName && hasTransfers) {
        riskLabel = "Transfer activity (unknown call)";
        riskKind = "warn";
      } else if (decodedName) {
        riskLabel = "Contract interaction";
        riskKind = "warn";
      }

      // -------------------------
      // Max impact (Allowance-aware + largest transfer)
      // -------------------------
      let impactLabel = "â€”";
      let impactKind = "unk";

      if (sawUnlimited) {
        if (sawKnownRouterUnlimited) {
          const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
          impactLabel = `Unlimited spending approved (known router${names ? ": " + names : ""})`;
          impactKind = "warn";
        } else {
          impactLabel = "Unlimited spending approved (unknown spender)";
          impactKind = "bad";
        }
      } else if (sawFiniteApprove) {
        impactLabel = "Spending approved (limited)";
        impactKind = "warn";
      } else if (sawRevoke && !hasTransfers) {
        impactLabel = "Allowance revoked";
        impactKind = "ok";
      } else if (tx.value && BigInt(tx.value) > 0n) {
        impactLabel = `Sends ${E.formatEther(tx.value)} native`;
        impactKind = "warn";
      } else if (hasTransfers) {
        let largest = transfers[0];
        for (const t of transfers) if (t.value > largest.value) largest = t;

        const meta = metaMap[largest?.token] || null;
        const sym = (meta?.symbol || "").trim();
        const dec = meta?.decimals;

        const pretty = (dec != null) ? tx_formatUnitsSafe(largest.value, dec) : null;
        if (pretty && sym) impactLabel = `Largest transfer: ${pretty} ${sym}`;
        else if (sym) impactLabel = `Largest transfer: ${sym} (raw)`;
        else impactLabel = `${transfers.length} token transfer(s)`;

        impactKind = "ok";
      } else if (hasApproval) {
        impactLabel = "Allowance changed";
        impactKind = "warn";
      }

      // -------------------------
      // Fill the 4 fixed lines
      // (Target now includes Tokens touched subline)
      // (+ allowance subline under Max impact)
      // -------------------------
      tx_setLine("#tx-sum-action", "Action", tx_badge(actionKind, actionLabel));
      tx_setLine("#tx-sum-risk", "Risk", tx_badge(riskKind, riskLabel));
      tx_setTargetLine(tx_badge(targetKind, targetLabel), touchedSub);
      tx_setImpactLine(tx_badge(impactKind, impactLabel), allowanceSub);

      // -------------------------
      // Details panel (professional: Status + Gas + MethodId + Tokens touched)
      // -------------------------
      const gasUsed = rc?.gasUsed ? String(rc.gasUsed) : "â€”";
      const statusTxt = (typeof rcStatus === "undefined") ? "â€”" : (reverted ? "FAILED" : "SUCCESS");
      const tokensLine = tokensTouched.length ? `<b>Tokens:</b> <span class="mono">${tx_esc(tokensTouched.join(", "))}</span><br>` : "";
      const methodLine = (!decodedName && methodId) ? `<b>Method:</b> <span class="mono">${tx_esc(methodId)}</span><br>` : "";

      out.innerHTML = `
        <div class="small" style="margin-bottom:10px;">
          <b>Tx:</b> <a href="${txLink}" target="_blank" rel="noopener">${shortAddr(hash)}</a>
          <span class="muted">(${tx_esc(String(net).toUpperCase())})</span><br>
          <b>Status:</b> <span class="mono">${tx_esc(statusTxt)}</span> &nbsp; <b>Gas used:</b> <span class="mono">${tx_esc(gasUsed)}</span><br>
          ${methodLine}
          ${tokensLine}
          <b>From:</b> <span class="mono">${tx_esc(tx.from)}</span><br>
          <b>To:</b> <span class="mono">${tx_esc(tx.to || "â€”")}</span><br>
          <b>Value:</b> <span class="mono">${tx_esc(tx.value ? E.formatEther(tx.value) : "0")}</span>
        </div>
      `;
      out.style.display = "block";

      // -------------------------
      // Events (with token labels best-effort)
      // -------------------------
      const items = [];

      if (decoded?.args) {
        const args = [];
        decoded.args.forEach((v, i) => {
          args.push(`<div class="small mono" style="margin-top:6px;">arg${i}: ${tx_esc(String(v))}</div>`);
        });
        items.push(`
          <div class="card">
            <h3>Decoded Inputs</h3>
            <div class="small">Best-effort decode for common router calls.</div>
            ${args.join("")}
          </div>
        `);
      }

      if (transfers.length) {
        const rows = transfers.map(d => {
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const tag = sym ? ` <span class="muted">(${tx_esc(sym)})</span>` : "";
          return `<div class="small mono" style="margin-top:6px;">Transfer ${shortAddr(d.from)} â†’ ${shortAddr(d.to)}${tag} â€¢ raw: ${tx_esc(d.value.toString())}</div>`;
        }).join("");

        items.push(`
          <div class="card">
            <h3>Transfer Events</h3>
            ${rows}
          </div>
        `);
      }

      if (approvals.length) {
        const rows = approvals.map(d => {
          const routerName = tx_getKnownRouterName(net, d.spender);
          const routerTag = routerName ? ` <span class="muted">(${tx_esc(routerName)})</span>` : "";
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const tokenTag = sym ? ` <span class="muted">(${tx_esc(sym)})</span>` : "";

          const inf = tx_isUnlimitedApprove(d.value)
            ? ` <span class="muted">(unlimited)</span>`
            : (d.value === 0n ? ` <span class="muted">(revoked)</span>` : "");

          return `<div class="small mono" style="margin-top:6px;">Approval ${shortAddr(d.owner)} â†’ ${shortAddr(d.spender)}${routerTag}${tokenTag} â€¢ raw: ${tx_esc(d.value.toString())}${inf}</div>`;
        }).join("");

        items.push(`
          <div class="card">
            <h3>Approval Events</h3>
            ${rows}
          </div>
        `);
      }

      evWrap.innerHTML = items.length
        ? `<div class="grid-2">${items.join("")}</div>`
        : `<div class="small muted">No common events detected (or log count is zero).</div>`;

      setStatus(st, "ok", "Done.");
      gtagEvent("sec_tx_decode", { net });

    } catch (e) {
      setStatus(st, "bad", `Decode failed: ${String(e?.message || e)}`);
    }
  }

  // =========================
  // UI wiring (idempotent)
  // =========================
  let tx_ui_inited = false;

  function initTxUi() {
    if (tx_ui_inited) return;
    tx_ui_inited = true;

    $("#tx-run")?.addEventListener("click", runTxDecode);

    $("#tx-copy-md")?.addEventListener("click", async () => {
      const a = (document.querySelector("#tx-sum-action")?.innerText || "Action â€”").trim();
      const r = (document.querySelector("#tx-sum-risk")?.innerText || "Risk â€”").trim();
      const t = (document.querySelector("#tx-sum-target")?.innerText || "Target â€”").trim();
      const m = (document.querySelector("#tx-sum-impact")?.innerText || "Max impact â€”").trim();
      const body = ($("#tx-out")?.innerText || "").trim();

      const txt = ["Tx Decoder Summary", a, r, t, m, "", body].join("\n");

      const ok = await copyText(txt);
      setStatus($("#tx-status"), ok ? "ok" : "warn", ok ? "Copied." : "Copy failed.");
    });
  }

  // =========================
  // Export
  // =========================
  window.CX = window.CX || {};
  window.CX.runTxDecode = runTxDecode;
  window.CX.initTxUi = initTxUi;
  window.CX.txDecoder = window.CX.txDecoder || {};
  window.CX.txDecoder.getTokenMeta = tx_getTokenMeta;
  window.CX.txDecoder.metaCache = tx_TOKEN_META_CACHE;

})();



    // =========================
    // Dev Tools (Bookmarklet + Monitor)
    // =========================
    function renderBmHelp(){
      const el = $("#bm-help");
      if (!el) return;
      el.innerHTML = t(currentLang, "bm_help_html") || "";
    }

    function bmGenerate(){
      const base = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
      const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${base}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

      const bm = `javascript:${encodeURIComponent(js)}`;
      setStatus($("#bm-out"), "ok", `Bookmarklet generated. <span class="mono">(copy it)</span>`);
      $("#bm-out").dataset.bm = bm;
      const drag = $("#bm-drag");
if (drag) {
  drag.href = bm;                 
  drag.classList.remove("hidden");
  drag.setAttribute("data-ready", "1");
}
      renderBmHelp();
      gtagEvent("sec_bm_generate");
    }

    async function bmCopy(){
      const bm = $("#bm-out")?.dataset?.bm || "";
      if (!bm) return setStatus($("#bm-out"), "warn", "Generate first.");
      const ok = await copyText(bm);
      setStatus($("#bm-out"), ok ? "ok" : "warn", ok ? "Copied bookmarklet." : "Copy failed.");
    }

    function loadMonitor(){
      try { return JSON.parse(localStorage.getItem(LS_MON) || "[]"); } catch { return []; }
    }
    function saveMonitor(list){
      try { localStorage.setItem(LS_MON, JSON.stringify(list || [])); } catch {}
    }

    function renderMonitorTable(){
      const table = $("#mon-table");
      if (!table) return;
      const head = table.querySelector(".trow.head");
      table.innerHTML = "";
      if (head) table.appendChild(head);

      const list = loadMonitor();
      if (!list.length) {
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell muted">â€”</div>
    <div class="cell muted">â€”</div>
    <div class="cell muted hide-sm">â€”</div>
    <div class="cell muted">â€”</div>
    <div class="cell muted">â€”</div>
  </div>
`);
        return;
      }

      for (const item of list) {
        const chain = CHAINS[item.net];
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell mono"><a href="${chain.addressUrl(item.addr)}" target="_blank" rel="noopener">${shortAddr(item.addr)}</a></div>
    <div class="cell">${String(item.net || "").toUpperCase()}</div>
    <div class="cell hide-sm">${
  item.lastSeen
    ? new Date(item.lastSeen * 1000).toLocaleString().replace(", ", "<br>")
    : "â€”"
}</div>
    <div class="cell">${item.status || "â€”"}</div>

    <div class="cell">
      <button class="mon-remove" type="button"
              data-action="mon-remove"
              data-addr="${item.addr}"
              data-net="${item.net}"
              title="Remove"
              aria-label="Remove">Ã—</button>
    </div>
  </div>
`);
      }
    }

    async function monAdd(){
      const st = $("#mon-status");
      clearStatus(st);

      const net = netFromSelect("#mon-net");
      const addrRaw = ($("#mon-addr")?.value || "").trim();
      if (!isAddr(addrRaw)) return setStatus(st, "warn", "Enter a valid contract address.");

      const addr = normAddr(addrRaw);
      const list = loadMonitor();
      const key = `${net}:${safeLower(addr)}`;
      const filtered = list.filter(x => `${x.net}:${safeLower(x.addr)}` !== key);
      filtered.unshift({ net, addr, status: "added", lastSeen: nowTs() });
      saveMonitor(filtered.slice(0, 50));
      renderMonitorTable();
      setStatus(st, "ok", "Added to monitor list (local).");
      gtagEvent("sec_mon_add", { net });
    }

    async function monCheckAll(){
      const st = $("#mon-status");
      clearStatus(st);

      const list = loadMonitor();
      if (!list.length) return setStatus(st, "warn", "Monitor list is empty.");

      setStatus(st, "info", `Checking ${list.length} contract(s)â€¦`);

      for (const item of list) {
        try{
          const codeRes = await getCodeSafe(item.net, item.addr);
          item.status = (codeRes.ok && codeRes.code && codeRes.code !== "0x") ? "code âœ…" : "no code âŒ";
          item.lastSeen = nowTs();
        } catch {
          item.status = "error";
          item.lastSeen = nowTs();
        }
      }

      saveMonitor(list);
      renderMonitorTable();
      setStatus(st, "ok", "Monitor check done.");
      gtagEvent("sec_mon_check");
    }

    async function monExport(){
      const list = loadMonitor();
      const ok = await copyText(safeJson(list));
      setStatus($("#mon-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
    }
    function monRemove(addr, net){
  const st = $("#mon-status");
  const addrLower = safeLower(String(addr || "").trim());
  const netLower  = safeLower(String(net || "").trim());

  const list = loadMonitor();
  const next = list.filter(it =>
    !(safeLower(it.net) === netLower && safeLower(it.addr) === addrLower)
  );

  saveMonitor(next);
  renderMonitorTable();
  setStatus(st, "ok", "Removed.");
  gtagEvent("sec_mon_remove", { net: netLower });
}

function bindMonRemove(){
  const table = $("#mon-table");
  if (!table || table.__cxBoundRemove) return;
  table.__cxBoundRemove = true;

  table.addEventListener("click", (e) => {
    const btn = e.target.closest('button[data-action="mon-remove"]');
    if (!btn) return;
    e.preventDefault();
    monRemove(btn.getAttribute("data-addr"), btn.getAttribute("data-net"));
  });
}


    function initDevUi(){
      const base = location.href.split("?")[0];
      const el = $("#bm-base");
      if (el) el.value = base;

      $("#bm-generate")?.addEventListener("click", bmGenerate);
      $("#bm-copy")?.addEventListener("click", bmCopy);

      $("#mon-add")?.addEventListener("click", monAdd);
      $("#mon-check")?.addEventListener("click", monCheckAll);
      $("#mon-export")?.addEventListener("click", monExport);

      renderBmHelp();
      renderMonitorTable();
      bindMonRemove();
      // Always enable the "drag to bookmarks" link (default bookmarklet)
try {
  const hubBase = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
  const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${hubBase}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

  const bmDefault = `javascript:${encodeURIComponent(js)}`;

  const drag = $("#bm-drag");
  if (drag) drag.href = bmDefault;
} catch {}

    }

    // =========================
    // URL auto-run (tool=...)
    // =========================
    async function handleAutoRun(){
      const q = parseQuery();
      if (!q.tool) return;

      const tool = q.tool;
      const netRaw = String(q.net || q.chain || "").toLowerCase();
      const net = (netRaw === "eth" || netRaw === "ethereum" || netRaw === "1") ? "eth" : "bsc";

      if (tool === "quick") {
        showPanel("quick");
        if ($("#qs-net")) $("#qs-net").value = net;
        if (q.token && isAddr(q.token)) {
          if ($("#qs-token")) $("#qs-token").value = normAddr(q.token);
          setTimeout(() => {
  const fn = window.CX_QS_V5?.runQuickScan || window.runQuickScan;
  if (typeof fn === "function") fn();
}, 250);

        }
      }

      if (tool === "liq") {
        showPanel("liq");
        if ($("#liq-net")) $("#liq-net").value = net;
        if (q.token && isAddr(q.token)) {
          if ($("#liq-token")) $("#liq-token").value = normAddr(q.token);
          setTimeout(() => runLiqScan(), 250);
        }
      }

      if (tool === "tx") {
  showPanel("tx");

  if (q.tx && /^0x([A-Fa-f0-9]{64})$/.test(q.tx)) {
    if ($("#tx-hash")) $("#tx-hash").value = q.tx;

    setTimeout(() => {
      const sel = $("#tx-net");
      if (sel) {
        sel.value = net; 
        sel.dispatchEvent(new Event("change", { bubbles: true }));
      }
      const btn = $("#tx-run");
      if (btn) btn.click();
    }, 400);
  }
}
      setTimeout(() => {
  const target = `#panel-${tool}`;   
  const el = document.querySelector(target);
  if (!el) return;

  try { history.replaceState(null, "", target); }
  catch { location.hash = target; }

  el.scrollIntoView({ behavior: "smooth", block: "start" });
}, 450);
    }

    // =========================
    // Boot
    // =========================
    function boot(){
      initLang();
      bindLangButtons();

      initPanels();
      initWalletButtons();
      initApiKeysUi();

      initQuickScanUi();
      initLiqUi();
      initWalletSecurityDNAUi();
      initRpcUi();
      if (window.CX && typeof window.CX.initTxUi === "function") {
  window.CX.initTxUi();
}
      initDevUi();

      applyI18n(currentLang);
      renderWalletLabels();
      handleAutoRun();

      // UX: close panels via ESC
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") showPanel(null);
      });
    }

    // Run
    boot();
  </script>
</body>
</html>

        
