<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (optional, same as main site) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/logo.png">
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>CycleX Security Hub</title>
  <link rel="icon" href="/logo.png" />
  <style>
    :root{
      --bg:#060714;
      --bg2:#0a1630;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --muted2: rgba(255,255,255,.55);
      --good: rgba(95,255,190,.9);
      --warn: rgba(255,209,102,.9);
      --bad: rgba(255,120,145,.9);
      --accent: rgba(80,215,255,.95);
      --accent2: rgba(140,120,255,.95);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --r: 26px;
      --r2: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 500px at 20% 10%, rgba(140,120,255,.22), transparent 60%),
        radial-gradient(900px 600px at 80% 15%, rgba(80,215,255,.18), transparent 60%),
        radial-gradient(900px 700px at 50% 90%, rgba(80,255,190,.10), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      min-height:100vh;
    }

    .wrap{ max-width: 1200px; margin: 0 auto; padding: 28px 16px 80px; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px; margin-bottom: 18px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      user-select:none;
    }
    .brand img{ width:34px; height:34px; border-radius: 10px; }
    .brand .t1{ font-weight:800; letter-spacing:.2px; }
    .brand .t2{ font-size:12px; color: var(--muted); margin-top:2px; }

    .navbtns{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      text-decoration:none;
      font-weight:700;
      letter-spacing:.2px;
      cursor:pointer;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      gap:8px;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.18); }
    .btn.primary{
      background: linear-gradient(90deg, rgba(80,215,255,.95), rgba(95,255,190,.85));
      color: rgba(0,0,0,.85);
      border-color: transparent;
    }
    .btn.ghost{
      background: rgba(255,255,255,.04);
    }
    .btn.small{ padding: 8px 12px; font-size: 13px; }
    .pill{
      font-size: 12px; color: rgba(0,0,0,.75);
      padding: 5px 10px; border-radius: 999px;
      background: rgba(255,255,255,.85);
      font-weight: 800;
      letter-spacing:.2px;
    }

    .hero{
      margin-top: 12px;
      padding: 30px 24px;
      border-radius: var(--r);
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .hero:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(800px 240px at 30% 0%, rgba(80,215,255,.18), transparent 60%),
        radial-gradient(700px 260px at 70% 0%, rgba(140,120,255,.18), transparent 60%);
      pointer-events:none;
    }
    .hero .kicker{
      text-transform: uppercase;
      letter-spacing: 4px;
      font-size: 12px;
      color: rgba(180,160,255,.75);
      position:relative;
      text-align:center;
      margin-bottom: 10px;
    }
    .hero h1{
      position:relative;
      margin: 0;
      text-align:center;
      font-size: 44px;
      line-height: 1.05;
      font-weight: 900;
      letter-spacing: -0.5px;
    }
    .hero p{
      position:relative;
      margin: 10px auto 0;
      max-width: 820px;
      text-align:center;
      color: var(--muted);
      font-size: 16px;
      line-height: 1.5;
    }

    .grid{ display:grid; grid-template-columns: 1fr; gap: 18px; margin-top: 18px; }
    @media(min-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      border-radius: var(--r);
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .card .head{
      padding: 18px 18px 10px;
      display:flex; align-items:flex-end; justify-content:space-between; gap: 10px;
    }
    .head .title{
      font-weight: 900;
      letter-spacing: -.2px;
      font-size: 24px;
      margin: 0;
    }
    .head .sub{
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
      line-height: 1.35;
    }
    .card .body{ padding: 14px 18px 18px; }

    .two{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media(min-width: 980px){
      .two{ grid-template-columns: 1fr 1fr; }
    }
    .panel{
      border-radius: var(--r2);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      padding: 14px;
    }

    label{ display:block; font-size: 12px; color: var(--muted2); letter-spacing: .16em; text-transform:uppercase; margin: 0 0 8px; }
    input, textarea, select{
      width:100%;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: var(--text);
      padding: 12px 14px;
      outline:none;
      font-size: 14px;
    }
    textarea{
      border-radius: 16px;
      min-height: 110px;
      font-family: var(--mono);
      resize: vertical;
    }
    .row{ display:flex; gap: 10px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex:1; min-width: 180px; }

    .hint{ margin-top: 10px; color: var(--muted2); font-size: 13px; line-height: 1.45; }
    .muted{ color: var(--muted); }

    .statusBox{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.28);
      padding: 12px 12px;
      display:flex; align-items:center; gap:10px;
    }
    .dot{
      width: 10px; height: 10px; border-radius: 999px;
      background: rgba(255,255,255,.35);
      box-shadow: 0 0 20px rgba(255,255,255,.25);
    }
    .dot.good{ background: var(--good); box-shadow: 0 0 18px rgba(95,255,190,.35); }
    .dot.warn{ background: var(--warn); box-shadow: 0 0 18px rgba(255,209,102,.35); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 18px rgba(255,120,145,.35); }

    .siglist{ margin-top: 12px; display:grid; gap: 8px; }
    .sig{
      display:flex; align-items:flex-start; gap:10px;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .sig .icon{ width: 18px; text-align:center; margin-top: 1px; }
    .sig .txt{ flex:1; }
    .sig .t{ font-weight: 800; }
    .sig .d{ color: var(--muted); font-size: 13px; margin-top: 2px; line-height:1.35; }
    .sig.good{ border-color: rgba(95,255,190,.25); }
    .sig.warn{ border-color: rgba(255,209,102,.25); }
    .sig.bad{ border-color: rgba(255,120,145,.25); }

    .codebox{
      font-family: var(--mono);
      background: rgba(0,0,0,.40);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px;
      overflow:auto;
      max-height: 160px;
      white-space: pre;
      font-size: 12.5px;
      line-height: 1.35;
    }

    table{
      width:100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
    }
    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      font-size: 13px;
      text-align:left;
      color: var(--text);
    }
    th{ color: var(--muted); font-weight: 800; letter-spacing:.08em; text-transform:uppercase; font-size: 11px; }
    tr:last-child td{ border-bottom:none; }

    .tag{
      display:inline-flex; align-items:center; justify-content:center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: 12px;
      font-weight: 800;
      gap:6px;
      white-space:nowrap;
    }

    .footer{
      margin-top: 18px;
      color: rgba(255,255,255,.55);
      font-size: 12.5px;
      text-align:center;
    }
    .footer a{ color: rgba(255,255,255,.75); }
  </style>

  <!-- ethers v6 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>
</head>
<body>
  <div class="wrap">

    <div class="topbar">
      <div class="brand">
        <img src="/logo.png" alt="CycleX" />
        <div>
          <div class="t1">CycleX Security Hub</div>
          <div class="t2">On-chain hygiene checks ‚Ä¢ shareable scan links ‚Ä¢ safer swaps</div>
        </div>
      </div>
      <div class="navbtns">
        <a class="btn ghost" href="/" title="Back to main site">‚Üê Main site</a>
        <button class="btn" id="btnShareXTop">Share hub on X</button>
        <span class="pill" id="netPill">BSC</span>
      </div>
    </div>

    <div class="hero">
      <div class="kicker">SAFE SWAP GATE</div>
      <h1>Check token basics before you swap</h1>
      <p>
        Enter a token address on BSC. We‚Äôll read on-chain metadata, owner/proxy hints,
        multi-DEX liquidity signals, and generate shareable outputs.
        <span class="muted">Not a honeypot guarantee ‚Äî just solid hygiene checks.</span>
      </p>
    </div>

    <!-- 1) SafeSwap Gate -->
    <div class="grid">
      <div class="card" id="cardScan">
        <div class="head">
          <div>
            <div class="title">SafeSwap Gate</div>
            <div class="sub">Token scanner ‚Ä¢ Verified / Owner / Proxy hints ‚Ä¢ Liquidity signals ‚Ä¢ Share + X</div>
          </div>
          <div class="row" style="max-width:520px">
            <button class="btn small" id="btnCopyShare">Copy share link</button>
            <button class="btn small" id="btnCopyJson">Copy JSON report</button>
            <button class="btn small" id="btnShareX">Share on X</button>
          </div>
        </div>

        <div class="body">
          <div class="two">
            <div class="panel">
              <label>Token Address (BSC)</label>
              <input id="tokenAddr" placeholder="0x..." spellcheck="false" />

              <div class="row" style="margin-top:12px">
                <div>
                  <label>Open swap</label>
                  <select id="dexSelect"></select>
                </div>
                <div>
                  <label>Base</label>
                  <select id="baseSelect"></select>
                </div>
              </div>

              <div class="row" style="margin-top:12px">
                <button class="btn primary" id="btnScan">Scan</button>
                <button class="btn" id="btnOpenDex">Open DEX</button>
                <button class="btn" id="btnOpenBscscan">BscScan</button>
              </div>

              <div class="row" style="margin-top:12px">
                <label style="flex:1; margin:0; display:flex; align-items:center; gap:10px; text-transform:none; letter-spacing:0;">
                  <input type="checkbox" id="chkRequireLiq" style="width:18px; height:18px; accent-color: rgba(95,255,190,.85);" />
                  Require liquidity (production)
                </label>

                <label style="flex:1; margin:0; display:flex; align-items:center; gap:10px; text-transform:none; letter-spacing:0;">
                  <input type="checkbox" id="chkAutoRun" style="width:18px; height:18px; accent-color: rgba(80,215,255,.85);" />
                  Auto-run when opened with ?token=
                </label>
              </div>

              <div class="panel" style="margin-top:12px">
                <div class="row">
                  <div style="flex:2">
                    <label>BscScan API key (optional)</label>
                    <input id="bscscanKey" placeholder="(optional) for Verified / Creation / Proxy hints" spellcheck="false" />
                  </div>
                  <div style="flex:1; min-width:160px">
                    <label>&nbsp;</label>
                    <button class="btn" id="btnSaveKey">Save</button>
                  </div>
                </div>
                <div class="hint">
                  If you leave this empty, the scan still works. With a key we can additionally check <b>Verified source</b> via BscScan API.
                  The key is saved in <b>localStorage</b> (your browser only).
                </div>
              </div>

              <div class="hint">
                Tip: open directly with <span class="tag">/security/?token=0x‚Ä¶</span> and it will auto-run (if enabled).
              </div>
            </div>

            <div class="panel">
              <div class="statusBox" id="statusBox">
                <div class="dot" id="statusDot"></div>
                <div>
                  <div style="font-weight:900" id="statusTitle">Ready</div>
                  <div class="muted" id="statusSub">Paste a token address and press Scan.</div>
                </div>
              </div>

              <div class="siglist" id="siglist"></div>

              <div style="margin-top:12px" class="muted">
                Last report timestamp: <span id="ts">‚Äî</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 2) Approvals -->
      <div class="card" id="cardApprovals">
        <div class="head">
          <div>
            <div class="kicker" style="text-align:left; margin:0; color: rgba(95,255,190,.65);">APPROVALS GUARDIAN</div>
            <div class="title">Check and revoke ERC-20 allowances</div>
            <div class="sub">
              Targeted tool: you provide token(s) + spender.
              We read <span class="tag">allowance(owner, spender)</span> and can revoke via <span class="tag">approve(spender, 0)</span>.
            </div>
          </div>
          <div class="row" style="max-width:360px">
            <a class="btn small" href="https://revoke.cash/" target="_blank" rel="noopener">Open revoke.cash</a>
            <button class="btn small" id="btnCopyOwnerLink">Copy BscScan approvals link</button>
          </div>
        </div>

        <div class="body">
          <div class="two">
            <div class="panel">
              <div class="row">
                <div style="flex:2">
                  <label>Owner wallet</label>
                  <input id="ownerAddr" placeholder="Connected wallet address (or paste)" spellcheck="false" />
                </div>
                <div style="flex:1; min-width:200px">
                  <label>&nbsp;</label>
                  <button class="btn primary" id="btnConnect">CONNECT / REFRESH</button>
                </div>
              </div>

              <div class="row" style="margin-top:12px">
                <div style="flex:1">
                  <label>Spender preset</label>
                  <select id="spenderPreset"></select>
                </div>
                <div style="flex:1">
                  <label>Spender (address)</label>
                  <input id="spenderAddr" placeholder="0x..." spellcheck="false" />
                </div>
              </div>

              <div style="margin-top:12px">
                <label>Token list (one per line)</label>
                <textarea id="tokenList" placeholder="0x...&#10;0x..."></textarea>
              </div>

              <div class="row" style="margin-top:12px">
                <button class="btn" id="btnUseScannedToken">Use scanned token</button>
                <button class="btn" id="btnCheckAllow">Check allowances</button>
                <button class="btn" id="btnRevokeAll">Revoke all (non-zero)</button>
              </div>

              <div class="hint">
                Note: this cannot automatically enumerate every approval in your wallet. For a full indexed view, use revoke.cash or BscScan approvals page.
              </div>

              <div class="statusBox" style="margin-top:12px">
                <div class="dot" id="apprDot"></div>
                <div>
                  <div style="font-weight:900" id="apprTitle">Disconnected</div>
                  <div class="muted" id="apprSub">Connect your wallet to check/revoke.</div>
                </div>
              </div>
            </div>

            <div class="panel">
              <label>Allowances</label>
              <table>
                <thead>
                  <tr>
                    <th>Token</th>
                    <th>Symbol</th>
                    <th>Allowance</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody id="allowTbody">
                  <tr><td class="muted">‚Äî</td><td class="muted">‚Äî</td><td class="muted">‚Äî</td><td class="muted">‚Äî</td></tr>
                </tbody>
              </table>
              <div class="hint" id="apprHint"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- 3) Bookmarklet -->
      <div class="card" id="cardBookmarklet">
        <div class="head">
          <div>
            <div class="kicker" style="text-align:left; margin:0;">DEX GUARD</div>
            <div class="title">Bookmarklet redirect to your security page</div>
            <div class="sub">Save a bookmark that extracts token params from DEX pages and opens this hub with <span class="tag">?token=</span>.</div>
          </div>
          <div class="row" style="max-width:380px">
            <button class="btn small" id="btnCopyBm">Copy bookmarklet</button>
            <button class="btn small" id="btnCopyBmCode">Copy code</button>
          </div>
        </div>

        <div class="body">
          <div class="two">
            <div class="panel">
              <label>Security hub URL (used by the bookmarklet)</label>
              <input id="hubUrl" spellcheck="false" />
              <div class="hint">Set this to your production URL (recommended): <span class="tag">https://cyclex.network/security/</span></div>

              <div style="margin-top:12px">
                <label>Drag to bookmarks bar</label>
                <a class="btn primary" id="bmDrag" href="#">DEX GUARD ‚Üí CYCLEX SCAN</a>
              </div>

              <div class="hint">
                On desktop: drag the button into your bookmarks bar. If drag-drop is blocked, create a bookmark and paste the code (right panel) into the URL field.
              </div>
            </div>

            <div class="panel">
              <label>Bookmarklet code</label>
              <div class="codebox" id="bmCode"></div>
              <div class="hint">
                It extracts an address from URL params like <span class="tag">outputCurrency / token / address</span>,
                or prompts you if none is found ‚Äî then redirects to your hub.
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 4) RPC Checker -->
      <div class="card" id="cardRpc">
        <div class="head">
          <div>
            <div class="kicker" style="text-align:left; margin:0;">RPC CHECKER</div>
            <div class="title">Find the fastest working BSC RPC</div>
            <div class="sub">We measure response time using <span class="tag">eth_blockNumber</span> via ethers. Fastest result is highlighted.</div>
          </div>
          <div class="row" style="max-width:360px">
            <button class="btn small" id="btnTestRpcs">Test RPCs</button>
            <button class="btn small" id="btnCopyBestRpc">Copy best RPC</button>
          </div>
        </div>

        <div class="body">
          <div class="two">
            <div class="panel">
              <label>Endpoints</label>
              <label style="margin-top:0">Optional custom RPC</label>
              <input id="customRpc" placeholder="https://..." spellcheck="false" />
              <div class="hint">
                Browser tests are limited by CORS. If a node blocks browser calls, it will show as failed here even if it works on servers/scripts.
              </div>

              <div style="margin-top:12px" class="statusBox">
                <div class="dot" id="rpcDot"></div>
                <div>
                  <div style="font-weight:900" id="rpcTitle">Ready</div>
                  <div class="muted" id="rpcSub">Press ‚ÄúTest RPCs‚Äù.</div>
                </div>
              </div>

              <div class="hint" id="bestRpcLine" style="margin-top:12px"></div>
            </div>

            <div class="panel">
              <label>Results</label>
              <table>
                <thead>
                  <tr>
                    <th>RPC</th>
                    <th>Latency</th>
                    <th>Block</th>
                    <th>Status</th>
                    <th>Notes</th>
                  </tr>
                </thead>
                <tbody id="rpcTbody">
                  <tr><td class="muted">‚Äî</td><td class="muted">‚Äî</td><td class="muted">‚Äî</td><td class="muted">‚Äî</td><td class="muted">‚Äî</td></tr>
                </tbody>
              </table>
              <div class="hint">Tip: if one RPC fails due to CORS/timeout, try another ‚Äî CycleX can still auto-fallback in scripts.</div>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        This hub performs best-effort checks. Always validate with multiple sources before swapping.
        ‚Ä¢ <a href="https://bscscan.com/" target="_blank" rel="noopener">BscScan</a>
        ‚Ä¢ <a href="https://revoke.cash/" target="_blank" rel="noopener">revoke.cash</a>
      </div>
    </div>
  </div>

  <script>
    const { ethers } = window;

    // =========================
    // Network + Constants (BSC)
    // =========================
    const BSC = {
      chainId: 56,
      name: "BSC",
      tokens: {
        WBNB: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
        USDT: "0x55d398326f99059ff775485246999027b3197955",
        USDC: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
        BUSD: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
      },
      chainlink: {
        // BNB / USD feed on BSC
        BNBUSD: "0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE",
      },
      explorer: {
        token: (a) => `https://bscscan.com/token/${a}`,
        address: (a) => `https://bscscan.com/address/${a}`,
        approvals: (owner) => `https://bscscan.com/tokenapprovalchecker?search=${owner}`,
      }
    };

    // DEX Routers (used for spender presets + factory() discovery)
    const DEXES = [
      {
        id: "pancake",
        name: "PancakeSwap",
        router: "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        buildSwapUrl: ({ token, base }) => `https://pancakeswap.finance/swap?outputCurrency=${token}&inputCurrency=${base}`
      },
      {
        id: "biswap",
        name: "BiSwap",
        router: "0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8",
        buildSwapUrl: ({ token, base }) => `https://exchange.biswap.org/#/swap?outputCurrency=${token}&inputCurrency=${base}`
      },
      {
        id: "apeswap",
        name: "ApeSwap",
        router: "0x3b0C2151549714109Ce035BB648A41144f2ea720",
        buildSwapUrl: ({ token, base }) => `https://apeswap.finance/swap?outputCurrency=${token}&inputCurrency=${base}`
      },
      {
        id: "mdex",
        name: "MDEX (BSC)",
        router: "0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8",
        buildSwapUrl: ({ token, base }) => `https://bsc.mdex.com/#/swap?outputCurrency=${token}&inputCurrency=${base}`
      },
      {
        id: "bakery",
        name: "BakerySwap",
        router: "0x6BFeA2BD40A41eF7E431aC1f452B51E72Bfc7059",
        buildSwapUrl: ({ token, base }) => `https://www.bakeryswap.org/#/swap?outputCurrency=${token}&inputCurrency=${base}`
      },
      {
        id: "babyswap",
        name: "BabySwap",
        router: "0x169a490C385c5eeac12acc3999f4bC9605cD3aC5",
        buildSwapUrl: ({ token, base }) => `https://exchange.babyswap.finance/#/swap?outputCurrency=${token}&inputCurrency=${base}`
      },
    ];

    // Browser-friendly public RPCs (some may fail due to CORS)
    const DEFAULT_RPCS = [
      { url: "https://bsc-dataseed.binance.org", note: "BNBChain (public)" },
      { url: "https://bsc-dataseed1.bnbchain.org", note: "BNBChain mirror" },
      { url: "https://bsc-dataseed2.bnbchain.org", note: "BNBChain mirror" },
      { url: "https://bsc-dataseed3.bnbchain.org", note: "BNBChain mirror" },
      { url: "https://bsc-dataseed4.bnbchain.org", note: "BNBChain mirror" },

      { url: "https://bsc-dataseed1.defibit.io", note: "Defibit mirror" },
      { url: "https://bsc-dataseed2.defibit.io", note: "Defibit mirror" },
      { url: "https://bsc-dataseed3.defibit.io", note: "Defibit mirror" },
      { url: "https://bsc-dataseed4.defibit.io", note: "Defibit mirror" },

      { url: "https://rpc.ankr.com/bsc", note: "Ankr (public)" },
      { url: "https://bsc.blockpi.network/v1/rpc/public", note: "BlockPI (public)" },
      { url: "https://bsc-rpc.publicnode.com", note: "PublicNode (public)" },
      { url: "https://bsc.drpc.org", note: "dRPC (public)" },
      { url: "https://bsc.llamarpc.com", note: "LlamaRPC (public)" },
      { url: "https://1rpc.io/bnb", note: "1RPC (public)" },
    ];

    // =========
    // ABIs
    // =========
    const ABI_ERC20 = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function owner() view returns (address)",
      "function getOwner() view returns (address)",
      "function admin() view returns (address)",
      "function implementation() view returns (address)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 amount) returns (bool)",
    ];

    const ABI_ROUTER = [
      "function factory() view returns (address)",
      "function WETH() view returns (address)"
    ];

    const ABI_FACTORY = [
      "function getPair(address tokenA, address tokenB) view returns (address pair)"
    ];

    const ABI_PAIR = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)"
    ];

    const ABI_CHAINLINK = [
      "function latestRoundData() view returns (uint80, int256, uint256, uint256, uint80)",
      "function decimals() view returns (uint8)"
    ];

    // =========================
    // Small helpers
    // =========================
    const $ = (id) => document.getElementById(id);

    function nowIso(){ return new Date().toISOString(); }

    async function copyText(text){
      await navigator.clipboard.writeText(text);
    }

    function shortAddr(a){
      if(!a) return "‚Äî";
      return a.slice(0,6) + "‚Ä¶" + a.slice(-4);
    }

    function safeJson(obj){
      return JSON.stringify(obj, (_, v) => typeof v === "bigint" ? v.toString() : v, 2);
    }

    function setDot(dotEl, state){
      dotEl.classList.remove("good","warn","bad");
      if(state) dotEl.classList.add(state);
    }

    function addSignal({ level, title, desc }){
      const wrap = document.createElement("div");
      wrap.className = `sig ${level}`;
      wrap.innerHTML = `
        <div class="icon">${level==="good"?"‚úÖ":level==="warn"?"‚ö†Ô∏è":"üõë"}</div>
        <div class="txt">
          <div class="t">${title}</div>
          <div class="d">${desc}</div>
        </div>
      `;
      $("siglist").appendChild(wrap);
    }

    function clearSignals(){
      $("siglist").innerHTML = "";
    }

    function parseTokenFromUrl(){
      const u = new URL(window.location.href);
      const tok = u.searchParams.get("token");
      if(tok && /^0x[a-fA-F0-9]{40}$/.test(tok.trim())) return tok.trim();
      return "";
    }

    // =========================
    // Provider selection
    // =========================
    let _activeRpc = localStorage.getItem("cx_best_rpc") || DEFAULT_RPCS[0].url;

    function makeProvider(rpcUrl){
      return new ethers.JsonRpcProvider(rpcUrl, BSC.chainId, { staticNetwork: true });
    }

    async function pickWorkingProvider(preferredList){
      // Try cached first, then list
      const tryList = [ _activeRpc, ...preferredList.filter(x => x !== _activeRpc) ];

      for(const url of tryList){
        try{
          const p = makeProvider(url);
          await Promise.race([
            p.getBlockNumber(),
            new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), 4500))
          ]);
          _activeRpc = url;
          localStorage.setItem("cx_best_rpc", url);
          return p;
        }catch(e){}
      }

      // last resort
      return makeProvider(DEFAULT_RPCS[0].url);
    }

    // =========================
    // Base / DEX selectors
    // =========================
    const BASES = [
      { id:"BNB", label:"BNB", value:"BNB" },
      { id:"WBNB", label:"WBNB", value: BSC.tokens.WBNB },
      { id:"USDT", label:"USDT", value: BSC.tokens.USDT },
      { id:"USDC", label:"USDC", value: BSC.tokens.USDC },
      { id:"BUSD", label:"BUSD", value: BSC.tokens.BUSD },
    ];

    function initSelectors(){
      const dexSel = $("dexSelect");
      dexSel.innerHTML = DEXES.map(d => `<option value="${d.id}">${d.name}</option>`).join("");

      const baseSel = $("baseSelect");
      baseSel.innerHTML = BASES.map(b => `<option value="${b.value}">${b.label}</option>`).join("");

      // presets for approvals spender
      const spenderPreset = $("spenderPreset");
      spenderPreset.innerHTML =
        `<option value="">(choose preset)</option>` +
        DEXES.map(d => `<option value="${d.router}">${d.name} Router</option>`).join("");

      spenderPreset.addEventListener("change", ()=>{
        $("spenderAddr").value = spenderPreset.value || "";
      });
    }

    // =========================
    // Bookmarklet generator
    // =========================
    function extractFirstAddress(str){
      const m = (str || "").match(/0x[a-fA-F0-9]{40}/);
      return m ? m[0] : "";
    }

    function makeBookmarklet(hubUrl){
      const base = (hubUrl || "").trim() || (window.location.origin + "/security/");
      const js = `(function(){try{var hub="${base.replace(/"/g,'\\"')}";var href=String(location.href||"");var u;try{u=new URL(href);}catch(e){u=null;}var cand="";function pick(v){if(!cand&&v&&/0x[a-fA-F0-9]{40}/.test(v))cand=v.match(/0x[a-fA-F0-9]{40}/)[0];}
if(u){var sp=u.searchParams;["outputCurrency","inputCurrency","token","tokenIn","tokenOut","address","contractAddress","currency","fromToken","toToken"].forEach(function(k){pick(sp.get(k)||"");});pick(u.hash||"");pick(u.pathname||"");}
pick(href);
if(!cand){cand=prompt("Paste token address (BSC):","");}
if(!cand){return;}
cand=cand.trim();
if(!/^0x[a-fA-F0-9]{40}$/.test(cand)){alert("Invalid address");return;}
var dest=hub+(hub.indexOf("?")>-1?"&":"?")+"token="+encodeURIComponent(cand);
location.href=dest;}catch(e){alert("Bookmarklet error: "+(e&&e.message?e.message:e));}})();`;
      const href = "javascript:" + js;
      return { href, js };
    }

    function updateBookmarklet(){
      const hubUrl = $("hubUrl").value.trim();
      localStorage.setItem("cx_hub_url", hubUrl);

      const bm = makeBookmarklet(hubUrl);
      $("bmDrag").setAttribute("href", bm.href);
      $("bmCode").textContent = bm.href;
    }

    // =========================
    // BscScan optional
    // =========================
    function getBscscanKey(){
      return ($("bscscanKey").value || "").trim();
    }
    async function bscscanGetSource(addr){
      const key = getBscscanKey();
      if(!key) return { ok:false, reason:"no_key" };

      const url = `https://api.bscscan.com/api?module=contract&action=getsourcecode&address=${addr}&apikey=${encodeURIComponent(key)}`;
      const r = await fetch(url);
      const j = await r.json();
      if(j && j.status === "1" && Array.isArray(j.result) && j.result[0]){
        return { ok:true, data: j.result[0] };
      }
      return { ok:false, reason:"api_fail", raw:j };
    }

    // =========================
    // Scan logic
    // =========================
    let lastReport = null;

    function setStatus(level, title, sub){
      setDot($("statusDot"), level);
      $("statusTitle").textContent = title;
      $("statusSub").textContent = sub;
    }

    async function tryCall(fn){
      try{ return await fn(); }catch(e){ return null; }
    }

    function isZeroAddr(a){
      return !a || /^0x0{40}$/.test(a.toLowerCase());
    }
    function isDeadAddr(a){
      if(!a) return false;
      const x = a.toLowerCase();
      return x === "0x000000000000000000000000000000000000dead" || isZeroAddr(x);
    }

    async function getOwnerLike(contract){
      const candidates = [
        () => contract.owner(),
        () => contract.getOwner(),
        () => contract.admin(),
      ];
      for(const c of candidates){
        const v = await tryCall(c);
        if(v && /^0x[a-fA-F0-9]{40}$/.test(v)) return v;
      }
      return null;
    }

    async function getEip1967(provider, addr){
      // EIP-1967 implementation slot: 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
      // admin slot: 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
      const implSlot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
      const admSlot  = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";
      const [implRaw, admRaw] = await Promise.all([
        provider.getStorage(addr, implSlot).catch(()=> "0x"),
        provider.getStorage(addr, admSlot).catch(()=> "0x"),
      ]);

      function slotToAddr(hex){
        if(!hex || hex === "0x") return null;
        const h = hex.replace(/^0x/,"").padStart(64,"0");
        const a = "0x" + h.slice(24);
        if(/^0x0{40}$/.test(a.toLowerCase())) return null;
        try{ return ethers.getAddress(a); }catch(e){ return null; }
      }

      return {
        implementation: slotToAddr(implRaw),
        admin: slotToAddr(admRaw)
      };
    }

    async function getBnbUsd(provider){
      const feed = new ethers.Contract(BSC.chainlink.BNBUSD, ABI_CHAINLINK, provider);
      const dec = await feed.decimals().catch(()=> 8);
      const rd = await feed.latestRoundData();
      const price = Number(rd[1]) / (10 ** Number(dec)); // int256
      return price;
    }

    async function findLiquiditySignals(provider, tokenAddr){
      // Multi-DEX, multi-base:
      // We'll discover each DEX factory via router.factory(), then check getPair(token, base)
      const bases = [
        { symbol:"WBNB", addr: BSC.tokens.WBNB, usdType:"bnb" },
        { symbol:"USDT", addr: BSC.tokens.USDT, usdType:"stable" },
        { symbol:"USDC", addr: BSC.tokens.USDC, usdType:"stable" },
        { symbol:"BUSD", addr: BSC.tokens.BUSD, usdType:"stable" },
      ];

      let bnbUsd = null;
      try{ bnbUsd = await getBnbUsd(provider); }catch(e){ bnbUsd = null; }

      const results = [];

      for(const dex of DEXES){
        const router = new ethers.Contract(dex.router, ABI_ROUTER, provider);
        const factoryAddr = await tryCall(()=>router.factory());
        if(!factoryAddr) continue;

        const factory = new ethers.Contract(factoryAddr, ABI_FACTORY, provider);

        for(const b of bases){
          const pair = await tryCall(()=>factory.getPair(tokenAddr, b.addr));
          if(!pair || isZeroAddr(pair)) continue;

          const pairC = new ethers.Contract(pair, ABI_PAIR, provider);
          const [t0,t1,res,ts,deadBal,zeroBal] = await Promise.all([
            pairC.token0().catch(()=> null),
            pairC.token1().catch(()=> null),
            pairC.getReserves().catch(()=> null),
            pairC.totalSupply().catch(()=> null),
            pairC.balanceOf("0x000000000000000000000000000000000000dEaD").catch(()=> 0n),
            pairC.balanceOf("0x0000000000000000000000000000000000000000").catch(()=> 0n),
          ]);

          if(!t0 || !t1 || !res) continue;

          const reserve0 = BigInt(res[0]);
          const reserve1 = BigInt(res[1]);

          const baseIs0 = (t0.toLowerCase() === b.addr.toLowerCase());
          const baseReserve = baseIs0 ? reserve0 : reserve1;

          // LP burn %
          let lpBurnPct = null;
          if(ts && ts > 0n){
            const burned = deadBal + zeroBal;
            lpBurnPct = Number((burned * 10000n) / ts) / 100; // 2 decimals
          }

          // USD liquidity estimate: base side * 2 (rough)
          let usd = null;
          try{
            if(b.usdType === "stable"){
              // stable has 18 for BUSD, 18 for USDT on BSC, 18? USDC is 18 on BSC.
              // We'll assume 18 to avoid calling decimals for base tokens (fast). It's fine for signal.
              const baseAmt = Number(baseReserve) / 1e18;
              usd = baseAmt * 2;
            }else if(b.usdType === "bnb" && bnbUsd){
              const baseAmt = Number(baseReserve) / 1e18;
              usd = baseAmt * bnbUsd * 2;
            }
          }catch(e){ usd = null; }

          results.push({
            dex: dex.name,
            dexId: dex.id,
            pair,
            base: b.symbol,
            baseReserve: baseReserve.toString(),
            approxUsdLiquidity: usd,
            lpBurnPct,
          });
        }
      }

      // sort best USD
      results.sort((a,b)=>(b.approxUsdLiquidity||0)-(a.approxUsdLiquidity||0));
      return { results, bnbUsd };
    }

    async function runScan(){
      const raw = $("tokenAddr").value.trim();
      clearSignals();
      lastReport = null;

      let tokenAddr;
      try{ tokenAddr = ethers.getAddress(raw); }
      catch(e){
        setStatus("bad","Invalid address","Please paste a valid 0x‚Ä¶ token contract address.");
        addSignal({ level:"bad", title:"Invalid address", desc:"The input is not a valid EVM address." });
        return;
      }

      setStatus("warn","Scanning‚Ä¶","Reading on-chain data (metadata, owner/proxy hints, liquidity).");
      $("ts").textContent = nowIso();

      const provider = await pickWorkingProvider(DEFAULT_RPCS.map(x=>x.url));

      const code = await provider.getCode(tokenAddr);
      if(!code || code === "0x"){
        setStatus("bad","No contract bytecode","This address has no contract code on BSC.");
        addSignal({ level:"bad", title:"Contract bytecode not found", desc:"No contract deployed at this address (on BSC)." });
        lastReport = { token: tokenAddr, ok:false, reason:"no_code", rpc:_activeRpc, ts: nowIso() };
        return;
      }

      const token = new ethers.Contract(tokenAddr, ABI_ERC20, provider);

      // Basic metadata
      const [name, symbol, decimals, totalSupply] = await Promise.all([
        tryCall(()=>token.name()),
        tryCall(()=>token.symbol()),
        tryCall(()=>token.decimals()),
        tryCall(()=>token.totalSupply()),
      ]);

      if(name && symbol){
        addSignal({ level:"good", title:`${name} (${symbol})`, desc:`Decimals: ${decimals ?? "?"} ‚Ä¢ Total supply: ${totalSupply ? totalSupply.toString() : "?"}` });
      }else{
        addSignal({ level:"warn", title:"Metadata partially unavailable", desc:"Could not read name/symbol/decimals reliably. (May still be a valid token.)" });
      }

      addSignal({ level:"good", title:"Contract bytecode found", desc:"The address has deployed bytecode on BSC." });

      // Owner / Proxy hints
      const ownerLike = await getOwnerLike(token);
      const eip1967 = await getEip1967(provider, tokenAddr);
      const implFn = await tryCall(()=>token.implementation());
      const proxyImpl = implFn || eip1967.implementation;

      let ownerRisk = 0;
      if(ownerLike){
        if(isDeadAddr(ownerLike)){
          addSignal({ level:"good", title:"Owner appears renounced", desc:`Owner-like address: ${ownerLike}` });
        }else{
          ownerRisk += 1;
          addSignal({ level:"warn", title:"Owner not renounced", desc:`Owner-like address detected: ${ownerLike}` });
        }
      }else{
        addSignal({ level:"warn", title:"Owner not detected", desc:"Could not read owner/getOwner/admin from common patterns." });
      }

      let proxyRisk = 0;
      if(proxyImpl){
        proxyRisk += 1;
        addSignal({ level:"warn", title:"Proxy hint detected", desc:`Implementation: ${proxyImpl} (EIP-1967/implementation() hint)` });
      }else{
        addSignal({ level:"good", title:"No obvious proxy hint", desc:"No EIP-1967 implementation detected (best-effort)." });
      }

      // Owner balance concentration
      let ownerBalPct = null;
      if(ownerLike && totalSupply && !isDeadAddr(ownerLike)){
        const bal = await tryCall(()=>token.balanceOf(ownerLike));
        if(bal != null){
          try{
            ownerBalPct = Number((BigInt(bal) * 10000n) / BigInt(totalSupply)) / 100; // 2dp
            if(ownerBalPct >= 20){
              ownerRisk += 2;
              addSignal({ level:"bad", title:"High owner concentration", desc:`Owner holds ~${ownerBalPct}% of total supply.` });
            }else if(ownerBalPct >= 5){
              ownerRisk += 1;
              addSignal({ level:"warn", title:"Owner concentration", desc:`Owner holds ~${ownerBalPct}% of total supply.` });
            }else{
              addSignal({ level:"good", title:"Owner concentration looks lower", desc:`Owner holds ~${ownerBalPct}% of total supply.` });
            }
          }catch(e){}
        }
      }

      // Liquidity signals across DEXs
      const { results: liq, bnbUsd } = await findLiquiditySignals(provider, tokenAddr);

      const requireLiq = $("chkRequireLiq").checked;
      if(liq.length === 0){
        if(requireLiq){
          addSignal({ level:"bad", title:"No DEX pair found (required)", desc:"No pair found on checked DEX factories for WBNB/USDT/USDC/BUSD." });
        }else{
          addSignal({ level:"warn", title:"No DEX pair found", desc:"May be not listed yet. Liquidity checks are informational unless ‚ÄòRequire liquidity‚Äô is enabled." });
        }
      }else{
        const best = liq[0];
        const usd = best.approxUsdLiquidity ? `$${best.approxUsdLiquidity.toFixed(0)}` : "‚Äî";
        const burn = (best.lpBurnPct == null) ? "‚Äî" : `${best.lpBurnPct.toFixed(2)}%`;
        addSignal({
          level: (best.approxUsdLiquidity && best.approxUsdLiquidity >= 10000) ? "good" : "warn",
          title: `Liquidity detected (${best.dex} / ${best.base})`,
          desc: `Pair: ${best.pair} ‚Ä¢ Est. liquidity: ${usd} ‚Ä¢ LP burned (0x0 + dead): ${burn}`
        });

        // Also show additional pairs (compact)
        if(liq.length > 1){
          const extra = liq.slice(1,4).map(x=>{
            const u = x.approxUsdLiquidity ? `$${x.approxUsdLiquidity.toFixed(0)}` : "‚Äî";
            return `${x.dex}(${x.base}) ${u}`;
          }).join(" ‚Ä¢ ");
          addSignal({ level:"good", title:"More liquidity signals", desc: extra });
        }

        if(bnbUsd){
          addSignal({ level:"good", title:"BNB/USD oracle read", desc:`Chainlink BNB/USD ‚âà ${bnbUsd.toFixed(2)}` });
        }
      }

      // Optional: Verified source via BscScan
      let verified = null;
      const bscRes = await bscscanGetSource(tokenAddr);
      if(bscRes.ok){
        const sc = bscRes.data;
        verified = (sc.ABI && sc.ABI !== "Contract source code not verified") ? true : false;
        if(verified){
          addSignal({ level:"good", title:"BscScan: Verified source", desc:"Contract source appears verified on BscScan." });
        }else{
          addSignal({ level:"warn", title:"BscScan: Not verified", desc:"BscScan API indicates source is not verified." });
        }
        if(sc.Proxy && sc.Proxy !== "0"){
          addSignal({ level:"warn", title:"BscScan: Proxy flagged", desc:`BscScan reports Proxy=${sc.Proxy}. Implementation: ${sc.Implementation || "‚Äî"}` });
          proxyRisk += 1;
        }
      }else{
        addSignal({ level:"warn", title:"Verified status: unknown", desc:"Add an optional BscScan API key to check if the contract is verified." });
      }

      // Final rating
      let risk = ownerRisk + proxyRisk;

      // if requireLiq and none found -> heavy risk
      if(requireLiq && liq.length === 0) risk += 3;

      let level = "good";
      let title = "Looks OK (basic hygiene)";
      let sub = "No critical red flags detected by these checks.";
      if(risk >= 4){
        level = "bad";
        title = "High caution";
        sub = "Multiple risk signals detected. Verify carefully before swapping.";
      }else if(risk >= 2){
        level = "warn";
        title = "Caution (some risk signals)";
        sub = "Some signals need attention (owner/proxy/liquidity/verification).";
      }
      setStatus(level, title, sub);

      lastReport = {
        ok: true,
        token: tokenAddr,
        name: name || null,
        symbol: symbol || null,
        decimals: decimals ?? null,
        totalSupply: totalSupply ? totalSupply.toString() : null,
        ownerLike: ownerLike || null,
        ownerBalPct,
        proxyImpl: proxyImpl || null,
        liquidity: liq,
        requireLiquidity: requireLiq,
        rpc: _activeRpc,
        ts: nowIso(),
      };
    }

    // =========================
    // Buttons
    // =========================
    $("btnScan").addEventListener("click", runScan);

    $("btnOpenBscscan").addEventListener("click", ()=>{
      const a = $("tokenAddr").value.trim();
      const tok = extractFirstAddress(a);
      if(!tok) return alert("Paste token address first.");
      window.open(BSC.explorer.token(tok), "_blank", "noopener");
    });

    $("btnOpenDex").addEventListener("click", ()=>{
      const a = $("tokenAddr").value.trim();
      const tok = extractFirstAddress(a);
      if(!tok) return alert("Paste token address first.");
      const dexId = $("dexSelect").value;
      const base = $("baseSelect").value;
      const dex = DEXES.find(d=>d.id===dexId) || DEXES[0];
      const url = dex.buildSwapUrl({ token: tok, base });
      window.open(url, "_blank", "noopener");
    });

    $("btnCopyShare").addEventListener("click", async ()=>{
      const a = $("tokenAddr").value.trim();
      const tok = extractFirstAddress(a);
      if(!tok) return alert("Paste token address first.");
      const share = `${window.location.origin}/security/?token=${encodeURIComponent(tok)}`;
      await copyText(share);
      alert("Share link copied.");
    });

    $("btnCopyJson").addEventListener("click", async ()=>{
      if(!lastReport) return alert("Run Scan first.");
      await copyText(safeJson(lastReport));
      alert("JSON report copied.");
    });

    function openXIntent(text, url){
      const u = new URL("https://twitter.com/intent/tweet");
      u.searchParams.set("text", text);
      if(url) u.searchParams.set("url", url);
      window.open(u.toString(), "_blank", "noopener");
    }

    $("btnShareX").addEventListener("click", ()=>{
      const a = $("tokenAddr").value.trim();
      const tok = extractFirstAddress(a);
      if(!tok) return alert("Paste token address first.");
      const share = `${window.location.origin}/security/?token=${encodeURIComponent(tok)}`;
      const title = lastReport?.ok ? (lastReport.symbol ? `${lastReport.symbol} scan` : "Token scan") : "Token scan";
      const text =
        `CycleX Security Hub ‚Ä¢ ${title}\n` +
        `Token: ${tok}\n` +
        `Run basic checks (owner/proxy/liquidity) before swapping.`;
      openXIntent(text, share);
    });

    $("btnShareXTop").addEventListener("click", ()=>{
      const share = `${window.location.origin}/security/`;
      openXIntent("CycleX Security Hub ‚Ä¢ on-chain hygiene checks before swapping.", share);
    });

    $("btnSaveKey").addEventListener("click", ()=>{
      localStorage.setItem("cx_bscscan_key", getBscscanKey());
      alert("Saved (local browser).");
    });

    // =========================
    // Approvals tool
    // =========================
    let apprProvider = null;
    let apprSigner = null;

    function setAppr(level, title, sub){
      setDot($("apprDot"), level);
      $("apprTitle").textContent = title;
      $("apprSub").textContent = sub;
    }

    async function connectWallet(){
      if(!window.ethereum){
        setAppr("bad","No wallet detected","Install MetaMask / a Web3 wallet.");
        return;
      }
      setAppr("warn","Connecting‚Ä¶","Waiting for wallet approval.");
      const bp = new ethers.BrowserProvider(window.ethereum, "any");
      await bp.send("eth_requestAccounts", []);
      const signer = await bp.getSigner();
      const addr = await signer.getAddress();
      apprProvider = bp;
      apprSigner = signer;
      $("ownerAddr").value = addr;
      setAppr("good","Connected", `Wallet: ${addr}`);
    }

    $("btnConnect").addEventListener("click", connectWallet);

    $("btnUseScannedToken").addEventListener("click", ()=>{
      const a = $("tokenAddr").value.trim();
      const tok = extractFirstAddress(a);
      if(!tok) return alert("No scanned token.");
      const cur = $("tokenList").value.trim();
      $("tokenList").value = cur ? (cur + "\n" + tok) : tok;
    });

    $("btnCopyOwnerLink").addEventListener("click", async ()=>{
      const owner = extractFirstAddress($("ownerAddr").value.trim());
      if(!owner) return alert("Paste/Connect owner wallet first.");
      const link = BSC.explorer.approvals(owner);
      await copyText(link);
      alert("BscScan approvals link copied.");
    });

    async function readTokenMeta(p, tokenAddr){
      const c = new ethers.Contract(tokenAddr, ABI_ERC20, p);
      const [sym, dec] = await Promise.all([
        tryCall(()=>c.symbol()),
        tryCall(()=>c.decimals()),
      ]);
      return { sym: sym || "?", dec: (dec == null ? 18 : Number(dec)) };
    }

    function parseTokenLines(){
      return $("tokenList").value
        .split(/\r?\n/)
        .map(x=>x.trim())
        .filter(Boolean)
        .map(extractFirstAddress)
        .filter(x=>/^0x[a-fA-F0-9]{40}$/.test(x));
    }

    $("btnCheckAllow").addEventListener("click", async ()=>{
      const owner = extractFirstAddress($("ownerAddr").value.trim());
      const spender = extractFirstAddress($("spenderAddr").value.trim());
      const tokens = parseTokenLines();

      if(!owner || !spender) return alert("Owner + Spender are required.");
      if(tokens.length === 0) return alert("Paste at least 1 token address.");

      if(!apprProvider) await connectWallet();
      if(!apprProvider) return;

      setAppr("warn","Checking‚Ä¶",`Reading allowances for ${tokens.length} token(s).`);
      $("allowTbody").innerHTML = "";

      for(const t of tokens){
        const meta = await readTokenMeta(apprProvider, t);
        const c = new ethers.Contract(t, ABI_ERC20, apprProvider);
        const alw = await tryCall(()=>c.allowance(owner, spender));
        const pretty = (alw == null) ? "‚Äî" : ethers.formatUnits(alw, meta.dec);

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><span class="tag">${shortAddr(t)}</span></td>
          <td>${meta.sym}</td>
          <td>${pretty}</td>
          <td><button class="btn small" data-revoke="${t}">Revoke</button></td>
        `;
        $("allowTbody").appendChild(tr);
      }

      $("allowTbody").querySelectorAll("button[data-revoke]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          if(!apprSigner) return alert("Connect wallet first.");
          const t = btn.getAttribute("data-revoke");
          await revokeOne(t);
        });
      });

      setAppr("good","Done","Allowances loaded.");
      $("apprHint").textContent = "If allowance is large/infinite for a spender you don‚Äôt trust, revoke it.";
    });

    async function revokeOne(tokenAddr){
      const spender = extractFirstAddress($("spenderAddr").value.trim());
      if(!spender) return alert("Spender is required.");
      setAppr("warn","Revoking‚Ä¶",`Sending approve(spender, 0) for ${shortAddr(tokenAddr)}‚Ä¶`);

      const c = new ethers.Contract(tokenAddr, ABI_ERC20, apprSigner);
      const tx = await c.approve(spender, 0);
      await tx.wait();
      setAppr("good","Revoked","Transaction confirmed.");
    }

    $("btnRevokeAll").addEventListener("click", async ()=>{
      const owner = extractFirstAddress($("ownerAddr").value.trim());
      const spender = extractFirstAddress($("spenderAddr").value.trim());
      const tokens = parseTokenLines();

      if(!owner || !spender) return alert("Owner + Spender are required.");
      if(tokens.length === 0) return alert("Paste at least 1 token address.");
      if(!apprProvider) await connectWallet();
      if(!apprSigner) return;

      setAppr("warn","Scanning allowances‚Ä¶","Will revoke only non-zero allowances.");

      for(const t of tokens){
        const meta = await readTokenMeta(apprProvider, t);
        const cRead = new ethers.Contract(t, ABI_ERC20, apprProvider);
        const alw = await tryCall(()=>cRead.allowance(owner, spender));
        if(alw == null || BigInt(alw) === 0n) continue;

        setAppr("warn","Revoking‚Ä¶",`${shortAddr(t)} (${meta.sym})`);
        const c = new ethers.Contract(t, ABI_ERC20, apprSigner);
        const tx = await c.approve(spender, 0);
        await tx.wait();
      }

      setAppr("good","Finished","All non-zero allowances revoked (for the chosen spender).");
    });

    // =========================
    // Bookmarklet buttons
    // =========================
    $("btnCopyBm").addEventListener("click", async ()=>{
      await copyText($("bmDrag").getAttribute("href"));
      alert("Bookmarklet copied.");
    });
    $("btnCopyBmCode").addEventListener("click", async ()=>{
      await copyText($("bmCode").textContent);
      alert("Code copied.");
    });

    // =========================
    // RPC Checker
    // =========================
    function setRpc(level, title, sub){
      setDot($("rpcDot"), level);
      $("rpcTitle").textContent = title;
      $("rpcSub").textContent = sub;
    }

    async function testOneRpc(url){
      const p = makeProvider(url);
      const t0 = performance.now();
      const block = await Promise.race([
        p.getBlockNumber(),
        new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), 4500))
      ]);
      const t1 = performance.now();
      return { url, ms: Math.round(t1 - t0), block };
    }

    $("btnTestRpcs").addEventListener("click", async ()=>{
      setRpc("warn","Testing‚Ä¶","Measuring latency. (CORS/timeouts may fail in browser)");
      $("rpcTbody").innerHTML = "";

      const list = [...DEFAULT_RPCS];
      const custom = $("customRpc").value.trim();
      if(custom) list.unshift({ url: custom, note: "Custom" });

      const rows = [];
      for(const r of list){
        try{
          const res = await testOneRpc(r.url);
          rows.push({ ...res, ok:true, note:r.note });
        }catch(e){
          rows.push({ url:r.url, ok:false, ms:null, block:null, note:r.note });
        }
      }

      // choose best
      const okRows = rows.filter(x=>x.ok).sort((a,b)=>a.ms-b.ms);
      const best = okRows[0] || null;
      if(best){
        _activeRpc = best.url;
        localStorage.setItem("cx_best_rpc", best.url);
        $("bestRpcLine").innerHTML = `<span class="tag">Best RPC: ${best.url}</span>`;
        setRpc("good","Done",`Best: ${best.url} (${best.ms} ms)`);
      }else{
        $("bestRpcLine").innerHTML = `<span class="tag">No working RPC found</span>`;
        setRpc("bad","No working RPCs","Try another network / disable extensions / check CORS.");
      }

      // render table
      for(const r of rows){
        const tr = document.createElement("tr");
        const status = r.ok ? `<span class="tag">‚úÖ OK</span>` : `<span class="tag">‚ùå FAIL</span>`;
        const ms = r.ok ? `${r.ms} ms` : "‚Äî";
        const block = r.ok ? String(r.block) : "‚Äî";
        const isBest = best && r.url === best.url;
        tr.style.background = isBest ? "rgba(95,255,190,.10)" : "transparent";
        tr.innerHTML = `
          <td style="max-width:420px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
            ${r.url}
          </td>
          <td>${ms}</td>
          <td>${block}</td>
          <td>${status}</td>
          <td>${r.note || ""}</td>
        `;
        $("rpcTbody").appendChild(tr);
      }
    });

    $("btnCopyBestRpc").addEventListener("click", async ()=>{
      const best = localStorage.getItem("cx_best_rpc") || _activeRpc;
      await copyText(best);
      alert("Best RPC copied.");
    });

    // =========================
    // Init
    // =========================
    (function init(){
      initSelectors();

      // load saved bscscan key
      const k = localStorage.getItem("cx_bscscan_key") || "";
      $("bscscanKey").value = k;

      // hub url for bookmarklet
      const savedHub = localStorage.getItem("cx_hub_url");
      $("hubUrl").value = savedHub || (window.location.origin + "/security/");
      $("hubUrl").addEventListener("input", updateBookmarklet);
      updateBookmarklet();

      // auto token
      const tok = parseTokenFromUrl();
      if(tok) $("tokenAddr").value = tok;

      // auto-run preference
      const ar = localStorage.getItem("cx_autorun") === "1";
      $("chkAutoRun").checked = ar;
      $("chkAutoRun").addEventListener("change", ()=>{
        localStorage.setItem("cx_autorun", $("chkAutoRun").checked ? "1" : "0");
      });

      const rl = localStorage.getItem("cx_require_liq") === "1";
      $("chkRequireLiq").checked = rl;
      $("chkRequireLiq").addEventListener("change", ()=>{
        localStorage.setItem("cx_require_liq", $("chkRequireLiq").checked ? "1" : "0");
      });

      // approvals default
      setAppr(null,"Disconnected","Connect your wallet to check/revoke.");
      setRpc(null,"Ready","Press ‚ÄúTest RPCs‚Äù.");

      // if token present + autorun -> scan
      if(tok && $("chkAutoRun").checked){
        runScan();
      }
    })();
  </script>
</body>
</html>
