<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#05060a">
  <meta name="application-name" content="CycleX">
  <meta name="apple-mobile-web-app-title" content="CycleX">

  <meta charset="UTF-8" />
  <title>CycleX ‚Äì Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
   <style>
  :root{
    --bg-main:#05060a;
    --bg-gradient-start:#05060a;
    --bg-gradient-mid:#1a0d3a;
    --bg-gradient-end:#003a4c;

    --text-main:#f4f6ff;
    --text-muted:rgba(244,246,255,.7);

    --accent-cyan:#00e5ff;
    --accent-green:#5dffb2;
    --accent-purple:#7c5cff;
    --green:#3cffb0;

    --card-bg:rgba(255,255,255,.06);
    --border-subtle:rgba(255,255,255,.12);

    --shadow-soft:0 24px 70px rgba(0,0,0,.65);
    --radius-xl:24px;
    --radius-lg:18px;
    --transition-fast:.18s ease-out;

    --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    --sans:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;

    --container: 1160px;
    --container-wide: 1160px;

    /* ‚úÖ single source of truth for grid/panel spacing */
    --tool-panel-gap: 18px;
    --tool-grid-gap: 18px;

    /* sticky bar offset for scrollIntoView (even if we later disable scroll) */
    --scroll-offset: 96px;
  }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{min-height:100%}
  html{
    font-size:16px;
    -webkit-text-size-adjust:100%;
    text-size-adjust:100%;
    background:
    radial-gradient(circle at top left, rgba(124,92,255,.35) 0%, transparent 45%),
    radial-gradient(circle at top right, rgba(0,229,255,.35) 0%, transparent 45%),
    radial-gradient(circle at bottom, rgba(0,58,76,.55) 0%, transparent 55%),
    linear-gradient(160deg,var(--bg-gradient-start),var(--bg-gradient-mid),var(--bg-gradient-end));
    background-repeat:no-repeat;
    background-attachment: fixed; /* ‚úÖ makes it feel smooth while scrolling */
  }

  body{
    font-family:var(--sans);
    background:transparent;
    color:var(--text-main);
    min-height:100vh;
    -webkit-font-smoothing:antialiased;
    animation:fadeBody .7s ease-out forwards;
    opacity:1;
    overflow-x:hidden;
  }
  @keyframes fadeBody{from{opacity:0}to{opacity:1}}
  a{color:inherit;text-decoration:none}

  .page-shell{
    width:100%;
    max-width:1160px;
    margin:0 auto;
    padding:32px 20px 64px;
    transform:none !important;
  }

  /* helpers */
  .hide-sm{}
  .mono{font-family:var(--mono);font-variant-numeric:tabular-nums;direction:ltr;unicode-bidi:plaintext}
  .muted{color:var(--text-muted);font-size:13px;line-height:1.45}
  .small{font-size:12px;color:var(--text-muted);line-height:1.45}
  .cell{min-width:0}
  .wrap{white-space:normal;overflow-wrap:anywhere}

  /* Top bar */
  .top-bar{
    position:sticky; top:14px; z-index:999;
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding:12px 18px;
    margin:0 auto 32px;
    width:100%;
    max-width:1160px;
    border-radius:999px;
    background:rgba(8,10,22,.55);
    backdrop-filter:blur(18px);
    -webkit-backdrop-filter:blur(18px);
    border:1px solid rgba(255,255,255,.14);
    box-shadow:0 20px 70px rgba(0,0,0,.6), inset 0 1px 0 rgba(255,255,255,.06);
  }
  .brand{display:flex;align-items:center;gap:10px;min-width:0}
  .brand-logo{
    width:44px;height:44px;border-radius:16px;object-fit:contain;
    box-shadow:0 12px 32px rgba(0,0,0,.8);
    flex:0 0 auto;
  }
  .brand-text{display:flex;flex-direction:column;gap:2px;min-width:0}
  .brand-title{
    font-weight:800;letter-spacing:.05em;font-size:18px;text-transform:uppercase;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }
  .brand-sub{
    font-size:11px;text-transform:uppercase;letter-spacing:.16em;color:var(--text-muted);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }

  .lang-switch{
    display:inline-flex;align-items:center;padding:4px;border-radius:999px;gap:2px;
    background:rgba(255,255,255,.06);
    backdrop-filter:blur(10px);
    border:1px solid rgba(255,255,255,.16);
    box-shadow:0 12px 36px rgba(0,0,0,.55);
    flex:0 0 auto;
  }
  .lang-btn{
    border:none;background:transparent;color:var(--text-muted);
    font-size:11px;padding:6px 9px;border-radius:999px;cursor:pointer;
    transition:background var(--transition-fast),color var(--transition-fast),transform var(--transition-fast);
    user-select:none;white-space:nowrap;
  }
  .lang-btn:hover{transform:translateY(-1px)}
  .lang-btn.active{background:rgba(0,229,255,.14);color:var(--accent-cyan)}

  body.lang-switching{animation:langFade .28s ease-out}
  @keyframes langFade{from{opacity:.5;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}

  /* Hero */
  .hero{text-align:center;max-width:980px;margin:0 auto 16px;animation:fadeUp .8s ease-out forwards}
  @keyframes fadeUp{from{opacity:0;transform:translateY(14px)}to{opacity:1;transform:translateY(0)}}
  .hero-kicker{font-size:13px;letter-spacing:.16em;text-transform:uppercase;color:var(--accent-cyan);margin-bottom:12px}
  .hero-title{font-size:clamp(36px,4.7vw,56px);line-height:1.05;font-weight:900;margin-bottom:12px;letter-spacing:-.02em}
  .hero-subtitle{max-width:760px;margin:0 auto 16px;font-size:15px;line-height:1.5;color:var(--text-muted)}
  .hero-actions{display:flex;justify-content:center;flex-wrap:wrap;gap:12px;margin-bottom:10px}

  .btn{
    border-radius:999px;border:none;
    padding:12px 22px;
    font-size:13px;font-weight:700;
    letter-spacing:.04em;text-transform:uppercase;
    cursor:pointer;
    display:inline-flex;align-items:center;justify-content:center;gap:8px;
    transition:transform var(--transition-fast),box-shadow var(--transition-fast),background var(--transition-fast),color var(--transition-fast),border-color var(--transition-fast);
    user-select:none;white-space:nowrap;max-width:100%;min-width:0;
  }
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .btn-primary{
    background:linear-gradient(135deg,var(--accent-cyan),#7df2ff);
    color:#020308;
    box-shadow:0 14px 40px rgba(0,229,255,.35);
  }
  .btn-primary:hover{transform:translateY(-1px);box-shadow:0 18px 60px rgba(0,229,255,.55)}
  .btn-secondary{
    background:linear-gradient(135deg,var(--accent-green),#b9ffcf);
    color:#020308;
    box-shadow:0 14px 40px rgba(0,230,118,.35);
  }
  .btn-secondary:hover{transform:translateY(-1px);box-shadow:0 18px 60px rgba(0,230,118,.6)}
  .btn-ghost{
    background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.16);
    color:var(--text-main);
    box-shadow:0 12px 34px rgba(0,0,0,.45);
  }
  .btn-ghost:hover{transform:translateY(-1px);border-color:rgba(0,229,255,.26)}
  .note-line{margin-top:10px;font-size:12px;color:var(--text-muted);line-height:1.45}

  /* =========================
     Tool grid (single source of truth)
     ========================= */
  .tool-grid-wrap{
    width:100%;
    max-width:1160px;
    margin:0 auto;
  }
  .tool-grid-title{
    text-align:center;
    margin:12px 0 6px;
    font-size:12px;letter-spacing:.16em;text-transform:uppercase;
    color:rgba(244,246,255,.72);
  }

  .tool-grid{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:var(--tool-grid-gap);
    margin-top:12px;
    align-items:stretch;
  }

  .tool-card{
    background:rgba(255,255,255,.05);
    border-radius:var(--radius-xl);
    border:1px solid rgba(255,255,255,.12);
    padding:22px 22px 18px;
    box-shadow:0 20px 55px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.05);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    transition:transform var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
    min-width:0;
    min-height:178px;
  }
    /* ALL tool cards ‚Äî subtle frame like Quick Scan (safe, no layout change) */


  .tool-card::before{
    content:"";
    position:absolute; inset:-2px;
    background:
      radial-gradient(520px 180px at 18% -5%, rgba(0,229,255,.18), transparent 60%),
      radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.18), transparent 60%);
    pointer-events:none;
    opacity:.95;
  }
/* Wallet Security DNA: keep badges aligned with other cards */
a.tool-card[data-tool="approvals"]{
  display:flex;
  flex-direction:column;
}

a.tool-card[data-tool="approvals"] .badge-row{
  margin-top:auto;
  margin-bottom:14px; 
}


  .tool-card > *{position:relative}
  .tool-card:hover{transform:translateY(-2px);border-color:rgba(0,229,255,.28);background:rgba(255,255,255,.06)}
  .tool-card.active{border-color:rgba(0,229,255,.42);background:rgba(0,229,255,.06)}

  .tool-head{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;margin-bottom:10px}
  .tool-name{font-size:17px;font-weight:900;letter-spacing:.01em;line-height:1.22}
  .tool-desc{font-size:14px;color:var(--text-muted);line-height:1.5}

  .badge-row{display:flex;flex-wrap:wrap;gap:8px;margin-top:14px}
  .badge{
    display:inline-flex;align-items:center;gap:8px;
    font-size:12px;padding:7px 11px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:var(--text-muted);
    white-space:nowrap;user-select:none;
  }
  .badge strong{color:rgba(244,246,255,.92);font-weight:800}
  .badge.beta{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08);color:rgba(244,246,255,.92)}

  /* Risk badges */
  .risk-badges{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .risk{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;font-size:12px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.88);
    user-select:none;
  }
  .risk .dot{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.25);box-shadow:0 0 0 3px rgba(255,255,255,.06);flex:0 0 auto}
  .risk.ok{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .risk.ok .dot{background:rgba(0,230,118,.95)}
  .risk.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .risk.warn .dot{background:rgba(255,193,7,.95)}
  .risk.bad{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}
  .risk.bad .dot{background:rgba(220,53,69,.95)}

  /* =========================
     Panels (same width as cubes)
     ========================= */
  .panel-shell{
    width:100%;
    max-width:1160px;
    margin:var(--tool-panel-gap) auto 0;
    padding:18px 18px;
    border-radius:var(--radius-xl);
    background:rgba(255,255,255,.04);
    backdrop-filter:blur(20px);
    border:1px solid rgba(255,255,255,.12);
    box-shadow:0 26px 70px rgba(0,0,0,.60), inset 0 1px 0 rgba(255,255,255,.05);
    scroll-margin-top: var(--scroll-offset);
  }
  .panel-shell.hidden{display:none}

  .panel-head{
    display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
    margin-bottom:12px;
  }
  .panel-kicker{
    font-size:12px;letter-spacing:.16em;text-transform:uppercase;
    color:var(--accent-purple);margin-bottom:8px;
  }
  .panel-title{
    font-size:clamp(22px,2.2vw,28px);
    font-weight:900;letter-spacing:-.01em;line-height:1.12;
  }
  .panel-sub{margin-top:8px;max-width:900px;color:var(--text-muted);font-size:14px;line-height:1.6}

  .panel-actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;align-items:center}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    font-size:12px;padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:var(--text-muted);
    white-space:nowrap;
  }

  .grid-2{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1fr);gap:12px;margin-top:14px}

  .card{
    background:var(--card-bg);
    border-radius:var(--radius-lg);
    border:1px solid var(--border-subtle);
    padding:14px;
    box-shadow:var(--shadow-soft);
    backdrop-filter:blur(18px);
    min-width:0;
  }
    /* TX Events: make event rows look like premium pills */
#panel-tx #tx-events .card .mono{
  display:block;
  padding:8px 10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
  margin-top:12px;

  white-space:normal;          /* allow wrap */
  overflow-wrap:anywhere;
  line-height:1.25;
}

/* Slightly dim the "raw" part so it doesn't dominate */
#panel-tx #tx-events .card .mono .muted{
  opacity:.85;
}

/* Mobile: keep pills readable */
@media (max-width:640px){
  #panel-tx #tx-events .card .mono{
    padding:9px 11px;
  }
}

  .card h3{font-size:14px;letter-spacing:.02em;margin-bottom:8px;color:var(--text-main)}

  .field{margin-top:10px}
  .label{font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:rgba(244,246,255,.75);margin-bottom:6px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

  input,textarea,select{
    width:100%;
    padding:10px 12px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(5,7,18,.9);
    color:var(--text-main);
    font-size:13px;
    outline:none;
  }
  textarea{border-radius:18px;min-height:96px;resize:vertical;padding:12px 12px}
  input:focus,textarea:focus,select:focus{border-color:var(--accent-cyan)}

  .toggle{
    display:flex;align-items:center;gap:10px;
    padding:10px 12px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04);
    border-radius:14px;
    user-select:none;
    width:100%;
  }
  .toggle input{width:auto;accent-color:var(--accent-cyan)}

  .status{
    margin-top:10px;
    padding:12px 14px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    color:var(--text-main);
    line-height:1.5;
    font-size:13px;
    display:none;
    overflow-wrap:anywhere;
  }
  .status.ok{display:block;background:rgba(0,230,118,.10);border-color:rgba(0,230,118,.35);color:#78ffbf}
  .status.warn{display:block;background:rgba(255,193,7,.10);border-color:rgba(255,193,7,.35);color:#ffd166}
  .status.bad{display:block;background:rgba(220,53,69,.10);border-color:rgba(220,53,69,.35);color:#ff7a8a}
  .status.info{display:block;background:rgba(0,229,255,.10);border-color:rgba(0,229,255,.30);color:#7df2ff}
/* =========================
   TX DECODER ‚Äî 4-line Security Summary (BADGES)  [FINAL ALIGN]
   ========================= */

#panel-tx .tx-sum{
  display:grid;
  grid-template-columns: 1fr;
  gap:10px;
  padding:12px;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.04);
  box-shadow:0 18px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
  backdrop-filter:blur(16px);
}

/* line layout: label | value-column (value-column is capped so it sits closer to label) */
#panel-tx .tx-sum-line{
  display:grid;
  grid-template-columns: 85px minmax(0, clamp(240px, 42vw, 480px)) !important;
  justify-content:start;   
  align-items:center;
  column-gap:10px;
  row-gap:6px;

  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  min-width:0;
}
#panel-tx .tx-sum .tx-sum-line:first-child .v{
  white-space:normal !important;
  overflow-wrap:anywhere;
  word-break:break-word;

  max-width:100%;
  overflow:hidden;          
  text-overflow:clip;      
  line-height:1.15;
}


#panel-tx .tx-sum-line .k{
  font-size:12px;
  letter-spacing:.10em;
  text-transform:uppercase;
  color:rgba(244,246,255,.72);
  white-space:nowrap;
}

/* ‚úÖ The badge: stays inside the capped column, aligned right, and never paints the whole row */
#panel-tx .tx-sum-line .v{
  justify-self:end;        
  max-width:100%;
  min-width:0;
  box-sizing:border-box;

  display:inline-flex;
  align-items:center;
  gap:8px;

  font-size:12px;
  font-weight:800;
  letter-spacing:.02em;

  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  color:rgba(244,246,255,.92);

  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* Dot inside badge */
#panel-tx .tx-sum-line .v .dot{
  width:10px;
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,.25);
  box-shadow:0 0 0 3px rgba(255,255,255,.06);
  flex:0 0 auto;
}

/* States (ONLY the badge is colored) */
#panel-tx .tx-sum-line .v.ok{
  border-color:rgba(0,230,118,.28);
  background:rgba(0,230,118,.10);
}
#panel-tx .tx-sum-line .v.ok .dot{ background:rgba(0,230,118,.95); }

#panel-tx .tx-sum-line .v.warn{
  border-color:rgba(255,193,7,.30);
  background:rgba(255,193,7,.10);
}
#panel-tx .tx-sum-line .v.warn .dot{ background:rgba(255,193,7,.95); }

#panel-tx .tx-sum-line .v.bad{
  border-color:rgba(220,53,69,.30);
  background:rgba(220,53,69,.12);
}
#panel-tx .tx-sum-line .v.bad .dot{ background:rgba(220,53,69,.95); }

#panel-tx .tx-sum-line .v.unk{
  border-color:rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  color:rgba(244,246,255,.78);
}
#panel-tx .tx-sum-line .v.unk .dot{ background:rgba(255,255,255,.25); }

/* Subline under the badge (aligned with badge column) */
#panel-tx .tx-sum-line .tx-sum-sub{
  grid-column:2;
  justify-self:end;
  max-width:100%;
  min-width:0;

  margin-top:2px;
  text-align:right;

  font-size:12px;
  line-height:1.25;
  color:rgba(244,246,255,.62);

  white-space:normal;
  overflow-wrap:anywhere;
  word-break:break-word;
}

/* Action: keep LTR so it truncates nicely (no weird left-cut) */
#tx-sum-action .v{
  direction:ltr;
  unicode-bidi:plaintext;
}

/* Mobile */
@media (max-width:640px){
  #panel-tx .tx-sum-line{
    grid-template-columns: 1fr;
    justify-content:stretch;
    row-gap:8px;
    align-items:start;
  }
  #panel-tx .tx-sum-line .v{
    justify-self:start !important;
    max-width:100%;
  }
  #panel-tx .tx-sum-line .tx-sum-sub{
    grid-column:1;
    justify-self:start;
    text-align:left;
  }
}


    /* Bookmarklet tip under the green status */
.bm-tip{
  margin-top:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  color:rgba(244,246,255,.78);
  font-size:13px;
  line-height:1.45;
}
    /* Drag-to-bookmarks bookmarklet link */
.bm-drag{
  display:flex;
  align-items:center;
  gap:10px;
  padding:12px 14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.05);
  box-shadow:0 14px 40px rgba(0,0,0,.35);
  cursor:grab;
  user-select:none;
  margin-top:10px;
  font-weight:900;
  letter-spacing:.04em;
  text-transform:none;
  width:100%;
}
    /* icon inside the drag-to-bookmarks button */
.bm-drag-icon{
  width:28px;
  height:28px;
  border-radius:10px;
  object-fit:contain;
  flex:0 0 auto;
  box-shadow:0 10px 26px rgba(0,0,0,.35);
}

/* keep the label clean */
.bm-drag span{
  line-height:1;
  min-width:0;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* make sure link doesn't look like a normal link */
#bm-drag{
  text-decoration:none;
  color:inherit;
}

/* optional: nicer hover */
#bm-drag:hover{
  border-color:rgba(0,229,255,.22);
  background:rgba(255,255,255,.07);
  transform:translateY(-1px);
}

.bm-drag:active{ cursor:grabbing; }
.bm-drag.hidden{ display:none; }

  /* =========================
     TABLES ‚Äî merged in from the "old code" that fixed spacing/readability
     What you asked to carry over:
     ‚úÖ proper cell ellipsis
     ‚úÖ RPC table special grid + 2-line clamp (URL + status)
     ‚úÖ numeric/icon columns centered
     ‚úÖ highlight row style
     ========================= */

  /* generic table shell (keep your look) */
  .table{
    margin-top:10px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    overflow: hidden;                 /* from old code (clean corners) */
    background:rgba(255,255,255,.03);
  }
    /* =========================
   QuickScan ‚Äî Liquidity table (FORCE wrap + compact rows)
   Target: table rendered inside #qs-liq-tablewrap
   ========================= */

#qs-liq-tablewrap .table .trow.head,
#qs-liq-tablewrap .table .trow{
  /* give RESULT more room */
  grid-template-columns: 1.15fr .75fr .75fr 2.6fr;
  gap: 10px;
}

/* reduce row height a bit */
#qs-liq-tablewrap .table .trow{
  padding: 8px 10px;
}

/* ‚úÖ IMPORTANT: override your global "nowrap + ellipsis" for RESULT column only */
#qs-liq-tablewrap .table .trow .cell:nth-child(4){
  white-space: normal !important;
  overflow: hidden !important;
  text-overflow: clip !important;
  overflow-wrap: anywhere !important;
  line-height: 1.15;
  font-size: 12px;

  /* optional: clamp to 3 lines so it doesn't get tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
}

/* if result uses .sig (your pill), it forces nowrap ‚Äî cancel it here */
#qs-liq-tablewrap .table .trow .cell:nth-child(4) .sig{
  white-space: normal !important;
  display: block !important;   /* lets it wrap nicely */
}

/* if result uses .mono inside, cancel nowrap too */
#qs-liq-tablewrap .table .trow .cell:nth-child(4) .mono{
  white-space: normal !important;
}

/* on medium screens, your global .trow min-width can break layout ‚Äî disable for this table */
@media (max-width:980px){
  #qs-liq-tablewrap .table .trow{ min-width: 0 !important; }
}


/* keep head centered, rows top-aligned like your earlier fix */
#qsLiqTable .trow{ align-items: start; }
#qsLiqTable .trow.head{ align-items: center; }

/* result column: allow wrap + compact typography so it stays inside */
#qsLiqTable .trow .cell:nth-child(4),
#qs-liq-tablewrap .table .trow .cell:nth-child(4){
  white-space: normal;
  overflow: hidden;
  text-overflow: clip;
  overflow-wrap: anywhere;
  line-height: 1.18;
  font-size: 12px;
  font-family: var(--mono);
  font-variant-numeric: tabular-nums;

  /* keep it from becoming too tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4;
}

/* Pair/Pool column stays mono + tidy */
#qsLiqTable .trow .cell:nth-child(1){
  font-family: var(--mono);
}

/* on medium screens your global .trow gets min-width:560px (causes weird layout)
   cancel it only for this table */
@media (max-width:980px){
  #qsLiqTable .trow{ min-width: 0 !important; }
}

    /* ===== DNA approvals table: stronger frame + clearer row separation ===== */
#ap-table.table{
  border-color: rgba(242,211,138,.30) !important;            /* gold-ish like DNA */
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08),         /* inner frame */
              0 18px 40px rgba(0,0,0,.25) !important;        /* soft lift */
}

#ap-table .trow{
  border-top: 1px solid rgba(255,255,255,.14) !important;    /* clearer separators */
}

#ap-table .trow.head{
  background: rgba(255,255,255,.06) !important;              /* stronger header bar */
  border-bottom: 1px solid rgba(255,255,255,.14) !important; /* makes it feel ‚Äúone table‚Äù */
}


  /* generic rows */
  .trow{
    display:grid;
    grid-template-columns:1.3fr 1.1fr .9fr .9fr;
    gap:10px;
    padding:10px 12px;
    border-top:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
    align-items:center;
    font-size:13px;
  }
  .trow.head{
    border-top:none;
    background:rgba(255,255,255,.05);
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:rgba(244,246,255,.75);
  }

  /* generic cells (from old code) */
  .trow .cell{
    min-width:0;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  /* optional wrapping cell */
  .trow .cell.wrap{
    white-space:normal;
    text-overflow:clip;
    overflow:hidden;
    overflow-wrap:anywhere;
  }
    /* =========================
   Wallet Security DNA ‚Äî Approvals table (A)
   Flags go to a second full-width row
   ========================= */

/* Desktop: 7 columns (Token, Spender, Allowance, Verified, Last Updated, Risk, Action) */
#ap-table .trow.head,
#ap-table .trow.ap-main{
  grid-template-columns: 1.15fr 1.15fr 1.35fr .95fr 1.25fr .75fr .75fr;
}

/* Mobile/Tablet: hide-sm disappears => 4 columns (Token, Allowance, Risk, Action) */
@media (max-width: 980px){
  #ap-table .trow.head,
  #ap-table .trow.ap-main{
    grid-template-columns: 1.25fr 1.35fr .75fr .75fr;
  }
}

/* Flags row: single column full-width, nice wrapping */
#ap-table .trow.ap-flags-row{
  grid-template-columns: 1fr;
  padding-top: 8px;
  padding-bottom: 12px;
  background: rgba(255,255,255,.02);
}

#ap-table .ap-flags-cell{
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.25;
  font-size: 12px;
  color: rgba(244,246,255,.78);
}


    /* =========================
   Contract Monitor (mon-table) ‚Äî add inline X button column
   No "Remove" header text, just an empty last cell like screenshot
   ========================= */

/* Desktop / default: 5th column reserved for X */
#mon-table .trow,
#mon-table .trow.head{
  grid-template-columns: 1.35fr 1fr 1.05fr 1fr 44px;
}
    /* ‚úÖ MON: Last seen should wrap to 2 lines (no ellipsis) */
#mon-table .trow .cell:nth-child(3){
  white-space: normal;
  text-overflow: clip;
  overflow: hidden;
  overflow-wrap: anywhere;
  line-height: 1.15;

  /* optional: limit to 2 lines so row doesn't get too tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}


#mon-table .trow.head .cell:last-child{
  visibility:hidden;  /* stays in layout, but truly invisible */
}
    
/* Small clean X (no weird circle) */
.mon-remove{
  width:22px;
  height:22px;
  padding:0;
  margin:0;

  border:none;
  background:transparent;
  box-shadow:none;

  color:rgba(244,246,255,.70);
  cursor:pointer;
  user-select:none;

  line-height:1;
  font-size:18px;
  font-weight:900;

  display:inline-flex;
  align-items:center;
  justify-content:center;

  transition:transform var(--transition-fast), color var(--transition-fast), opacity var(--transition-fast);
  opacity:.9;
}

.mon-remove:hover{
  opacity:1;
  color:rgba(255,120,138,.95);  /* red-ish but subtle */
  transform:translateY(-1px);
}

.mon-remove:active{
  transform:translateY(0);
}


.mon-remove:focus-visible{
  outline:2px solid rgba(0,229,255,.55);
  outline-offset:2px;
}
/* =========================
   RPC Results ‚Äî Card rows (B)
   No horizontal scroll. Domain on top, metrics in one compact line.
   ========================= */

#rpc-table{
  overflow-x:hidden;   /* ‚úÖ no swipe */
  overflow-y:hidden;
}

/* header */
#rpc-table .trow.head.rpc{
  display:grid;
  grid-template-columns: 1fr 240px 120px; /* RPC | Metrics | Status */
  gap:12px;
  align-items:center;
}

/* each result row becomes a 2-line "card" */
#rpc-table .trow.rpc{
  display:grid;
  grid-template-columns: 1fr auto; /* top row: RPC left, status right */
  grid-template-rows: auto auto;   /* row 1: rpc+status | row 2: meta */
  gap:10px 12px;
  align-items:center;

  padding:12px 12px;
  border-top:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
}

/* RPC cell (top-left) */
#rpc-table .rpc-url{
  grid-column:1;
  grid-row:1;
  min-width:0;
}

#rpc-table .rpc-url .rpc-host{
  font-weight:900;
  letter-spacing:.01em;
  color:rgba(244,246,255,.92);
  line-height:1.15;
}

#rpc-table .rpc-url .rpc-full{
  margin-top:6px;
  color:rgba(244,246,255,.62);
  line-height:1.15;

  /* allow up to 3 lines */
  display:-webkit-box;
  -webkit-box-orient:vertical;
  -webkit-line-clamp:3;
  overflow:hidden;
  overflow-wrap:anywhere;

  direction:ltr;
  unicode-bidi:plaintext;
}

/* STATUS (top-right) */
#rpc-table .rpc-status{
  grid-column:2;
  grid-row:1;
  justify-self:end;
  white-space:nowrap;
}

/* META line (bottom full width) */
#rpc-table .rpc-meta{
  grid-column:1 / -1;
  grid-row:2;

  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:center;

  color:rgba(244,246,255,.85);
  font-size:12px;
}

/* compact metric pills */
#rpc-table .m{
  display:inline-flex;
  align-items:center;
  gap:8px;

  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);

  white-space:nowrap;
}

#rpc-table .m b{
  font-weight:900;
  color:rgba(244,246,255,.92);
}



/* Responsive: tighter header */
@media (max-width:980px){
  #rpc-table .trow.head.rpc{
    grid-template-columns: 1fr 140px; /* RPC | Status */
  }
  #rpc-table .trow.head.rpc .cell:nth-child(2){ display:none; } /* hide "Metrics" header label */
}

/* Small screens: status under host if needed */
@media (max-width:640px){
  #rpc-table .trow.rpc{
    grid-template-columns: 1fr; /* stack */
  }
  #rpc-table .rpc-status{
    grid-column:1;
    justify-self:start;
  }
}
  /* keep highlight style */
  .trow.highlight{
    background:rgba(0,230,118,.10);
    border-top-color:rgba(0,230,118,.20);
  }

  /* chips */
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.88);
    cursor:pointer;user-select:none;
    transition:transform var(--transition-fast), border-color var(--transition-fast);
    font-size:12px;
  }
  .chip:hover{transform:translateY(-1px);border-color:rgba(0,229,255,.26)}
  .chip-danger{border-color:rgba(255,80,80,.25);background:rgba(255,80,80,.08)}
  .chip-danger:hover{border-color:rgba(255,80,80,.45);transform:translateY(-1px)}
  .share-row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}

  /* QuickScan actions */
  #panel-quick .row.qs-actions,
  #panel-quick .qs-share{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:10px;
    align-items:stretch;
  }
  #panel-quick .qs-share{margin-top:12px}
  #panel-quick .qs-actions .btn,
  #panel-quick .qs-share .btn{
    width:100%;
    min-width:0;
    padding:12px 14px;
    font-size:12px;
    letter-spacing:.03em;
    white-space:normal;
    line-height:1.15;
    min-height:44px;
    overflow:hidden;text-overflow:ellipsis;
  }
  #panel-quick .qs-actions #qs-run{grid-column:1/-1}
  #panel-quick .qs-actions #qs-copy-md{grid-column:1/-1}
  #panel-quick .qs-share #qs-copy-xtext{grid-column:1/-1}

  @media (min-width:1280px){
    #panel-quick .row.qs-actions{grid-template-columns:repeat(4,minmax(0,1fr))}
    #panel-quick .qs-actions #qs-run,
    #panel-quick .qs-actions #qs-copy-md{grid-column:auto}
    #panel-quick .qs-share{grid-template-columns:repeat(3,minmax(0,1fr))}
    #panel-quick .qs-share #qs-copy-xtext{grid-column:auto}
  }
   
  /* QuickScan risk table */
  #qs-riskTable{margin-top:12px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}
  #qs-riskTable .trow.head.risk,
  #qs-riskTable .trow.risk{
    display:grid;
    grid-template-columns:.95fr .95fr .95fr .95fr .95fr .95fr .85fr 1.5fr;
    gap:10px;padding:10px 12px;align-items:center;min-width:980px;
  }
  #qs-riskTable .trow.head.risk{
    background:rgba(255,255,255,.05);
    font-size:12px;letter-spacing:.08em;text-transform:uppercase;
    color:rgba(244,246,255,.75);
    border-top:none;
  }
  #qs-riskTable .trow.risk{background:rgba(255,255,255,.03);border-top:1px solid rgba(255,255,255,.10)}
  #qs-riskTable .cell{min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  #qs-riskTable .cell:not(:last-child){text-align:center;justify-self:center}
  #qs-riskTable .cell:last-child{
    text-align:left;white-space:normal;overflow-wrap:anywhere;line-height:1.15;
    display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3;
  }

  /* signals (QuickScan top row UI) */
  .sig{
    display:inline-flex;align-items:center;justify-content:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.92);
    font-size:12px;white-space:nowrap;
  }
  .sig .dot{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.25);box-shadow:0 0 0 3px rgba(255,255,255,.06)}
  .sig.ok{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .sig.ok .dot{background:rgba(0,230,118,.95)}
  .sig.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .sig.warn .dot{background:rgba(255,193,7,.95)}
  .sig.bad{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}
  .sig.bad .dot{background:rgba(220,53,69,.95)}
  .sig.unk{border-color:rgba(255,255,255,.10);background:rgba(255,255,255,.04);color:rgba(244,246,255,.75)}
  .sig.unk .dot{background:rgba(255,255,255,.25)}

  .qs-scoreRow{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:10px}
  .score-pill{
    display:inline-flex;align-items:center;gap:10px;
    padding:8px 12px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    font-size:12px;color:rgba(244,246,255,.92);
  }
  .score-pill strong{font-weight:900;letter-spacing:.02em}
  .score-pill.low{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .score-pill.med{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .score-pill.high{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}

  .flags-box{
    margin-top:10px;padding:12px 14px;border-radius:16px;
    border:1px solid rgba(255,193,7,.25);
    background:rgba(255,193,7,.08);
    color:#ffd166;font-size:13px;line-height:1.45;display:none;
  }
  .flags-box ul{margin-top:8px;padding-left:18px}
  .flags-box li{margin:4px 0}
  .qs-disclaimer{margin-top:10px;font-size:12px;color:var(--text-muted);line-height:1.45}

  /* Bookmarklet help */
  .h3-row{display:flex;align-items:center;gap:10px}
  .h3-row img{width:22px;height:22px;border-radius:8px;box-shadow:0 10px 24px rgba(0,0,0,.6)}
  .help-box{
    margin-top:10px;padding:12px 14px;border-radius:16px;
    border:1px solid rgba(0,229,255,.20);
    background:rgba(0,229,255,.08);
    color:#7df2ff;font-size:13px;line-height:1.45;display:none;
  }
  .help-box ol{margin-top:8px;padding-left:18px}
  .help-box li{margin:4px 0}

  /* Footer */
  .footer{
    border-top:1px solid rgba(255,255,255,.06);
    margin-top:20px;padding-top:16px;
    display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:10px;
    font-size:12px;color:var(--text-muted);
  }
  .footer-tagline{color:var(--accent-cyan);font-weight:700}

  /* RTL */
  html[dir="rtl"] body{direction:rtl}
  html[dir="rtl"] .top-bar{flex-direction:row-reverse}
  html[dir="rtl"] .brand{flex-direction:row-reverse}
  html[dir="rtl"] .panel-head{flex-direction:row-reverse}
  html[dir="rtl"] .row{flex-direction:row-reverse}
  html[dir="rtl"] .panel-actions{justify-content:flex-start}

  /* ‚úÖ responsive */
  @media (max-width:980px){
    .grid-2{grid-template-columns:1fr}
    .hide-sm{display:none!important}

    .tool-grid{grid-template-columns:repeat(2, minmax(0, 1fr))}

    /* generic table swipe width on medium screens */
    #qs-riskTable .trow{ min-width:560px; }

    #mon-table .trow,
#mon-table .trow.head{
  grid-template-columns:1.7fr 1fr 1fr 44px; /* contract | net | status | X */
  min-width:520px;
}

  }

  @media (max-width:640px){
    .top-bar{top:10px;padding:10px 12px}
    .brand-logo{width:40px;height:40px;border-radius:14px}
    .btn{padding:12px 18px;font-size:13px}

    .tool-grid{grid-template-columns:1fr; gap:14px}
  }
    /* ===== CycleX ‚Äî Wallet Security DNA (SAFE PATCH) ===== */

/* DNA cube: subtle gold frame + glow */
a.tool-card[data-tool="approvals"]{
  border-color: rgba(242,211,138,.42) !important;
  background: linear-gradient(165deg, rgba(242,211,138,.06), rgba(255,255,255,.04)) !important;
  box-shadow:
    0 20px 55px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 0 2px rgba(242,211,138,.22),
    0 0 28px rgba(242,211,138,.20) !important;
}
/* Wallet DNA cube ‚Äî make subtitle a bit more prominent (ONLY this cube) */
a.tool-card[data-tool="approvals"] .tool-desc{
  font-size: 15px !important;
  font-weight: 700 !important;
  color: rgba(244,246,255,.86) !important;
  letter-spacing: .01em !important;
  text-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
  margin-top: 2px !important;
}
    /* ===== DNA table: Verified / Unverified colors (ONLY in approvals table) ===== */
#ap-table .chip.chip-ok{
  border-color: rgba(0,230,118,.32) !important;
  background: rgba(0,230,118,.12) !important;
  color: #a8ffd5 !important;
}

/* In DNA you currently output Unverified as chip-warn ‚Üí make it RED only here */
#ap-table .chip.chip-warn{
  border-color: rgba(220,53,69,.34) !important;
  background: rgba(220,53,69,.14) !important;
  color: #ffb3bd !important;
}



/* Optional: tiny spacing so it breathes under the title */
.tool-card[data-tool="approvals"] .tool-desc{
  margin-top: 2px !important;
}

a.tool-card[data-tool="approvals"]::before{
  background:
    radial-gradient(520px 180px at 18% -5%, rgba(242,211,138,.16), transparent 62%),
    radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.14), transparent 62%) !important;
}
    /* DNA cube ‚Äî top light hit (premium highlight) */
a.tool-card[data-tool="approvals"]{
  position: relative; /* safe, for ::after */
}

a.tool-card[data-tool="approvals"]::after{
  content:"";
  position:absolute;
  left:10px;
  right:10px;
  top:10px;
  height:46px;
  border-radius:18px;
  pointer-events:none;

  /* subtle "light hit" only on top */
  background: linear-gradient(
    180deg,
    rgba(255,255,255,.14),
    rgba(242,211,138,.10) 45%,
    rgba(255,255,255,0) 100%
  );

  /* keeps it premium, not loud */
  opacity:.75;
  mix-blend-mode: screen;
}



/* DNA panel: subtle gold outline */
#panel-approvals.panel-shell,
#panel-approvals{
  border-color: rgba(242,211,138,.30) !important;
  box-shadow:
    0 26px 70px rgba(0,0,0,.60),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 0 1px rgba(242,211,138,.16),
    0 0 34px rgba(242,211,138,.14) !important;
}

/* Score/Risk pills (hooks) */
#dna-score,
#dna-risk{
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  padding: 7px 11px !important;
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.05) !important;
  color: rgba(244,246,255,.92) !important;
  font-size: 12px !important;
  font-weight: 800 !important;
  letter-spacing: .02em !important;
  white-space: nowrap !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05) !important;
}


/* Color states (only if classes exist) */
#dna-score.score-low,  #dna-score.score-ok,
#dna-risk.risk-low,    #dna-risk.risk-ok{
  border-color: rgba(0,230,118,.28) !important;
  background: rgba(0,230,118,.10) !important;
  color: #a8ffd5 !important;
}

#dna-score.score-med,  #dna-score.score-warn,
#dna-risk.risk-med,    #dna-risk.risk-warn{
  border-color: rgba(255,193,7,.30) !important;
  background: rgba(255,193,7,.10) !important;
  color: #ffe29a !important;
}

#dna-score.score-high, #dna-score.score-bad,
#dna-risk.risk-high,   #dna-risk.risk-bad{
  border-color: rgba(220,53,69,.30) !important;
  background: rgba(220,53,69,.12) !important;
  color: #ffb3bd !important;
}

#dna-score.score-unk,
#dna-risk.risk-unk{
  opacity: .88 !important;
}

/* DNA approvals table: card rows */
#ap-table .trow{
  display: grid !important;
  grid-template-columns: 1fr auto !important;
  grid-template-rows: auto auto !important;
  gap: 10px 12px !important;
  align-items: center !important;
  padding: 12px 12px !important;
  min-width: 0 !important;
}

#ap-table .trow.head{
  display: grid !important;
  grid-template-columns: 1fr auto !important;
  padding: 10px 12px !important;
  min-width: 0 !important;
}

#ap-table .ap-main{ grid-column: 1; grid-row: 1; min-width: 0; }
#ap-table .ap-actions{
  grid-column: 2; grid-row: 1;
  justify-self: end;
  display: flex;
  gap: 10px;
  align-items: center;
  white-space: nowrap;
}
#ap-table .ap-meta{
  grid-column: 1 / -1; grid-row: 2;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  color: rgba(244,246,255,.78);
  font-size: 12px;
}

#ap-table .ap-sub{
  margin-top: 6px;
  color: rgba(244,246,255,.62);
  line-height: 1.15;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}
#ap-table .ap-sub .m{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  white-space: nowrap;
}


/* ===== DNA: lock Score/Risk position (no wrap jump) ===== */
#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child{
  flex-wrap: nowrap !important;
  align-items: flex-start !important;
}

#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row{
  margin-left: auto !important;
  flex-wrap: nowrap !important;
  justify-content: flex-end !important;
  align-items: center !important;
}

#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row .pill{
  flex: 0 0 auto !important;
}
    /* Mobile fix: long connected address shouldn't shift layout */
#dna-address,
#dna-wallet,
#dna-status .mono{
  max-width:100%;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
     /* =========================
   DNA ‚Äì small, controlled tweaks
   ========================= */

/* Tips: same size, just bold */
#panel-approvals #dna-tips li{
  font-weight: 700;
}

/* Locked card: slightly clearer + bolder, tiny size bump */
#panel-approvals #dna-approvals-locked .small{
  font-weight: 650;
  line-height: 1.55;
  font-size: 14.5px; /* ◊û◊û◊© ◊ò◊ô◊§◊î */
}

/* spacing between lines in the locked card */
#panel-approvals #dna-approvals-locked .small + .small{
  margin-top: 8px;
}

/* Eligibility message line */
#panel-approvals #dna-elig-msg{
  margin-top: 10px;
  font-weight: 800;
  font-size: 14.5px;
}

/* Red / Green states */
#panel-approvals #dna-elig-msg.elig-ok{ color: var(--green) !important; }
#panel-approvals #dna-elig-msg.elig-bad{ color: #ff6a6a !important; }
#panel-approvals #dna-elig-msg.elig-warn{ color: #ffd36a !important; }
.hidden{ display:none !important; }

/* =========================================================
   CycleX ‚Äî THEME OVERRIDES (colors/background/buttons only)
   Paste at the VERY END of your existing <style>
   (No layout changes)
   ========================================================= */

:root{
  /* Reference palette */
  --bg0:#05060a;
  --bg1:#0b0a18;
  --bg2:#021b24;

  --text:#f4f6ff;
  --muted:rgba(244,246,255,.74);
  --dim:rgba(244,246,255,.56);

  --c:#00e5ff;
  --g:#5dffb2;
  --p:#7c5cff;

  --hair:rgba(255,255,255,.10);
  --hair2:rgba(255,255,255,.14);
  --glass:rgba(255,255,255,.030);
  --glass2:rgba(255,255,255,.050);

  --sh1:0 18px 60px rgba(0,0,0,.50);
  --sh2:0 36px 120px rgba(0,0,0,.72);

  --ease:cubic-bezier(.2,.8,.2,1);

  /* Map to your existing vars (so nothing breaks) */
  --bg-main: var(--bg0);
  --bg-gradient-start: var(--bg0);
  --bg-gradient-mid: var(--bg1);
  --bg-gradient-end: var(--bg2);

  --text-main: var(--text);
  --text-muted: var(--muted);

  --accent-cyan: var(--c);
  --accent-green: var(--g);
  --accent-purple: var(--p);

  --card-bg: rgba(255,255,255,.06);
  --border-subtle: rgba(255,255,255,.12);

  /* Keep your radiuses */
  /* --radius-xl / --radius-lg stay as-is */

  /* Make transitions match ref feel */
  --transition-fast: .18s var(--ease);
}

/* ===== Background: match reference (smooth, premium, no ‚Äúpixel‚Äù vibe) ===== */
html{
  background:
    radial-gradient(1200px 720px at 14% 10%, rgba(124,92,255,.18), transparent 58%),
    radial-gradient(1200px 720px at 86% 12%, rgba(0,229,255,.16), transparent 56%),
    radial-gradient(980px 680px at 55% 120%, rgba(0,58,76,.40), transparent 62%),
    linear-gradient(160deg, var(--bg0), var(--bg1), var(--bg2));
  background-repeat:no-repeat;
  background-attachment:fixed;
}

body{
  background: transparent;
  color: var(--text);
}

/* Film-grain + soft orbs overlay (reference style) */
body::before{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background:
    radial-gradient(740px 640px at 20% 14%, rgba(0,229,255,.12), transparent 60%),
    radial-gradient(940px 780px at 78% 18%, rgba(124,92,255,.11), transparent 62%),
    radial-gradient(820px 700px at 52% 78%, rgba(93,255,178,.07), transparent 64%),
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
  background-size:auto, auto, auto, 260px 260px;
  background-repeat:no-repeat, no-repeat, no-repeat, repeat;
  opacity:.10;
  transform: translate3d(0,0,0) scale(1.12);
  transform-origin:center;
  mix-blend-mode: overlay;
  filter: blur(.25px);
}

body::after{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background: radial-gradient(circle at 50% 18%, transparent 0%, rgba(0,0,0,.18) 55%, rgba(0,0,0,.60) 100%);
  opacity:.82;
  transform: scale(1.12);
  transform-origin:center;
}

/* ===== Top bar: same colors + subtle gradient frame ===== */
.top-bar{
  background: rgba(10,12,22,.50) !important;
  border-color: rgba(255,255,255,.14) !important;
  backdrop-filter: blur(18px) saturate(1.12) !important;
  -webkit-backdrop-filter: blur(18px) saturate(1.12) !important;
  box-shadow: 0 14px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06) !important;
  overflow:hidden; /* enables the frame */
  position: sticky; /* keep your behavior */
}

.top-bar::before{
  content:"";
  position:absolute; inset:0;
  border-radius:999px;
  padding:1px;
  background: linear-gradient(120deg, rgba(0,229,255,.22), rgba(124,92,255,.16), rgba(255,255,255,.10));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
          mask-composite: exclude;
  pointer-events:none;
  opacity:.55;
}

/* ===== Language switch colors ===== */
.lang-switch{
  background: rgba(255,255,255,.045) !important;
  border-color: rgba(255,255,255,.12) !important;
}
.lang-btn.active{
  background: rgba(0,229,255,.14) !important;
  color: rgba(0,229,255,.95) !important;
}

/* ===== Buttons: match reference feel (without changing sizing/layout) ===== */
.btn{
  border: 1px solid transparent;
  transition: transform .32s var(--ease), box-shadow .32s var(--ease),
              background .32s var(--ease), border-color .32s var(--ease),
              filter .32s var(--ease);
}

/* Primary = Cyan gradient + sheen */
.btn-primary{
  background: linear-gradient(135deg, rgba(0,229,255,1), rgba(125,242,255,1)) !important;
  color:#03040a !important;
  border-color: rgba(0,229,255,.18) !important;
  box-shadow: 0 22px 90px rgba(0,229,255,.38) !important;
  position: relative;
  isolation: isolate;
}
.btn-primary::after{
  content:"";
  position:absolute; inset:0;
  border-radius:999px;
  background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,.58) 18%, transparent 36%, transparent 100%);
  transform: translateX(-120%);
  opacity:.65;
  z-index:-1;
  transition: transform .65s var(--ease);
  filter: blur(.2px);
}
.btn-primary:hover{
  transform: translateY(-2px) !important;
  box-shadow: 0 30px 130px rgba(0,229,255,.48) !important;
  filter: saturate(1.05);
}
.btn-primary:hover::after{ transform: translateX(120%); }

/* Secondary = keep green but align to reference vibe */
.btn-secondary{
  background: linear-gradient(135deg, rgba(93,255,178,1), rgba(185,255,207,1)) !important;
  color:#03040a !important;
  border-color: rgba(93,255,178,.18) !important;
  box-shadow: 0 18px 80px rgba(93,255,178,.26) !important;
}
.btn-secondary:hover{
  transform: translateY(-2px) !important;
  box-shadow: 0 26px 110px rgba(93,255,178,.38) !important;
}

/* Ghost = glass (reference) */
.btn-ghost{
  background: rgba(255,255,255,.030) !important;
  color: var(--text) !important;
  border-color: rgba(255,255,255,.16) !important;
  backdrop-filter: blur(14px) !important;
  box-shadow: 0 16px 55px rgba(0,0,0,.34) !important;
}
.btn-ghost:hover{
  transform: translateY(-2px) !important;
  border-color: rgba(0,229,255,.24) !important;
  box-shadow: 0 24px 90px rgba(0,0,0,.56) !important;
}

/* Small text colors to match reference */
.muted, .small{ color: var(--muted) !important; }

     
</style>
   
   
</head>
<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX" data-i18n-title="title_back_to_cyclex">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector" data-i18n-aria-label="aria_lang_selector">
        <button class="lang-btn active" data-lang="en">üá∫üá∏ EN</button>
        <button class="lang-btn" data-lang="zh">üá®üá≥ ‰∏≠Êñá</button>
        <button class="lang-btn" data-lang="ar">üá∏üá¶ ÿπÿ±ÿ®Ÿä</button>
        <button class="lang-btn" data-lang="ru">üá∑üá∫ RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Tools</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          A lightweight, client-side toolkit for safer swaps, approvals hygiene, liquidity checks, RPC health, and transaction decoding across BSC + Ethereum.
        </p>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-quick" data-i18n="btn_quick">Run Quick Scan</button>
        </div>

        <div class="note-line" data-i18n="hero_note">
          Note: These checks are informational and do not guarantee safety. Always verify independently.
        </div>
      </section>

      <section class="tool-grid-wrap">
        <div class="tool-grid-title" data-i18n="tools_kicker">CHOOSE A TOOL</div>

        <div class="tool-grid" id="toolGrid">
          <a class="tool-card active" data-tool="quick" href="#panel-quick">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_quick_title">Quick Scan</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_quick_desc">Fast token sanity-check + shareable report + cache.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_fast">Fast</strong></div>
              <div class="badge"><strong data-i18n="badge_share">Share</strong></div>
              <div class="badge"><strong data-i18n="badge_cache">Cache</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="approvals" href="#panel-approvals">
  <div class="tool-head">
    <div class="tool-name" data-i18n="cube_walletdna_title">Wallet Security DNA</div>
    <div class="badge"><strong data-i18n="badge_wallet">Wallet</strong></div>
  </div>

  <div class="tool-desc" data-i18n="cube_walletdna_desc">
    Approval &amp; Permission Risk Snapshot
  </div>

  <div class="badge-row">
    <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
    <div class="badge"><strong data-i18n="badge_safe">Safe</strong></div>
  </div>
</a>

          <a class="tool-card" data-tool="liq" href="#panel-liq">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_liq_title">Token + Liquidity Scan</div>
              <div class="badge"><strong>V2</strong> + <strong>V3</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_liq_desc">DEX Registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_dex">DEX</strong></div>
              <div class="badge"><strong>USDT</strong></div>
              <div class="badge"><strong data-i18n="badge_pairs">Pairs</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="rpc" href="#panel-rpc">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
              <div class="badge"><strong>‚úÖ</strong> <span data-i18n="badge_table">Table</span></div>
            </div>
            <div class="tool-desc" data-i18n="cube_rpc_desc">Latency + chainId + block + eth_call + read logs + dev custom test.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_copy">Copy</strong></div>
              <div class="badge"><strong data-i18n="badge_dev">Dev</strong></div>
              <div class="badge"><strong>X</strong> <span data-i18n="badge_share">Share</span></div>
            </div>
          </a>

          <a class="tool-card" data-tool="tx" href="#panel-tx">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_tx_title">Tx Decoder</div>
              <div class="badge"><strong data-i18n="badge_decode">Decode</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_tx_desc">Decode inputs + common events (Transfer/Approval) from a tx hash.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_receipt">Receipt</strong></div>
              <div class="badge"><strong data-i18n="badge_events">Events</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="dev" href="#panel-dev">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_dev_title">Dev Tools</div>
              <div class="badge"><strong data-i18n="badge_tools">Tools</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_dev_desc">Bookmarklet generator + local contract monitor (no server).</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_bookmarklet">Bookmarklet</strong></div>
              <div class="badge"><strong data-i18n="badge_local">Local</strong></div>
            </div>
          </a>
        </div>
      </section>

      <!-- PANELS -->
      <section class="panel-shell" id="panel-quick">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
            <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
            <div class="panel-sub" data-i18n="p_quick_sub">
              Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="walletLabel" data-i18n="wallet_not_connected">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseQuick" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="quick_input_title">Token Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="qs-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="qs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="qs_tip">
                Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="options_label">Options</div>
              <label class="toggle">
                <input type="checkbox" id="qs-require-liq">
                <span data-i18n="opt_require_liq">Require liquidity (stricter score)</span>
              </label>
              <label class="toggle" style="margin-top:10px">
                <input type="checkbox" id="qs-show-json" checked>
                <span data-i18n="opt_show_json">Enable JSON report (copy)</span>
              </label>
            </div>

            <div class="field" style="margin-top:14px">
              <div class="label" data-i18n="api_keys_label">Explorer API keys (optional)</div>
              <label class="toggle">
                <input type="checkbox" id="api-use">
                <span data-i18n="opt_use_explorer_apis">Use BscScan/Etherscan (adds Verified + ABI heuristics)</span>
              </label>

              <div class="row" style="margin-top:10px">
                <input id="api-bscscan" class="mono" placeholder="BscScan API key (stored locally)" data-i18n-placeholder="ph_bscscan_key" />
                <input id="api-unified" class="mono" placeholder="Unified API key (stored locally)" data-i18n-placeholder="ph_unified_key" />
                <input id="api-etherscan" class="mono" placeholder="Etherscan API key (stored locally)" data-i18n-placeholder="ph_etherscan_key" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="api-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="api-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>

              <div class="small" style="margin-top:8px" data-i18n="api_keys_tip">
                Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.
              </div>
            </div>

            <div class="field">
              <div class="row qs-actions">
                <button class="btn btn-primary" id="qs-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
                <button class="btn btn-ghost" id="qs-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
              </div>
            </div>

            <div class="qs-share">
              <button class="btn btn-ghost" id="qs-share-x">Share to X</button>
              <button class="btn btn-ghost" id="qs-share-tg">Share to Telegram</button>
              <button class="btn btn-ghost" id="qs-copy-xtext" data-i18n="btn_copy_xtext">Copy X text</button>
            </div>

            <div id="qs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="results_title">Results</h3>
            <div class="small" data-i18n="results_hint">
              Green / Yellow / Red signals. Not a guarantee ‚Äî just verifiable on-chain checks.
            </div>

            <div id="qs-out" class="status info" style="display:block; margin-top:10px;" data-i18n="qs_ready_html">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="qs-risk" class="risk-badges"></div>
            <div id="qs-pairsWrap" style="margin-top:12px;"></div>
          </div>
        </div>
        
      </section>
     <section class="panel-shell hidden" id="panel-approvals">
  <div class="panel-head">
    <div>
      <div class="panel-kicker" data-i18n="p_dna_kicker">WALLET SECURITY DNA</div>
      <div class="panel-title" data-i18n="p_dna_title">Wallet Security DNA</div>
      <div class="panel-sub" data-i18n="p_dna_sub">
        Approval &amp; Permission Risk Snapshot
      </div>
    </div>

    <div class="panel-actions">
      <div class="pill">
        <span data-i18n="pill_wallet">Wallet</span>:
        <span class="mono" id="dna-wallet" data-i18n="wallet_not_connected">not connected</span>
      </div>
      <button class="btn btn-ghost" id="btnCloseApprovals" data-i18n="btn_close">Close</button>
    </div>
  </div>

  <div class="grid-2">
    <!-- LEFT -->
    <div class="card">
      <h3 data-i18n="dna_controls_title">DNA Scan</h3>

      <div class="field">
        <div class="label" data-i18n="dna_wallet_address_label">Wallet Address</div>
        <input
          id="dna-walletAddress"
          class="mono"
          placeholder="0x... (optional if you connect)"
          data-i18n-placeholder="dna_wallet_address_ph"
        />
        <div class="small" style="margin-top:8px" data-i18n="dna_wallet_address_tip">
          You can scan by address first. Connect a wallet only when you want to revoke.
        </div>
      </div>

      <div class="field">
        <div class="label" data-i18n="net_label">Network</div>
        <select id="dna-net">
          <option value="bsc" data-i18n="net_bsc">BSC (BNB Chain)</option>
          <option value="eth" data-i18n="net_eth">Ethereum</option>
          <option value="polygon" data-i18n="net_polygon">Polygon</option>
        </select>
      </div>

      <div class="field">
        <div class="row" style="justify-content:space-between; gap:10px; flex-wrap:wrap">
          <div class="pill">
            <span data-i18n="dna_connected">Connected:</span>
            <span id="dna-address" class="mono">‚Äî</span>
          </div>
          <button class="btn btn-secondary" id="dna-connect" data-i18n="dna_connect">Connect Wallet</button>
        </div>
      </div>

      <div class="field">
        <div class="row" style="gap:10px; flex-wrap:wrap">
          <button class="btn btn-primary" id="dna-run" data-i18n="dna_run">Scan</button>
          <button class="btn btn-ghost" id="dna-reset" data-i18n="dna_reset">Reset</button>
        </div>
        <div class="small" style="margin-top:8px" data-i18n="safe_mode_note">
          Safe mode: revoke actions require a connected wallet.
        </div>
      </div>

      <div id="dna-status" class="status info"></div>

      <div class="field" style="margin-top:14px">
        <div class="label" data-i18n="dna_tokens_label">Token list (optional)</div>
        <textarea
          id="dna-tokens"
          class="mono"
          placeholder="0x...\n0x...\n0x..."
          data-i18n-placeholder="ph_token_list"
        ></textarea>
        <div class="row" style="margin-top:10px">
          <button class="btn btn-ghost" id="dna-seed-common" data-i18n="ap_seed">Seed common tokens</button>
          <button class="btn btn-ghost" id="dna-seed-history" data-i18n="ap_seed_history">Use scan history</button>
        </div>
      </div>

      <!-- Compatibility hooks (hidden) -->
      <div style="display:none">
        <select id="ap-net"></select>
        <button id="ap-connect"></button>
        <button id="ap-revoke-all"></button>
        <div id="ap-status"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap">
        <div>
          <h3 data-i18n="dna_results_title">Wallet Security DNA</h3>
          <div class="small" data-i18n="dna_results_hint">
            Score is a snapshot. Always verify before signing.
          </div>
        </div>

        <div class="row dna-metrics">
          <div class="pill">
            <span data-i18n="dna_score">Score</span>:
            <span class="mono" id="dna-score">‚Äî</span>
          </div>
          <div class="pill">
            <span data-i18n="dna_risk_level">Risk</span>:
            <span class="mono" id="dna-risk">‚Äî</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px; padding:12px">
        <div class="small" style="margin-bottom:8px" data-i18n="dna_tips_title">Tips</div>
        <ul id="dna-tips" class="small" style="margin:0; padding-left:18px">
          <li class="muted" data-i18n="dna_tips_placeholder">‚Äî</li>
        </ul>

        <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap">
          <button class="btn btn-ghost" id="dna-share" data-i18n="dna_share">Share score</button>
        </div>
      </div>

      <div style="margin-top:14px">
  <div class="row" style="justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap">
    <h3 style="margin:0" data-i18n="dna_allowances_title">Approvals</h3>

    <!-- RIGHT ACTIONS (gated) -->
    <div class="row" style="gap:10px; flex-wrap:wrap">
      <!-- New: Full access button (default visible) -->
      <button class="btn btn-secondary" id="dna-full-access" data-i18n="dna_full_access_btn">
        Full Access (CYCX users)
      </button>

      <!-- Existing: Revoke all (default hidden; becomes visible only if eligible) -->
      <button class="btn btn-ghost hidden" id="dna-revoke-all" data-i18n="ap_revoke_all">
        Revoke All (non-zero)
      </button>
    </div>
  </div>

  <!-- Locked notice (default visible) -->
  <div id="dna-approvals-locked" class="card" style="margin-top:10px; padding:12px">
    <div class="small" data-i18n="dna_locked_title">Advanced approvals are locked</div>
    <div class="small muted" style="margin-top:6px" data-i18n="dna_locked_body">
      Full access (spender details + revoke actions) is available for CYCX holders.
    </div>
    <div id="dna-elig-msg" class="small" style="margin-top:10px"></div>
    <div class="small muted" style="margin-top:8px" data-i18n="dna_locked_hint">
      Connect your wallet to check eligibility. This is a read-only balance check.
    </div>
  </div>

  <!-- Approvals content (default hidden) -->
  <div id="dna-approvals-content" class="hidden">
    <div id="ap-table" class="table ap-table" style="margin-top:10px;">
      <div class="trow head">
        <div class="cell">Token</div>
        <div class="cell hide-sm">Spender</div>
        <div class="cell">Allowance</div>
        <div class="cell hide-sm">Verified</div>
        <div class="cell hide-sm">Last Updated</div>
        <div class="cell">Risk</div>
        <div class="cell">Action</div>
      </div>

      <div class="trow">
        <div class="cell muted">‚Äî</div>
        <div class="cell muted hide-sm">‚Äî</div>
        <div class="cell muted">‚Äî</div>
        <div class="cell muted hide-sm">‚Äî</div>
        <div class="cell muted hide-sm">‚Äî</div>
        <div class="cell muted hide-sm">‚Äî</div>
        <div class="cell muted">‚Äî</div>
        <div class="cell muted">‚Äî</div>
      </div>
    </div>

    <div class="small" style="margin-top:8px" data-i18n="dna_table_note">
      Tip: revoke ‚Äúinfinite‚Äù approvals you don‚Äôt fully trust. Verified status and flags are informational only.
    </div>
  </div>
</div>

  </div>
</section>


      <section class="panel-shell hidden" id="panel-liq">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_liq_kicker">Token + Liquidity Scan</div>
            <div class="panel-title" data-i18n="p_liq_title">DEX Registry liquidity checks</div>
            <div class="panel-sub" data-i18n="p_liq_sub">
              We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="liq-wallet" data-i18n="wallet_not_connected">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseLiq" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="liq_input_title">Token + Network</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="liq-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="liq-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="liq_tip">
                Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="liq_dex_label">DEX registry (checked)</div>
              <div class="small" id="liq-dex-note" style="margin-top:6px;"></div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="liq-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="liq-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="liq-share-x" data-i18n="btn_share_x">Share to X</button>
              </div>
            </div>

            <div id="liq-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="liq_results_title">Liquidity Results</h3>
            <div class="small" data-i18n="liq_results_hint">
              V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.
            </div>

            <div id="liq-out" class="status info" style="display:block; margin-top:10px;" data-i18n="liq_ready_html">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="liq-risk" class="risk-badges"></div>
            <div id="liq-tablewrap" style="margin-top:10px;"></div>
          </div>
        </div>
      </section>
      <section class="panel-shell hidden" id="panel-rpc">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_rpc_kicker">RPC Health Checker</div>
            <div class="panel-title" data-i18n="p_rpc_title">Find the best endpoint</div>
            <div class="panel-sub" data-i18n="p_rpc_sub">
              We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseRpc" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_inputs">Inputs</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="rpc-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_private_label">Private RPC (saved locally)</div>
              <input id="rpc-private" class="mono" placeholder="https://... (stored locally only)" data-i18n-placeholder="ph_rpc_private" />
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-private-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="rpc-private-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>
              <div class="small" style="margin-top:8px" data-i18n="rpc_private_tip">
                Not embedded in HTML. Stored in your browser only (localStorage).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC (top priority)</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." data-i18n-placeholder="ph_rpc_custom" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-share-x" data-i18n="btn_share_x">Share to X</button>
              </div>
            </div>

            <div class="field" style="margin-top:14px">
              <h3 data-i18n="rpc_dev_title">Developer custom logs test</h3>
              <div class="small" data-i18n="rpc_dev_hint">
                Optional: test logs for a contract. This helps developers verify their own RPC stability.
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_addr">Contract address (optional)</div>
                <input id="rpc-dev-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_topic">Topic0 (optional)</div>
                <input id="rpc-dev-topic" class="mono" placeholder="0xddf252ad... (Transfer) or leave empty" data-i18n-placeholder="ph_rpc_dev_topic" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-dev-run" style="padding:10px 14px; font-size:12px;" data-i18n="rpc_dev_run">Run custom test</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
             <div class="trow head rpc">
             <div class="cell">RPC</div>
             <div class="cell">Metrics</div>
             <div class="cell">Status</div>
             </div>
           </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-tx">
  <div class="panel-head">
    <div>
      <div class="panel-kicker" data-i18n="p_tx_kicker">Tx Decoder</div>
      <div class="panel-title" data-i18n="p_tx_title">Decode a transaction</div>
      <div class="panel-sub" data-i18n="p_tx_sub">
        Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).
      </div>
    </div>
    <div class="panel-actions">
      <button class="btn btn-ghost" id="btnCloseTx" data-i18n="btn_close">Close</button>
    </div>
  </div>

  <div class="grid-2">
    <!-- LEFT: INPUT -->
    <div class="card">
      <h3 data-i18n="tx_input_title">Tx Input</h3>

      <div class="field">
        <div class="label" data-i18n="net_label">Network</div>
        <select id="tx-net">
          <option value="bsc">BSC (BNB Chain)</option>
          <option value="eth">Ethereum</option>
        </select>
      </div>

      <div class="field">
        <div class="label" data-i18n="tx_hash_label">Transaction hash</div>
        <input id="tx-hash" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
        <div class="small" style="margin-top:8px" data-i18n="tx_tip">
          Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.
        </div>
      </div>

      <div class="field">
        <div class="row">
          <button class="btn btn-primary" id="tx-run" data-i18n="btn_decode">Decode</button>
          <button class="btn btn-ghost" id="tx-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
        </div>
      </div>

      <div id="tx-status" class="status info"></div>
    </div>

    <!-- RIGHT: OUTPUT -->
    <div class="card">
      <h3 data-i18n="tx_results_title">Decoded Output</h3>
      
<!-- 4-line Security Summary (always visible) -->
<div id="tx-sum" class="tx-sum" style="margin-top:10px;">
  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_action_k">Action</span>
    <span class="tx-sum-v" id="tx-sum-action">‚Äî</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_risk_k">Risk</span>
    <span class="tx-sum-v" id="tx-sum-risk">‚Äî</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_target_k">Target</span>
    <span class="tx-sum-v mono" id="tx-sum-target">‚Äî</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_impact_k">Max impact</span>
    <span class="tx-sum-v" id="tx-sum-impact">‚Äî</span>
  </div>
</div>
      <!-- Main decoded text / ready state -->
      <div id="tx-out" class="status info" style="display:block; margin-top:10px;" data-i18n="tx_ready_html">
        <strong>Ready.</strong><br>
        Paste a tx hash and click <b>Decode</b>.
      </div>

      <!-- Parsed events / extra cards -->
      <div id="tx-events" style="margin-top:10px;"></div>
    </div>
  </div>
</section>
            <section class="panel-shell hidden" id="panel-dev">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_dev_kicker">Dev Tools</div>
            <div class="panel-title" data-i18n="p_dev_title">Bookmarklet + Local Monitor</div>
            <div class="panel-sub" data-i18n="p_dev_sub">
              Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseDev" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="bm_title">Bookmarklet Generator</h3>
            <div class="small" data-i18n="bm_hint">
              Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.
            </div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="bm_base_label">Hub URL (this page)</div>
              <input id="bm-base" class="mono" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="bm-generate" data-i18n="bm_generate">Generate</button>
                <button class="btn btn-ghost" id="bm-copy" data-i18n="bm_copy">Copy Bookmarklet</button>
              </div>
            </div>
            <a id="bm-drag" class="bm-drag" href="#">
  <img class="bm-drag-icon" src="/logo.png" alt="CycleX">
  <span data-i18n="bm_drag_label">CycleX ‚Äì Security Hub</span>
</a>

            <div id="bm-out" class="status info"></div>
            <div id="bm-tip" class="bm-tip" data-i18n="bm_tip">
  Add the bookmarklet to your browser, then check any contract from any site with one click.
</div>
          </div>

          <div class="card">
            <h3 data-i18n="mon_list_title">Contract Monitor (local)</h3>
            <div class="small" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="mon-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Contract address</div>
              <input id="mon-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
                <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
                <button class="btn btn-ghost" id="mon-export" data-i18n="mon_export">Copy JSON</button>
              </div>
            </div>

            <div id="mon-status" class="status info"></div>

            <div id="mon-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell" data-i18n="th_contract">Contract</div>
                <div class="cell" data-i18n="th_network">Network</div>
                <div class="cell hide-sm" data-i18n="th_last_seen">Last seen</div>
                <div class="cell" data-i18n="th_status">Status</div>
                <div class="cell" aria-hidden="true"></div>
              </div>

              <!-- ‚úÖ placeholder row (JS will replace/append real rows) -->
              <div class="trow">
                <div class="cell muted">‚Äî</div>
                <div class="cell muted">‚Äî</div>
                <div class="cell muted hide-sm">‚Äî</div>
                <div class="cell muted">‚Äî</div>
                <div class="cell">
                  <button class="mon-remove" type="button"
                          data-action="mon-remove"
                          data-addr=""
                          data-i18n-title="remove"
                          data-i18n-aria-label="remove"
                          title="Remove"
                          aria-label="Remove">√ó</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>

    </main>
  </div>
</body>

  <!-- ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <!-- AppKit + App logic -->
  <script type="module">
    "use strict";

    var E = window.E || window.ethers;
    window.E = E;


    // =========================
    // AppKit (Reown)
    // =========================
    import { createAppKit } from "https://esm.sh/@reown/appkit@1.8.15";
    import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@1.8.15";
    import { bsc, mainnet } from "https://esm.sh/@reown/appkit/networks";

    const APPKIT_PROJECT_ID = "7886bcb95105e9e47337cec481d5de75";

    const appkit = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc, mainnet],
      defaultNetwork: bsc,
      projectId: APPKIT_PROJECT_ID,
      analytics: false,
      metadata: {
        name: "CycleX",
        description: "CycleX Security Hub",
        url: window.location.origin,
        icons: [`${window.location.origin}/logo.png`]
      }
    });

    window.CxAppKitModal = appkit;

    async function waitForWalletProvider(timeoutMs = 12000) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const p = window.CxAppKitModal?.getWalletProvider?.();
          if (p) return p;
        } catch {}
        await new Promise(r => setTimeout(r, 250));
      }
      return null;
    }

   // =========================
// i18n (4 languages)
// =========================
const translations = {
  en: {
    // header / hero
    brand_sub: "On-Chain Security & Rewards",
    hero_kicker: "Security Hub",
    hero_title: "CycleX Security Tools",
    hero_subtitle:
      "A lightweight, client-side toolkit for safer swaps, approvals hygiene, liquidity checks, RPC health, and transaction decoding across BSC + Ethereum.",
    btn_back: "Back to Site",
    btn_connect: "Connect Wallet (optional)",
    wallet_not_connected: "not connected",
    btn_quick: "Run Quick Scan",
    hero_note:
      "Note: These checks are informational and do not guarantee safety. Always verify independently.",
    tools_kicker: "CHOOSE A TOOL",

    // tiles
    cube_quick_title: "Quick Scan",
    cube_quick_desc: "Fast token sanity-check + shareable report + cache.",
    cube_liq_title: "Token + Liquidity Scan",
    cube_liq_desc: "DEX registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc: "Check and revoke ERC-20 allowances safely (approve ‚Üí 0).",
    cube_rpc_title: "RPC Health Checker",
    cube_rpc_desc: "Latency + chainId + block + eth_call + read logs + dev custom test.",
    cube_tx_title: "Tx Decoder",
    cube_tx_desc: "Decode inputs + common events (Transfer/Approval) from a tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc: "Bookmarklet generator + local contract monitor (no server).",

    // tile badges
    badge_fast: "Fast",
    badge_share: "Share",
    badge_cache: "Cache",
    badge_dex: "DEX",
    badge_pairs: "Pairs",
    badge_wallet: "Wallet",
    badge_safe: "Safe",
    badge_copy: "Copy",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",

    // generic
    pill_wallet: "Wallet",
    btn_close: "Close",
    btn_save: "Save",
    btn_clear: "Clear",
    btn_scan: "Scan",
    btn_decode: "Decode",
    btn_copy_md: "Copy Markdown",
    btn_copy_link: "Copy Share Link",
    btn_copy_json: "Copy JSON",
    btn_copy_xtext: "Copy X text",

    // quick panel
    p_quick_kicker: "Quick Scan",
    p_quick_title: "Score a token in seconds",
    p_quick_sub:
      "Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.",
    quick_input_title: "Token Input",
    net_label: "Network",
    addr_label: "Token contract",
    qs_tip:
      'Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).',
    options_label: "Options",
    opt_require_liq: "Require liquidity (stricter score)",
    opt_show_json: "Enable JSON report (copy)",
    api_keys_label: "Explorer API keys (optional)",
    opt_use_explorer_apis: "Use BscScan/Etherscan (adds Verified + ABI heuristics)",
    api_keys_tip:
      "Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.",
    results_title: "Results",
    results_hint:
      "Green / Yellow / Red signals. Not a guarantee ‚Äî just verifiable on-chain checks.",

    // liquidity panel
    p_liq_kicker: "Token + Liquidity Scan",
    p_liq_title: "DEX registry liquidity checks",
    p_liq_sub:
      "We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.",
    liq_input_title: "Token + Network",
    liq_tip:
      'Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.',
    liq_dex_label: "DEX registry (checked)",
    liq_results_title: "Liquidity Results",
    liq_results_hint:
      "V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.",

    
    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "Check and revoke allowances",
    p_app_sub:
      "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
    ap_settings_title: "Settings",
    ap_connected: "Connected:",
    ap_connect: "Connect / Refresh",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "Start with a router preset, then add tokens you want to clean up.",
    ap_tokens_label: "Token list (one per line)",
    ap_seed: "Seed common tokens",
    ap_seed_history: "Use scan history",
    ap_check: "Check Allowances",
    ap_revoke_all: "Revoke All (non-zero)",
    ap_results: "Allowances",
    ap_results_hint:
      "If allowance is ‚Äúinfinite‚Äù, revoke is recommended unless you fully trust the spender.",
    safe_mode_note:
      "Safe mode: actions that require a signature are disabled until you connect a wallet.",
    // DNA (Wallet Security DNA)
p_dna_kicker: "WALLET SECURITY DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Approval & Permission Risk Snapshot",

pill_wallet: "Wallet",
wallet_not_connected: "not connected",
btn_close: "Close",

dna_controls_title: "DNA Scan",
dna_wallet_address_label: "Wallet Address",
dna_wallet_address_ph: "0x... (optional if you connect)",
dna_wallet_address_tip: "You can scan by address first. Connect a wallet only when you want to revoke.",

net_label: "Network",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Connected:",
dna_connect: "Connect Wallet",
dna_run: "Scan",
dna_reset: "Reset",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "Score is a snapshot. Always verify before signing.",

dna_score: "Score",
dna_risk_level: "Risk",

dna_tips_title: "Tips",
dna_tips_placeholder: "‚Äî",
dna_share: "Share score",

dna_allowances_title: "Approvals",
dna_table_note: "Tip: revoke ‚Äúinfinite‚Äù approvals you don‚Äôt fully trust. Verified status and flags are informational only.",

dna_full_access_btn: "Full Access (CYCX users)",
dna_locked_title: "Advanced approvals are locked",
dna_locked_body: "Full access (spender details + revoke actions) is available for CYCX holders.",
dna_locked_hint: "Connect your wallet to check eligibility. This is a read-only balance check.",
dna_elig_checking: "Checking CYCX balance‚Ä¶",
dna_elig_ok: "Eligible ‚Äî unlocking approvals",
dna_elig_no: "Not eligible for full access.",
dna_elig_wrong_net: "Please switch to BSC (BNB Chain) to check CYCX eligibility.",
dna_elig_error: "Could not check eligibility. Please try again.",

    // rpc panel
    p_rpc_kicker: "RPC Health Checker",
    p_rpc_title: "Find the best endpoint",
    p_rpc_sub:
      "We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.",
    rpc_inputs: "Inputs",
    rpc_private_label: "Private RPC (saved locally)",
    rpc_private_tip:
      "Not embedded in HTML. Stored in your browser only (localStorage).",
    rpc_custom_label: "Optional custom RPC (top priority)",
    rpc_test: "Test RPCs",
    rpc_copy_best: "Copy Best RPC",
    rpc_results: "Results",
    rpc_tip:
      "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",
    rpc_dev_title: "Developer custom logs test",
    rpc_dev_hint:
      "Optional: test logs for a contract. This helps developers verify their own RPC stability.",
    rpc_dev_addr: "Contract address (optional)",
    rpc_dev_topic: "Topic0 (optional)",
    rpc_dev_run: "Run custom test",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Decode a transaction",
    p_tx_sub:
      "Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).",
    tx_input_title: "Tx Input",
    tx_hash_label: "Transaction hash",
    tx_tip:
      'Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.',
    tx_results_title: "Decoded Output",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + Local Monitor",
    p_dev_sub:
      "Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).",
    bm_title: "Bookmarklet Generator",
    bm_hint:
      "Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.",
    bm_base_label: "Hub URL (this page)",
    bm_generate: "Generate",
    bm_copy: "Copy Bookmarklet",

    mon_add_title: "Add to watchlist",
    mon_list_title: "Contract Monitor (local)",
    mon_list_hint: "Stored locally only. No server tracking.",
    mon_add: "Add",
    mon_check: "Check all",
    mon_export: "Copy JSON",

    // footer
    footer_left:
      "CycleX Security Hub runs client-side and reads public on-chain data.",
    footer_tagline: "Verify twice. Connect only when you trust the page.",
    // --- ADD THESE KEYS (EN) ---
title_back_to_cyclex: "Back to CycleX",
aria_lang_selector: "Language selector",
badge_table: "Table",
btn_share_x: "Share to X",
btn_share_tg: "Share to Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "Custom‚Ä¶",

th_token: "Token",
th_allowance: "Allowance",
th_symbol: "Symbol",
th_action: "Action",
th_rpc: "RPC",
th_ms: "ms",
th_chain: "chain",
th_block: "block",
th_call: "call",
th_logs: "logs",
th_status: "status",
th_contract: "Contract",
th_network: "Network",
th_last_seen: "Last seen",
    th_remove: "Remove",
    bm_tip: "Add the bookmarklet to your browser, then check any contract from any site with one click.",
bm_drag_label: "CycleX ‚Äì Security Hub",

qs_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
liq_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
tx_ready_html: "<strong>Ready.</strong><br>Paste a tx hash and click <b>Decode</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (stored locally)",
ph_unified_key: "Unified API Key (Stored Locally)",
ph_etherscan_key: "Etherscan API key (stored locally)",
ph_rpc_private: "https://... (stored locally only)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) or leave empty"

    
  },

  zh: {
    // header / hero
    brand_sub: "Èìæ‰∏äÂÆâÂÖ®‰∏éÂ•ñÂä±",
    hero_kicker: "ÂÆâÂÖ®‰∏≠ÂøÉ",
    hero_title: "CycleX ÂÆâÂÖ®Â∑•ÂÖ∑",
    hero_subtitle:
      "ËΩªÈáèÁ∫ßÂÆ¢Êà∑Á´ØÂ∑•ÂÖ∑ÔºöÊõ¥ÂÆâÂÖ®ÁöÑ‰∫§Êç¢„ÄÅÊéàÊùÉÁÆ°ÁêÜ„ÄÅÊµÅÂä®ÊÄßÊ£ÄÊü•„ÄÅRPC ÂÅ•Â∫∑Ê£ÄÊµã‰∏é‰∫§ÊòìËß£Á†ÅÔºàBSC + ‰ª•Â§™ÂùäÔºâ„ÄÇ",
    btn_back: "ËøîÂõû‰∏ªÁ´ô",
    btn_connect: "ËøûÊé•Èí±ÂåÖÔºàÂèØÈÄâÔºâ",
    wallet_not_connected: "Êú™ËøûÊé•",
    btn_quick: "ËøêË°åÂø´ÈÄüÊâ´Êèè",
    hero_note:
      "ÊèêÁ§∫ÔºöËøô‰∫õÊ£ÄÊü•‰ªÖ‰æõÂèÇËÄÉÔºå‰∏ç‰øùËØÅÂÆâÂÖ®„ÄÇËØ∑Âä°ÂøÖËá™Ë°åÈ™åËØÅ„ÄÇ",
    tools_kicker: "ÈÄâÊã©Â∑•ÂÖ∑",

    // tiles
    cube_quick_title: "Âø´ÈÄüÊâ´Êèè",
    cube_quick_desc: "Âø´ÈÄü‰ª£Â∏Å‰ΩìÊ£Ä + ÂèØÂàÜ‰∫´Êä•Âëä + ÁºìÂ≠ò„ÄÇ",
    cube_liq_title: "‰ª£Â∏Å + ÊµÅÂä®ÊÄßÊâ´Êèè",
    cube_liq_desc: "DEX Ê£ÄÊü•ÔºàPancake/UniÔºâÔºö‰ª£Â∏Å vs WBNB/WETH ‰∏é USDT„ÄÇ",
    cube_approvals_title: "ÊéàÊùÉÂç´Â£´",
    cube_approvals_desc: "Ê£ÄÊü•Âπ∂ÂÆâÂÖ®Êí§ÈîÄ ERC-20 ÊéàÊùÉÔºàapprove ‚Üí 0Ôºâ„ÄÇ",
    cube_rpc_title: "RPC ÂÅ•Â∫∑Ê£ÄÊµã",
    cube_rpc_desc: "Âª∂Ëøü + chainId + Âå∫Âùó + eth_call + ËØªÂèñ logs + ÂºÄÂèëËá™ÂÆö‰πâÊµãËØï„ÄÇ",
    cube_tx_title: "‰∫§ÊòìËß£Á†Å",
    cube_tx_desc: "‰ªé‰∫§ÊòìÂìàÂ∏åËß£Á†ÅËæìÂÖ•‰∏éÂ∏∏ËßÅ‰∫ã‰ª∂ÔºàTransfer/ApprovalÔºâ„ÄÇ",
    cube_dev_title: "ÂºÄÂèëÂ∑•ÂÖ∑",
    cube_dev_desc: "‰π¶Á≠æËÑöÊú¨ÁîüÊàêÂô® + Êú¨Âú∞ÂêàÁ∫¶ÁõëÊéßÔºàÊó†ÊúçÂä°Âô®Ôºâ„ÄÇ",

    // tile badges
    badge_fast: "Âø´ÈÄü",
    badge_share: "ÂàÜ‰∫´",
    badge_cache: "ÁºìÂ≠ò",
    badge_dex: "DEX",
    badge_pairs: "‰∫§ÊòìÂØπ",
    badge_wallet: "Èí±ÂåÖ",
    badge_safe: "ÂÆâÂÖ®",
    badge_copy: "Â§çÂà∂",
    badge_dev: "ÂºÄÂèë",
    badge_decode: "Ëß£Á†Å",
    badge_receipt: "ÂõûÊâß",
    badge_events: "‰∫ã‰ª∂",
    badge_tools: "Â∑•ÂÖ∑",
    badge_bookmarklet: "‰π¶Á≠æËÑöÊú¨",
    badge_local: "Êú¨Âú∞",

    // generic
    pill_wallet: "Èí±ÂåÖ",
    btn_close: "ÂÖ≥Èó≠",
    btn_save: "‰øùÂ≠ò",
    btn_clear: "Ê∏ÖÈô§",
    btn_scan: "Êâ´Êèè",
    btn_decode: "Ëß£Á†Å",
    btn_copy_md: "Â§çÂà∂ Markdown",
    btn_copy_link: "Â§çÂà∂ÂàÜ‰∫´ÈìæÊé•",
    btn_copy_json: "Â§çÂà∂ JSON",
    btn_copy_xtext: "Â§çÂà∂ X ÊñáÊ°à",

    // quick panel
    p_quick_kicker: "Âø´ÈÄüÊâ´Êèè",
    p_quick_title: "Âá†ÁßíÂÜÖÁªô‰ª£Â∏ÅÊâìÂàÜ",
    p_quick_sub:
      "Á≤òË¥¥‰ª£Â∏ÅÂú∞ÂùÄÔºåÈÄâÊã©ÁΩëÁªúÂπ∂Êâ´Êèè„ÄÇÁºìÂ≠ò 10 ÂàÜÈíü„ÄÇÂèØÁîüÊàêÂèØÂàÜ‰∫´ÊñáÊú¨ + JSON + Markdown„ÄÇ",
    quick_input_title: "‰ª£Â∏ÅËæìÂÖ•",
    net_label: "ÁΩëÁªú",
    addr_label: "‰ª£Â∏ÅÂêàÁ∫¶",
    qs_tip:
      'ÊèêÁ§∫ÔºöÂèØÁî® <span class="mono">?tool=quick&net=bsc&token=0x...</span> ÊâìÂºÄËá™Âä®ËøêË°åÔºàÈôêÈÄüÔºâ„ÄÇ',
    options_label: "ÈÄâÈ°π",
    opt_require_liq: "Ë¶ÅÊ±ÇÊúâÊµÅÂä®ÊÄßÔºàÊõ¥‰∏•Ê†ºËØÑÂàÜÔºâ",
    opt_show_json: "ÂêØÁî® JSON Êä•ÂëäÔºàÂèØÂ§çÂà∂Ôºâ",
    api_keys_label: "Âå∫ÂùóÊµèËßàÂô® API KeyÔºàÂèØÈÄâÔºâ",
    opt_use_explorer_apis: "‰ΩøÁî® BscScan/EtherscanÔºàÂ¢ûÂä† Verified + ABI ËßÑÂàôÔºâ",
    api_keys_tip:
      "Key ‰ªÖ‰øùÂ≠òÂú®ÊµèËßàÂô®Êú¨Âú∞ÔºàlocalStorageÔºâ„ÄÇ‰∏çË¶ÅÊää Key ÂÜôËøõÂÖ¨ÂºÄ HTML„ÄÇ",
    results_title: "ÁªìÊûú",
    results_hint:
      "ÁªøËâ≤ / ÈªÑËâ≤ / Á∫¢Ëâ≤‰ø°Âè∑„ÄÇ‰∏çÊòØ‰øùËØÅ‚Äî‚ÄîÂè™ÊòØÂèØÈ™åËØÅÁöÑÈìæ‰∏äÊ£ÄÊü•„ÄÇ",

    // liquidity panel
    p_liq_kicker: "‰ª£Â∏Å + ÊµÅÂä®ÊÄßÊâ´Êèè",
    p_liq_title: "DEX Ê≥®ÂÜåË°®ÊµÅÂä®ÊÄßÊ£ÄÊü•",
    p_liq_sub:
      "Ê£ÄÊü• PancakeSwapÔºàBSCÔºâ/ UniswapÔºàETHÔºâV2 + V3 Â∑•ÂéÇ„ÄÇÊµãËØï‰∫§ÊòìÂØπÔºö‰ª£Â∏Å vs WBNB/WETH ‰∏é‰ª£Â∏Å vs USDT„ÄÇ",
    liq_input_title: "‰ª£Â∏Å + ÁΩëÁªú",
    liq_tip:
      'ÊèêÁ§∫ÔºöÂèØÁî® <span class="mono">?tool=liq&net=bsc&token=0x...</span> ÊâìÂºÄËá™Âä®ËøêË°å„ÄÇ',
    liq_dex_label: "DEX Ê≥®ÂÜåË°®ÔºàÂ∑≤Ê£ÄÊü•Ôºâ",
    liq_results_title: "ÊµÅÂä®ÊÄßÁªìÊûú",
    liq_results_hint:
      "V2Ôºö‰∫§ÊòìÂØπ + ÂÇ®Â§áÂø´ÁÖß„ÄÇV3ÔºöÊ±†Â≠êÂ≠òÂú®ÊÄß + liquidity() + slot0 tick Âø´ÁÖß„ÄÇ",

    // approvals panel
    p_app_kicker: "ÊéàÊùÉÂç´Â£´",
    p_app_title: "Ê£ÄÊü•Âπ∂Êí§ÈîÄÊéàÊùÉ",
    p_app_sub:
      "Â°´ÂÜô spender + ‰ª£Â∏ÅÂàóË°®ÔºàÊàñ‰∏ÄÈîÆÂ°´ÂÖ•Â∏∏Áî®‰ª£Â∏ÅÔºâ„ÄÇËØªÂèñ allowance(owner, spender)ÔºåÂπ∂Áî® approve(spender, 0) Êí§ÈîÄ„ÄÇ",
    ap_settings_title: "ËÆæÁΩÆ",
    ap_connected: "Â∑≤ËøûÊé•Ôºö",
    ap_connect: "ËøûÊé• / Âà∑Êñ∞",
    ap_spender_label: "Spender È¢ÑËÆæ",
    ap_spender_tip: "ÂÖàÈÄâË∑ØÁî±È¢ÑËÆæÔºåÂÜçÊ∑ªÂä†‰Ω†ÊÉ≥Ê∏ÖÁêÜÁöÑ‰ª£Â∏Å„ÄÇ",
    ap_tokens_label: "‰ª£Â∏ÅÂàóË°®ÔºàÊØèË°å‰∏Ä‰∏™Ôºâ",
    ap_seed: "Â°´ÂÖ•Â∏∏Áî®‰ª£Â∏Å",
    ap_seed_history: "‰ΩøÁî®Êâ´ÊèèÂéÜÂè≤",
    ap_check: "Ê£ÄÊü•ÊéàÊùÉ",
    ap_revoke_all: "Êí§ÈîÄÂÖ®ÈÉ®ÔºàÈùûÈõ∂Ôºâ",
    ap_results: "ÊéàÊùÉÂàóË°®",
    ap_results_hint:
      "Ëã•ÊéàÊùÉ‰∏∫‚ÄúÊó†Èôê‚ÄùÔºåÈô§Èùû‰Ω†ÂÆåÂÖ®‰ø°‰ªªËØ• spenderÔºåÂê¶ÂàôÂª∫ËÆÆÊí§ÈîÄ„ÄÇ",
    safe_mode_note:
      "ÂÆâÂÖ®Ê®°ÂºèÔºöÈúÄË¶ÅÁ≠æÂêçÁöÑÊìç‰Ωú‰ºöÂú®ËøûÊé•Èí±ÂåÖÂâçË¢´Á¶ÅÁî®„ÄÇ",
    // DNAÔºàÈí±ÂåÖÂÆâÂÖ® DNAÔºâ
p_dna_kicker: "Èí±ÂåÖÂÆâÂÖ® DNA",
p_dna_title: "Èí±ÂåÖÂÆâÂÖ® DNA",
p_dna_sub: "ÊéàÊùÉ‰∏éÊùÉÈôêÈ£éÈô©Âø´ÁÖß",

pill_wallet: "Èí±ÂåÖ",
wallet_not_connected: "Êú™ËøûÊé•",
btn_close: "ÂÖ≥Èó≠",

dna_controls_title: "DNA Êâ´Êèè",
dna_wallet_address_label: "Èí±ÂåÖÂú∞ÂùÄ",
dna_wallet_address_ph: "0x...ÔºàÂèØÈÄâÔºåËøûÊé•Èí±ÂåÖÂêéÂèØËá™Âä®Â°´ÂÖ•Ôºâ",
dna_wallet_address_tip: "ÂèØÂÖàÁî®Âú∞ÂùÄÊâ´Êèè„ÄÇ‰ªÖÂú®ÈúÄË¶ÅÊí§ÈîÄÊó∂ÂÜçËøûÊé•Èí±ÂåÖ„ÄÇ",

net_label: "ÁΩëÁªú",
net_bsc: "BSCÔºàBNB ChainÔºâ",
net_eth: "‰ª•Â§™Âùä",
net_polygon: "Polygon",

dna_connected: "Â∑≤ËøûÊé•Ôºö",
dna_connect: "ËøûÊé•Èí±ÂåÖ",
dna_run: "Êâ´Êèè",
dna_reset: "ÈáçÁΩÆ",

dna_results_title: "Èí±ÂåÖÂÆâÂÖ® DNA",
dna_results_hint: "ËØÑÂàÜÊòØÂø´ÁÖß„ÄÇÁ≠æÂêçÂâçËØ∑Âä°ÂøÖËá™Ë°åÊ†∏ÂÆû„ÄÇ",

dna_score: "ËØÑÂàÜ",
dna_risk_level: "È£éÈô©",

dna_tips_title: "ÊèêÁ§∫",
dna_tips_placeholder: "‚Äî",
dna_share: "ÂàÜ‰∫´ËØÑÂàÜ",

dna_allowances_title: "ÊéàÊùÉ",
dna_table_note: "ÊèêÁ§∫Ôºö‰∏çÂÆåÂÖ®‰ø°‰ªªÁöÑ‚ÄúÊó†Èôê‚ÄùÊéàÊùÉÂª∫ËÆÆÊí§ÈîÄ„ÄÇVerified ‰∏é Flags ‰ªÖ‰æõÂèÇËÄÉ„ÄÇ",
        dna_full_access_btn: "ÂÆåÊï¥ÊùÉÈôêÔºàCYCX Áî®Êà∑Ôºâ",
    dna_locked_title: "È´òÁ∫ßÊéàÊùÉ‰ø°ÊÅØÂ∑≤ÈîÅÂÆö",
    dna_locked_body: "ÂÆåÊï¥ÊùÉÈôêÔºàSpender ËØ¶ÊÉÖ + Êí§ÈîÄÊìç‰ΩúÔºâ‰ªÖÂØπ CYCX ÊåÅÊúâËÄÖÂºÄÊîæ„ÄÇ",
    dna_locked_hint: "ËøûÊé•Èí±ÂåÖ‰ª•Ê£ÄÊü•ËµÑÊ†º„ÄÇËØ•Ê≠•È™§‰ªÖËøõË°åÂè™ËØª‰ΩôÈ¢ùÊü•ËØ¢„ÄÇ",
    dna_elig_checking: "Ê≠£Âú®Ê£ÄÊü• CYCX ‰ΩôÈ¢ù‚Ä¶",
    dna_elig_ok: "Á¨¶ÂêàËµÑÊ†º ‚Äî Ê≠£Âú®Ëß£ÈîÅÊéàÊùÉ‰ø°ÊÅØ",
    dna_elig_no: "ÂΩìÂâç‰∏çÁ¨¶ÂêàÂÆåÊï¥ÊùÉÈôêÊù°‰ª∂„ÄÇ",
    dna_elig_wrong_net: "ËØ∑ÂàáÊç¢Âà∞ BSCÔºàBNB ChainÔºâ‰ª•Ê£ÄÊü• CYCX ËµÑÊ†º„ÄÇ",
    dna_elig_error: "Êó†Ê≥ïÊ£ÄÊü•ËµÑÊ†ºÔºåËØ∑ÈáçËØï„ÄÇ",


    // rpc panel
    p_rpc_kicker: "RPC ÂÅ•Â∫∑Ê£ÄÊµã",
    p_rpc_title: "ÊâæÂà∞ÊúÄ‰Ω≥ËäÇÁÇπ",
    p_rpc_sub:
      "ÊµãËØï RPCÔºöÂª∂Ëøü + chainId + Âå∫Âùó + eth_call + ËØªÂèñ logs„ÄÇÂåÖÂê´ÂºÄÂèëËÄÖËá™ÂÆö‰πâ logs ÊµãËØïÔºåÂπ∂ÊääÊúÄ‰Ω≥ RPC Â≠òÂà∞Êú¨Âú∞„ÄÇ",
    rpc_inputs: "ËæìÂÖ•",
    rpc_private_label: "ÁßÅÊúâ RPCÔºàÊú¨Âú∞‰øùÂ≠òÔºâ",
    rpc_private_tip:
      "‰∏ç‰ºöÂÜôËøõ HTMLÔºåÂè™‰øùÂ≠òÂú®‰Ω†ÁöÑÊµèËßàÂô®ÔºàlocalStorageÔºâ„ÄÇ",
    rpc_custom_label: "ÂèØÈÄâËá™ÂÆö‰πâ RPCÔºà‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºâ",
    rpc_test: "ÊµãËØï RPC",
    rpc_copy_best: "Â§çÂà∂ÊúÄ‰Ω≥ RPC",
    rpc_results: "ÁªìÊûú",
    rpc_tip:
      "ÊèêÁ§∫ÔºöÈÉ®ÂàÜ RPC ‰ºöÂõ† CORS/Ë∂ÖÊó∂Â§±Ë¥•„ÄÇËøêË°åÊµãËØïÂπ∂ÈÄâÊã©Á®≥ÂÆö‰∏îÊúÄÂø´ÁöÑ„ÄÇ",
    rpc_dev_title: "ÂºÄÂèëËÄÖËá™ÂÆö‰πâ logs ÊµãËØï",
    rpc_dev_hint:
      "ÂèØÈÄâÔºöÂØπÊüêÂêàÁ∫¶ÊµãËØï logsÔºåÂ∏ÆÂä©ÂºÄÂèëËÄÖÈ™åËØÅ RPC ÁöÑÁ®≥ÂÆöÊÄß„ÄÇ",
    rpc_dev_addr: "ÂêàÁ∫¶Âú∞ÂùÄÔºàÂèØÈÄâÔºâ",
    rpc_dev_topic: "Topic0ÔºàÂèØÈÄâÔºâ",
    rpc_dev_run: "ËøêË°åËá™ÂÆö‰πâÊµãËØï",

    // tx panel
    p_tx_kicker: "‰∫§ÊòìËß£Á†Å",
    p_tx_title: "Ëß£Á†Å‰∏ÄÁ¨î‰∫§Êòì",
    p_tx_sub:
      "Á≤òË¥¥‰∫§ÊòìÂìàÂ∏å„ÄÇËé∑Âèñ tx + receiptÔºåÂπ∂Ëß£Á†ÅÂ∏∏ËßÅËæìÂÖ•‰∏é‰∫ã‰ª∂ÔºàTransfer / Approval + Â∏∏ËßÅ swap Ë∞ÉÁî®Ôºâ„ÄÇ",
    tx_input_title: "‰∫§ÊòìËæìÂÖ•",
    tx_hash_label: "‰∫§ÊòìÂìàÂ∏å",
    tx_tip:
      'ÊèêÁ§∫ÔºöÂèØÁî® <span class="mono">?tool=tx&net=bsc&tx=0x...</span> ÊâìÂºÄËá™Âä®ËøêË°å„ÄÇ',
    tx_results_title: "Ëß£Á†ÅËæìÂá∫",

    // dev panel
    p_dev_kicker: "ÂºÄÂèëÂ∑•ÂÖ∑",
    p_dev_title: "‰π¶Á≠æËÑöÊú¨ + Êú¨Âú∞ÁõëÊéß",
    p_dev_sub:
      "ÁîüÊàê‰π¶Á≠æËÑöÊú¨ÔºåÊääÊµèËßàÂô®È°µÈù¢‰∏äÁöÑ‰ª£Â∏Å/‰∫§Êòì‰∏ÄÈîÆÂèëÈÄÅÂà∞ CycleX Hub„ÄÇ‰πüÂåÖÂê´Êú¨Âú∞ÂêàÁ∫¶ÁõëÊéßÔºàÂàóË°®‰øùÂ≠òÂú®ÊµèËßàÂô®Ôºâ„ÄÇ",
    bm_title: "‰π¶Á≠æËÑöÊú¨ÁîüÊàêÂô®",
    bm_hint:
      "ÊãñÂà∞‰π¶Á≠æÊ†èÊàñÂ§çÂà∂ÁîüÊàêÁöÑ‰π¶Á≠æËÑöÊú¨„ÄÇÂú® BscScan/Etherscan È°µÈù¢‰ΩøÁî®„ÄÇ",
    bm_base_label: "Hub URLÔºàÂΩìÂâçÈ°µÈù¢Ôºâ",
    bm_generate: "ÁîüÊàê",
    bm_copy: "Â§çÂà∂‰π¶Á≠æËÑöÊú¨",

    mon_add_title: "Âä†ÂÖ•ÁõëÊéßÂàóË°®",
    mon_list_title: "ÂêàÁ∫¶ÁõëÊéßÔºàÊú¨Âú∞Ôºâ",
    mon_list_hint: "‰ªÖÊú¨Âú∞‰øùÂ≠ò„ÄÇÊó†ÊúçÂä°Âô®Ë∑üË∏™„ÄÇ",
    mon_add: "Ê∑ªÂä†",
    mon_check: "ÂÖ®ÈÉ®Ê£ÄÊü•",
    mon_export: "Â§çÂà∂ JSON",

    // footer
    footer_left: "CycleX ÂÆâÂÖ®‰∏≠ÂøÉÂú®Êú¨Âú∞ËøêË°åÔºåËØªÂèñÂÖ¨ÂºÄÈìæ‰∏äÊï∞ÊçÆ„ÄÇ",
    footer_tagline: "Â§öÈ™åËØÅ‰∏ÄÊ¨°„ÄÇÂè™Âú®‰ø°‰ªªÈ°µÈù¢Êó∂ËøûÊé•Èí±ÂåÖ„ÄÇ",
    // --- ADD THESE KEYS (ZH) ---
title_back_to_cyclex: "ËøîÂõû CycleX",
aria_lang_selector: "ËØ≠Ë®ÄÈÄâÊã©",
badge_table: "Ë°®Ê†º",
btn_share_x: "ÂàÜ‰∫´Âà∞ X",
btn_share_tg: "ÂàÜ‰∫´Âà∞ Telegram",
net_bsc: "BSCÔºàBNB ChainÔºâ",
net_eth: "‰ª•Â§™Âùä",
spender_pcs_router: "PancakeSwap Ë∑ØÁî±Âô®ÔºàBSCÔºâ",
spender_uni_router: "Uniswap V2 Ë∑ØÁî±Âô®ÔºàETHÔºâ",
spender_custom: "Ëá™ÂÆö‰πâ‚Ä¶",

th_token: "‰ª£Â∏Å",
th_allowance: "ÊéàÊùÉÈ¢ùÂ∫¶",
th_symbol: "Á¨¶Âè∑",
th_action: "Êìç‰Ωú",
th_rpc: "RPC",
th_ms: "ÊØ´Áßí",
th_chain: "Èìæ",
th_block: "Âå∫Âùó",
th_call: "Ë∞ÉÁî®",
th_logs: "Êó•Âøó",
th_status: "Áä∂ÊÄÅ",
th_contract: "ÂêàÁ∫¶",
th_network: "ÁΩëÁªú",
th_last_seen: "‰∏äÊ¨°Âá∫Áé∞",
    th_remove: "ÁßªÈô§",
    bm_tip: "Â∞Ü‰π¶Á≠æÂ∞èÂ∑•ÂÖ∑Ê∑ªÂä†Âà∞ÊµèËßàÂô®ÔºåÁÑ∂Âêé‰∏ÄÈîÆ‰ªé‰ªª‰ΩïÁΩëÁ´ôÊ£ÄÊü•‰ªª‰ΩïÂêàÁ∫¶„ÄÇ",
bm_drag_label: "CycleX ‚Äì ÂÆâÂÖ®‰∏≠ÂøÉ",

qs_ready_html: "<strong>ÂáÜÂ§áÂ∞±Áª™„ÄÇ</strong><br>Á≤òË¥¥‰ª£Â∏ÅÂú∞ÂùÄÂπ∂ÁÇπÂáª <b>Êâ´Êèè</b>„ÄÇ",
liq_ready_html: "<strong>ÂáÜÂ§áÂ∞±Áª™„ÄÇ</strong><br>Á≤òË¥¥‰ª£Â∏ÅÂú∞ÂùÄÂπ∂ÁÇπÂáª <b>Êâ´Êèè</b>„ÄÇ",
tx_ready_html: "<strong>ÂáÜÂ§áÂ∞±Áª™„ÄÇ</strong><br>Á≤òË¥¥‰∫§ÊòìÂìàÂ∏åÂπ∂ÁÇπÂáª <b>Ëß£Á†Å</b>„ÄÇ",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API KeyÔºàÊú¨Âú∞‰øùÂ≠òÔºâ",
ph_unified_key: "Unified API Key (Êú¨Âú∞‰øùÂ≠ò)",
ph_etherscan_key: "Etherscan API KeyÔºàÊú¨Âú∞‰øùÂ≠òÔºâ",
ph_rpc_private: "https://...Ôºà‰ªÖÊú¨Âú∞‰øùÂ≠òÔºâ",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad...ÔºàTransferÔºâÊàñÁïôÁ©∫"

  },

  ar: {
    // header / hero
    brand_sub: "ÿ£ŸÖÿßŸÜ ŸàŸÖŸÉÿßŸÅÿ¢ÿ™ ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©",
    hero_kicker: "ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ£ŸÖÿßŸÜ",
    hero_title: "ÿ£ÿØŸàÿßÿ™ CycleX ÿßŸÑÿ£ŸÖŸÜŸäÿ©",
    hero_subtitle:
      "ŸÖÿ¨ŸÖŸàÿπÿ© ÿÆŸÅŸäŸÅÿ© ÿ™ÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠: swaps ÿ£ŸÉÿ´ÿ± ÿ£ŸÖÿßŸÜÿßŸãÿå ÿ•ÿØÿßÿ±ÿ© approvalsÿå ŸÅÿ≠ÿµ ÿßŸÑÿ≥ŸäŸàŸÑÿ©ÿå ÿµÿ≠ÿ© RPCÿå ŸàŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖÿπÿßŸÖŸÑÿßÿ™ ÿπÿ®ÿ± BSC + Ethereum.",
    btn_back: "ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÖŸàŸÇÿπ",
    btn_connect: "ÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)",
    wallet_not_connected: "ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ",
    btn_quick: "ÿ™ÿ¥ÿ∫ŸäŸÑ ŸÅÿ≠ÿµ ÿ≥ÿ±Ÿäÿπ",
    hero_note:
      "ŸÖŸÑÿßÿ≠ÿ∏ÿ©: Ÿáÿ∞Ÿá ÿßŸÑŸÅÿ≠Ÿàÿµÿßÿ™ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿäÿ© ŸàŸÑÿß ÿ™ÿ∂ŸÖŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ. ÿ™ÿ≠ŸÇŸÇ ÿØÿßÿ¶ŸÖÿßŸã ÿ®ŸÜŸÅÿ≥ŸÉ.",
    tools_kicker: "ÿßÿÆÿ™ÿ± ÿ£ÿØÿßÿ©",

    // tiles
    cube_quick_title: "ŸÅÿ≠ÿµ ÿ≥ÿ±Ÿäÿπ",
    cube_quick_desc: "ŸÅÿ≠ÿµ ÿ≥ÿ±Ÿäÿπ ŸÑŸÑÿ™ŸàŸÉŸÜ + ÿ™ŸÇÿ±Ÿäÿ± ŸÇÿßÿ®ŸÑ ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© + ŸÉÿßÿ¥.",
    cube_liq_title: "ŸÅÿ≠ÿµ ÿßŸÑÿ™ŸàŸÉŸÜ + ÿßŸÑÿ≥ŸäŸàŸÑÿ©",
    cube_liq_desc: "ŸÅÿ≠ÿµ DEX (Pancake/Uni): ÿßŸÑÿ™ŸàŸÉŸÜ ŸÖŸÇÿßÿ®ŸÑ WBNB/WETH Ÿà USDT.",
    cube_approvals_title: "ÿ≠ÿßÿ±ÿ≥ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™",
    cube_approvals_desc: "ÿ™ÿ≠ŸÇŸÇ Ÿàÿ£ŸÑÿ∫Ÿê ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ERC-20 ÿ®ÿ£ŸÖÿßŸÜ (approve ‚Üí 0).",
    cube_rpc_title: "ŸÅÿ≠ÿµ ÿµÿ≠ÿ© RPC",
    cube_rpc_desc: "ÿ≤ŸÖŸÜ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© + chainId + ÿ®ŸÑŸàŸÉ + eth_call + ŸÇÿ±ÿßÿ°ÿ© logs + ÿßÿÆÿ™ÿ®ÿßÿ± ŸÖÿ∑ŸàŸëÿ±.",
    cube_tx_title: "ŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± Tx",
    cube_tx_desc: "ŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™ + ÿ£ÿ≠ÿØÿßÿ´ ÿ¥ÿßÿ¶ÿπÿ© (Transfer/Approval) ŸÖŸÜ tx hash.",
    cube_dev_title: "ÿ£ÿØŸàÿßÿ™ ÿßŸÑŸÖÿ∑ŸàŸëÿ±",
    cube_dev_desc: "ŸÖŸàŸÑŸëÿØ Bookmarklet + ŸÖÿ±ÿßŸÇÿ®ÿ© ÿπŸÇÿØ ŸÖÿ≠ŸÑŸäÿ© (ÿ®ÿØŸàŸÜ ÿ≥Ÿäÿ±ŸÅÿ±).",

    // tile badges
    badge_fast: "ÿ≥ÿ±Ÿäÿπ",
    badge_share: "ŸÖÿ¥ÿßÿ±ŸÉÿ©",
    badge_cache: "ŸÉÿßÿ¥",
    badge_dex: "DEX",
    badge_pairs: "ÿ£ÿ≤Ÿàÿßÿ¨",
    badge_wallet: "ŸÖÿ≠ŸÅÿ∏ÿ©",
    badge_safe: "ÿ¢ŸÖŸÜ",
    badge_copy: "ŸÜÿ≥ÿÆ",
    badge_dev: "ŸÖÿ∑ŸàŸëÿ±",
    badge_decode: "ŸÅŸÉ",
    badge_receipt: "ÿ•ŸäÿµÿßŸÑ",
    badge_events: "ÿ£ÿ≠ÿØÿßÿ´",
    badge_tools: "ÿ£ÿØŸàÿßÿ™",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "ŸÖÿ≠ŸÑŸä",

    // generic
    pill_wallet: "ŸÖÿ≠ŸÅÿ∏ÿ©",
    btn_close: "ÿ•ÿ∫ŸÑÿßŸÇ",
    btn_save: "ÿ≠ŸÅÿ∏",
    btn_clear: "ŸÖÿ≥ÿ≠",
    btn_scan: "ŸÅÿ≠ÿµ",
    btn_decode: "ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±",
    btn_copy_md: "ŸÜÿ≥ÿÆ Markdown",
    btn_copy_link: "ŸÜÿ≥ÿÆ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉÿ©",
    btn_copy_json: "ŸÜÿ≥ÿÆ JSON",
    btn_copy_xtext: "ŸÜÿ≥ÿÆ ŸÜÿµ X",

    // quick panel
    p_quick_kicker: "ŸÅÿ≠ÿµ ÿ≥ÿ±Ÿäÿπ",
    p_quick_title: "ŸÇŸäŸëŸÖ ÿ™ŸàŸÉŸÜ ÿÆŸÑÿßŸÑ ÿ´ŸàÿßŸÜŸç",
    p_quick_sub:
      "ÿ£ŸÑÿµŸÇ ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ™ŸàŸÉŸÜÿå ÿßÿÆÿ™ÿ± ÿßŸÑÿ¥ÿ®ŸÉÿ©ÿå ÿ¥ÿ∫ŸëŸÑ ÿßŸÑŸÅÿ≠ÿµ. ŸäŸèÿ≠ŸÅÿ∏ ÿ®ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© 10 ÿØŸÇÿßÿ¶ŸÇ. ÿ£ŸÜÿ¥ÿ¶ ŸÜÿµÿßŸã ŸÇÿßÿ®ŸÑÿßŸã ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© + JSON + Markdown.",
    quick_input_title: "ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ŸàŸÉŸÜ",
    net_label: "ÿßŸÑÿ¥ÿ®ŸÉÿ©",
    addr_label: "ÿπŸÇÿØ ÿßŸÑÿ™ŸàŸÉŸÜ",
    qs_tip:
      'ŸÜÿµŸäÿ≠ÿ©: ÿßŸÅÿ™ÿ≠ <span class="mono">?tool=quick&net=bsc&token=0x...</span> ŸÑŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä (ŸÖÿ≠ÿØŸàÿØ).',
    options_label: "ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™",
    opt_require_liq: "Ÿäÿ™ÿ∑ŸÑÿ® ÿ≥ŸäŸàŸÑÿ© (ÿ™ŸÇŸäŸäŸÖ ÿ£ŸÉÿ´ÿ± ÿµÿ±ÿßŸÖÿ©)",
    opt_show_json: "ÿ™ŸÅÿπŸäŸÑ ÿ™ŸÇÿ±Ÿäÿ± JSON (ŸÜÿ≥ÿÆ)",
    api_keys_label: "ŸÖŸÅÿßÿ™Ÿäÿ≠ API ŸÑŸÑŸÖÿ≥ÿ™ŸÉÿ¥ŸÅ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)",
    opt_use_explorer_apis: "ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ BscScan/Etherscan (Ÿäÿ≤ŸäÿØ Verified + ŸÇŸàÿßÿπÿØ ABI)",
    api_keys_tip:
      "ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿ™Ÿèÿ≠ŸÅÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã ŸÅŸä ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ (localStorage) ŸÅŸÇÿ∑. ŸÑÿß ÿ™ÿ∂ÿπŸáÿß ÿØÿßÿÆŸÑ HTML ÿπÿßŸÖ.",
    results_title: "ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨",
    results_hint:
      "ÿ•ÿ¥ÿßÿ±ÿßÿ™ ÿÆÿ∂ÿ±ÿßÿ°/ÿµŸÅÿ±ÿßÿ°/ÿ≠ŸÖÿ±ÿßÿ°. ŸÑŸäÿ≥ÿ™ ÿ∂ŸÖÿßŸÜÿßŸã ‚Äî ŸÖÿ¨ÿ±ÿØ ŸÅÿ≠Ÿàÿµÿßÿ™ ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ© ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ.",

    // liquidity panel
    p_liq_kicker: "ŸÅÿ≠ÿµ ÿßŸÑÿ™ŸàŸÉŸÜ + ÿßŸÑÿ≥ŸäŸàŸÑÿ©",
    p_liq_title: "ŸÅÿ≠ÿµ ÿ≥ŸäŸàŸÑÿ© DEX",
    p_liq_sub:
      "ŸÜŸèÿ¨ÿ±Ÿä ŸÅÿ≠ÿµ PancakeSwap (BSC) / Uniswap (ETH) V2 + V3. ÿßŸÑÿ£ÿ≤Ÿàÿßÿ¨: ÿßŸÑÿ™ŸàŸÉŸÜ ŸÖŸÇÿßÿ®ŸÑ WBNB/WETH Ÿà USDT.",
    liq_input_title: "ÿ™ŸàŸÉŸÜ + ÿ¥ÿ®ŸÉÿ©",
    liq_tip:
      'ŸÜÿµŸäÿ≠ÿ©: ÿßŸÅÿ™ÿ≠ <span class="mono">?tool=liq&net=bsc&token=0x...</span> ŸÑŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä.',
    liq_dex_label: "ÿ≥ÿ¨ŸÑ DEX (ŸÖŸÅÿ≠Ÿàÿµ)",
    liq_results_title: "ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ≥ŸäŸàŸÑÿ©",
    liq_results_hint:
      "V2: ÿ≤Ÿàÿ¨ + ŸÑŸÇÿ∑ÿ© ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä. V3: Ÿàÿ¨ŸàÿØ ÿßŸÑÿ≠Ÿàÿ∂ + liquidity() + ŸÑŸÇÿ∑ÿ© slot0/tick.",

    // approvals panel
    p_app_kicker: "ÿ≠ÿßÿ±ÿ≥ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™",
    p_app_title: "ÿ™ÿ≠ŸÇŸÇ Ÿàÿ£ŸÑÿ∫Ÿê ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™",
    p_app_sub:
      "ÿ£ÿØÿÆŸÑ spender + ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ (ÿ£Ÿà ÿ£ÿ∂ŸÅ ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©). ŸÜŸÇÿ±ÿ£ allowance(owner, spender) ŸàŸÜŸÑÿ∫Ÿä ÿπÿ®ÿ± approve(spender, 0).",
    ap_settings_title: "ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™",
    ap_connected: "ŸÖÿ™ÿµŸÑ:",
    ap_connect: "ÿßÿ™ÿµÿßŸÑ / ÿ™ÿ≠ÿØŸäÿ´",
    ap_spender_label: "ÿ•ÿπÿØÿßÿØ spender",
    ap_spender_tip:
      "ÿßÿ®ÿØÿ£ ÿ®ÿßÿÆÿ™Ÿäÿßÿ± ÿ±ÿßŸàÿ™ÿ± ÿ¨ÿßŸáÿ≤ÿå ÿ´ŸÖ ÿ£ÿ∂ŸÅ ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ™ŸÜÿ∏ŸäŸÅŸáÿß.",
    ap_tokens_label: "ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ (ŸÉŸÑ ÿ≥ÿ∑ÿ± ÿπŸÜŸàÿßŸÜ)",
    ap_seed: "ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸàŸÉŸÜÿßÿ™ ÿ¥ÿßÿ¶ÿπÿ©",
    ap_seed_history: "ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÅÿ≠ÿµ",
    ap_check: "ŸÅÿ≠ÿµ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™",
    ap_revoke_all: "ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑŸÉŸÑ (ÿ∫Ÿäÿ± ÿßŸÑÿµŸÅÿ±Ÿäÿ©)",
    ap_results: "ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™",
    ap_results_hint:
      "ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© ‚Äúÿ∫Ÿäÿ± ŸÖÿ≠ÿØŸàÿØÿ©‚Äùÿå ŸäŸèŸÜÿµÿ≠ ÿ®ÿßŸÑÿ•ŸÑÿ∫ÿßÿ° ŸÖÿß ŸÑŸÖ ÿ™ŸÉŸÜ ÿ™ÿ´ŸÇ ÿ™ŸÖÿßŸÖÿßŸã ÿ®ÿßŸÑŸÄ spender.",
    safe_mode_note:
      "ÿßŸÑŸàÿ∂ÿπ ÿßŸÑÿ¢ŸÖŸÜ: ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿ™ÿ∑ŸÑÿ® ÿ™ŸàŸÇŸäÿπÿßŸã ŸÖÿπÿ∑ŸÑÿ© ÿ≠ÿ™Ÿâ ÿ™ÿ™ÿµŸÑ ÿ®ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©.",
    // DNA (ÿ®ÿµŸÖÿ© ÿ£ŸÖÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©)
p_dna_kicker: "ÿ®ÿµŸÖÿ© ÿ£ŸÖÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©",
p_dna_title: "ÿ®ÿµŸÖÿ© ÿ£ŸÖÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©",
p_dna_sub: "ŸÑŸÇÿ∑ÿ© ŸÑŸÖÿÆÿßÿ∑ÿ± ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ŸàÿßŸÑÿ£ÿ∞ŸàŸÜÿßÿ™",

pill_wallet: "ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©",
wallet_not_connected: "ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ",
btn_close: "ÿ•ÿ∫ŸÑÿßŸÇ",

dna_controls_title: "ŸÅÿ≠ÿµ DNA",
dna_wallet_address_label: "ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©",
dna_wallet_address_ph: "0x... (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä ÿ•ÿ∞ÿß ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßÿ™ÿµÿßŸÑ)",
dna_wallet_address_tip: "ŸäŸÖŸÉŸÜŸÉ ÿßŸÑŸÅÿ≠ÿµ ÿ®ÿßŸÑÿπŸÜŸàÿßŸÜ ÿ£ŸàŸÑÿßŸã. ÿßÿ™ÿµŸÑ ÿ®ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿ±ÿ∫ÿ®ÿ™ŸÉ ŸÅŸä ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°.",

net_label: "ÿßŸÑÿ¥ÿ®ŸÉÿ©",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "ŸÖÿ™ÿµŸÑ:",
dna_connect: "ÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©",
dna_run: "ŸÅÿ≠ÿµ",
dna_reset: "ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑",

dna_results_title: "ÿ®ÿµŸÖÿ© ÿ£ŸÖÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©",
dna_results_hint: "ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ŸÑŸÇÿ∑ÿ© ÿ≥ÿ±Ÿäÿπÿ©. ÿ™ÿ≠ŸÇŸëŸÇ ÿØÿßÿ¶ŸÖÿßŸã ŸÇÿ®ŸÑ ÿßŸÑÿ™ŸàŸÇŸäÿπ.",

dna_score: "ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©",
dna_risk_level: "ÿßŸÑŸÖÿÆÿßÿ∑ÿ±",

dna_tips_title: "ŸÜÿµÿßÿ¶ÿ≠",
dna_tips_placeholder: "‚Äî",
dna_share: "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©",

dna_allowances_title: "ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™",
dna_table_note: "ŸÜÿµŸäÿ≠ÿ©: ÿ£ŸÑÿ∫Ÿê ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ‚Äúÿ∫Ÿäÿ± ÿßŸÑŸÖÿ≠ÿØŸàÿØÿ©‚Äù ÿßŸÑÿ™Ÿä ŸÑÿß ÿ™ÿ´ŸÇ ÿ®Ÿáÿß ÿ™ŸÖÿßŸÖÿßŸã. ÿ≠ÿßŸÑÿ© Verified Ÿà Flags ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿäÿ© ŸÅŸÇÿ∑.",
    dna_full_access_btn: "ŸàÿµŸàŸÑ ŸÉÿßŸÖŸÑ (ŸÖÿ≥ÿ™ÿÆÿØŸÖŸä CYCX)",
    dna_locked_title: "ÿßŸÑŸÖŸàÿßŸÅŸÇÿßÿ™ ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ŸÖŸÇŸÅŸÑÿ©",
    dna_locked_body: "ÿßŸÑŸàÿµŸàŸÑ ÿßŸÑŸÉÿßŸÖŸÑ (ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÖŸèÿµÿ±Ÿëÿ≠ ŸÑŸá + ÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°) ŸÖÿ™ÿßÿ≠ ŸÑÿ≠ÿßŸÖŸÑŸä CYCX ŸÅŸÇÿ∑.",
    dna_locked_hint: "ÿßÿ™ÿµŸÑ ÿ®ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ£ŸáŸÑŸäÿ©. Ÿáÿ∞ÿß ŸÅÿ≠ÿµ ÿ±ÿµŸäÿØ ŸÑŸÑŸÇÿ±ÿßÿ°ÿ© ŸÅŸÇÿ∑.",
    dna_elig_checking: "ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ÿµŸäÿØ CYCX‚Ä¶",
    dna_elig_ok: "ŸÖÿ§ŸáŸÑ ‚Äî ÿ¨ÿßÿ±Ÿç ŸÅÿ™ÿ≠ ŸÇÿ≥ŸÖ ÿßŸÑŸÖŸàÿßŸÅŸÇÿßÿ™",
    dna_elig_no: "ÿ∫Ÿäÿ± ŸÖÿ§ŸáŸÑ ŸÑŸÑŸàÿµŸàŸÑ ÿßŸÑŸÉÿßŸÖŸÑ.",
    dna_elig_wrong_net: "Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ•ŸÑŸâ BSC (BNB Chain) ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸáŸÑŸäÿ© CYCX.",
    dna_elig_error: "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ£ŸáŸÑŸäÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",


    // rpc panel
    p_rpc_kicker: "ŸÅÿ≠ÿµ ÿµÿ≠ÿ© RPC",
    p_rpc_title: "ÿßÿπÿ´ÿ± ÿπŸÑŸâ ÿ£ŸÅÿ∂ŸÑ Endpoint",
    p_rpc_sub:
      "ŸÜÿÆÿ™ÿ®ÿ± RPC: ÿ≤ŸÖŸÜ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© + chainId + ÿ®ŸÑŸàŸÉ + eth_call + ŸÇÿ±ÿßÿ°ÿ© logs. Ÿäÿ™ÿ∂ŸÖŸÜ ÿßÿÆÿ™ÿ®ÿßÿ± logs ŸÑŸÑŸÖÿ∑Ÿàÿ± ŸàŸäÿ≠ŸÅÿ∏ ÿ£ŸÅÿ∂ŸÑ RPC ŸÖÿ≠ŸÑŸäÿßŸã.",
    rpc_inputs: "ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™",
    rpc_private_label: "RPC ÿÆÿßÿµ (ŸÖÿ≠ŸÅŸàÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã)",
    rpc_private_tip:
      "ÿ∫Ÿäÿ± ŸÖÿØŸÖÿ¨ ŸÅŸä HTML. ŸÖÿ≠ŸÅŸàÿ∏ ŸÅŸä ŸÖÿ™ÿµŸÅÿ≠ŸÉ ŸÅŸÇÿ∑ (localStorage).",
    rpc_custom_label: "RPC ŸÖÿÆÿµÿµ (ÿ£ŸàŸÑŸàŸäÿ© ÿ£ÿπŸÑŸâ)",
    rpc_test: "ÿßÿÆÿ™ÿ®ÿßÿ± RPCs",
    rpc_copy_best: "ŸÜÿ≥ÿÆ ÿ£ŸÅÿ∂ŸÑ RPC",
    rpc_results: "ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨",
    rpc_tip:
      "ŸÜÿµŸäÿ≠ÿ©: ÿ®ÿπÿ∂ RPCs ÿ™ŸÅÿ¥ŸÑ ÿ®ÿ≥ÿ®ÿ® CORS/ŸÖŸáŸÑÿ©. ÿ¥ÿ∫ŸëŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ŸàÿßÿÆÿ™ÿ± ÿßŸÑÿ£ÿ≥ÿ±ÿπ ŸàÿßŸÑÿ£ŸÉÿ´ÿ± ÿßÿ≥ÿ™ŸÇÿ±ÿßÿ±ÿßŸã.",
    rpc_dev_title: "ÿßÿÆÿ™ÿ®ÿßÿ± logs ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ∑Ÿàÿ±",
    rpc_dev_hint:
      "ÿßÿÆÿ™Ÿäÿßÿ±Ÿä: ÿßÿÆÿ™ÿ®ÿ± logs ŸÑÿπŸÇÿØ ŸÖÿ≠ÿØÿØ ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßÿ≥ÿ™ŸÇÿ±ÿßÿ± ÿßŸÑŸÄ RPC.",
    rpc_dev_addr: "ÿπŸÜŸàÿßŸÜ ÿßŸÑÿπŸÇÿØ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)",
    rpc_dev_topic: "Topic0 (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)",
    rpc_dev_run: "ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±",

    // tx panel
    p_tx_kicker: "ŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± Tx",
    p_tx_title: "ŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ŸÖÿπÿßŸÖŸÑÿ©",
    p_tx_sub:
      "ÿ£ŸÑÿµŸÇ tx hash. ŸÜÿ¨ŸÑÿ® tx + receipt ŸàŸÜŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™ ŸàÿßŸÑÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑÿ¥ÿßÿ¶ÿπÿ© (Transfer / Approval + ÿßÿ≥ÿ™ÿØÿπÿßÿ°ÿßÿ™ swap).",
    tx_input_title: "ÿ•ÿØÿÆÿßŸÑ Tx",
    tx_hash_label: "Ÿáÿßÿ¥ ÿßŸÑŸÖÿπÿßŸÖŸÑÿ©",
    tx_tip:
      'ŸÜÿµŸäÿ≠ÿ©: ÿßŸÅÿ™ÿ≠ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> ŸÑŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä.',
    tx_results_title: "ÿßŸÑŸÖÿÆÿ±ÿ¨ÿßÿ™",

    // dev panel
    p_dev_kicker: "ÿ£ÿØŸàÿßÿ™ ÿßŸÑŸÖÿ∑ŸàŸëÿ±",
    p_dev_title: "Bookmarklet + ŸÖÿ±ÿßŸÇÿ®ÿ© ŸÖÿ≠ŸÑŸäÿ©",
    p_dev_sub:
      "ÿ£ŸÜÿ¥ÿ¶ Bookmarklet Ÿäÿ±ÿ≥ŸÑ ÿßŸÑÿ™ŸàŸÉŸÜ/ÿßŸÑŸÖÿπÿßŸÖŸÑÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸÉÿ¥ŸÅ ÿ•ŸÑŸâ CycleX Hub. ŸàŸäÿ™ÿ∂ŸÖŸÜ ŸÖÿ±ÿßŸÇÿ®ÿ© ÿπŸÇÿØ ŸÖÿ≠ŸÑŸäÿ© (ŸÇÿßÿ¶ŸÖÿ© ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÅŸä ŸÖÿ™ÿµŸÅÿ≠ŸÉ).",
    bm_title: "ŸÖŸàŸÑŸëÿØ Bookmarklet",
    bm_hint:
      "ÿßÿ≥ÿ≠ÿ® ÿ•ŸÑŸâ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ•ÿ¥ÿßÿ±ÿßÿ™ ÿ£Ÿà ÿßŸÜÿ≥ÿÆ ÿßŸÑŸÄ Bookmarklet. ÿßÿ≥ÿ™ÿÆÿØŸÖŸá ŸÅŸä ÿµŸÅÿ≠ÿßÿ™ BscScan/Etherscan.",
    bm_base_label: "ÿ±ÿßÿ®ÿ∑ Hub (Ÿáÿ∞Ÿá ÿßŸÑÿµŸÅÿ≠ÿ©)",
    bm_generate: "ÿ•ŸÜÿ¥ÿßÿ°",
    bm_copy: "ŸÜÿ≥ÿÆ Bookmarklet",

    mon_add_title: "ÿ•ÿ∂ÿßŸÅÿ© ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ©",
    mon_list_title: "ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿπŸÇŸàÿØ (ŸÖÿ≠ŸÑŸä)",
    mon_list_hint: "ŸÖÿ≠ŸÅŸàÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã ŸÅŸÇÿ∑. ÿ®ÿØŸàŸÜ ÿ™ÿ™ÿ®ÿπ ÿ≥Ÿäÿ±ŸÅÿ±.",
    mon_add: "ÿ•ÿ∂ÿßŸÅÿ©",
    mon_check: "ŸÅÿ≠ÿµ ÿßŸÑŸÉŸÑ",
    mon_export: "ŸÜÿ≥ÿÆ JSON",

    // footer
    footer_left:
      "CycleX Security Hub ŸäÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸàŸäŸÇÿ±ÿ£ ÿ®ŸäÿßŸÜÿßÿ™ ÿπÿßŸÖÿ© ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©.",
    footer_tagline: "ÿ™ÿ≠ŸÇŸÇ ŸÖÿ±ÿ™ŸäŸÜ. ŸÑÿß ÿ™ÿ™ÿµŸÑ ÿ•ŸÑÿß ÿπŸÜÿØŸÖÿß ÿ™ÿ´ŸÇ ÿ®ÿßŸÑÿµŸÅÿ≠ÿ©.",
    // --- ADD THESE KEYS (AR) ---
title_back_to_cyclex: "ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ CycleX",
aria_lang_selector: "ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÑÿ∫ÿ©",
badge_table: "ÿ¨ÿØŸàŸÑ",
btn_share_x: "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿπŸÑŸâ X",
btn_share_tg: "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿπŸÑŸâ ÿ™ŸäŸÑŸäÿ¨ÿ±ÿßŸÖ",
net_bsc: "BSC (BNB Chain)",
net_eth: "ÿ•Ÿäÿ´ÿ±ŸäŸàŸÖ",
spender_pcs_router: "ÿ±ÿßŸàÿ™ÿ± PancakeSwap (BSC)",
spender_uni_router: "ÿ±ÿßŸàÿ™ÿ± Uniswap V2 (ETH)",
spender_custom: "ŸÖÿÆÿµÿµ‚Ä¶",

th_token: "ÿßŸÑÿ™ŸàŸÉŸÜ",
th_allowance: "ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©",
th_symbol: "ÿßŸÑÿ±ŸÖÿ≤",
th_action: "ÿ•ÿ¨ÿ±ÿßÿ°",
th_rpc: "RPC",
th_ms: "ŸÖŸÑŸÑŸä ÿ´ÿßŸÜŸäÿ©",
th_chain: "ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©",
th_block: "ÿ®ŸÑŸàŸÉ",
th_call: "ÿßÿ≥ÿ™ÿØÿπÿßÿ°",
th_logs: "ÿ≥ÿ¨ŸÑÿßÿ™",
th_status: "ÿßŸÑÿ≠ÿßŸÑÿ©",
th_contract: "ÿßŸÑÿπŸÇÿØ",
th_network: "ÿßŸÑÿ¥ÿ®ŸÉÿ©",
th_last_seen: "ÿ¢ÿÆÿ± ÿ∏ŸáŸàÿ±",
    th_remove: "ÿ•ÿ≤ÿßŸÑÿ©",
    bm_tip: "ÿ£ÿ∂ŸêŸÅ ÿ£ÿØÿßÿ© ÿßŸÑÿ•ÿ¥ÿßÿ±ÿ© ÿßŸÑŸÖÿ±ÿ¨ÿπŸäÿ© ÿ•ŸÑŸâ ŸÖÿ™ÿµŸÅÿ≠ŸÉÿå ÿ´ŸÖ ÿßŸÅÿ≠ÿµ ÿ£Ÿä ÿπŸÇÿØ ŸÖŸÜ ÿ£Ÿä ŸÖŸàŸÇÿπ ÿ®ŸÜŸÇÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©.",
bm_drag_label: "CycleX ‚Äì ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ£ŸÖÿßŸÜ",

qs_ready_html: "<strong>ÿ¨ÿßŸáÿ≤.</strong><br>ÿ£ŸÑÿµŸÇ ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ™ŸàŸÉŸÜ ÿ´ŸÖ ÿßÿ∂ÿ∫ÿ∑ <b>ŸÅÿ≠ÿµ</b>.",
liq_ready_html: "<strong>ÿ¨ÿßŸáÿ≤.</strong><br>ÿ£ŸÑÿµŸÇ ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ™ŸàŸÉŸÜ ÿ´ŸÖ ÿßÿ∂ÿ∫ÿ∑ <b>ŸÅÿ≠ÿµ</b>.",
tx_ready_html: "<strong>ÿ¨ÿßŸáÿ≤.</strong><br>ÿ£ŸÑÿµŸÇ tx hash ÿ´ŸÖ ÿßÿ∂ÿ∫ÿ∑ <b>ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "ŸÖŸÅÿ™ÿßÿ≠ BscScan API (ŸÖÿ≠ŸÅŸàÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã)",
ph_unified_key: "Unified API Key (ŸÖÿ≠ŸÅŸàÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã)",
ph_etherscan_key: "ŸÖŸÅÿ™ÿßÿ≠ Etherscan API (ŸÖÿ≠ŸÅŸàÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã)",
ph_rpc_private: "https://... (ŸÖÿ≠ŸÅŸàÿ∏ ŸÖÿ≠ŸÑŸäÿßŸã ŸÅŸÇÿ∑)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) ÿ£Ÿà ÿßÿ™ÿ±ŸÉŸá ŸÅÿßÿ±ÿ∫ÿßŸã"

  },

  ru: {
    // header / hero
    brand_sub: "–û–Ω—á–µ–π–Ω –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –Ω–∞–≥—Ä–∞–¥—ã",
    hero_kicker: "Security Hub",
    hero_title: "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ CycleX",
    hero_subtitle:
      "–õ—ë–≥–∫–∏–π –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π –Ω–∞–±–æ—Ä: –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ swaps, –≥–∏–≥–∏–µ–Ω–∞ approvals, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏, –∑–¥–æ—Ä–æ–≤—å–µ RPC –∏ –¥–µ–∫–æ–¥–µ—Ä —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –¥–ª—è BSC + Ethereum.",
    btn_back: "–ù–∞–∑–∞–¥ –Ω–∞ —Å–∞–π—Ç",
    btn_connect: "–ü–æ–¥–∫–ª—é—á–∏—Ç—å –∫–æ—à–µ–ª—ë–∫ (–æ–ø—Ü.)",
    wallet_not_connected: "–Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω",
    btn_quick: "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±—ã—Å—Ç—Ä—ã–π —Å–∫–∞–Ω",
    hero_note:
      "–í–∞–∂–Ω–æ: –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ—Å—è—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –∏ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å. –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ.",
    tools_kicker: "–í–´–ë–ï–†–ò–¢–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢",

    // tiles
    cube_quick_title: "–ë—ã—Å—Ç—Ä—ã–π —Å–∫–∞–Ω",
    cube_quick_desc: "–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ + —à–∞—Ä–∏–º—ã–π –æ—Ç—á—ë—Ç + –∫—ç—à.",
    cube_liq_title: "–¢–æ–∫–µ–Ω + –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å",
    cube_liq_desc: "–ü—Ä–æ–≤–µ—Ä–∫–∞ DEX (Pancake/Uni): —Ç–æ–∫–µ–Ω vs WBNB/WETH –∏ USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc:
      "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –æ—Ç–∑—ã–≤ ERC-20 allowance (approve ‚Üí 0).",
    cube_rpc_title: "–ü—Ä–æ–≤–µ—Ä–∫–∞ RPC",
    cube_rpc_desc:
      "Latency + chainId + block + eth_call + —á—Ç–µ–Ω–∏–µ logs + dev custom test.",
    cube_tx_title: "–î–µ–∫–æ–¥–µ—Ä Tx",
    cube_tx_desc:
      "–î–µ–∫–æ–¥–∏—Ä—É–µ—Ç input –∏ —Å–æ–±—ã—Ç–∏—è (Transfer/Approval) –ø–æ tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc:
      "–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä bookmarklet + –ª–æ–∫–∞–ª—å–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (–±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞).",

    // tile badges
    badge_fast: "–ë—ã—Å—Ç—Ä–æ",
    badge_share: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è",
    badge_cache: "–ö—ç—à",
    badge_dex: "DEX",
    badge_pairs: "–ü–∞—Ä—ã",
    badge_wallet: "–ö–æ—à–µ–ª—ë–∫",
    badge_safe: "–ë–µ–∑–æ–ø–∞—Å–Ω–æ",
    badge_copy: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",

    // generic
    pill_wallet: "–ö–æ—à–µ–ª—ë–∫",
    btn_close: "–ó–∞–∫—Ä—ã—Ç—å",
    btn_save: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
    btn_clear: "–û—á–∏—Å—Ç–∏—Ç—å",
    btn_scan: "–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å",
    btn_decode: "–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å",
    btn_copy_md: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å Markdown",
    btn_copy_link: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É",
    btn_copy_json: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å JSON",
    btn_copy_xtext: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç –¥–ª—è X",

    // quick panel
    p_quick_kicker: "–ë—ã—Å—Ç—Ä—ã–π —Å–∫–∞–Ω",
    p_quick_title: "–û—Ü–µ–Ω–∏—Ç–µ —Ç–æ–∫–µ–Ω –∑–∞ —Å–µ–∫—É–Ω–¥—ã",
    p_quick_sub:
      "–í—Å—Ç–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–∫–∞–Ω. –ö—ç—à –Ω–∞ 10 –º–∏–Ω—É—Ç. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —à–∞—Ä–∏–Ω–≥–∞ + JSON + Markdown.",
    quick_input_title: "–í–≤–æ–¥ —Ç–æ–∫–µ–Ω–∞",
    net_label: "–°–µ—Ç—å",
    addr_label: "–ö–æ–Ω—Ç—Ä–∞–∫—Ç —Ç–æ–∫–µ–Ω–∞",
    qs_tip:
      '–°–æ–≤–µ—Ç: –æ—Ç–∫—Ä–æ–π—Ç–µ <span class="mono">?tool=quick&net=bsc&token=0x...</span> –¥–ª—è –∞–≤—Ç–æ-—Å—Ç–∞—Ä—Ç–∞ (–ª–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–æ).',
    options_label: "–û–ø—Ü–∏–∏",
    opt_require_liq: "–¢—Ä–µ–±–æ–≤–∞—Ç—å –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å (—Å—Ç—Ä–æ–∂–µ)",
    opt_show_json: "–í–∫–ª—é—á–∏—Ç—å JSON –æ—Ç—á—ë—Ç (–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ)",
    api_keys_label: "API –∫–ª—é—á–∏ Explorer (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)",
    opt_use_explorer_apis:
      "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å BscScan/Etherscan (Verified + ABI —ç–≤—Ä–∏—Å—Ç–∏–∫–∏)",
    api_keys_tip:
      "–ö–ª—é—á–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ (localStorage). –ù–µ –≤—Å—Ç–∞–≤–ª—è–π—Ç–µ –∫–ª—é—á–∏ –≤ –ø—É–±–ª–∏—á–Ω—ã–π HTML.",
    results_title: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã",
    results_hint:
      "–ó–µ–ª—ë–Ω—ã–µ / –∂—ë–ª—Ç—ã–µ / –∫—Ä–∞—Å–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã. –≠—Ç–æ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—è ‚Äî —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º—ã–µ –æ–Ω—á–µ–π–Ω-–ø—Ä–æ–≤–µ—Ä–∫–∏.",

    // liquidity panel
    p_liq_kicker: "–¢–æ–∫–µ–Ω + –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å",
    p_liq_title: "–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ DEX",
    p_liq_sub:
      "–ü—Ä–æ–≤–µ—Ä—è–µ–º PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 —Ñ–∞–±—Ä–∏–∫–∏. –ü–∞—Ä—ã: —Ç–æ–∫–µ–Ω vs WBNB/WETH –∏ —Ç–æ–∫–µ–Ω vs USDT.",
    liq_input_title: "–¢–æ–∫–µ–Ω + —Å–µ—Ç—å",
    liq_tip:
      '–°–æ–≤–µ—Ç: –æ—Ç–∫—Ä–æ–π—Ç–µ <span class="mono">?tool=liq&net=bsc&token=0x...</span> –¥–ª—è –∞–≤—Ç–æ-—Å—Ç–∞—Ä—Ç–∞.',
    liq_dex_label: "DEX —Ä–µ–µ—Å—Ç—Ä (–ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è)",
    liq_results_title: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏",
    liq_results_hint:
      "V2: –ø–∞—Ä–∞ + snapshot —Ä–µ–∑–µ—Ä–≤–æ–≤. V3: –Ω–∞–ª–∏—á–∏–µ –ø—É–ª–∞ + liquidity() + slot0/tick snapshot.",

    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ—Ç–∑—ã–≤ allowance",
    p_app_sub:
      "–£–∫–∞–∂–∏—Ç–µ spender + —Ç–æ–∫–µ–Ω—ã (–∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ). –ß–∏—Ç–∞–µ–º allowance(owner, spender) –∏ –æ—Ç–∑—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ approve(spender, 0).",
    ap_settings_title: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    ap_connected: "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ:",
    ap_connect: "–ü–æ–¥–∫–ª—é—á–∏—Ç—å / –û–±–Ω–æ–≤–∏—Ç—å",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "–ù–∞—á–Ω–∏—Ç–µ —Å —Ä–æ—É—Ç–µ—Ä–∞, –∑–∞—Ç–µ–º –¥–æ–±–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω—ã –¥–ª—è –æ—á–∏—Å—Ç–∫–∏.",
    ap_tokens_label: "–°–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ (–ø–æ –æ–¥–Ω–æ–º—É –≤ —Å—Ç—Ä–æ–∫–µ)",
    ap_seed: "–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã",
    ap_seed_history: "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å–∫–∞–Ω–æ–≤",
    ap_check: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å allowance",
    ap_revoke_all: "–û—Ç–æ–∑–≤–∞—Ç—å –≤—Å–µ (–Ω–µ–Ω—É–ª–µ–≤—ã–µ)",
    ap_results: "Allowances",
    ap_results_hint:
      "–ï—Å–ª–∏ allowance ‚Äú–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π‚Äù, –ª—É—á—à–µ –æ—Ç–æ–∑–≤–∞—Ç—å, –µ—Å–ª–∏ –≤—ã –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –¥–æ–≤–µ—Ä—è–µ—Ç–µ spender.",
    safe_mode_note:
      "Safe mode: –¥–µ–π—Å—Ç–≤–∏—è, —Ç—Ä–µ–±—É—é—â–∏–µ –ø–æ–¥–ø–∏—Å—å, –æ—Ç–∫–ª—é—á–µ–Ω—ã –¥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫–æ—à–µ–ª—å–∫–∞.",
    // DNA (–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ—à–µ–ª—å–∫–∞)
p_dna_kicker: "–ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ –ö–û–®–ï–õ–¨–ö–ê DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "–°–Ω–∏–º–æ–∫ —Ä–∏—Å–∫–æ–≤ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –∏ –ø—Ä–∞–≤",

pill_wallet: "–ö–æ—à–µ–ª—ë–∫",
wallet_not_connected: "–Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω",
btn_close: "–ó–∞–∫—Ä—ã—Ç—å",

dna_controls_title: "DNA-—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ",
dna_wallet_address_label: "–ê–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞",
dna_wallet_address_ph: "0x... (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫)",
dna_wallet_address_tip: "–ú–æ–∂–Ω–æ —Å–Ω–∞—á–∞–ª–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ –∞–¥—Ä–µ—Å—É. –ü–æ–¥–∫–ª—é—á–∞–π—Ç–µ –∫–æ—à–µ–ª—ë–∫ —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–∑—ã–≤–∞—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.",

net_label: "–°–µ—Ç—å",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ:",
dna_connect: "–ü–æ–¥–∫–ª—é—á–∏—Ç—å –∫–æ—à–µ–ª—ë–∫",
dna_run: "–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å",
dna_reset: "–°–±—Ä–æ—Å",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "–û—Ü–µ–Ω–∫–∞ ‚Äî —ç—Ç–æ —Å–Ω–∏–º–æ–∫. –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –ø–µ—Ä–µ–¥ –ø–æ–¥–ø–∏—Å—å—é.",

dna_score: "–û—Ü–µ–Ω–∫–∞",
dna_risk_level: "–†–∏—Å–∫",

dna_tips_title: "–°–æ–≤–µ—Ç—ã",
dna_tips_placeholder: "‚Äî",
dna_share: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –æ—Ü–µ–Ω–∫–æ–π",

dna_allowances_title: "–†–∞–∑—Ä–µ—à–µ–Ω–∏—è",
dna_table_note: "–°–æ–≤–µ—Ç: –æ—Ç–∑—ã–≤–∞–π—Ç–µ ‚Äú–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ‚Äù approvals, –µ—Å–ª–∏ –Ω–µ –¥–æ–≤–µ—Ä—è–µ—Ç–µ –∏–º –ø–æ–ª–Ω–æ—Å—Ç—å—é. Verified –∏ Flags ‚Äî —Ç–æ–ª—å–∫–æ —Å–ø—Ä–∞–≤–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è.",
dna_full_access_btn: "–ü–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ CYCX)",
    dna_locked_title: "–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã",
    dna_locked_body: "–ü–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø (–¥–µ—Ç–∞–ª–∏ spender + –¥–µ–π—Å—Ç–≤–∏—è revoke) –¥–æ—Å—Ç—É–ø–µ–Ω –¥–µ—Ä–∂–∞—Ç–µ–ª—è–º CYCX.",
    dna_locked_hint: "–ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–∞–≤–æ –¥–æ—Å—Ç—É–ø–∞. –≠—Ç–æ —Ç–æ–ª—å–∫–æ —á—Ç–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞.",
    dna_elig_checking: "–ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å CYCX‚Ä¶",
    dna_elig_ok: "–î–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à—ë–Ω ‚Äî –æ—Ç–∫—Ä—ã–≤–∞–µ–º approvals",
    dna_elig_no: "–ù–µ—Ç –ø—Ä–∞–≤–∞ –Ω–∞ –ø–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø.",
    dna_elig_wrong_net: "–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–µ—Å—å –Ω–∞ BSC (BNB Chain), —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø CYCX.",
    dna_elig_error: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.",

    // rpc panel
    p_rpc_kicker: "–ü—Ä–æ–≤–µ—Ä–∫–∞ RPC",
    p_rpc_title: "–ù–∞–π–¥–∏—Ç–µ –ª—É—á—à–∏–π endpoint",
    p_rpc_sub:
      "–¢–µ—Å—Ç–∏—Ä—É–µ–º RPC: latency + chainId + block + eth_call + —á—Ç–µ–Ω–∏–µ logs. –ï—Å—Ç—å dev custom logs test, –ª—É—á—à–∏–π RPC —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ.",
    rpc_inputs: "–í–≤–æ–¥",
    rpc_private_label: "–ü—Ä–∏–≤–∞—Ç–Ω—ã–π RPC (–ª–æ–∫–∞–ª—å–Ω–æ)",
    rpc_private_tip:
      "–ù–µ –≤—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –≤ HTML. –•—Ä–∞–Ω–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ (localStorage).",
    rpc_custom_label: "–ö–∞—Å—Ç–æ–º–Ω—ã–π RPC (–≤—ã—Å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)",
    rpc_test: "–¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å RPC",
    rpc_copy_best: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ª—É—á—à–∏–π RPC",
    rpc_results: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã",
    rpc_tip:
      "–°–æ–≤–µ—Ç: –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ RPC –ø–∞–¥–∞—é—Ç –∏–∑-–∑–∞ CORS/timeout. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Ç–µ—Å—Ç –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –∏ –±—ã—Å—Ç—Ä—ã–π.",
    rpc_dev_title: "Dev custom logs test",
    rpc_dev_hint:
      "–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: —Ç–µ—Å—Ç logs –ø–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç—É, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å RPC.",
    rpc_dev_addr: "–ê–¥—Ä–µ—Å –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)",
    rpc_dev_topic: "Topic0 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)",
    rpc_dev_run: "–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é",
    p_tx_sub:
      "–í—Å—Ç–∞–≤—å—Ç–µ tx hash. –ü–æ–ª—É—á–∏–º tx + receipt –∏ –¥–µ–∫–æ–¥–∏—Ä—É–µ–º input –∏ —Å–æ–±—ã—Ç–∏—è (Transfer / Approval + –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ swap –≤—ã–∑–æ–≤—ã).",
    tx_input_title: "–í–≤–æ–¥ Tx",
    tx_hash_label: "–•—ç—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏",
    tx_tip:
      '–°–æ–≤–µ—Ç: –æ—Ç–∫—Ä–æ–π—Ç–µ <span class="mono">?tool=tx&net=bsc&tx=0x...</span> –¥–ª—è –∞–≤—Ç–æ-—Å—Ç–∞—Ä—Ç–∞.',
    tx_results_title: "–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤—ã–≤–æ–¥",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + –ª–æ–∫–∞–ª—å–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä",
    p_dev_sub:
      "–°–æ–∑–¥–∞–π—Ç–µ bookmarklet, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç token/tx —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü explorer –≤ CycleX Hub. –¢–∞–∫–∂–µ –µ—Å—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (—Å–ø–∏—Å–æ–∫ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ).",
    bm_title: "–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä Bookmarklet",
    bm_hint:
      "–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –≤ –ø–∞–Ω–µ–ª—å –∑–∞–∫–ª–∞–¥–æ–∫ –∏–ª–∏ —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ bookmarklet. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ BscScan/Etherscan.",
    bm_base_label: "Hub URL (—ç—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞)",
    bm_generate: "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å",
    bm_copy: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å Bookmarklet",

    mon_add_title: "–î–æ–±–∞–≤–∏—Ç—å –≤ —Å–ø–∏—Å–æ–∫",
    mon_list_title: "–ú–æ–Ω–∏—Ç–æ—Ä –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (–ª–æ–∫–∞–ª—å–Ω–æ)",
    mon_list_hint: "–•—Ä–∞–Ω–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ. –ë–µ–∑ —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ —Ç—Ä–µ–∫–∏–Ω–≥–∞.",
    mon_add: "–î–æ–±–∞–≤–∏—Ç—å",
    mon_check: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—Å–µ",
    mon_export: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å JSON",

    // footer
    footer_left:
      "CycleX Security Hub —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –∏ —á–∏—Ç–∞–µ—Ç –ø—É–±–ª–∏—á–Ω—ã–µ –æ–Ω—á–µ–π–Ω-–¥–∞–Ω–Ω—ã–µ.",
    footer_tagline: "–ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –¥–≤–∞–∂–¥—ã. –ü–æ–¥–∫–ª—é—á–∞–π—Ç–µ—Å—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–æ–≤–µ—Ä—è–µ—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü–µ.",
    // --- ADD THESE KEYS (RU) ---
title_back_to_cyclex: "–ù–∞–∑–∞–¥ –∫ CycleX",
aria_lang_selector: "–í—ã–±–æ—Ä —è–∑—ã–∫–∞",
badge_table: "–¢–∞–±–ª–∏—Ü–∞",
btn_share_x: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –≤ X",
btn_share_tg: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –≤ Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "–≠—Ñ–∏—Ä–∏—É–º",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π‚Ä¶",

th_token: "–¢–æ–∫–µ–Ω",
th_allowance: "–õ–∏–º–∏—Ç",
th_symbol: "–°–∏–º–≤–æ–ª",
th_action: "–î–µ–π—Å—Ç–≤–∏–µ",
th_rpc: "RPC",
th_ms: "–º—Å",
th_chain: "—Å–µ—Ç—å",
th_block: "–±–ª–æ–∫",
th_call: "call",
th_logs: "–ª–æ–≥–∏",
th_status: "—Å—Ç–∞—Ç—É—Å",
th_contract: "–ö–æ–Ω—Ç—Ä–∞–∫—Ç",
th_network: "–°–µ—Ç—å",
th_last_seen: "–ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑",
th_remove: "–£–¥–∞–ª–∏—Ç—å",
    bm_tip: "–î–æ–±–∞–≤—å—Ç–µ –±—É–∫–º–∞—Ä–∫–ª–µ—Ç –≤ –±—Ä–∞—É–∑–µ—Ä –∏ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –ª—é–±–æ–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç —Å –ª—é–±–æ–≥–æ —Å–∞–π—Ç–∞ –æ–¥–Ω–∏–º –∫–ª–∏–∫–æ–º.",
bm_drag_label: "CycleX ‚Äì Security Hub",

qs_ready_html: "<strong>–ì–æ—Ç–æ–≤–æ.</strong><br>–í—Å—Ç–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞ –∏ –Ω–∞–∂–º–∏—Ç–µ <b>–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å</b>.",
liq_ready_html: "<strong>–ì–æ—Ç–æ–≤–æ.</strong><br>–í—Å—Ç–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞ –∏ –Ω–∞–∂–º–∏—Ç–µ <b>–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å</b>.",
tx_ready_html: "<strong>–ì–æ—Ç–æ–≤–æ.</strong><br>–í—Å—Ç–∞–≤—å—Ç–µ tx hash –∏ –Ω–∞–∂–º–∏—Ç–µ <b>–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (–ª–æ–∫–∞–ª—å–Ω–æ)",
ph_unified_key: "Unified API Key (–ª–æ–∫–∞–ª—å–Ω–æ)",
ph_etherscan_key: "Etherscan API key (–ª–æ–∫–∞–ª—å–Ω–æ)",
ph_rpc_private: "https://... (—Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–æ)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º"

  }
};
// =========================
// i18n (after translations)
// =========================
let currentLang = "en";
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

function normalizeLang(x){
  const v = String(x || "").trim().toLowerCase();
  const map = { "cn":"zh", "zh-cn":"zh", "zh-hans":"zh" };
  return map[v] || v;
}

function setDirForLang(lang) {
  const html = document.documentElement;
  html.setAttribute("lang", lang === "zh" ? "zh" : lang);
  html.setAttribute("dir", lang === "ar" ? "rtl" : "ltr");
}

// ‚úÖ t(lang,key) with EN fallback
function t(lang, key) {
  return (translations?.[lang]?.[key] ?? translations?.en?.[key] ?? "");
}

function applyI18n(lang) {
  const L = normalizeLang(lang || currentLang);
  currentLang = translations?.[L] ? L : "en";

  if (document.body) {
    document.body.classList.add("lang-switching");
    setTimeout(() => document.body && document.body.classList.remove("lang-switching"), 260);
  }

  // normal text/HTML
  $$("[data-i18n]").forEach((el) => {
    const key = el.getAttribute("data-i18n");
    const val = t(currentLang, key);
    if (val) el.innerHTML = val;
  });

  // placeholders
  $$("[data-i18n-placeholder]").forEach((el) => {
    const key = el.getAttribute("data-i18n-placeholder");
    const val = t(currentLang, key);
    if (val) el.setAttribute("placeholder", val);
  });

  // title attr
  $$("[data-i18n-title]").forEach((el) => {
    const key = el.getAttribute("data-i18n-title");
    const val = t(currentLang, key);
    if (val) el.setAttribute("title", val);
  });

  // aria-label attr
  $$("[data-i18n-aria-label]").forEach((el) => {
    const key = el.getAttribute("data-i18n-aria-label");
    const val = t(currentLang, key);
    if (val) el.setAttribute("aria-label", val);
  });

  setDirForLang(currentLang);

  // keep your existing behavior
  try { renderWalletLabels && renderWalletLabels(); } catch {}
}

function setLang(lang) {
  const picked = normalizeLang(lang);
  currentLang = translations?.[picked] ? picked : "en";

  try { localStorage.setItem("cx_sec_lang", currentLang); } catch {}

  $$(".lang-btn").forEach((b) => {
    const bl = normalizeLang(b.dataset?.lang || b.getAttribute("data-lang") || "");
    b.classList.toggle("active", bl === currentLang);
  });

  applyI18n(currentLang);
}

function initLang() {
  let saved = null;
  try { saved = localStorage.getItem("cx_sec_lang"); } catch {}

  const s = normalizeLang(saved);
  setLang(translations?.[s] ? s : "en");
}

// =========================
// i18n buttons wiring (FIX)
// =========================
function bindLangButtons(){
  $$(".lang-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      try { e.preventDefault(); } catch {}

      const raw = btn.dataset?.lang || btn.getAttribute("data-lang") || "";
      const lang = normalizeLang(raw);

      setLang(lang);
      try { gtagEvent && gtagEvent("sec_lang_change", { lang }); } catch {}
    }, { passive: false });
  });
}
    // =========================
    // Utils (dedup, single source of truth)
    // =========================
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const nowTs = () => Math.floor(Date.now() / 1000);

    const DEAD = "0x000000000000000000000000000000000000dEaD";
    const ZERO = "0x0000000000000000000000000000000000000000";

    function shortAddr(a) {
      return (!a || typeof a !== "string") ? "‚Äî" : `${a.slice(0, 6)}‚Ä¶${a.slice(-4)}`;
    }
    function safeJson(obj) {
      try { return JSON.stringify(obj, null, 2); } catch { return "{}"; }
    }
    function isAddr(x){
      try { return E.isAddress(String(x||"").trim()); } catch { return false; }
    }
    function normAddr(x){
      return E.getAddress(String(x||"").trim());
    }
    function isBurnAddr(a){
      if (!a) return false;
      const z = String(a).toLowerCase();
      return z === ZERO.toLowerCase() || z === DEAD.toLowerCase();
    }
    function dnaFormatLastUpdated(ts) {
  const s = String(ts ?? "").trim();
  if (!s || s === "‚Äî") return `<span class="muted">‚Äî</span>`;

  const d = new Date(s);
  if (!isNaN(d.getTime())) {
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mi = String(d.getMinutes()).padStart(2, "0");
    const nice = `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    return `<span class="mono" title="${window.escapeHtml(s)}">${window.escapeHtml(nice)}</span>`;
  }

  return `<span class="mono">${window.escapeHtml(s)}</span>`;
}


    async function copyText(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
          return true;
        } catch {
          return false;
        }
      }
    }
    function dnaEscAttr(s){
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}


    function setStatus(el, type, html) {
      if (!el) return;
      el.classList.remove("ok", "warn", "bad", "info");
      el.classList.add(type);
      el.style.display = "block";
      el.innerHTML = html;
    }
    function clearStatus(el) {
      if (!el) return;
      el.style.display = "none";
      el.innerHTML = "";
      el.classList.remove("ok", "warn", "bad", "info");
    }

    function gtagEvent(name, params = {}) {
      try { if (typeof window.gtag === "function") window.gtag("event", name, params); } catch {}
    }

    function parseQuery() {
      const u = new URL(location.href);
      return {
        tool: (u.searchParams.get("tool") || "").toLowerCase(),
        net: (u.searchParams.get("net") || "").toLowerCase(),
        token: (u.searchParams.get("token") || ""),
        tx: (u.searchParams.get("tx") || "")
      };
    }

    // =========================
    // Panels / Tiles
    // =========================
    let toolCards = [];
    let panels = {};

    function initPanels() {
      toolCards = $$("#toolGrid .tool-card");
      panels = {
        quick: $("#panel-quick"),
        liq: $("#panel-liq"),
        approvals: $("#panel-approvals"),
        rpc: $("#panel-rpc"),
        tx: $("#panel-tx"),
        dev: $("#panel-dev")
      };

      function showPanel(key) {
        Object.entries(panels).forEach(([k, el]) => {
          if (el) el.classList.toggle("hidden", k !== key);
        });
        toolCards.forEach((c) => c.classList.toggle("active", c.dataset.tool === key));
        if (key) gtagEvent("sec_tool_open", { tool: key });
      }
      window.showPanel = showPanel;

      toolCards.forEach((card) => card.addEventListener("click", () => showPanel(card.dataset.tool)));

      $("#btnCloseQuick")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseLiq")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseApprovals")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseRpc")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseTx")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseDev")?.addEventListener("click", () => showPanel(null));

      $("#btn-quick")?.addEventListener("click", () => {
        showPanel("quick");
        $("#qs-token")?.focus();
        gtagEvent("sec_quick_btn");
      });
    }

    // =========================
    // Wallet (AppKit) ‚Äî single global state
    // =========================
    const wallet = {
      providerRaw: null,     // EIP-1193
      browserProvider: null, // ethers BrowserProvider
      signer: null,
      address: "",
      chainId: 0
    };
    window.wallet = wallet;
window.__wallet = wallet; 


    function renderWalletLabels() {
      const notConn = t(currentLang, "wallet_not_connected") || "not connected";
      const labelTxt = wallet.address ? wallet.address : notConn;

      const w1 = $("#walletLabel");
      if (w1) w1.textContent = labelTxt;

      const w2 = $("#ap-wallet");
      if (w2) w2.textContent = labelTxt;

      const w3 = $("#liq-wallet");
      if (w3) w3.textContent = labelTxt;

      const w4 = $("#ap-address");
      if (w4) w4.textContent = wallet.address ? shortAddr(wallet.address) : "‚Äî";
    }

    function attachProviderListeners(p) {
      try {
        if (!p || typeof p.on !== "function") return;
        p.removeAllListeners?.("accountsChanged");
        p.removeAllListeners?.("chainChanged");

        p.on("accountsChanged", async (accs) => {
          const a = (accs && accs[0]) ? E.getAddress(accs[0]) : "";
          wallet.address = a;
          renderWalletLabels();
        });

        p.on("chainChanged", async (hex) => {
          try { wallet.chainId = Number(hex); } catch { wallet.chainId = 0; }
          renderWalletLabels();
        });
      } catch {}
    }

    async function cxConnectWallet({ silent = false } = {}) {
      const stQuick = $("#qs-status");
if (wallet?.address && wallet?.signer && (wallet?.providerRaw || wallet?.browserProvider)) {
  renderWalletLabels();
  if (!silent) setStatus(stQuick, "ok", `Wallet already connected: <span class="mono">${wallet.address}</span>`);
  try { await window.CxAppKitModal?.close?.(); } catch {}
  return true;
}

if (silent) return false;

      try {
  if (!silent) {
    await window.CxAppKitModal?.open?.({ view: "ConnectWallet" });
  }

  const providerRaw = await waitForWalletProvider(12000);
  if (!providerRaw) {
    if (!silent) setStatus(stQuick, "warn", "Wallet provider not ready (timeout). Try again.");
    try { await window.CxAppKitModal?.close?.(); } catch {}
    return false;
  }

  wallet.providerRaw = providerRaw;
  attachProviderListeners(providerRaw);

  const bp = new E.BrowserProvider(providerRaw);
  wallet.browserProvider = bp;

  const signer = await bp.getSigner();
  wallet.signer = signer;

  const addr = await signer.getAddress();
  const net = await bp.getNetwork();

  wallet.address = E.getAddress(addr);
  wallet.chainId = Number(net.chainId || 0);

  renderWalletLabels();
  if (!silent) setStatus(stQuick, "ok", `Wallet connected: <span class="mono">${wallet.address}</span>`);
  gtagEvent("sec_wallet_connected", { chainId: wallet.chainId });

  return true;

} catch (e) {
  try { await window.CxAppKitModal?.close?.(); } catch {}
  if (!silent) setStatus(stQuick, "bad", `Wallet connect failed: ${String(e?.message || e)}`);
  return false;
}


    }
window.cxConnectWallet = cxConnectWallet;
window.connectWallet = cxConnectWallet;


    async function ensureChain(targetChainId) {
      const p = wallet.providerRaw;
      if (!p?.request) return false;
      try {
        await p.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: "0x" + Number(targetChainId).toString(16) }]
        });
        await cxConnectWallet({ silent: true });
        return true;
      } catch {
        return false;
      }
    }

    function initWalletButtons() {
      $("#btn-connect")?.addEventListener("click", async () => { await cxConnectWallet(); });
      $("#ap-connect")?.addEventListener("click", async () => { await cxConnectWallet(); });
    }

    // =========================
    // Explorer API keys (local)
    // =========================
    const LS_KEYS = "cx_sec_explorer_keys";
    function loadApiKeys() {
    try {
    const raw = localStorage.getItem(LS_KEYS);
    if (!raw) return { use: false, unified: "", bscscan: "", etherscan: "" };

    const o = JSON.parse(raw) || {};
    return {
      use: !!o.use,
      unified: String(o.unified || "").trim(),
      bscscan: String(o.bscscan || "").trim(),
      etherscan: String(o.etherscan || "").trim()
    };
  } catch {
    return { use: false, unified: "", bscscan: "", etherscan: "" };
  }
}

    function saveApiKeys(keys) {
  try { localStorage.setItem(LS_KEYS, JSON.stringify(keys || {})); } catch {}
}
    
    function initApiKeysUi() {
      const keys = loadApiKeys();
      const useEl = $("#api-use"); if (useEl) useEl.checked = keys.use;
      const b1 = $("#api-bscscan"); if (b1) b1.value = keys.bscscan;
      const b2 = $("#api-etherscan"); if (b2) b2.value = keys.etherscan;
      const u1 = $("#api-unified"); if (u1) u1.value = keys.unified || "";

      $("#api-save")?.addEventListener("click", () => {
        const nk = {
        use: !!$("#api-use")?.checked,
        unified: ($("#api-unified")?.value || "").trim(),   
        bscscan: ($("#api-bscscan")?.value || "").trim(),   
        etherscan: ($("#api-etherscan")?.value || "").trim()
      };
        saveApiKeys(nk);
        setStatus($("#qs-status"), "ok", "Saved keys to localStorage.");
        gtagEvent("sec_keys_saved", { use: nk.use ? 1 : 0 });
      });

      $("#api-clear")?.addEventListener("click", () => {
        saveApiKeys({ use: false, unified: "", bscscan: "", etherscan: "" });
        const iu = $("#api-unified"); if (iu) iu.value = "";
        const u = $("#api-use"); if (u) u.checked = false;
        const i1 = $("#api-bscscan"); if (i1) i1.value = "";
        const i2 = $("#api-etherscan"); if (i2) i2.value = "";
        setStatus($("#qs-status"), "ok", "Cleared keys.");
        gtagEvent("sec_keys_cleared");
      });
    }

    // =========================
    // Network config (‚úÖ fix ETH everywhere)
    // =========================
    const CHAINS = {
      bsc: {
        chainId: 56,
        name: "BSC",
        wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
        usdt: "0x55d398326f99059ff775485246999027b3197955",
        explorer: "https://bscscan.com",
        addressUrl: (a) => `https://bscscan.com/address/${a}`,
        txUrl: (h) => `https://bscscan.com/tx/${h}`,
        publicRpcs: [
  "https://bsc-rpc.publicnode.com",
  "https://bsc.publicnode.com",
  "https://bsc-dataseed1.bnbchain.org",
  "https://bsc-dataseed2.bnbchain.org",
          "https://bsc-rpc.publicnode.com",
          "https://1rpc.io/bnb",
          "https://endpoints.omniatech.io/v1/bsc/mainnet/",
          "https://api-bsc-mainnet-full.dwellir.com/",
          "https://binance.llamarpc.com",
          "https://bsc.meowrpc.com",
  "https://bsc-dataseed3.bnbchain.org",
  "https://bsc-dataseed4.bnbchain.org",
  "https://bsc-dataseed1.ninicoin.io",
  "https://bsc-dataseed2.ninicoin.io",
  "https://bsc-dataseed3.ninicoin.io",
  "https://bsc-dataseed4.ninicoin.io",
  "https://bsc-mainnet.gateway.pokt.network/v1/lb/6136201a7bad1500343e248d",
  "https://binance.nodereal.io",
  "https://rpc.ankr.com/bsc",
  "https://bsc.rpc.blxrbdn.com"
]

      },

      eth: {
        chainId: 1,
        name: "Ethereum",
        wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        usdt: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        explorer: "https://etherscan.io",
        addressUrl: (a) => `https://etherscan.io/address/${a}`,
        txUrl: (h) => `https://etherscan.io/tx/${h}`,
        publicRpcs: [
          "https://cloudflare-eth.com",
          "https://rpc.ankr.com/eth",
          "https://ethereum.publicnode.com",
          "https://eth.llamarpc.com"
        ]
      }
    };

    const DEX = {
      bsc: {
        v2Factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73",
        v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865",
        routerV2: "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        label: "PancakeSwap"
      },
      eth: {
        v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
        v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
        routerV2: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
        label: "Uniswap"
      }
    };

    // =========================
    // ABIs (minimal) ‚Äî ‚úÖ V3 token0/token1 added
    // =========================
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)"
    ];

    const V2_FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];
    const V2_PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const V3_FACTORY_ABI = [
      "function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)"
    ];
    const V3_POOL_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function liquidity() view returns (uint128)",
      "function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked)"
    ];

    const TRANSFER_TOPIC0 = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
    const APPROVAL_TOPIC0 = "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";

    // =========================
    // Local storage keys
    // =========================
    const LS_BEST_RPC = (net) => `cx_sec_best_rpc_${net}`;
    const LS_PRIV_RPC = (net) => `cx_sec_private_rpc_${net}`;
    const LS_QS_CACHE = "cx_sec_qs_cache_v2";
    const LS_QS_HISTORY = "cx_sec_qs_history_v1";
    const LS_MON = "cx_sec_monitor_v1";

    // =========================
    // Unified RPC layer (‚úÖ item #1 + #2)
    // =========================
    function uniq(arr) {
      const s = new Set();
      const out = [];
      for (const x of arr) {
        const k = String(x || "").trim();
        if (!k) continue;
        if (s.has(k)) continue;
        s.add(k);
        out.push(k);
      }
      return out;
    }

    function getSavedBestRpc(net) {
      try { return localStorage.getItem(LS_BEST_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedBestRpc(net, url) {
      try { localStorage.setItem(LS_BEST_RPC(net), url); } catch {}
    }

    function getSavedPrivateRpc(net) {
      try { return localStorage.getItem(LS_PRIV_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedPrivateRpc(net, url) {
      try { localStorage.setItem(LS_PRIV_RPC(net), url); } catch {}
    }

    async function rpcRequest(url, method, params = [], timeoutMs = 9000) {
      const ctrl = new AbortController();
      const tmr = setTimeout(() => ctrl.abort(), timeoutMs);
      const body = JSON.stringify({ jsonrpc: "2.0", id: 1, method, params });

      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body,
          signal: ctrl.signal
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const j = await res.json();
        if (j.error) throw new Error(j.error.message || "RPC error");
        return j.result;
      } finally {
        clearTimeout(tmr);
      }
    }

    function buildRpcCandidates(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const privSaved = getSavedPrivateRpc(net);
      const privInput = ($("#rpc-private")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      return uniq([custom, privInput, privSaved, bestSaved, ...(chain?.publicRpcs || [])]);
    }

    const _providerCache = new Map(); // key: net|url
    function getProviderForUrl(net, url){
  const key = `${net}|${url}`;
  if (_providerCache.has(key)) return _providerCache.get(key);

  const n = E.Network.from({
  name: CHAINS[net].name.toLowerCase(),
  chainId: CHAINS[net].chainId
});
const p = new E.JsonRpcProvider(url, n, { staticNetwork: n });


  _providerCache.set(key, p);
  return p;
}


    async function withRpcFallback(net, fn, { timeoutMs = 9500, preferUrls = null } = {}) {
      const urls = preferUrls && preferUrls.length ? preferUrls : buildRpcCandidates(net);
      let lastErr = null;
      for (const url of urls) {
        try {
          const provider = getProviderForUrl(net, url);
          const res = await Promise.race([
            fn(provider, url),
            new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), timeoutMs))
          ]);
          return { ok: true, url, res };
        } catch (e) {
          lastErr = e;
          continue;
        }
      }
      return { ok: false, url: "", err: lastErr || new Error("All RPCs failed") };
    }

    async function getCodeSafe(net, addr){
      const a = normAddr(addr);
      // Use raw eth_getCode (faster + abortable) with fallback
      const urls = buildRpcCandidates(net);
      let last = null;
      for (const url of urls) {
        try {
          const code = await rpcRequest(url, "eth_getCode", [a, "latest"], 9000);
          if (typeof code === "string") {
            // mark as ‚Äúbest‚Äù if it works well
            return { ok: true, url, code };
          }
        } catch (e) { last = e; }
      }
      return { ok: false, url: "", err: last || new Error("eth_getCode failed"), code: "0x" };
    }

    function getReadProvider(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      const privSaved = getSavedPrivateRpc(net);
      const url = custom || privSaved || bestSaved || (chain?.publicRpcs?.[0] || "");
      if (!url) return null;
      try { return new E.JsonRpcProvider(url, chain.chainId); } catch { return null; }
    }
    // --- Debug exports (safe) ---
window.CX = window.CX || {};
window.CX.getReadProvider = getReadProvider;


    function netFromSelect(selId) {
      const v = ($(selId)?.value || "bsc").toLowerCase();
      return (v === "eth") ? "eth" : "bsc";
    }

    // =========================
    // Explorer API (optional)
    // =========================
    function explorerApiBase(net) {
  return net === "bsc" ? "https://api.bscscan.com/api" : "https://api.etherscan.io/api";
}

async function explorerGetSource(net, addr, apiKey, isUnified) {
  const keyTrim = String(apiKey || "").trim();

  const v2Base = "https://api.etherscan.io/v2/api";
  const chainid = (net === "bsc") ? "56" : "1"; 

  const useV2 = !!isUnified; 

  const u = new URL(useV2 ? v2Base : explorerApiBase(net));
  if (useV2) u.searchParams.set("chainid", chainid);

  u.searchParams.set("module", "contract");
  u.searchParams.set("action", "getsourcecode");
  u.searchParams.set("address", addr);
  if (keyTrim) u.searchParams.set("apikey", keyTrim);

  const r = await fetch(u.toString());
  const j = await r.json().catch(() => null);
  if (!j || j.status !== "1" || !j.result || !j.result[0]) return { ok: false, raw: j };

  const row = j.result[0];

  const abiRaw = String(row.ABI || "").trim();
  const isVerified =
    !!abiRaw &&
    abiRaw !== "Contract source code not verified" &&
    abiRaw !== "[]" &&
    abiRaw.startsWith("[");

  let abiJson = null;
  if (isVerified) {
    try { abiJson = JSON.parse(abiRaw); } catch { abiJson = null; }
  }

  const isProxy = String(row.Proxy || row.proxy || "").trim() === "1";
  const impl = String(row.Implementation || row.implementation || "").trim();
  const contractName = String(row.ContractName || row.contractName || "").trim();

  return {
    ok: true,
    verified: isVerified,
    abi: abiJson,
    isProxy,
    implementation: impl,
    contractName,
    raw: row
  };
}



    // =========================
    // Formatting helpers
    // =========================
    function fmtNum(x, digits = 2){
      const n = Number(x);
      if (!Number.isFinite(n)) return "‚Äî";
      const d = clamp(digits, 0, 8);
      return n.toLocaleString(undefined, { maximumFractionDigits: d });
    }
    function fmtBig(bn, decimals = 18, digits = 4){
      try {
        const v = Number(E.formatUnits(bn, decimals));
        if (!Number.isFinite(v)) return "‚Äî";
        return fmtNum(v, digits);
      } catch { return "‚Äî"; }
    }
    function looksInfiniteAllowance(v){
      try {
        // ethers v6 returns bigint
        const x = BigInt(v);
        return x > (BigInt(2) ** BigInt(255)); // "practically infinite"
      } catch { return false; }
    }
    function safeLower(x){ return String(x || "").toLowerCase(); }

// =========================
// Quick Scan (client-only) ‚úÖ FIXED: no collisions, no TDZ, clean table
// =========================
(function () {
  "use strict";

  // ‚úÖ Unique LS keys (avoid collisions with other features)
  const QS_LS_CACHE    = "cx_sec_qs_cache_safe_v6";
  const QS_LS_HISTORY  = "cx_sec_qs_history_safe_v6";
  const QS_LS_API_KEYS = "cx_sec_explorer_keys"; // {use,bscscan,etherscan} if exists

  // EIP-1967 implementation slot
  const EIP1967_IMPL_SLOT =
    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";

  // Minimal ABIs (self-contained ‚Äî does NOT depend on Liquidity Scan script)
  const ERC20_MIN_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)"
  ];
  const OWNER_ABI = ["function owner() view returns (address)"];
  const PAUSABLE_ABI = ["function paused() view returns (bool)"];

  // V2/V3 minimal ABIs for the small liquidity table
  const QS_V2_FACTORY_ABI = ["function getPair(address,address) view returns (address)"];
  const QS_V2_PAIR_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function getReserves() view returns (uint112,uint112,uint32)"
  ];
  const QS_V3_FACTORY_ABI = ["function getPool(address,address,uint24) view returns (address)"];
  const QS_V3_POOL_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function liquidity() view returns (uint128)",
    "function slot0() view returns (uint160,int24,uint16,uint16,uint16,uint8,bool)"
  ];

  // PUSH4 selector scan (bytecode heuristic)
  const SEL = {
    mint: ["40c10f19", "a0712d68"],         // mint(address,uint256), mint(uint256)
    pause: ["8456cb59"],                   // pause()
    unpause: ["3f4ba83a"],                 // unpause()
    paused: ["5c975abb"],                  // paused()
    owner: ["8da5cb5b"],                   // owner()
    transferOwnership: ["f2fde38b"]         // transferOwnership(address)
  };

  const DEAD_ADDRESSES = new Set([
    "0x0000000000000000000000000000000000000000",
    "0x000000000000000000000000000000000000dead"
  ]);

  // QuickScan DEX targets (single ‚Äúmain‚Äù DEX for the compact table)
  const QS_NET = {
    bsc: {
      name: "BSC (BNB Chain)",
      wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // WBNB
      usdt:    "0x55d398326f99059fF775485246999027B3197955", // USDT (BSC)
      v2Factory: "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73", // Pancake V2
      v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865", // Pancake V3
      addressUrl: (a)=> `https://bscscan.com/address/${a}`
    },
    eth: {
      name: "Ethereum",
      wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
      usdt:    "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT (ETH)
      v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", // Uniswap V2
      v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984", // Uniswap V3
      addressUrl: (a)=> `https://etherscan.io/address/${a}`
    }
  };

  // -------------------------
  // Tiny safe helpers (local)
  // -------------------------
  function qsLower(x) { return String(x || "").toLowerCase(); }
  function qsClamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function qsNowTs() { return Math.floor(Date.now() / 1000); }

  function qsEscapeHtml(s){
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function qsIsAddr(a){
    try {
      if (typeof isAddr === "function") return !!isAddr(a);
      if (typeof E !== "undefined" && E?.isAddress) return E.isAddress(a);
    } catch {}
    return false;
  }
  function qsNormAddr(a){
    try {
      if (typeof normAddr === "function") return normAddr(a);
      if (typeof E !== "undefined" && E?.getAddress) return E.getAddress(a);
    } catch {}
    return String(a || "");
  }
  function qsShortAddr(a){
    try { if (typeof shortAddr === "function") return shortAddr(a); } catch {}
    const s = String(a || "");
    return s.length > 12 ? (s.slice(0, 6) + "‚Ä¶" + s.slice(-4)) : s;
  }

  function qsFmtNum(x, digits = 2){
    const n = Number(x);
    if (!Number.isFinite(n)) return "‚Äî";
    const d = qsClamp(digits, 0, 8);
    try { return n.toLocaleString(undefined, { maximumFractionDigits: d }); } catch { return String(n); }
  }
  function qsFmtBig(bn, decimals = 18, digits = 4){
    try {
      if (typeof E === "undefined" || !E?.formatUnits) return "‚Äî";
      const v = Number(E.formatUnits(bn, decimals));
      if (!Number.isFinite(v)) return "‚Äî";
      return qsFmtNum(v, digits);
    } catch { return "‚Äî"; }
  }

  function loadQsCache(){
    try { return JSON.parse(localStorage.getItem(QS_LS_CACHE) || "{}"); } catch { return {}; }
  }
  function saveQsCache(obj){
    try { localStorage.setItem(QS_LS_CACHE, JSON.stringify(obj || {})); } catch {}
  }
  function loadQsHistory(){
    try { return JSON.parse(localStorage.getItem(QS_LS_HISTORY) || "[]"); } catch { return []; }
  }
  function saveQsHistory(arr){
    try { localStorage.setItem(QS_LS_HISTORY, JSON.stringify(arr || [])); } catch {}
  }

  function qsCacheKey(net, token, requireLiq, useApis){
    return `${net}:${qsLower(token)}:${requireLiq ? 1 : 0}:${useApis ? 1 : 0}`;
  }
  function addQsHistory(net, token){
    try{
      const arr = loadQsHistory();
      const key = `${net}:${qsLower(token)}`;
      const filtered = arr.filter(x => x?.key !== key);
      filtered.unshift({ key, net, token: qsNormAddr(token), ts: qsNowTs() });
      saveQsHistory(filtered.slice(0, 80));
    } catch {}
  }
  function qsBuildShareLink(net, token){
    const u = new URL(location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", net);
    u.searchParams.set("token", token);
    return u.toString();
  }

 // ‚úÖ safe explorer key read
function qsExplorerKeyFor(net){
  // 1) optional legacy helper
  try{
    if (typeof explorerKeyFor === "function") {
      const k = String(explorerKeyFor(net) || "").trim();
      return { key: k, isUnified: false };
    }
  } catch {}

  // 2) localStorage (V2 unified first, then per-net)
  try{
    const raw = localStorage.getItem(QS_LS_API_KEYS) || "";
    if (!raw) return { key: "", isUnified: false };

    const o = JSON.parse(raw) || {};

    // ‚úÖ FIRST: if user disabled API usage
    if (typeof o.use === "boolean" && o.use === false) {
      return { key: "", isUnified: false };
    }

    // ‚úÖ THEN: unified key has priority
    const unified = String(o.unified || "").trim();
    if (unified) return { key: unified, isUnified: true };

    // ‚úÖ fallback: per-network keys
    if (net === "bsc") return { key: String(o.bscscan || "").trim(), isUnified: false };
    if (net === "eth") return { key: String(o.etherscan || "").trim(), isUnified: false };

    return { key: "", isUnified: false };
  } catch {
    return { key: "", isUnified: false };
  }
}
  // ‚úÖ UI (TEMP) explorer key read (no-save)
// Supports unified V2 key OR per-network keys if present in the UI.
function qsUiExplorerKeyFor(net){
  try{
    const unifiedEl = $("#api-unified");
    const bscEl = $("#api-bscscan");
    const ethEl = $("#api-etherscan");

    const unified = String(unifiedEl?.value || "").trim();
    if (unified) return { key: unified, isUnified: true };

    if (net === "bsc") {
      const k = String(bscEl?.value || "").trim();
      if (k) return { key: k, isUnified: false };
    }
    if (net === "eth") {
      const k = String(ethEl?.value || "").trim();
      if (k) return { key: k, isUnified: false };
    }

    return { key: "", isUnified: false };
  } catch {
    return { key: "", isUnified: false };
  }
}



  // Chip UI
  function qsMiniChip(type, title, value){
    const map = { ok:"ok", warn:"warn", bad:"bad", info:"warn" };
    const cls = map[type] || "warn";
    return `<div class="risk ${cls}"><span class="dot"></span><span><b>${qsEscapeHtml(title)}</b> ‚Äî ${qsEscapeHtml(value)}</span></div>`;
  }

  function codeHasSelector(bytecode, selHex){
    try{
      const code = qsLower(bytecode || "");
      const sel = qsLower(selHex || "").replace(/^0x/,"");
      if (!sel || sel.length !== 8) return false;
      return code.includes("63" + sel); // PUSH4 <selector>
    } catch { return false; }
  }
  function anySelector(bytecode, sels){
    for (const s of (sels || [])) if (codeHasSelector(bytecode, s)) return true;
    return false;
  }

  async function tryReadOwner(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return "";
    try{
      const c = new E.Contract(token, OWNER_ABI, read);
      const o = await c.owner();
      return qsIsAddr(o) ? qsNormAddr(o) : "";
    } catch { return ""; }
  }

  async function tryReadPaused(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return null;
    try{
      const c = new E.Contract(token, PAUSABLE_ABI, read);
      const p = await c.paused();
      return !!p;
    } catch { return null; }
  }

  async function tryEip1967Impl(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return "";
    try{
      const raw = await read.getStorage(token, EIP1967_IMPL_SLOT);
      const hex = String(raw || "0x");
      if (!hex || hex === "0x") return "";
      const addr = "0x" + hex.slice(-40);
      if (!qsIsAddr(addr)) return "";
      const norm = qsNormAddr(addr);
      if (qsLower(norm) === "0x0000000000000000000000000000000000000000") return "";
      return norm;

    } catch { return ""; }
  }

  // =========================
  // Compact Liquidity table (ONLY QuickScan)
  // - shows ONLY existing pairs/pools (reduces rows)
  // - does NOT touch Liquidity Scan panel
  // =========================
  const QS_ERC20_META_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)"
  ];
  const _qsErc20MetaCache = new Map();

  function _qsToBI(x){
    try { return (typeof x === "bigint") ? x : BigInt(x); } catch { return 0n; }
  }
  async function _qsGetErc20Meta(addr, provider){
    const key = String(addr || "").toLowerCase();
    if (_qsErc20MetaCache.has(key)) return _qsErc20MetaCache.get(key);

    const c = new E.Contract(addr, QS_ERC20_META_ABI, provider);
    let decimals = 18;
    let symbol = qsShortAddr(addr);

    try { decimals = Number(await c.decimals()); } catch {}
    try {
      const s = await c.symbol();
      if (s && String(s).trim()) symbol = String(s).trim();
    } catch {}

    const meta = { decimals, symbol };
    _qsErc20MetaCache.set(key, meta);
    return meta;
  }

  function _qsCompactDecimalString(str, dp = 2){
    if (str == null) return "0";
    let s = String(str).trim();
    if (!s) return "0";

    let neg = false;
    if (s[0] === "-") { neg = true; s = s.slice(1); }

    const parts = s.split(".");
    let intp = (parts[0] || "0").replace(/^0+(?=\d)/, "");
    const frac = parts[1] || "";

    const len = intp.length;
    let pow = 0, suf = "";
    if (len >= 16) { pow = 15; suf = "Q"; }
    else if (len >= 13) { pow = 12; suf = "T"; }
    else if (len >= 10) { pow = 9;  suf = "B"; }
    else if (len >= 7)  { pow = 6;  suf = "M"; }
    else if (len >= 4)  { pow = 3;  suf = "K"; }

    if (pow === 0){
      const frac6 = frac.slice(0, 6).replace(/0+$/,"");
      const out = frac6 ? `${intp}.${frac6}` : intp;
      return (neg ? "-" : "") + out;
    }

    const wholeLen = len - pow;
    const whole = intp.slice(0, wholeLen) || "0";
    const rest = intp.slice(wholeLen);

    const dec = (rest + "0".repeat(dp)).slice(0, dp).replace(/0+$/,"");
    const out = dec ? `${whole}.${dec}${suf}` : `${whole}${suf}`;
    return (neg ? "-" : "") + out;
  }

  function _qsFmtUnits(amount, decimals, dp = 2){
    try {
      const s = E.formatUnits(amount, decimals);
      return _qsCompactDecimalString(s, dp);
    } catch {
      return "0";
    }
  }

  async function qsLiqCheckBasic(net, token, provider) {
    const cfg = QS_NET?.[net];
    if (!cfg || !provider) return { any:false, hint:"none", rows:[] };

    const rows = [];
    let any = false;
    const ZERO = "0x0000000000000000000000000000000000000000";

    const targets = [
      { label: "Wrapped", addr: cfg.wrapped },
      { label: "USDT", addr: cfg.usdt }
    ];

    // ---------- V2 ----------
    try {
      const fac = new E.Contract(cfg.v2Factory, QS_V2_FACTORY_ABI, provider);
      for (const t of targets) {
        const pair = await fac.getPair(token, t.addr).catch(()=> ZERO);
if (!pair || pair === ZERO) {
  rows.push({
    type: "V2",
    target: t.label,
    addr: "‚Äî",
    ok: false,
    note: "pair not found"
  });
  continue;
}


        const p = new E.Contract(pair, QS_V2_PAIR_ABI, provider);

        let token0 = token, token1 = t.addr;
        try { token0 = await p.token0(); } catch {}
        try { token1 = await p.token1(); } catch {}

        const [r0Raw, r1Raw] = await p.getReserves().catch(()=> [0n,0n,0n]);
        const r0 = _qsToBI(r0Raw), r1 = _qsToBI(r1Raw);

        const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
        const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

        const ok = (r0 > 0n || r1 > 0n);
        any = any || ok;

        const a0 = _qsFmtUnits(r0, m0.decimals, 2);
        const a1 = _qsFmtUnits(r1, m1.decimals, 2);

        rows.push({
          type: "V2",
          target: t.label,
          addr: pair,
          ok,
          note: ok ? `reserves: ${a0} ${m0.symbol} / ${a1} ${m1.symbol}` : "reserves: 0"
        });
      }
    } catch {
      // ignore (don‚Äôt spam rows)
    }

    // ---------- V3 ----------
    try {
      const fac3 = new E.Contract(cfg.v3Factory, QS_V3_FACTORY_ABI, provider);
      const feeTiers = [500, 3000, 10000];

      for (const t of targets) {
        for (const fee of feeTiers) {
          const pool = await fac3.getPool(token, t.addr, fee).catch(()=> ZERO);
if (!pool || pool === ZERO) {
  rows.push({
    type: `V3 ${fee}`,
    target: t.label,
    addr: "‚Äî",
    ok: false,
    note: "pool not found"
  });
  continue;
}


          const p = new E.Contract(pool, QS_V3_POOL_ABI, provider);

          let token0 = token, token1 = t.addr;
          try { token0 = await p.token0(); } catch {}
          try { token1 = await p.token1(); } catch {}

          const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
          const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

          const c0 = new E.Contract(token0, QS_ERC20_META_ABI, provider);
          const c1 = new E.Contract(token1, QS_ERC20_META_ABI, provider);

          let b0 = 0n, b1 = 0n;
          try { b0 = _qsToBI(await c0.balanceOf(pool)); } catch {}
          try { b1 = _qsToBI(await c1.balanceOf(pool)); } catch {}

          let liq = 0n;
          try { liq = _qsToBI(await p.liquidity()); } catch {}

          const ok = (b0 > 0n || b1 > 0n || liq > 0n);
          any = any || ok;

          const fb0 = _qsFmtUnits(b0, m0.decimals, 2);
          const fb1 = _qsFmtUnits(b1, m1.decimals, 2);

          rows.push({
            type: `V3 ${fee}`,
            target: t.label,
            addr: pool,
            ok,
            note: ok ? `balances: ${fb0} ${m0.symbol} / ${fb1} ${m1.symbol}` : "balances: 0"
          });
        }
      }
    } catch {
      // ignore
    }

    return { any, hint: any ? "V2/V3 pairs exist" : "none", rows };
  }

  function qsRenderLiquidityTable(container, liqRes){
    if (!container) return;

    const rows = (liqRes?.rows || []);
    const body = rows.length ? rows.map(r => `
      <div class="trow ${r.ok ? "highlight" : ""}">
        <div class="cell wrap"><span class="mono">${r.addr ? qsEscapeHtml(qsShortAddr(r.addr)) : "‚Äî"}</span></div>
        <div class="cell">${qsEscapeHtml(r.type)}</div>
        <div class="cell">${qsEscapeHtml(r.target)}</div>
        <div class="cell">${r.ok ? "‚úÖ" : "‚Äî"} ${qsEscapeHtml(r.note || "")}</div>
      </div>
    `).join("") : `
      <div class="trow">
        <div class="cell muted">‚Äî</div>
        <div class="cell muted">‚Äî</div>
        <div class="cell muted">‚Äî</div>
        <div class="cell muted">No pairs/pools detected</div>
      </div>
    `;

    container.innerHTML = `
      <div id="qsLiqTable" class="table">
        <div class="trow head">
          <div class="cell">PAIR/POOL</div>
          <div class="cell">TYPE</div>
          <div class="cell">TARGET</div>
          <div class="cell">RESULT</div>
        </div>
        ${body}
      </div>
    `;
  }

  function qsBuildMarkdownReport(rep){
    const lines = [];
    lines.push(`## Quick Scan ‚Äî ${rep.chainName || rep.net}`);
    lines.push(`Token: \`${rep.token}\``);
    lines.push(`Explorer: ${rep.explorer}`);
    lines.push(`Score: **${rep.score}/100** (${rep.overallText})`);
    lines.push("");
    lines.push(`### Signals`);
    for (const c of (rep.mini || [])) lines.push(`- ${c.title}: ${c.value}`);
    if (rep.redFlags?.length) {
      lines.push("");
      lines.push(`### Red Flags`);
      for (const f of rep.redFlags) lines.push(`- ‚ùó ${f}`);
    }
    lines.push("");
    lines.push(`> ${rep.disclaimer}`);
    return lines.join("\n");
  }

  function qsBuildXText(rep){
    const base = `Quick Scan (${rep.chainName || rep.net})\nToken: ${qsShortAddr(rep.token)}\nScore: ${rep.score}/100 (${rep.overallText})\n`;
    return `${base}${rep.shareLink || ""}`.trim();
  }

  async function runQuickScan(){
    const st = $("#qs-status");
    const out = $("#qs-out");
    const chipsWrap = $("#qs-risk");
    const pairsWrap = $("#qs-pairsWrap");

    clearStatus(st);

    const net = netFromSelect("#qs-net");
    const tokenRaw = ($("#qs-token")?.value || "").trim();
    const requireLiq = !!$("#qs-require-liq")?.checked;
    const uiKey = ($("#api-unified")?.value || "").trim();
    const useApis = !!$("#api-use")?.checked;

    if (!tokenRaw || !qsIsAddr(tokenRaw)) {
      setStatus(st, "warn", "Please paste a valid token address.");
      return;
    }
    const token = qsNormAddr(tokenRaw);

    if (typeof E === "undefined" || !E?.Contract) {
      setStatus(st, "bad", "Ethers not loaded.");
      return;
    }
    if (typeof getReadProvider !== "function") {
      setStatus(st, "bad", "RPC provider missing (getReadProvider not found).");
      return;
    }

    setStatus(st, "info", "Scanning‚Ä¶");

    const cache = loadQsCache();
    const ckey = qsCacheKey(net, token, requireLiq, useApis);
    const cached = cache?.[ckey];

    // ‚úÖ Render is SAFE now (no TDZ vars)
    if (cached?.rep && cached?.ts && (qsNowTs() - cached.ts) < 600) {
      setStatus(st, "ok", "Loaded cached result (‚â§10 min).");
      render(cached.rep);
      return;
    }

    const cfg = QS_NET?.[net];
    const read = getReadProvider(net);
    if (!cfg || !read) {
      setStatus(st, "bad", "No network config / RPC available.");
      return;
    }

    const rep = {
      ts: qsNowTs(),
      net,
      chainName: cfg.name,
      token,
      explorer: cfg.addressUrl(token),
      shareLink: qsBuildShareLink(net, token),
      disclaimer: "Informational checks only. Not an audit. No safety guarantee.",
      score: 0,
      overallText: "Unknown",
      meta: {},
      liq: { any:false, hint:"none", rows:[] },
      mini: [],
      redFlags: [],
      json: ""
    };

    // 1) Bytecode exists
    let code = "0x";
    try {
      if (typeof getCodeSafe === "function") {
        const codeRes = await getCodeSafe(net, token);
        code = codeRes?.code || "0x";
      } else {
        code = await read.getCode(token);
      }
    } catch {}

    const hasCode = !!(code && code !== "0x");
    if (!hasCode) {
      rep.score = 0;
      rep.overallText = "Invalid";
      rep.redFlags.push("No contract code (EOA or invalid address).");
      rep.json = safeJson(rep);
      cache[ckey] = { ts: qsNowTs(), rep };
      saveQsCache(cache);
      addQsHistory(net, token);
      setStatus(st, "bad", "No contract code detected.");
      render(rep);
      return;
    }

    // 2) ERC-20 basics
    let name = "", symbol = "", decimals = 18, totalSupply = 0n;
    try {
      const c = new E.Contract(token, ERC20_MIN_ABI, read);
      const r = await Promise.all([
        c.name().catch(()=> ""),
        c.symbol().catch(()=> ""),
        c.decimals().catch(()=> 18),
        c.totalSupply().catch(()=> 0n)
      ]);
      name = String(r[0] || "");
      symbol = String(r[1] || "");
      decimals = Number(r[2] ?? 18);
      totalSupply = BigInt(r[3] ?? 0n);
      rep.meta = { name, symbol, decimals, totalSupply: totalSupply.toString() };
    } catch {}

    // 3) Liquidity rows (compact table)
    try {
      rep.liq = await qsLiqCheckBasic(net, token, read);
    } catch {}

    // 4) Proxy
    let impl = await tryEip1967Impl(net, token);
    let isProxy = !!impl;

    // 5) Owner
    const owner = await tryReadOwner(net, token);
    const ownerIsRenounced = owner && DEAD_ADDRESSES.has(qsLower(owner));
    const ownerShown = owner ? qsShortAddr(owner) : "No/Unknown";

    // 6) Pause (INFO)
    const pausedState = await tryReadPaused(net, token);
    const pauseDetected =
      (pausedState !== null) ||
      anySelector(code, SEL.pause) ||
      anySelector(code, SEL.unpause) ||
      anySelector(code, SEL.paused);
    const pauseText = pausedState === true ? "Detected (paused)" : pauseDetected ? "Detected" : "No/Unknown";

    // 7) Mint
    const mintDetected = anySelector(code, SEL.mint);

    // 8) Verified (optional)
let verified = null;

if (useApis) {
  const ui = qsUiExplorerKeyFor(net);
  let apiKey = ui.key;
  let isUnified = ui.isUnified;

  if (!apiKey) {
    const k = qsExplorerKeyFor(net);
    apiKey = k.key;
    isUnified = k.isUnified;
  }

  if (typeof explorerGetSource === "function") {
    try {
      const src = await explorerGetSource(net, token, apiKey, isUnified);
      if (src?.ok) {
        verified = (src.verified === true) ? true : (src.verified === false) ? false : null;
        if (!isProxy && src.isProxy) isProxy = true;
        if (!impl && src.implementation) impl = String(src.implementation || "");
      }
    } catch {}
  }

  // B) fallback: direct explorer call (ONLY if still unknown)
  if (verified === null && typeof qsExplorerGetSourceDirect === "function") {
    try {
      const src2 = await qsExplorerGetSourceDirect(net, token, apiKey);
      if (src2?.ok) {
        verified = (src2.verified === true) ? true : (src2.verified === false) ? false : null;
        if (!isProxy && src2.isProxy) isProxy = true;
        if (!impl && src2.implementation) impl = String(src2.implementation || "");
      }
    } catch {}
  }
}

    // Score model
    let score = 75;

    if (rep.liq?.any) score += 10;
    else score -= (requireLiq ? 30 : 20);

    if (mintDetected) score -= 22;

    if (isProxy) score -= 12;
    else score += 3;

    if (!owner) score += 0;
    else if (ownerIsRenounced) score += 5;
    else score -= 6;

    if (verified === true) score += 8;
    if (verified === false) score -= 6;

    if (!symbol && !name) score -= 5;

    score = qsClamp(score, 0, 100);

    const overallText =
      score >= 85 ? "Good" :
      score >= 70 ? "Mixed signals" :
      score >= 50 ? "Caution" :
      "High risk";

    rep.score = score;
    rep.overallText = overallText;

    rep.mini = [
      { type: score >= 85 ? "ok" : score >= 70 ? "warn" : score >= 50 ? "warn" : "bad", title: "Overall", value: overallText },
      { type: verified === true ? "ok" : "warn", title: "Verified", value: verified === true ? "Yes" : "No/Unknown" },
      { type: isProxy ? "warn" : "ok", title: "Proxy", value: isProxy ? "Detected" : "No/Unknown" },
      { type: owner ? (ownerIsRenounced ? "ok" : "warn") : "warn", title: "Owner", value: ownerShown },
      { type: rep.liq?.any ? "ok" : "warn", title: "Liquidity", value: rep.liq?.any ? "V2/V3 pairs exist" : "No/Unknown" },
      { type: mintDetected ? "bad" : "ok", title: "Mint", value: mintDetected ? "Detected" : "No/Unknown" },
      { type: pauseDetected ? "warn" : "ok", title: "Pause", value: pauseText }
    ];

    if (mintDetected) rep.redFlags.push("Mint surface detected (supply risk).");
    if (isProxy) rep.redFlags.push("Proxy detected (upgrade risk).");
    if (!rep.liq?.any) rep.redFlags.push("No clear DEX liquidity signal detected.");

    rep.json = safeJson(rep);

    cache[ckey] = { ts: qsNowTs(), rep };
    saveQsCache(cache);
    addQsHistory(net, token);

    setStatus(st, score >= 70 ? "ok" : score >= 50 ? "warn" : "bad", `Done. Score: <b>${score}/100</b> (${overallText}).`);
    render(rep);
    // ‚úÖ Activity counter: count "High-risk contract" when score is 0..80
try {
  if (typeof cxActivitySend === "function" && Number(score) <= 80) {
    cxActivitySend("high_risk_contract", 1);
  }
} catch {}

    function render(rep){
      const sym = rep.meta?.symbol || "Token";
      const nm = rep.meta?.name ? ` ‚Äî ${rep.meta.name}` : "";

      // ‚úÖ compute supply inside render (no TDZ, safe for cached rep)
      let supplyTxt = "‚Äî";
      try {
        const ts = rep?.meta?.totalSupply;
        const dec = Number(rep?.meta?.decimals ?? 18);
        if (ts != null) supplyTxt = qsFmtBig(BigInt(ts), dec, 4);
      } catch {}

      out.className = "status info";
      out.style.display = "block";
      out.innerHTML = `
        <div style="font-size:18px;font-weight:900;letter-spacing:-0.01em;">
          ${qsEscapeHtml(sym)}${qsEscapeHtml(nm)}
        </div>
        <div class="small" style="margin-top:6px;">
          Network: <b>${qsEscapeHtml(rep.chainName || rep.net)}</b> ‚Ä¢ Score: <b>${rep.score}/100</b> (${qsEscapeHtml(rep.overallText)})
        </div>
        <div class="small" style="margin-top:8px;">
          Token: <span class="mono">${qsEscapeHtml(rep.token)}</span>
        </div>
        <div class="small" style="margin-top:8px;">
          Supply: <span class="mono">${qsEscapeHtml(supplyTxt)}</span>
        </div>
        <div class="small" style="margin-top:8px;">
          Explorer: <a href="${qsEscapeHtml(rep.explorer)}" target="_blank" rel="noopener">open</a>
        </div>
      `;

      if (chipsWrap){
        chipsWrap.innerHTML = (rep.mini || []).map(x => qsMiniChip(x.type, x.title, x.value)).join("");
      }

      if (pairsWrap){
        qsRenderLiquidityTable(pairsWrap, rep.liq);
      }
    }
  }

  function initQuickScanUi(){
    if (window.__cx_qs_bound_v6) return;
    window.__cx_qs_bound_v6 = true;
    
    // ‚úÖ Auto checkbox UX (TEMP key without saving)
// Works for unified OR per-network keys, and supports manual override.
// ‚úÖ Auto checkbox UX (works for unified + per-net, supports manual override)
(function qsBindApiAutoCheckbox(){
  const useEl = $("#api-use");
  if (!useEl) return;

  const unifiedEl = $("#api-unified");   
  const bscEl = $("#api-bscscan");       
  const ethEl = $("#api-etherscan");     
  const netEl = $("#qs-net");

  let userOverrode = false;

  function currentNet(){
    try { return netFromSelect("#qs-net"); } catch { return ""; }
  }

  function hasRelevantKey(){
  const u = String(unifiedEl?.value || "").trim();
  const b = String(bscEl?.value || "").trim();
  const e = String(ethEl?.value || "").trim();
  return !!(u || b || e);
}

  function apply(){
    const hasKey = hasRelevantKey();

    if (!hasKey) {
      useEl.checked = false;
      userOverrode = false;
      return;
    }

    if (!userOverrode) useEl.checked = true;
  }

  apply();

  useEl.addEventListener("change", () => { userOverrode = true; });

  const onInput = () => apply();
  unifiedEl?.addEventListener("input", onInput);
  bscEl?.addEventListener("input", onInput);
  ethEl?.addEventListener("input", onInput);
  netEl?.addEventListener("change", onInput);
})();

    $("#qs-run")?.addEventListener("click", () => {
      runQuickScan();
      try { gtagEvent("sec_qs_run"); } catch {}
    });

    $("#qs-copy-link")?.addEventListener("click", async () => {
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");
      const link = qsBuildShareLink(net, qsNormAddr(token));
      const ok = await copyText(link);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_link"); } catch {}
    });

    $("#qs-copy-json")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const ok = await copyText(rep.json || safeJson(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_json"); } catch {}
    });

    $("#qs-copy-md")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const md = qsBuildMarkdownReport(rep);
      const ok = await copyText(md);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied Markdown report." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_md"); } catch {}
    });

    $("#qs-share-x")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const text = qsBuildXText(rep);
      const u = new URL("https://twitter.com/intent/tweet");
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_x"); } catch {}
    });

    $("#qs-share-tg")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const link = rep.shareLink || qsBuildShareLink(net, qsNormAddr(token));
      const text = qsBuildXText(rep);
      const u = new URL("https://t.me/share/url");
      u.searchParams.set("url", link);
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_tg"); } catch {}
    });

    $("#qs-copy-xtext")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const ok = await copyText(qsBuildXText(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied X text." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_xtext"); } catch {}
    });
  }

  // expose safely
  window.CX_QS_V6 = window.CX_QS_V6 || {};
  window.CX_QS_V6.initQuickScanUi = initQuickScanUi;
  window.CX_QS_V6.runQuickScan = runQuickScan;

  // keep compatibility
  window.initQuickScanUi = initQuickScanUi;
  window.runQuickScan = window.runQuickScan || runQuickScan;


})();


// ‚úÖ Compatibility helper (do NOT remove) ‚Äî used by Liquidity Scan
window.qsRiskChip = window.qsRiskChip || function(type, text){
  const cls = (type === "ok" ? "ok" : type === "bad" ? "bad" : "warn");
  const esc = (s)=> String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  return `<div class="risk ${cls}"><span class="dot"></span><span>${esc(text)}</span></div>`;
};
 // =========================
// Liquidity Scan panel (Multi-DEX Sources) ‚Äî FINAL DROP-IN
// =========================

/**
 * DEX_SOURCES:
 * - v2Factory: UniswapV2-style factory (getPair)
 * - v3Type:
 *    - "univ3"   => UniswapV3-style factory (getPool(tokenA, tokenB, fee))
 *    - "algebra" => Algebra-style factory (poolByPair(tokenA, tokenB))
 *    - "registry"=> not checked (Curve/Balancer style)
 */
const DEX_SOURCES = {
  bsc: [
    { id: "pancake", label: "PancakeSwap", v2Factory: "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73", v3Type: "univ3",  v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865" },
    { id: "apeswap", label: "ApeSwap",      v2Factory: "0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6", v3Type: null,     v3Factory: null },
    { id: "biswap",  label: "BiSwap",       v2Factory: "0x858E3312ed3A876947EA49d572A7C42DE08af7EE", v3Type: null,     v3Factory: null },
    { id: "bakery",  label: "BakerySwap",   v2Factory: "0x01bF7C66c6BD861915CdaaE475042d3c4BaE16A7", v3Type: null,     v3Factory: null },
    { id: "sushi",   label: "SushiSwap",    v2Factory: "0xc35DADB65012eC5796536bD9864eD8773aBc74C4", v3Type: "univ3",  v3Factory: "0x126555dd55a39328F69400d6aE4F782Bd4C34ABb" },
    { id: "thena",   label: "THENA V3 (Algebra)", v2Factory: null, v3Type: "algebra", v3Factory: "0x306F06C147f064A010530292A1EB6737c3e378e4" }
  ],

  eth: [
    { id: "uniswap", label: "Uniswap",     v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", v3Type: "univ3",  v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984" },
    { id: "sushi",   label: "SushiSwap",   v2Factory: "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac", v3Type: "univ3",  v3Factory: "0xbACEB8eC6b9355Dfc0269C18bac9d6E2Bdc29C4F" },
    { id: "pancake", label: "PancakeSwap", v2Factory: "0x1097053Fd2ea711dad45caCcc45EfF7548fCB362", v3Type: "univ3",  v3Factory: "0x13f4EA83D0bd40E75C8222255bc855a974568Dd4" },

    { id: "curve",   label: "Curve",       v2Factory: null, v3Type: "registry", v3Factory: null, infoUrl: "https://curve.fi" },
    { id: "balancer",label: "Balancer",    v2Factory: null, v3Type: "registry", v3Factory: null, infoUrl: "https://balancer.fi" }
  ]
};

// --- Minimal ABIs (safe even if unused) ---
const ALG_FACTORY_ABI = [
  "function poolByPair(address tokenA, address tokenB) view returns (address pool)"
];
const ALG_POOL_ABI = [
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function liquidity() view returns (uint128)"
];

// ---- stability helpers ----
function liqWithTimeout(promise, ms, label){
  let t;
  const timeout = new Promise((_, rej) => {
    t = setTimeout(() => rej(new Error(`timeout:${label||"call"}`)), ms);
  });
  return Promise.race([promise, timeout]).finally(() => clearTimeout(t));
}

async function liqPoolMap(items, limit, fn){
  const out = new Array(items.length);
  let i = 0;
  const workers = new Array(Math.max(1, limit)).fill(0).map(async () => {
    while (true) {
      const idx = i++;
      if (idx >= items.length) break;
      out[idx] = await fn(items[idx], idx);
    }
  });
  await Promise.all(workers);
  return out;
}

function liqBuildShareLink(net, token){
  const u = new URL(location.href);
  u.searchParams.set("tool", "liq");
  u.searchParams.set("net", net);
  u.searchParams.set("token", token);
  return u.toString();
}

function liqGetSources(net){
  const src = Array.isArray(DEX_SOURCES?.[net]) ? DEX_SOURCES[net] : [];
  // Dedup by id/label to avoid duplicate checks
  const seen = new Set();
  const out = [];
  for (const s of src) {
    const key = String(s.id || s.label || "").toLowerCase();
    if (!key || seen.has(key)) continue;
    seen.add(key);
    out.push(s);
  }
  return out;
}

async function runLiqScan(){
  const st = $("#liq-status");
  const out = $("#liq-out");
  const risk = $("#liq-risk");
  const wrap = $("#liq-tablewrap");

  clearStatus(st);
  risk.innerHTML = "";

  const net = netFromSelect("#liq-net");
  const tokenRaw = ($("#liq-token")?.value || "").trim();
  if (!isAddr(tokenRaw)) {
    setStatus(st, "warn", "Please paste a valid token address.");
    return;
  }
  const token = normAddr(tokenRaw);

  setStatus(st, "info", "Scanning liquidity‚Ä¶");
  const chain = CHAINS[net];
  const read = getReadProvider(net);
  if (!read) {
    setStatus(st, "bad", "No RPC available.");
    return;
  }

  const sources = liqGetSources(net);
  const res = {
    net, token,
    sources: sources.map(s => s.label),
    v2: [],
    v3: [],
    unknown: [],
    ts: nowTs()
  };

  // Config (safe defaults for public RPC)
  const CALL_TIMEOUT_MS = 6500;   // prevents hanging
  const V3_CONCURRENCY  = 3;      // avoid rate limit
  const v2PairsToCheck = [
    { other: chain.wrapped, label: "Wrapped" },
    { other: chain.usdt,    label: "USDT" }
  ];
  const v3Fees = [500, 3000, 10000];

  const pushUnknown = (s, kind, detail, link) => {
    res.unknown.push({
      source: s.label || s.id || "Source",
      kind,
      detail,
      link: link || ""
    });
  };

  for (const s of sources) {
    // Registry DEXes => explicit not checked
    if (s.v3Type === "registry") {
      pushUnknown(s, "Registry", "Not checked (registry model not supported in this scanner yet).", s.infoUrl || "");
      continue;
    }

    // ---------- V2 ----------
    if (s.v2Factory && isAddr(s.v2Factory)) {
      try {
        const f = new E.Contract(s.v2Factory, V2_FACTORY_ABI, read);

        // Only 2 getPair calls; add timeout
        const pairAddrs = await Promise.all(
          v2PairsToCheck.map(p =>
            liqWithTimeout(f.getPair(token, p.other).catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.getPair")
          )
        );

        for (let i = 0; i < v2PairsToCheck.length; i++) {
          const p = v2PairsToCheck[i];
          const pair = pairAddrs[i];

          if (pair && pair !== ZERO) {
            const pairC = new E.Contract(pair, V2_PAIR_ABI, read);
            const [t0, t1, r] = await Promise.all([
              liqWithTimeout(pairC.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.token0"),
              liqWithTimeout(pairC.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.token1"),
              liqWithTimeout(pairC.getReserves().catch(()=>[0n,0n,0n]), CALL_TIMEOUT_MS, "v2.reserves")
            ]);

            res.v2.push({
              source: s.label,
              pair,
              token0: t0,
              token1: t1,
              reserve0: String(r[0]),
              reserve1: String(r[1]),
              otherLabel: p.label,
              other: p.other
            });
          }
        }
      } catch (e) {
        pushUnknown(s, "V2", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v2Factory));
      }
    } else if (s.v2Factory === null) {
      // intentionally no V2
    } else {
      pushUnknown(s, "V2", "Not checked (no V2 factory configured).", "");
    }

    // ---------- V3 UniswapV3 style ----------
    if (s.v3Type === "univ3") {
      if (s.v3Factory && isAddr(s.v3Factory)) {
        try {
          const vf = new E.Contract(s.v3Factory, V3_FACTORY_ABI, read);

          // Build (pair x fee) tasks
          const tasks = [];
          for (const p of v2PairsToCheck) {
            for (const fee of v3Fees) tasks.push({ p, fee });
          }

          const pools = await liqPoolMap(tasks, V3_CONCURRENCY, async ({p, fee}) => {
            const pool = await liqWithTimeout(
              vf.getPool(token, p.other, fee).catch(()=>ZERO),
              CALL_TIMEOUT_MS,
              "v3.getPool"
            );
            return { p, fee, pool };
          });

          for (const x of pools) {
            if (!x.pool || x.pool === ZERO) continue;

            const vp = new E.Contract(x.pool, V3_POOL_ABI, read);
            const [t0, t1, liq, slot0] = await Promise.all([
              liqWithTimeout(vp.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "v3.token0"),
              liqWithTimeout(vp.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "v3.token1"),
              liqWithTimeout(vp.liquidity().catch(()=>0n), CALL_TIMEOUT_MS, "v3.liquidity"),
              liqWithTimeout(vp.slot0().catch(()=>null), CALL_TIMEOUT_MS, "v3.slot0")
            ]);

            res.v3.push({
              source: s.label,
              fee: x.fee,
              otherLabel: x.p.label,
              other: x.p.other,
              pool: x.pool,
              token0: t0,
              token1: t1,
              liquidity: String(liq),
              tick: slot0 ? String(slot0[1]) : "‚Äî"
            });
          }
        } catch (e) {
          pushUnknown(s, "V3", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v3Factory));
        }
      } else {
        pushUnknown(s, "V3", "Not checked (no V3 factory configured).", "");
      }
    }

    // ---------- V3 Algebra style (THENA) ----------
    if (s.v3Type === "algebra") {
      if (s.v3Factory && isAddr(s.v3Factory)) {
        try {
          const af = new E.Contract(s.v3Factory, ALG_FACTORY_ABI, read);

          const poolAddrs = await Promise.all(
            v2PairsToCheck.map(p =>
              liqWithTimeout(af.poolByPair(token, p.other).catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.poolByPair")
            )
          );

          for (let i = 0; i < v2PairsToCheck.length; i++) {
            const p = v2PairsToCheck[i];
            const pool = poolAddrs[i];
            if (!pool || pool === ZERO) continue;

            const ap = new E.Contract(pool, ALG_POOL_ABI, read);
            const [t0, t1, liq] = await Promise.all([
              liqWithTimeout(ap.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.token0"),
              liqWithTimeout(ap.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.token1"),
              liqWithTimeout(ap.liquidity().catch(()=>0n), CALL_TIMEOUT_MS, "alg.liquidity")
            ]);

            res.v3.push({
              source: s.label,
              fee: "‚Äî",
              otherLabel: p.label,
              other: p.other,
              pool,
              token0: t0,
              token1: t1,
              liquidity: String(liq),
              tick: "‚Äî"
            });
          }
        } catch (e) {
          pushUnknown(s, "V3", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v3Factory));
        }
      } else {
        pushUnknown(s, "V3", "Not checked (no Algebra factory configured).", "");
      }
    }
  }

  // Render chips (avoid false green)
  const chips = [];
  const v2n = res.v2.length;
  const v3n = res.v3.length;
  const un = res.unknown.length;

  if (v2n) chips.push(qsRiskChip("ok", `V2 pairs found: ${v2n}`));
  else chips.push(qsRiskChip("warn", "No V2 pairs found (wrapped/USDT)."));

  if (v3n) chips.push(qsRiskChip("ok", `V3 pools found: ${v3n}`));
  else chips.push(qsRiskChip("warn", "No V3 pools found (wrapped/USDT, fee tiers)."));

  if (un) chips.push(qsRiskChip("warn", `Unknown / not checked: ${un}`));
  risk.innerHTML = chips.join("");

  const rows = [];
  rows.push(`
    <div class="trow head">
      <div class="cell">Pool / Pair</div>
      <div class="cell">Type</div>
      <div class="cell">Detail</div>
      <div class="cell">Link</div>
    </div>
  `);

  // V2 rows
  for (const v of res.v2) {
    const hasRes = (BigInt(v.reserve0) > 0n && BigInt(v.reserve1) > 0n);
    rows.push(`
      <div class="trow ${hasRes ? "highlight" : ""}">
        <div class="cell mono">${shortAddr(v.pair)}</div>
        <div class="cell">V2</div>
        <div class="cell">${escapeHtml(v.source)} ‚Ä¢ Reserves: ${hasRes ? "‚úÖ" : "‚Äî"} ‚Ä¢ ${escapeHtml(v.otherLabel)}</div>
        <div class="cell"><a href="${chain.addressUrl(v.pair)}" target="_blank" rel="noopener">Explorer</a></div>
      </div>
    `);
  }

  // V3 rows
  for (const v of res.v3) {
    const liqOk = (() => { try { return BigInt(v.liquidity) > 0n; } catch { return false; } })();
    const feeTxt = (v.fee === "‚Äî") ? "Fee: ‚Äî" : `Fee: ${v.fee}`;
    rows.push(`
      <div class="trow ${liqOk ? "highlight" : ""}">
        <div class="cell mono">${shortAddr(v.pool)}</div>
        <div class="cell">V3</div>
        <div class="cell">${escapeHtml(v.source)} ‚Ä¢ ${escapeHtml(v.otherLabel)} ‚Ä¢ ${feeTxt} ‚Ä¢ Liquidity: ${liqOk ? "‚úÖ" : "‚Äî"}${v.tick ? ` ‚Ä¢ Tick: ${escapeHtml(v.tick)}` : ""}</div>
        <div class="cell"><a href="${chain.addressUrl(v.pool)}" target="_blank" rel="noopener">Explorer</a></div>
      </div>
    `);
  }

  // Unknown / Not checked rows
  for (const u of res.unknown) {
    const link = u.link ? `<a href="${u.link}" target="_blank" rel="noopener">Link</a>` : "‚Äî";
    rows.push(`
      <div class="trow">
        <div class="cell mono">‚Äî</div>
        <div class="cell">${escapeHtml(u.kind)}</div>
        <div class="cell">${escapeHtml(u.source)} ‚Ä¢ ${escapeHtml(u.detail)}</div>
        <div class="cell">${link}</div>
      </div>
    `);
  }

  wrap.innerHTML = `<div class="table">${rows.join("")}</div>`;

  out.innerHTML = `
    <b>Multi-source liquidity scan</b> completed.<br>
    Network: ${escapeHtml(chain.name)}<br>
    Token: <span class="mono">${token}</span><br>
    Sources: ${escapeHtml(res.sources.join(", "))}<br>
    Share: <span class="mono">${liqBuildShareLink(net, token)}</span>
  `;
  out.style.display = "block";

  setStatus(st, (v2n || v3n) ? "ok" : "warn", "Done.");
  gtagEvent("sec_liq_run", { net, sources: sources.length, unknown: un });
}

function initLiqUi(){
  const updateDexNote = () => {
    const net = netFromSelect("#liq-net");
    const src = liqGetSources(net).map(s => s.label);
    const el = $("#liq-dex-note");
    if (el) el.textContent = `Sources: ${src.join(", ")} (V2: wrapped+USDT ‚Ä¢ V3: wrapped+USDT + fee tiers ‚Ä¢ Algebra supported ‚Ä¢ Registry DEXes shown as not checked)`;
  };
  $("#liq-net")?.addEventListener("change", updateDexNote);
  updateDexNote();

  $("#liq-run")?.addEventListener("click", runLiqScan);

  $("#liq-copy-link")?.addEventListener("click", async () => {
    const net = netFromSelect("#liq-net");
    const token = ($("#liq-token")?.value || "").trim();
    if (!isAddr(token)) return setStatus($("#liq-status"), "warn", "Enter token address first.");
    const link = liqBuildShareLink(net, normAddr(token));
    const ok = await copyText(link);
    setStatus($("#liq-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
  });

  $("#liq-share-x")?.addEventListener("click", () => {
    const net = netFromSelect("#liq-net");
    const token = ($("#liq-token")?.value || "").trim();
    if (!isAddr(token)) return setStatus($("#liq-status"), "warn", "Enter token address first.");
    const link = liqBuildShareLink(net, normAddr(token));
    const u = new URL("https://twitter.com/intent/tweet");
    u.searchParams.set("text", `Liquidity scan (${CHAINS[net].name})\nToken: ${shortAddr(token)}\n${link}`);
    window.open(u.toString(), "_blank", "noopener,noreferrer");
  });
}

// ---- Safe HTML escape (global) ----
window.escapeHtml = window.escapeHtml || function (s) {
  if (s === null || s === undefined) return "";
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
};

// =========================
// Wallet Security DNA (replaces Approval Guardian)
// =========================

function dnaNet() {
  // dna-net is the new select; fallback to ap-net if exists
  return netFromSelect("#dna-net") || netFromSelect("#ap-net") || "bsc";
}

function dnaInputAddress() {
  const raw = ($("#dna-walletAddress")?.value || "").trim();
  if (raw && isAddr(raw)) return normAddr(raw);
  if (wallet?.address && isAddr(wallet.address)) return normAddr(wallet.address);
  return "";
}

function dnaSetWalletBadges() {
  const w = wallet?.address ? shortAddr(wallet.address) : "not connected";
  const addr = wallet?.address ? shortAddr(wallet.address) : "‚Äî";
  const net = dnaNet();

  const elWallet = $("#dna-wallet");
  const elAddr = $("#dna-address");

  if (elWallet) elWallet.textContent = w;
  if (elAddr) elAddr.textContent = addr;

  // optional: keep legacy ap-wallet/ap-address if you still have them somewhere
  if ($("#ap-wallet")) $("#ap-wallet").textContent = w;
  if ($("#ap-address")) $("#ap-address").textContent = addr;

  gtagEvent?.("sec_dna_wallet_badge", { net, connected: !!wallet?.address });
}

function dnaClearOutputs() {
  dnaApplyPills(null, "‚Äî");

  const tips = $("#dna-tips");
  if (tips) tips.innerHTML = `<li class="muted" data-i18n="dna_tips_placeholder">‚Äî</li>`;

  // clear approvals table but keep header
  const table = $("#ap-table");
  const head = table?.querySelector(".trow.head");
  if (table) table.innerHTML = "";
  if (table && head) table.appendChild(head);

  clearStatus?.($("#dna-status"));
  clearStatus?.($("#ap-status"));
}

function dnaRiskLevelFromScore(score) {
  const s = Number(score);
  if (!Number.isFinite(s)) return "‚Äî";
  if (s >= 80) return "Low";
  if (s >= 50) return "Medium";
  return "High";
}
// Score tier -> ok (green) | warn (orange) | bad (red) | unk
function dnaScoreTierFromScore(score){
  const s = Number(score);
  if (!Number.isFinite(s)) return "unk";
  if (s >= 80) return "ok";
  if (s >= 50) return "warn";
  return "bad";
}

// Apply text + color classes to the pills
function dnaApplyPills(score, riskText){
  const scoreEl = $("#dna-score");
  const riskEl  = $("#dna-risk");

  // --- SCORE ---
  if (scoreEl){
    const s = Number(score);
    scoreEl.textContent = Number.isFinite(s) ? String(Math.round(s)) : "‚Äî";

    scoreEl.classList.remove("score-ok","score-warn","score-bad","score-unk");
    scoreEl.classList.add("score-" + dnaScoreTierFromScore(s));
  }

  // --- RISK ---
  if (riskEl){
    const txt = (riskText == null ? "‚Äî" : String(riskText));
    riskEl.textContent = txt;

    riskEl.classList.remove("risk-low","risk-med","risk-high","risk-unk");
    const t = txt.toLowerCase();
    let lvl = "unk";
    if (t.includes("low")) lvl = "low";
    else if (t.includes("med")) lvl = "med";
    else if (t.includes("high")) lvl = "high";
    riskEl.classList.add("risk-" + lvl);
  }
}


function dnaNormalizeApiRow(row) {
  // Moralis-like keys (common)
  const tokenRaw =
    row?.token || row?.token_address || row?.tokenAddress || row?.contract_address || row?.contractAddress || "";
  const spenderRaw =
    row?.spender || row?.spender_address || row?.spenderAddress || row?.operator || "";

  const token = isAddr(tokenRaw) ? normAddr(tokenRaw) : "";
  const spender = isAddr(spenderRaw) ? normAddr(spenderRaw) : "";

  const symbol = row?.symbol || row?.token_symbol || row?.tokenSymbol || row?.token_name || "‚Äî";

  const allowanceRaw =
    row?.allowance ?? row?.value ?? row?.amount ?? row?.approved_amount ?? row?.approvedAmount ?? "0";
  const allowanceStr = String(allowanceRaw);

  const verified =
    row?.verified === true ? "Verified" :
    row?.verified === false ? "Unverified" :
    row?.verifiedStatus || row?.verification || row?.verified || "‚Äî";

  const lastUpdated =
    row?.lastUpdated || row?.updatedAt || row?.block_timestamp || row?.blockTimestamp || "‚Äî";

  let flags = row?.flags ?? row?.suspicious ?? row?.risk_flags ?? "‚Äî";
  if (Array.isArray(flags)) flags = flags.length ? flags.join(", ") : "‚Äî";

  const risk = row?.risk || row?.riskLevel || "‚Äî";
  const decRaw = row?.decimals ?? row?.token_decimals ?? row?.tokenDecimals ?? row?.tokenDecimals ?? null;
  const decimals = Number.isFinite(Number(decRaw)) ? Number(decRaw) : null;
  return { token, spender, symbol, allowanceStr, verified, lastUpdated, flags, risk, decimals };

}
function dnaFormatAllowance(rawStr, decimals = null) {
  let s0 = String(rawStr ?? "").trim();
  if (!s0 || s0 === "‚Äî") return "‚Äî";

  // Normalize ".1" -> "0.1"
  if (s0.startsWith(".")) s0 = "0" + s0;
  if (s0.startsWith("-.")) s0 = "-0" + s0.slice(1);

  const low0 = s0.toLowerCase();

  // Unlimited hints
  if (s0 === "‚àû" || low0 === "infinite" || low0 === "unlimited" || low0.includes("inf")) {
    return `<span class="mono" title="Unlimited" data-copy="Unlimited">Unlimited</span>`;
  }

  // ‚úÖ FIX for broken MaxUint256 coming as "0.<huge digits>"
  // Example: "0.1157920...(70+ digits)" => treat as integer "1157920..." and detect MaxUint256
  const brokenDec = /^-?0?\.\d{25,}$/; // 25+ digits after dot = suspicious/broken
  if (brokenDec.test(s0) && !s0.startsWith("0x")) {
    const neg = s0.startsWith("-");
    const digits = s0.replace("-", "").replace(/^0?\./, ""); // remove "0."
    s0 = (neg ? "-" : "") + digits; // now integer string
  }

  // If it's a normal human decimal (not broken) -> show SHORT (6 decimals) but keep full in title/copy
  if (s0.includes(".") && !s0.startsWith("0x")) {
    const full = s0;

    // shorten display to max 6 fraction digits without rounding (string cut)
    const m = full.match(/^(-?\d+)\.(\d+)/);
    let display = full;
    if (m) {
      const ip = m[1];
      const frac = m[2].slice(0, 6).replace(/0+$/, ""); // trim trailing zeros
      display = frac ? `${ip}.${frac}` : ip;
    }

    // extra safety: don't let it get too long
    if (display.length > 16) display = display.slice(0, 12) + "‚Ä¶";

    const safeDisplay = window.escapeHtml(display);
    const safeFull = window.escapeHtml(full);
    return `<span class="mono" title="Value: ${safeFull}" data-copy="${safeFull}">${safeDisplay}</span>`;
  }

  // Parse bigint (hex or integer string)
  let raw;
  try {
    raw = s0.startsWith("0x") ? BigInt(s0) : BigInt(s0);
  } catch {
    const safe = window.escapeHtml(s0);
    return `<span class="mono" title="${safe}" data-copy="${safe}">${safe}</span>`;
  }

  if (raw === 0n) {
    return `<span class="mono" title="Raw: 0" data-copy="0">0</span>`;
  }

  const MAX_UINT256 = (1n << 256n) - 1n;
  const NEAR_MAX = MAX_UINT256 - 1000n;

  // ‚úÖ Turn MaxUint256 into Unlimited
  if (raw === MAX_UINT256 || raw >= NEAR_MAX) {
    return `<span class="mono" title="Unlimited (MaxUint256)\nRaw: ${MAX_UINT256.toString()}" data-copy="${MAX_UINT256.toString()}">Unlimited</span>`;
  }

  // If decimals known -> format to human + shorten
  if (Number.isInteger(decimals) && decimals >= 0 && decimals <= 36) {
    const pad = decimals;

    const neg = raw < 0n;
    const v = neg ? (-raw) : raw;
    const str = v.toString().padStart(pad + 1, "0");
    const intPart = str.slice(0, -pad) || "0";
    let frac = str.slice(-pad).replace(/0+$/, "");
    const full = (neg ? "-" : "") + intPart + (frac ? "." + frac : "");

    // shorten display (K/M/B‚Ä¶)
    const ip = intPart.replace(/^0+/, "") || "0";
    const intLen = ip.length;
    const suffixes = ["", "K", "M", "B", "T", "Q"];
    const group = Math.floor((intLen - 1) / 3);

    let display = full;
    if (group > 0 && group < suffixes.length) {
      const cut = intLen - group * 3;
      const head = ip.slice(0, cut);
      const tail = ip.slice(cut, cut + 2);
      display = `${head}${tail ? "." + tail : ""}${suffixes[group]}`;
      if (neg) display = "-" + display;
    } else if (group >= suffixes.length) {
      display = `${ip.slice(0, 3)}e+${intLen - 3}`;
      if (neg) display = "-" + display;
    }

    const title = `Value: ${full}\nRaw: ${raw.toString()}`;
    return `<span class="mono" title="${window.escapeHtml(title)}" data-copy="${raw.toString()}">${window.escapeHtml(display)}</span>`;
  }

  // No decimals: show raw shortened
  const rawDec = raw.toString();
  const abs = rawDec.startsWith("-") ? rawDec.slice(1) : rawDec;
  let display = rawDec;
  if (abs.length > 10) display = `${rawDec.slice(0, 6)}‚Ä¶${rawDec.slice(-4)}`;

  return `<span class="mono" title="${window.escapeHtml("Raw: " + rawDec)}" data-copy="${rawDec}">${window.escapeHtml(display)}</span>`;
}

// optional - for console testing/debug
window.dnaFormatAllowance = dnaFormatAllowance;

function dnaRowRiskChip(risk) {
  const r = String(risk || "‚Äî").toLowerCase();
  if (r.includes("high")) return `<span class="chip chip-danger">High</span>`;
  if (r.includes("med")) return `<span class="chip chip-warn">Medium</span>`;
  if (r.includes("low")) return `<span class="chip chip-ok">Low</span>`;
  if (r === "‚Äî") return `<span class="muted">‚Äî</span>`;
  return `<span class="chip">${window.escapeHtml(String(risk))}</span>`;
}

// ‚úÖ FIX: "unverified" includes "verif" so must check UNVERIFIED first
function dnaVerifiedChip(verified) {
  const v = String(verified || "‚Äî").toLowerCase();
  if (v.includes("unver")) return `<span class="chip chip-warn">Unverified</span>`;
  if (v.includes("verif")) return `<span class="chip chip-ok">Verified</span>`;
  return `<span class="muted">‚Äî</span>`;
}

function dnaBindRevokeButtons(net) {
  $$("#ap-table [data-revoke]").forEach((btn) => {
    btn.addEventListener("click", async () => {
      const tk = btn.getAttribute("data-token");
      const sp = btn.getAttribute("data-spender");
      await dnaRevokeOne(net, tk, sp);
    });
  });
}

// -------------------------
// API fetch (handles 429 + JSON error bodies) ‚úÖ
// -------------------------
const DNA_API_BASE =
  (window.CYCLEX_API_BASE && String(window.CYCLEX_API_BASE).trim()) || location.origin;

    // -------------------------
// Live Activity ping (Home counters) ‚úÖ
// -------------------------
function cxActivitySend(t, n = 1) {
  try {
    const payload = JSON.stringify({ t, n });

    if (navigator.sendBeacon) {
      navigator.sendBeacon("/api/activity", new Blob([payload], { type: "application/json" }));
      return;
    }

    fetch("/api/activity", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: payload,
      keepalive: true,
    }).catch(() => {});
  } catch (e) {}
}


async function dnaFetchApprovals(net, address) {
  const u = new URL("/api/getApprovals", DNA_API_BASE);
  u.searchParams.set("net", net);
  u.searchParams.set("address", address);

  // optional timeout (keeps UI responsive)
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), 15000);

  let res;
  try {
    res = await fetch(u.toString(), { method: "GET", signal: ctrl.signal });
  } finally {
    clearTimeout(t);
  }

  // Try read json, else text
  const ct = (res.headers.get("content-type") || "").toLowerCase();
  const readBody = async () => {
    if (ct.includes("application/json")) {
      try { return await res.json(); } catch { /* ignore */ }
    }
    const txt = await res.text().catch(() => "");
    return txt;
  };

  if (res.status === 429) {
    const body = await readBody();
    const err = new Error("RATE_LIMIT");
    err.status = 429;
    err.body = body;
    return Promise.reject(err);
  }

  if (!res.ok) {
    const body = await readBody();
    const err = new Error(`API_ERROR_${res.status}`);
    err.status = res.status;
    err.body = body;
    return Promise.reject(err);
  }

  return await res.json();
}

function dnaRenderTips(list) {
  const tips = $("#dna-tips");
  if (!tips) return;
  if (!Array.isArray(list) || !list.length) {
    tips.innerHTML = `<li class="muted">‚Äî</li>`;
    return;
  }
  tips.innerHTML = list.map(t => `<li>${window.escapeHtml(String(t))}</li>`).join("");
}

function dnaRenderTable(rows) {
  if (!dnaFullAccess) {
    dnaClearApprovalsTable();
    return;
  }
  const table = $("#ap-table");
  const head = table?.querySelector(".trow.head");
  if (table) table.innerHTML = "";
  if (table && head) table.appendChild(head);

  if (!table) return;

  if (!rows.length) {
  table.insertAdjacentHTML("beforeend", `
    <div class="trow ap-main">
      <div class="cell muted">‚Äî</div>
      <div class="cell muted hide-sm">‚Äî</div>
      <div class="cell muted">‚Äî</div>
      <div class="cell muted hide-sm">‚Äî</div>
      <div class="cell muted hide-sm">‚Äî</div>
      <div class="cell muted">‚Äî</div>
      <div class="cell muted">‚Äî</div>
    </div>
  `);
  return;
}

    const html = rows.map(r => {
    const tkTxt = r.token ? shortAddr(r.token) : "‚Äî";
    const spTxt = r.spender ? shortAddr(r.spender) : "‚Äî";
    const tkFull = r.token || "";
    const spFull = r.spender || "";
    const alwHtml = dnaFormatAllowance(r.allowanceStr, r.decimals);
    const verTxt = dnaVerifiedChip(r.verified);
    const riskChip = dnaRowRiskChip(r.risk);

    const flagsTxtRaw = (r.flags && r.flags !== "‚Äî") ? String(r.flags) : "";
    const flagsTxt = flagsTxtRaw ? window.escapeHtml(flagsTxtRaw) : "‚Äî";

    const allowanceRawStr = String(r.allowanceStr ?? "0").trim();
    const low = allowanceRawStr.toLowerCase();
    const isUnlimited = (allowanceRawStr === "‚àû" || low === "infinite" || low === "unlimited" || low.includes("inf"));

    const allowanceIsNonZero = isUnlimited || (
    allowanceRawStr.startsWith("0x")
    ? !/^0x0+$/i.test(allowanceRawStr)
    : allowanceRawStr !== "" && allowanceRawStr !== "0" && allowanceRawStr !== "0.0"
);


const canRevoke =
  dnaFullAccess &&
  r.token && r.spender &&
  allowanceIsNonZero;

      const actionHtml = (dnaFullAccess && canRevoke)
  ? `<button class="chip chip-danger" data-revoke="1"
      data-token="${dnaEscAttr(r.token)}"
      data-spender="${dnaEscAttr(r.spender)}">Revoke</button>`
  : `<span class="muted">‚Äî</span>`;


    return `
      <!-- MAIN ROW (no Flags column) -->
      <div class="trow ap-main">
        <div class="cell mono">
  <span class="addr-short">${tkTxt}</span>
  ${tkFull ? `<button class="chip chip-ghost ap-copy" data-copy="${dnaEscAttr(tkFull)}" title="Copy token">Copy</button>` : ``}
</div>

<div class="cell mono hide-sm">
  <span class="addr-short">${spTxt}</span>
  ${spFull ? `<button class="chip chip-ghost ap-copy" data-copy="${dnaEscAttr(spFull)}" title="Copy spender">Copy</button>` : ``}
</div>

        <div class="cell">${alwHtml}</div>
        <div class="cell hide-sm">${verTxt}</div>
        <div class="cell hide-sm">${dnaFormatLastUpdated(r.lastUpdated)}</div>
        <div class="cell">${riskChip}</div>
        <div class="cell">${actionHtml}</div>
      </div>

      <!-- FLAGS ROW (full width; only visible on desktop where flags exist in head) -->
      <div class="trow ap-flags-row hide-sm">
        <div class="cell ap-flags-cell">
          <span class="muted" style="margin-right:10px;">Flags:</span>
          <span class="mono">${flagsTxt}</span>
        </div>
      </div>
    `;
  }).join("");

  table.insertAdjacentHTML("beforeend", html);

}
    (function bindApprovalsCopyOnce(){
  const table = document.getElementById("ap-table");
  if (!table || table.__copyBound) return;
  table.__copyBound = true;

  table.addEventListener("click", async (e) => {
    const btn = e.target.closest?.("[data-copy]");
    if (!btn) return;

    const text = String(btn.getAttribute("data-copy") || "").trim();
    if (!text) return;

    const ok = await copyText(text);
    if (ok) {
      const prev = btn.textContent;
      btn.textContent = "Copied";
      setTimeout(()=> (btn.textContent = prev), 900);
    }
  });
})();


function dnaComputeFallbackTips(rows) {
  const tips = [];
  const high = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
  const unverified = rows.filter(r => String(r.verified).toLowerCase().includes("unver")).length;
  const flagged = rows.filter(r => r.flags && r.flags !== "‚Äî").length;
  const infinite = rows.filter(r => String(r.allowanceStr).toLowerCase().includes("inf") || String(r.allowanceStr) === "‚àû").length;

  if (high) tips.push(`Revoke high-risk approvals first (${high}).`);
  if (infinite) tips.push(`Consider revoking infinite approvals you don‚Äôt fully trust (${infinite}).`);
  if (unverified) tips.push(`Review unverified spender contracts before keeping approvals (${unverified}).`);
  if (flagged) tips.push(`Check flagged interactions and bridges before signing again (${flagged}).`);
  if (!tips.length) tips.push("No major red flags detected. Keep monitoring regularly.");

  return tips;
}

async function dnaScan() {
  const st = $("#dna-status");
  clearStatus?.(st);

  const net = dnaNet();
  const address = dnaInputAddress();

  if (!address) return setStatus(st, "warn", "Enter a valid wallet address or connect a wallet.");

  setStatus(st, "info", "Scanning approvals‚Ä¶");

  try {
    const data = await dnaFetchApprovals(net, address);

    const approvals =
  Array.isArray(data) ? data :
  Array.isArray(data?.approvals) ? data.approvals :
  Array.isArray(data?.result) ? data.result :
  Array.isArray(data?.data) ? data.data :
  [];

    const rows = approvals.map(dnaNormalizeApiRow);
   dnaRenderTable(rows);

    // ‚úÖ Count a real completed wallet scan
cxActivitySend("wallet_scan", 1);
const riskyCount = rows.filter(r => {
  const rr = String(r.risk || "").toLowerCase();
  return rr.includes("high") || rr.includes("med");
}).length;

if (riskyCount > 0) cxActivitySend("risky_approvals", riskyCount);


if (dnaFullAccess) {
  dnaBindRevokeButtons(net);
}


    const score = (Array.isArray(data) ? null : data?.score);
    const riskLevel = (Array.isArray(data) ? null : data?.riskLevel);

    if (score != null || riskLevel) {
  dnaApplyPills(score, riskLevel || dnaRiskLevelFromScore(score));
}

    if (score == null) {
      let s = 100;
      const high = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
      const unverified = rows.filter(r => String(r.verified).toLowerCase().includes("unver")).length;
      const flagged = rows.filter(r => r.flags && r.flags !== "‚Äî").length;
      const infinite = rows.filter(r => String(r.allowanceStr).toLowerCase().includes("inf") || String(r.allowanceStr) === "‚àû").length;

      s -= high * 20;
      s -= unverified * 10;
      s -= flagged * 8;
      s -= infinite * 12;
      s = Math.max(0, Math.min(100, s));

      dnaApplyPills(s, dnaRiskLevelFromScore(s));

    }
    //try {
  //const scoreNow = Number(($("#dna-score")?.textContent || "0").trim());
  //const u = new URL("/api/saveScore", DNA_API_BASE);
  //await fetch(u.toString(), {
    //method: "POST",
    //headers: { "content-type": "application/json" },
    //body: JSON.stringify({ net, score: scoreNow })
  //});
//} catch {}

    // Best-effort: save score (ignore failures)
try {
  const scoreNow = Number(($("#dna-score")?.textContent || "0").trim());
  const u = new URL("/api/saveScore", DNA_API_BASE);
  const resp = await fetch(u.toString(), {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ net, score: scoreNow })
  });
  if (!resp.ok) throw new Error(`saveScore ${resp.status}`);
} catch {}

    const tips = (Array.isArray(data) ? null : data?.tips);
    dnaRenderTips(Array.isArray(tips) ? tips : dnaComputeFallbackTips(rows));

    setStatus(st, "ok", "Done.");
    gtagEvent?.("sec_dna_scan", { net });

  } catch (e) {
    // ‚úÖ Friendly 429 handling
    if (e?.status === 429) {
      return setStatus(
        st,
        "warn",
        "Rate limit: max 2 checks per hour per IP. Please try again later."
      );
    }

    // other errors
    const msg = e?.status
      ? `Scan failed (${e.status}). Make sure /api/getApprovals works.`
      : `Scan failed: ${String(e?.message || e)}`;

    setStatus(st, "bad", msg);
    // optional debug
    // console.log("dnaScan error:", e);
  }
}

async function dnaConnectWallet() {
  const st = $("#dna-status");
  clearStatus?.(st);

  try {
    // 1) Prefer AppKit/Web3Modal connect (interactive)
    if (typeof window.cxConnectWallet === "function") {
      const ok = await window.cxConnectWallet({ silent: false }); // ‚úÖ MUST be false to open modal
      if (!ok) {
        setStatus(st, "warn", "Wallet connect cancelled. Try again.");
        return;
      }
    }
    // 2) If you have another global connect function
    else if (typeof window.connectWallet === "function") {
      await window.connectWallet();
    }
    // 3) Fallback: click the TOPBAR connect button if it exists
    else {
      const topBtn =
        document.querySelector("#btn-connect, #connectWallet, [data-cx-connect], [data-w3m-connect]");

      if (topBtn) {
        topBtn.click(); // opens the same modal as topbar
      } else {
        setStatus(st, "warn", "No wallet connect entrypoint found (cxConnectWallet / top button).");
        return;
      }
    }

    await new Promise(r => setTimeout(r, 50));

    dnaSetWalletBadges();

    setStatus(
      st,
      "ok",
      wallet?.address
        ? `Wallet connected: <span class="mono">${shortAddr(wallet.address)}</span>`
        : "Wallet connected."
    );

    gtagEvent?.("sec_dna_connect", { net: dnaNet(), chainId: wallet?.chainId || 0 });
  } catch (e) {
    setStatus(st, "bad", `Connect failed: ${String(e?.message || e)}`);
  }
}

// --- Minimal ERC20 ABI (only what revoke needs) ---
// Safe: no redeclare, and works even if scripts load twice
if (!Array.isArray(window.ERC20_ABI) || window.ERC20_ABI.length === 0) {
  window.ERC20_ABI = [
    "function approve(address spender, uint256 amount) returns (bool)"
  ];
}


async function dnaRevokeOne(net, token, spender) {
  const st = $("#dna-status");
  if (!dnaFullAccess) {
    return setStatus(
      st,
      "warn",
      dnaTr("dna_revoke_requires_full_access", "Full access is required for revoke actions.")
    );
  }

  if (!wallet?.signer || !wallet?.address) {
    setStatus(st, "warn", "Connect a wallet first to revoke.");
    return;
  }

  const typed = ($("#dna-walletAddress")?.value || "").trim();
  if (typed && isAddr(typed) && normAddr(typed) !== normAddr(wallet.address)) {
    setStatus(st, "warn", "You are connected with a different wallet than the address you scanned. Revoke affects ONLY the connected wallet.");
    return;
  }

  const chainId = CHAINS[net]?.chainId;
  if (chainId && wallet.chainId && wallet.chainId !== chainId) {
    const ok = await ensureChain(chainId);
    if (!ok) return setStatus(st, "warn", `Please switch network to ${CHAINS[net].name}.`);
  }

  try {
    setStatus(st, "info", "Sending revoke tx (approve ‚Üí 0)‚Ä¶");
    const ABI = window.ERC20_ABI || ERC20_ABI;
    const c = new E.Contract(normAddr(token), window.ERC20_ABI, wallet.signer);

    const tx = await c.approve(normAddr(spender), 0n);
    setStatus(st, "info", `Pending: <span class="mono">${tx.hash}</span>`);
    await tx.wait();
    setStatus(st, "ok", "Revoke confirmed.");

    gtagEvent?.("sec_dna_revoke_one", { net });

    await dnaScan();

  } catch (e) {
    setStatus(st, "bad", `Revoke failed: ${String(e?.message || e)}`);
  }
}
    window.dnaRevokeOne = dnaRevokeOne;

async function dnaRevokeAll() {
  const st = $("#dna-status");
  const net = dnaNet();
  if (!dnaFullAccess) {
    return setStatus(
      st,
      "warn",
      dnaTr("dna_revoke_requires_full_access", "Full access is required for revoke actions.")
    );
  }

  if (!wallet?.signer || !wallet?.address) return setStatus(st, "warn", "Connect a wallet first to revoke.");

  const typed = ($("#dna-walletAddress")?.value || "").trim();
  if (typed && isAddr(typed) && normAddr(typed) !== normAddr(wallet.address)) {
    return setStatus(st, "warn", "You are connected with a different wallet than the address you scanned. Revoke affects ONLY the connected wallet.");
  }

  const btns = $$("#ap-table [data-revoke]");
  if (!btns.length) return setStatus(st, "ok", "Nothing to revoke.");

  const chainId = CHAINS[net]?.chainId;
  if (chainId && wallet.chainId && wallet.chainId !== chainId) {
    const ok = await ensureChain(chainId);
    if (!ok) return setStatus(st, "warn", `Please switch network to ${CHAINS[net].name}.`);
  }

  setStatus(st, "info", `Revoking ${btns.length} approval(s)‚Ä¶`);

  for (let i = 0; i < btns.length; i++) {
    const tk = btns[i].getAttribute("data-token");
    const sp = btns[i].getAttribute("data-spender");
    try {
      const ABI = window.ERC20_ABI || ERC20_ABI;
      const c = new E.Contract(normAddr(tk), window.ERC20_ABI, wallet.signer);

      const tx = await c.approve(normAddr(sp), 0n);
      setStatus(st, "info", `(${i + 1}/${btns.length}) Pending: <span class="mono">${tx.hash}</span>`);
      await tx.wait();
    } catch (e) {
      setStatus(st, "warn", `(${i + 1}/${btns.length}) Failed: ${shortAddr(tk)} ‚Äî ${String(e?.message || e)}`);
    }
  }
 
  setStatus(st, "ok", "Revoke-all finished.");
  gtagEvent?.("sec_dna_revoke_all", { net });

  await dnaScan();
}
    window.dnaRevokeAll = dnaRevokeAll;

function dnaSeedCommon() {
  const net = dnaNet();
  const chain = CHAINS[net];
  const list = [chain?.wrapped, chain?.usdt].filter(Boolean);
  const ta = $("#dna-tokens");
  if (ta) ta.value = list.join("\n");
  setStatus($("#dna-status"), "ok", "Seeded common tokens (wrapped + USDT).");
}

function dnaSeedHistory() {
  const hist = loadQsHistory?.() || [];
  const net = dnaNet();
  const tokens = hist.filter(x => x?.net === net).slice(0, 20).map(x => x.token).filter(Boolean);
  const ta = $("#dna-tokens");
  if (ta) ta.value = tokens.join("\n");
  setStatus($("#dna-status"), tokens.length ? "ok" : "warn", tokens.length ? "Seeded from scan history." : "No scan history found for this network.");
}

function dnaShareScore() {
  const score = ($("#dna-score")?.textContent || "‚Äî").trim();
  const risk = ($("#dna-risk")?.textContent || "‚Äî").trim();
  const net = dnaNet();
  const addr = dnaInputAddress() ? shortAddr(dnaInputAddress()) : "wallet";

  const text = `Wallet Security DNA (${net.toUpperCase()}): ${addr} ‚Äî Score: ${score}/100, Risk: ${risk}.`;
  const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(location.href)}`;
  window.open(shareUrl, "_blank", "noopener,noreferrer");
  gtagEvent?.("sec_dna_share", { net });
}

//async function dnaShowLeaderboard() {
  //const st = $("#dna-status");
  //const net = dnaNet();
  //setStatus(st, "info", "Loading leaderboard‚Ä¶");

  //try {
    //const u = new URL("/api/leaderboard", DNA_API_BASE);
//u.searchParams.set("net", net);
//const res = await fetch(u.toString());

  //  if (!res.ok) throw new Error(`API error: ${res.status}`);
   // const data = await res.json();

    //const top = Array.isArray(data) ? data : (data?.top || []);
    //if (!top.length) return setStatus(st, "warn", "Leaderboard is empty.");

    //const lines = top.slice(0, 10).map((x, i) => {
      //const s = x?.score ?? "‚Äî";
      //return `${i + 1}) ${s}`;
    //}).join(" ¬∑ ");

    //setStatus(st, "ok", `Leaderboard: ${lines}`);
    //gtagEvent?.("sec_dna_leaderboard", { net });

  //} catch (e) {
    //setStatus(st, "warn", `Leaderboard unavailable: ${String(e?.message || e)}`);
  //}
//}

    // =========================
// CYCX Gate ‚Äî RIGHT side only (Approvals section)
// Paste BETWEEN: dnaShareScore()  and  initWalletSecurityDNAUi()
// =========================

let dnaFullAccess = false;
  // expose dnaFullAccess for console debugging (kept in sync)
Object.defineProperty(window, "dnaFullAccess", {
  get() { return dnaFullAccess; },
  set(v) { dnaFullAccess = !!v; }
});


// TODO: confirm/update your CYCX token address on BSC
const CYCX_BSC_ADDRESS = "0xda63b65825AE30532a507B0C091B0bD9F8204F7E";

// TODO: you'll decide later. For now: must hold >= 1 token
const CYCX_MIN_TOKENS = 1;

const CYCX_GATE_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function decimals() view returns (uint8)"
];

function dnaTr(key, fallback) {
  try {
    if (typeof window.t === "function") {
      const v = window.t(key);
      if (v != null && String(v).trim() !== "") return v; 
    }
  } catch {}
  return fallback; 
}


function dnaSetEligMsg(text, state = "info") {
  const el = $("#dna-elig-msg");
  if (!el) return;

  el.textContent = text || "";
  el.classList.remove("elig-ok", "elig-bad", "elig-warn", "muted");

  if (state === "ok") el.classList.add("elig-ok");
  else if (state === "bad") el.classList.add("elig-bad");
  else if (state === "warn") el.classList.add("elig-warn");
  else el.classList.add("muted");
}


function dnaLockApprovalsUI(msgKey) {
  dnaFullAccess = false;

  // Show locked card, hide content/table
  $("#dna-approvals-locked")?.classList.remove("hidden");
  $("#dna-approvals-content")?.classList.add("hidden");

  // Buttons: show Full Access, hide Revoke All
  $("#dna-full-access")?.classList.remove("hidden");
  $("#dna-revoke-all")?.classList.add("hidden");
  dnaClearApprovalsTable();

  if (msgKey) {
  if (msgKey === "checking") {
    dnaSetEligMsg(dnaTr("dna_elig_checking", "Checking CYCX balance‚Ä¶"), "warn");
  } else if (msgKey === "wrong_net") {
    dnaSetEligMsg(dnaTr("dna_elig_wrong_net", "Please switch to BSC (BNB Chain) to check CYCX eligibility."), "warn");
  } else if (msgKey === "no") {
    dnaSetEligMsg(dnaTr("dna_elig_no", "Not eligible for full access."), "bad"); 
  } else {
    dnaSetEligMsg(dnaTr("dna_elig_error", "Could not check eligibility. Please try again."), "warn");
  }
} else {
  dnaSetEligMsg("", "info");
}

}
    function dnaClearApprovalsTable() {
  const table = $("#ap-table");
  if (!table) return;

  const head = table.querySelector(".trow.head");
  table.innerHTML = "";
  if (head) table.appendChild(head);

  table.insertAdjacentHTML("beforeend", `
    <div class="trow ap-main">
      <div class="cell muted">‚Äî</div>
      <div class="cell muted hide-sm">‚Äî</div>
      <div class="cell muted">‚Äî</div>
      <div class="cell muted hide-sm">‚Äî</div>
      <div class="cell muted hide-sm">‚Äî</div>
      <div class="cell muted">‚Äî</div>
      <div class="cell muted">‚Äî</div>
    </div>
  `);
}


function dnaUnlockApprovalsUI() {
  dnaFullAccess = true;

  $("#dna-approvals-locked")?.classList.add("hidden");
  $("#dna-approvals-content")?.classList.remove("hidden");

  $("#dna-full-access")?.classList.add("hidden");
  $("#dna-revoke-all")?.classList.remove("hidden");

  // ◊ê◊ú ◊™◊û◊ó◊ß ◊û◊ô◊ì ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î ◊î◊ô◊®◊ï◊ß◊î
  // ◊ê◊ï◊§◊¶◊ô◊î 1: ◊ú◊î◊©◊ê◊ô◊® ◊ê◊ï◊™◊î ◊¢◊ì ◊§◊¢◊ï◊ú◊î ◊î◊ë◊ê◊î:
  // (◊õ◊ú◊ï◊ù ◊õ◊ê◊ü)

  // ◊ê◊ï◊§◊¶◊ô◊î 2: ◊ú◊û◊ó◊ï◊ß ◊ê◊ó◊®◊ô 2.5 ◊©◊†◊ô◊ï◊™:
  // setTimeout(() => dnaSetEligMsg("", "info"), 2500);
}
async function dnaCheckCycxEligibility_BSC() {
  if (!wallet?.address) return { ok: false, reason: "no_wallet" };

  const BSC_RPC =
    window.BSC_RPC_URL ||
    "https://bsc-dataseed.binance.org";

  const provider = new E.JsonRpcProvider(BSC_RPC);
  const token = new E.Contract(CYCX_BSC_ADDRESS, CYCX_GATE_ABI, provider);

  let decimals = 18;
  try { decimals = Number(await token.decimals()); } catch {}

  const bal = await token.balanceOf(wallet.address);
  const minRaw = BigInt(CYCX_MIN_TOKENS) * (10n ** BigInt(decimals));
  const eligible = (BigInt(bal) >= minRaw);

  return { ok: true, eligible, bal: BigInt(bal), decimals };
}


async function dnaRequestFullAccess() {
  try {
    dnaLockApprovalsUI("checking");

if (!wallet?.address || !wallet?.signer) {
  const ok = await window.cxConnectWallet?.({ silent: false }); // interactive connect
  if (!ok || !wallet?.address || !wallet?.signer) {
    dnaLockApprovalsUI("error");
    return;
  }
}


    const res = await dnaCheckCycxEligibility_BSC();

    if (!res.ok) {
      if (res.reason === "wrong_net") dnaLockApprovalsUI("wrong_net");
      else dnaLockApprovalsUI("error");
      return;
    }

    if (!res.eligible) {
      dnaLockApprovalsUI("no");
      return;
    }

   dnaSetEligMsg(dnaTr("dna_elig_ok", "Eligible ‚Äî unlocking approvals"), "ok");
   dnaUnlockApprovalsUI();
   await dnaScan();


  } catch (e) {
    console.error("dnaRequestFullAccess error:", e);
    dnaLockApprovalsUI("error");
  }
}

function initDnaCycxGate() {
  // Default state: locked
  dnaLockApprovalsUI();

  // Button click
  $("#dna-full-access")?.addEventListener("click", dnaRequestFullAccess);

  // Safety: if someone forces click on revoke-all while locked
  $("#dna-revoke-all")?.addEventListener("click", (e) => {
    if (!dnaFullAccess) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  }, true);

  // When reset pressed ‚Üí lock again
  $("#dna-reset")?.addEventListener("click", () => dnaLockApprovalsUI());

  // When network changes ‚Üí lock again
  $("#dna-net")?.addEventListener("change", () => dnaLockApprovalsUI());
}


function initWalletSecurityDNAUi() {
  dnaSetWalletBadges();
    initDnaCycxGate();

  $("#dna-run")?.addEventListener("click", dnaScan);
  $("#dna-reset")?.addEventListener("click", dnaClearOutputs);
  $("#dna-connect")?.addEventListener("click", dnaConnectWallet);

  $("#dna-revoke-all")?.addEventListener("click", dnaRevokeAll);

  $("#dna-seed-common")?.addEventListener("click", dnaSeedCommon);
  $("#dna-seed-history")?.addEventListener("click", dnaSeedHistory);

  $("#dna-share")?.addEventListener("click", dnaShareScore);
  //$("#dna-leaderboard")?.addEventListener("click", dnaShowLeaderboard);

  $("#dna-net")?.addEventListener("change", () => {
    dnaClearOutputs();
    dnaSetWalletBadges();
  });

  window.initApprovalsUi = initWalletSecurityDNAUi;

}



    // =========================
    // RPC Health Checker
    // =========================
    function rpcRowHtml(url, ms, chain, block, callOk, logsOk, status){
  const ok = status === "ok";
  const cls = ok ? "highlight" : "";

  // Host label
  let host = url;
  try { host = new URL(url).host; } catch {}

  const msTxt    = (ms ?? "‚Äî");
  const blockTxt = (block ?? "‚Äî");
  const callTxt  = (callOk ?? "‚Äî");
  const logsTxt  = (logsOk ?? "‚Äî");

  return `
    <div class="trow rpc ${cls}">
      <div class="cell rpc-url">
        <div class="rpc-host mono">${host}</div>
        <div class="rpc-full mono" title="${url}">${url}</div>
      </div>

      <div class="cell rpc-status">
        <span class="sig ${ok ? "ok" : "unk"}">
          <span class="dot"></span>
          ${ok ? "ok" : "fail"}
        </span>
      </div>

      <div class="cell rpc-meta">
        <span class="m"><b>MS</b> ${msTxt}</span>
        <span class="m"><b>Block</b> ${blockTxt}</span>
        <span class="m"><b>Call</b> ${callTxt}</span>
        <span class="m"><b>Logs</b> ${logsTxt}</span>
      </div>
    </div>
  `;
}


    async function rpcTestOne(net, url){
      const chainIdExpected = CHAINS[net].chainId;

      const t0 = performance.now();
      let chainId = null;
      let block = null;
      let callOk = "‚Äî";
      let logsOk = "‚Äî";

      try{
        const cid = await rpcRequest(url, "eth_chainId", [], 8000);
        chainId = parseInt(cid, 16);
        if (chainId !== chainIdExpected) throw new Error(`wrong chainId ${chainId}`);
      } catch (e){
        const ms = Math.round(performance.now() - t0);
        return { ok: false, url, ms, chainId: chainId ?? "‚Äî", block: "‚Äî", callOk: "‚Äî", logsOk: "‚Äî", err: e };
      }

      try{
        const bn = await rpcRequest(url, "eth_blockNumber", [], 8000);
        block = parseInt(bn, 16);
      } catch {}

      try{
        // simple eth_call to get WETH/WBNB decimals (cheap)
        const wrapped = CHAINS[net].wrapped;
        const dataDecimals = "0x313ce567"; // decimals()
        const res = await rpcRequest(url, "eth_call", [{ to: wrapped, data: dataDecimals }, "latest"], 8000);
        callOk = (res && res !== "0x") ? "‚úÖ" : "‚Äî";
      } catch {
        callOk = "‚Äî";
      }

      try{
        // lightweight logs read: last 200 blocks, Transfer topic on wrapped
        const latest = block || (parseInt(await rpcRequest(url, "eth_blockNumber", [], 8000), 16));
        const from = Math.max(0, latest - 200);
        const filter = {
          address: CHAINS[net].wrapped,
          fromBlock: "0x" + from.toString(16),
          toBlock: "0x" + latest.toString(16),
          topics: [TRANSFER_TOPIC0]
        };
        const logs = await rpcRequest(url, "eth_getLogs", [filter], 8500);
        logsOk = Array.isArray(logs) ? "‚úÖ" : "‚Äî";
      } catch {
        logsOk = "‚Äî";
      }

      const ms = Math.round(performance.now() - t0);
      return { ok: true, url, ms, chainId, block, callOk, logsOk };
    }

    async function runRpcTest(){
      const st = $("#rpc-status");
      clearStatus(st);

      const net = netFromSelect("#rpc-net");
      const table = $("#rpc-table");

      // reset table head
      if (table) {
        const head = table.querySelector(".trow.head.rpc");
        table.innerHTML = "";
        if (head) table.appendChild(head);
      }

      const urls = buildRpcCandidates(net);
      if (!urls.length) return setStatus(st, "warn", "No RPCs available.");

      setStatus(st, "info", `Testing ${urls.length} RPC(s)‚Ä¶`);

      let best = null;
      for (const url of urls) {
        const r = await rpcTestOne(net, url);
        if (table) {
          table.insertAdjacentHTML("beforeend", rpcRowHtml(
            url,
            r.ms ?? "‚Äî",
            r.chainId ?? "‚Äî",
            r.block ?? "‚Äî",
            r.callOk ?? "‚Äî",
            r.logsOk ?? "‚Äî",
            r.ok ? "ok" : "fail"
          ));
        }
        if (r.ok) {
          if (!best || (r.ms < best.ms)) best = r;
        }
      }

      if (best) {
        setSavedBestRpc(net, best.url);
        setStatus(st, "ok", `Best RPC saved: <span class="mono">${best.url}</span>`);
        gtagEvent("sec_rpc_best_saved", { net });
      } else {
        setStatus(st, "bad", "All RPCs failed (CORS/timeout/blocked). Try adding a custom RPC.");
      }
      gtagEvent("sec_rpc_test", { net });
    }

    async function rpcCopyBest(){
      const net = netFromSelect("#rpc-net");
      const best = getSavedBestRpc(net);
      if (!best) return setStatus($("#rpc-status"), "warn", "No saved best RPC yet. Run test first.");
      const ok = await copyText(best);
      setStatus($("#rpc-status"), ok ? "ok" : "warn", ok ? "Copied best RPC." : "Copy failed.");
    }

    function initRpcUi(){
      const netSel = $("#rpc-net");
      const privInput = $("#rpc-private");

      const loadPrivToInput = () => {
        const net = netFromSelect("#rpc-net");
        const saved = getSavedPrivateRpc(net);
        if (privInput) privInput.value = saved;
      };

      netSel?.addEventListener("change", loadPrivToInput);
      loadPrivToInput();

      $("#rpc-private-save")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const v = ($("#rpc-private")?.value || "").trim();
        if (v) setSavedPrivateRpc(net, v);
        setStatus($("#rpc-status"), "ok", "Saved private RPC locally.");
      });

      $("#rpc-private-clear")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        setSavedPrivateRpc(net, "");
        if ($("#rpc-private")) $("#rpc-private").value = "";
        setStatus($("#rpc-status"), "ok", "Cleared private RPC.");
      });

      $("#rpc-test")?.addEventListener("click", runRpcTest);
      $("#rpc-copy-best")?.addEventListener("click", rpcCopyBest);

      $("#rpc-share-x")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const best = getSavedBestRpc(net) || "‚Äî";
        const u = new URL("https://twitter.com/intent/tweet");
        u.searchParams.set("text", `RPC Health (${CHAINS[net].name})\nBest: ${best}\nCycleX Security Hub`);
        window.open(u.toString(), "_blank", "noopener,noreferrer");
      });

      // Dev custom logs test
      $("#rpc-dev-run")?.addEventListener("click", async () => {
        const net = netFromSelect("#rpc-net");
        const addrRaw = ($("#rpc-dev-addr")?.value || "").trim();
        const topic0 = ($("#rpc-dev-topic")?.value || "").trim() || TRANSFER_TOPIC0;
        if (!addrRaw) return setStatus($("#rpc-status"), "warn", "Enter a contract address for the dev test.");
        if (!isAddr(addrRaw)) return setStatus($("#rpc-status"), "warn", "Invalid contract address.");

        const addr = normAddr(addrRaw);
        const urls = buildRpcCandidates(net);
        if (!urls.length) return setStatus($("#rpc-status"), "warn", "No RPCs available.");

        setStatus($("#rpc-status"), "info", "Running custom logs test‚Ä¶");
        const latest = await withRpcFallback(net, async (provider, url) => {
          const bn = await provider.getBlockNumber();
          return { url, bn };
        }, { timeoutMs: 9500 });

        if (!latest.ok) return setStatus($("#rpc-status"), "bad", `Failed to read block number: ${String(latest.err?.message || latest.err)}`);

        const bn = latest.res.bn;
        const from = Math.max(0, bn - 2000);

        const r = await withRpcFallback(net, async (provider, url) => {
          const logs = await provider.getLogs({
            address: addr,
            fromBlock: from,
            toBlock: bn,
            topics: [topic0]
          });
          return { url, count: logs.length };
        }, { timeoutMs: 10500 });

        if (r.ok) {
          setStatus($("#rpc-status"), "ok", `Custom logs test OK (${r.res.count} logs) ‚Äî RPC: <span class="mono">${r.url}</span>`);
        } else {
          setStatus($("#rpc-status"), "bad", `Custom logs test failed: ${String(r.err?.message || r.err)}`);
        }
        gtagEvent("sec_rpc_dev_logs", { net });
      });
    }

// =========================
// Tx Decoder (4-line fixed DOM + Allowance line + MethodId + Tokens touched)
// Drop-in replacement for your whole Tx Decoder block.
// =========================

(() => {
  // ---- Minimal ABIs ----
  const tx_ROUTER_ABI_MIN = [
    "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETH(uint256,uint256,address[],address,uint256)",
    "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)"
  ];

  const tx_ERC20_ABI_MIN = [
    "function symbol() view returns (string)",
    "function name() view returns (string)",
    "function decimals() view returns (uint8)"
  ];

  // ---- Constants ----
  const tx_U256_MAX = (1n << 256n) - 1n;

  // Known routers (lowercase keys)
  const tx_KNOWN_ROUTERS = {
    bsc: {
      "0x10ed43c718714eb63d5aa57b78b54704e256024e": "PancakeSwap Router",
      "0x13f4ea83d0bd40e75c8222255bc855a974568dd4": "PancakeSwap V3 Router"
    },
    eth: {
      "0x7a250d5630b4cf539739df2c5dacb4c659f2488d": "Uniswap V2 Router",
      "0xef1c6e67703c7bd7107eed8303fbe6ec2554bf6b": "Uniswap Universal Router"
    }
  };

  // ---- Token meta cache ----
  const tx_TOKEN_META_CACHE = {}; // key: `${net}:${addr}` -> {symbol,name,decimals}

  // ---- Helpers ----
  function tx_esc(s){
    try{
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    } catch { return ""; }
  }

  function tx_badge(kind, label) {
    const k = (kind === "ok" || kind === "warn" || kind === "bad" || kind === "unk") ? kind : "unk";
    return `<span class="v ${k}"><span class="dot"></span>${tx_esc(label)}</span>`;
  }

  function tx_setSum(sel, html) {
    const el = document.querySelector(sel);
    if (el) el.innerHTML = html;
  }

  // Titles already exist in HTML on the left; we only set the value HTML.
  function tx_setLine(sel, _title, badgeHtml) {
    tx_setSum(sel, badgeHtml);
  }

  // Impact line supports a subline (Allowance)
  function tx_setImpactLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-impact", `${badgeHtml}${sub}`);
  }

  // NEW: Target line supports a subline (Tokens touched)
  function tx_setTargetLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-target", `${badgeHtml}${sub}`);
  }

  function tx_resetSummary() {
    tx_setLine("#tx-sum-action", "Action", tx_badge("unk", "‚Äî"));
    tx_setLine("#tx-sum-risk", "Risk", tx_badge("unk", "‚Äî"));
    // use Target line with empty subline (keeps same DOM, just value HTML)
    tx_setTargetLine(tx_badge("unk", "‚Äî"), "");
    tx_setImpactLine(tx_badge("unk", "‚Äî"), "");
  }

  function tx_isUnlimitedApprove(vBigInt) {
    try { return typeof vBigInt === "bigint" && vBigInt === tx_U256_MAX; } catch { return false; }
  }

  function tx_getKnownRouterName(net, addr) {
    const m = (tx_KNOWN_ROUTERS && tx_KNOWN_ROUTERS[net]) ? tx_KNOWN_ROUTERS[net] : {};
    if (!addr) return "";
    const k = isAddr(addr) ? normAddr(addr) : String(addr).toLowerCase();
    return m[k] || "";
  }

  function tx_decodeTransferLog(log) {
    try {
      const from = "0x" + log.topics[1].slice(26);
      const to   = "0x" + log.topics[2].slice(26);
      const val  = BigInt(log.data);
      return { token: normAddr(log.address), from: normAddr(from), to: normAddr(to), value: val };
    } catch { return null; }
  }

  function tx_decodeApprovalLog(log) {
    try {
      const owner   = "0x" + log.topics[1].slice(26);
      const spender = "0x" + log.topics[2].slice(26);
      const val     = BigInt(log.data);
      return { token: normAddr(log.address), owner: normAddr(owner), spender: normAddr(spender), value: val };
    } catch { return null; }
  }

  // Method selector (4 bytes)
  function tx_callSelector(txData) {
    try {
      const d = String(txData || "");
      if (d && d.startsWith("0x") && d.length >= 10) return d.slice(0, 10);
      return "";
    } catch { return ""; }
  }

  async function tx_getTokenMeta(readProvider, net, tokenAddr) {
    try {
      if (!tokenAddr || !isAddr(tokenAddr)) return null;
      const a = normAddr(tokenAddr);
      const key = `${net}:${a}`;
      if (tx_TOKEN_META_CACHE[key]) return tx_TOKEN_META_CACHE[key];

      const c = new E.Contract(a, tx_ERC20_ABI_MIN, readProvider);
      const [symbol, name, decimals] = await Promise.allSettled([c.symbol(), c.name(), c.decimals()]);

      const meta = {
        symbol: symbol.status === "fulfilled" ? String(symbol.value || "") : "",
        name: name.status === "fulfilled" ? String(name.value || "") : "",
        decimals: decimals.status === "fulfilled" ? Number(decimals.value) : null
      };

      tx_TOKEN_META_CACHE[key] = meta; // cache even partial
      return meta;
    } catch {
      return null;
    }
  }

  function tx_formatUnitsSafe(valueBigInt, decimals) {
    try {
      if (decimals == null || Number.isNaN(decimals)) return null;
      return E.formatUnits(valueBigInt, decimals);
    } catch {
      return null;
    }
  }

  function tx_pickPrimaryToken(approvals, transfers) {
    return (approvals[0]?.token) || (transfers[0]?.token) || "";
  }

  function tx_pickPrimaryApproval(approvals, net){
    // Prefer: unlimited > known-router > larger value > first
    let best = null;
    let bestIsUnlimited = false;
    let bestHasRouter = false;

    for (const a of approvals) {
      if (!a) continue;
      if (!best) { best = a; bestIsUnlimited = tx_isUnlimitedApprove(a.value); bestHasRouter = !!tx_getKnownRouterName(net, a.spender); continue; }

      const aUnlimited = tx_isUnlimitedApprove(a.value);
      const aHasRouter = !!tx_getKnownRouterName(net, a.spender);

      if (!bestIsUnlimited && aUnlimited) { best = a; bestIsUnlimited = true; bestHasRouter = aHasRouter; continue; }
      if (bestIsUnlimited && aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
      }
      if (!bestIsUnlimited && !aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
        if (typeof a.value === "bigint" && typeof best.value === "bigint" && a.value > best.value) { best = a; continue; }
      }
    }
    return best;
  }

  // =========================
  // Main
  // =========================
  async function runTxDecode() {
    const st = $("#tx-status");
    const out = $("#tx-out");
    const evWrap = $("#tx-events");
    clearStatus(st);

    tx_resetSummary();

    const net = netFromSelect("#tx-net");
    const hash = ($("#tx-hash")?.value || "").trim();
    if (!hash || !/^0x([A-Fa-f0-9]{64})$/.test(hash)) {
      setStatus(st, "warn", "Please paste a valid tx hash.");
      return;
    }

    const urls = buildRpcCandidates(net);
if (!urls.length) return setStatus(st, "bad", "No RPC available.");

setStatus(st, "info", "Fetching tx + receipt‚Ä¶");

try {
  const r = await withRpcFallback(net, async (provider, url) => {
    const [tx, rc] = await Promise.all([
      provider.getTransaction(hash),
      provider.getTransactionReceipt(hash)
    ]);

    if (!tx) throw new Error("tx_null");
    return { provider, tx, rc };
  }, { timeoutMs: 12000 });

  if (!r.ok) {
    const msg = String(r.err?.message || r.err || "");
    if (msg.includes("tx_null")) return setStatus(st, "bad", "Tx not found (wrong network / unsynced RPC).");
    return setStatus(st, "bad", `RPC failed: ${msg}`);
  }

  const read = r.res.provider;
  const tx = r.res.tx;
  const rc = r.res.rc;


      const chain = CHAINS[net];
      const txLink = chain.txUrl(hash);

      // best-effort decode (router calls)
      let decoded = null;
      try {
        const iface = new E.Interface(tx_ROUTER_ABI_MIN);
        decoded = iface.parseTransaction({ data: tx.data, value: tx.value });
      } catch {}

      const logs = rc?.logs || [];
      const transfersRaw = logs.filter(l => l.topics?.[0] === TRANSFER_TOPIC0).slice(0, 50);
      const approvalsRaw = logs.filter(l => l.topics?.[0] === APPROVAL_TOPIC0).slice(0, 50);

      const transfers = transfersRaw.map(tx_decodeTransferLog).filter(Boolean);
      const approvals = approvalsRaw.map(tx_decodeApprovalLog).filter(Boolean);

      const decodedName = decoded?.name || "";
      const hasRouterSwap = decodedName.toLowerCase().includes("swap");
      const hasApproval = approvals.length > 0;
      const hasTransfers = transfers.length > 0;

      const rcStatus = (rc && typeof rc.status !== "undefined") ? rc.status : undefined;
      const reverted = (rcStatus === 0 || rcStatus === 0n);

      // --- MethodId (selector) for unknown calls ---
      const methodId = (!decodedName && tx?.to) ? tx_callSelector(tx.data) : "";

      // -------------------------
      // Token meta preload (1‚Äì3 tokens touched)
      // Keep it fast and stable: prefer primary token first.
      // -------------------------
      const primaryToken = tx_pickPrimaryToken(approvals, transfers);

      const tokenSet = new Set();
      if (primaryToken) tokenSet.add(primaryToken);
      for (const t of transfers) if (t?.token) tokenSet.add(t.token);
      for (const a of approvals) if (a?.token) tokenSet.add(a.token);

      const tokenList = Array.from(tokenSet).slice(0, 3);
      const metaMap = {};

      await Promise.all(tokenList.map(async (addr) => {
        const meta = await tx_getTokenMeta(read, net, addr);
        metaMap[addr] = meta || null;
      }));

      const tokensTouched = tokenList
        .map(addr => (metaMap[addr]?.symbol || metaMap[addr]?.name || "").trim())
        .filter(Boolean)
        .slice(0, 3);

      // -------------------------
      // Action
      // -------------------------
      let actionLabel = "Unknown";
      let actionKind  = "unk";

      if (!tx.to && rc?.contractAddress) {
        actionLabel = "Contract creation";
        actionKind = reverted ? "warn" : "ok";
      } else if (decodedName) {
        actionLabel = decodedName;
        actionKind  = hasRouterSwap ? "ok" : "warn";
      } else if ((tx.data === "0x" || !tx.data) && tx.value && BigInt(tx.value) > 0n) {
        actionLabel = "Native transfer";
        actionKind = "warn";
      } else if (tx.to) {
        actionLabel = methodId ? `Contract call (unknown ‚Ä¢ ${methodId})` : "Contract call (unknown)";
        actionKind = "warn";
      }

      // -------------------------
      // Approval analysis
      // -------------------------
      let sawUnlimited = false;
      let sawKnownRouterUnlimited = false;
      let sawFiniteApprove = false;
      let sawRevoke = false;

      const knownRouterNames = new Set();

      for (const a of approvals) {
        if (!a) continue;

        const rn = tx_getKnownRouterName(net, a.spender);
        if (rn) knownRouterNames.add(rn);

        if (tx_isUnlimitedApprove(a.value)) {
          sawUnlimited = true;
          if (rn) sawKnownRouterUnlimited = true;
        } else {
          if (a.value === 0n) sawRevoke = true;
          else sawFiniteApprove = true;
        }
      }

      // -------------------------
      // Allowance subline (ONLY when approvals exist)
      // Allowance: TOKEN ‚Üí SPENDER (Unlimited / Limited / Revoked)
      // -------------------------
      let allowanceSub = "";
      if (hasApproval) {
        const bestAppr = tx_pickPrimaryApproval(approvals, net);
        if (bestAppr) {
          const tokenAddr = bestAppr.token;
          const spenderAddr = bestAppr.spender;

          const tokenMeta = metaMap[tokenAddr] || null;
          const tokName = (tokenMeta?.symbol || tokenMeta?.name || shortAddr(tokenAddr)).trim();

          const spenderRouter = tx_getKnownRouterName(net, spenderAddr);
          const spenderName = spenderRouter ? spenderRouter : shortAddr(spenderAddr);

          let status = "";
          if (tx_isUnlimitedApprove(bestAppr.value)) {
            status = "Unlimited";
          } else if (bestAppr.value === 0n) {
            status = "Revoked";
          } else {
            // show amount if decimals known
            const dec = tokenMeta?.decimals;
            const pretty = (dec != null) ? tx_formatUnitsSafe(bestAppr.value, dec) : null;
            status = pretty ? `Limited: ${pretty}` : "Limited";
          }

          allowanceSub = `Allowance: ${tokName} \u2192 ${spenderName} (${status})`;
        }
      }

      // -------------------------
      // Target (Token/Asset + creation support)
      // -------------------------
      let targetKind = "unk";
      let targetLabel = "‚Äî";

      if (!tx.to && rc?.contractAddress) {
        targetLabel = `New contract (${shortAddr(rc.contractAddress)})`;
        targetKind = reverted ? "warn" : "ok";
      } else if (tx.to) {
        const toRouterName = tx_getKnownRouterName(net, tx.to);
        if (toRouterName) {
          targetLabel = `${toRouterName} (${shortAddr(tx.to)})`;
          targetKind = "warn";
        } else if (primaryToken) {
          const meta = metaMap[primaryToken] || null;
          const nm = (meta?.symbol || meta?.name || "").trim();
          targetLabel = nm ? `${nm} (${shortAddr(primaryToken)})` : shortAddr(primaryToken);
          targetKind = "ok";
        } else {
          targetLabel = shortAddr(tx.to);
          targetKind = "ok";
        }
      }

      // NEW: Tokens touched subline for Summary (only when we have 1‚Äì3)
      const touchedSub = tokensTouched.length ? `Tokens touched: ${tokensTouched.join(", ")}` : "";

      // -------------------------
      // Risk (heuristics)
      // -------------------------
      let riskLabel = "Unknown";
      let riskKind  = "unk";

      if (reverted) {
        riskLabel = "Tx reverted (failed)";
        riskKind = "warn";
      } else if (hasRouterSwap) {
        riskLabel = "Likely DEX swap";
        riskKind = "ok";
      } else if (sawUnlimited && !sawKnownRouterUnlimited) {
        riskLabel = "High risk: unlimited approval (unknown spender)";
        riskKind = "bad";
      } else if (sawUnlimited && sawKnownRouterUnlimited) {
        const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
        riskLabel = `Unlimited approval (known router${names ? ": " + names : ""})`;
        riskKind = "warn";
      } else if (hasApproval && !decodedName) {
        riskLabel = "Approval without decoded call";
        riskKind = "warn";
      } else if (!decodedName && hasTransfers) {
        riskLabel = "Transfer activity (unknown call)";
        riskKind = "warn";
      } else if (decodedName) {
        riskLabel = "Contract interaction";
        riskKind = "warn";
      }

      // -------------------------
      // Max impact (Allowance-aware + largest transfer)
      // -------------------------
      let impactLabel = "‚Äî";
      let impactKind = "unk";

      if (sawUnlimited) {
        if (sawKnownRouterUnlimited) {
          const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
          impactLabel = `Unlimited spending approved (known router${names ? ": " + names : ""})`;
          impactKind = "warn";
        } else {
          impactLabel = "Unlimited spending approved (unknown spender)";
          impactKind = "bad";
        }
      } else if (sawFiniteApprove) {
        impactLabel = "Spending approved (limited)";
        impactKind = "warn";
      } else if (sawRevoke && !hasTransfers) {
        impactLabel = "Allowance revoked";
        impactKind = "ok";
      } else if (tx.value && BigInt(tx.value) > 0n) {
        impactLabel = `Sends ${E.formatEther(tx.value)} native`;
        impactKind = "warn";
      } else if (hasTransfers) {
        let largest = transfers[0];
        for (const t of transfers) if (t.value > largest.value) largest = t;

        const meta = metaMap[largest?.token] || null;
        const sym = (meta?.symbol || "").trim();
        const dec = meta?.decimals;

        const pretty = (dec != null) ? tx_formatUnitsSafe(largest.value, dec) : null;
        if (pretty && sym) impactLabel = `Largest transfer: ${pretty} ${sym}`;
        else if (sym) impactLabel = `Largest transfer: ${sym} (raw)`;
        else impactLabel = `${transfers.length} token transfer(s)`;

        impactKind = "ok";
      } else if (hasApproval) {
        impactLabel = "Allowance changed";
        impactKind = "warn";
      }

      // -------------------------
      // Fill the 4 fixed lines
      // (Target now includes Tokens touched subline)
      // (+ allowance subline under Max impact)
      // -------------------------
      tx_setLine("#tx-sum-action", "Action", tx_badge(actionKind, actionLabel));
      tx_setLine("#tx-sum-risk", "Risk", tx_badge(riskKind, riskLabel));
      tx_setTargetLine(tx_badge(targetKind, targetLabel), touchedSub);
      tx_setImpactLine(tx_badge(impactKind, impactLabel), allowanceSub);

      // -------------------------
      // Details panel (professional: Status + Gas + MethodId + Tokens touched)
      // -------------------------
      const gasUsed = rc?.gasUsed ? String(rc.gasUsed) : "‚Äî";
      const statusTxt = (typeof rcStatus === "undefined") ? "‚Äî" : (reverted ? "FAILED" : "SUCCESS");
      const tokensLine = tokensTouched.length ? `<b>Tokens:</b> <span class="mono">${tx_esc(tokensTouched.join(", "))}</span><br>` : "";
      const methodLine = (!decodedName && methodId) ? `<b>Method:</b> <span class="mono">${tx_esc(methodId)}</span><br>` : "";

      out.innerHTML = `
        <div class="small" style="margin-bottom:10px;">
          <b>Tx:</b> <a href="${txLink}" target="_blank" rel="noopener">${shortAddr(hash)}</a>
          <span class="muted">(${tx_esc(String(net).toUpperCase())})</span><br>
          <b>Status:</b> <span class="mono">${tx_esc(statusTxt)}</span> &nbsp; <b>Gas used:</b> <span class="mono">${tx_esc(gasUsed)}</span><br>
          ${methodLine}
          ${tokensLine}
          <b>From:</b> <span class="mono">${tx_esc(tx.from)}</span><br>
          <b>To:</b> <span class="mono">${tx_esc(tx.to || "‚Äî")}</span><br>
          <b>Value:</b> <span class="mono">${tx_esc(tx.value ? E.formatEther(tx.value) : "0")}</span>
        </div>
      `;
      out.style.display = "block";

      // -------------------------
      // Events (with token labels best-effort)
      // -------------------------
      const items = [];

      if (decoded?.args) {
        const args = [];
        decoded.args.forEach((v, i) => {
          args.push(`<div class="small mono" style="margin-top:6px;">arg${i}: ${tx_esc(String(v))}</div>`);
        });
        items.push(`
          <div class="card">
            <h3>Decoded Inputs</h3>
            <div class="small">Best-effort decode for common router calls.</div>
            ${args.join("")}
          </div>
        `);
      }

      if (transfers.length) {
        const rows = transfers.map(d => {
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const tag = sym ? ` <span class="muted">(${tx_esc(sym)})</span>` : "";
          return `<div class="small mono" style="margin-top:6px;">Transfer ${shortAddr(d.from)} ‚Üí ${shortAddr(d.to)}${tag} ‚Ä¢ raw: ${tx_esc(d.value.toString())}</div>`;
        }).join("");

        items.push(`
          <div class="card">
            <h3>Transfer Events</h3>
            ${rows}
          </div>
        `);
      }

      if (approvals.length) {
        const rows = approvals.map(d => {
          const routerName = tx_getKnownRouterName(net, d.spender);
          const routerTag = routerName ? ` <span class="muted">(${tx_esc(routerName)})</span>` : "";
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const tokenTag = sym ? ` <span class="muted">(${tx_esc(sym)})</span>` : "";

          const inf = tx_isUnlimitedApprove(d.value)
            ? ` <span class="muted">(unlimited)</span>`
            : (d.value === 0n ? ` <span class="muted">(revoked)</span>` : "");

          return `<div class="small mono" style="margin-top:6px;">Approval ${shortAddr(d.owner)} ‚Üí ${shortAddr(d.spender)}${routerTag}${tokenTag} ‚Ä¢ raw: ${tx_esc(d.value.toString())}${inf}</div>`;
        }).join("");

        items.push(`
          <div class="card">
            <h3>Approval Events</h3>
            ${rows}
          </div>
        `);
      }

      evWrap.innerHTML = items.length
        ? `<div class="grid-2">${items.join("")}</div>`
        : `<div class="small muted">No common events detected (or log count is zero).</div>`;

      setStatus(st, "ok", "Done.");
      gtagEvent("sec_tx_decode", { net });

    } catch (e) {
      setStatus(st, "bad", `Decode failed: ${String(e?.message || e)}`);
    }
  }

  // =========================
  // UI wiring (idempotent)
  // =========================
  let tx_ui_inited = false;

  function initTxUi() {
    if (tx_ui_inited) return;
    tx_ui_inited = true;

    $("#tx-run")?.addEventListener("click", runTxDecode);

    $("#tx-copy-md")?.addEventListener("click", async () => {
      const a = (document.querySelector("#tx-sum-action")?.innerText || "Action ‚Äî").trim();
      const r = (document.querySelector("#tx-sum-risk")?.innerText || "Risk ‚Äî").trim();
      const t = (document.querySelector("#tx-sum-target")?.innerText || "Target ‚Äî").trim();
      const m = (document.querySelector("#tx-sum-impact")?.innerText || "Max impact ‚Äî").trim();
      const body = ($("#tx-out")?.innerText || "").trim();

      const txt = ["Tx Decoder Summary", a, r, t, m, "", body].join("\n");

      const ok = await copyText(txt);
      setStatus($("#tx-status"), ok ? "ok" : "warn", ok ? "Copied." : "Copy failed.");
    });
  }

  // =========================
  // Export
  // =========================
  window.CX = window.CX || {};
  window.CX.runTxDecode = runTxDecode;
  window.CX.initTxUi = initTxUi;
  window.CX.txDecoder = window.CX.txDecoder || {};
  window.CX.txDecoder.getTokenMeta = tx_getTokenMeta;
  window.CX.txDecoder.metaCache = tx_TOKEN_META_CACHE;

})();



    // =========================
    // Dev Tools (Bookmarklet + Monitor)
    // =========================
    function renderBmHelp(){
      const el = $("#bm-help");
      if (!el) return;
      el.innerHTML = t(currentLang, "bm_help_html") || "";
    }

    function bmGenerate(){
      const base = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
      const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${base}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

      const bm = `javascript:${encodeURIComponent(js)}`;
      setStatus($("#bm-out"), "ok", `Bookmarklet generated. <span class="mono">(copy it)</span>`);
      $("#bm-out").dataset.bm = bm;
      const drag = $("#bm-drag");
if (drag) {
  drag.href = bm;                 
  drag.classList.remove("hidden");
  drag.setAttribute("data-ready", "1");
}
      renderBmHelp();
      gtagEvent("sec_bm_generate");
    }

    async function bmCopy(){
      const bm = $("#bm-out")?.dataset?.bm || "";
      if (!bm) return setStatus($("#bm-out"), "warn", "Generate first.");
      const ok = await copyText(bm);
      setStatus($("#bm-out"), ok ? "ok" : "warn", ok ? "Copied bookmarklet." : "Copy failed.");
    }

    function loadMonitor(){
      try { return JSON.parse(localStorage.getItem(LS_MON) || "[]"); } catch { return []; }
    }
    function saveMonitor(list){
      try { localStorage.setItem(LS_MON, JSON.stringify(list || [])); } catch {}
    }

    function renderMonitorTable(){
      const table = $("#mon-table");
      if (!table) return;
      const head = table.querySelector(".trow.head");
      table.innerHTML = "";
      if (head) table.appendChild(head);

      const list = loadMonitor();
      if (!list.length) {
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell muted">‚Äî</div>
    <div class="cell muted">‚Äî</div>
    <div class="cell muted hide-sm">‚Äî</div>
    <div class="cell muted">‚Äî</div>
    <div class="cell muted">‚Äî</div>
  </div>
`);
        return;
      }

      for (const item of list) {
        const chain = CHAINS[item.net];
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell mono"><a href="${chain.addressUrl(item.addr)}" target="_blank" rel="noopener">${shortAddr(item.addr)}</a></div>
    <div class="cell">${String(item.net || "").toUpperCase()}</div>
    <div class="cell hide-sm">${
  item.lastSeen
    ? new Date(item.lastSeen * 1000).toLocaleString().replace(", ", "<br>")
    : "‚Äî"
}</div>
    <div class="cell">${item.status || "‚Äî"}</div>

    <div class="cell">
      <button class="mon-remove" type="button"
              data-action="mon-remove"
              data-addr="${item.addr}"
              data-net="${item.net}"
              title="Remove"
              aria-label="Remove">√ó</button>
    </div>
  </div>
`);
      }
    }

    async function monAdd(){
      const st = $("#mon-status");
      clearStatus(st);

      const net = netFromSelect("#mon-net");
      const addrRaw = ($("#mon-addr")?.value || "").trim();
      if (!isAddr(addrRaw)) return setStatus(st, "warn", "Enter a valid contract address.");

      const addr = normAddr(addrRaw);
      const list = loadMonitor();
      const key = `${net}:${safeLower(addr)}`;
      const filtered = list.filter(x => `${x.net}:${safeLower(x.addr)}` !== key);
      filtered.unshift({ net, addr, status: "added", lastSeen: nowTs() });
      saveMonitor(filtered.slice(0, 50));
      renderMonitorTable();
      setStatus(st, "ok", "Added to monitor list (local).");
      gtagEvent("sec_mon_add", { net });
    }

    async function monCheckAll(){
      const st = $("#mon-status");
      clearStatus(st);

      const list = loadMonitor();
      if (!list.length) return setStatus(st, "warn", "Monitor list is empty.");

      setStatus(st, "info", `Checking ${list.length} contract(s)‚Ä¶`);

      for (const item of list) {
        try{
          const codeRes = await getCodeSafe(item.net, item.addr);
          item.status = (codeRes.ok && codeRes.code && codeRes.code !== "0x") ? "code ‚úÖ" : "no code ‚ùå";
          item.lastSeen = nowTs();
        } catch {
          item.status = "error";
          item.lastSeen = nowTs();
        }
      }

      saveMonitor(list);
      renderMonitorTable();
      setStatus(st, "ok", "Monitor check done.");
      gtagEvent("sec_mon_check");
    }

    async function monExport(){
      const list = loadMonitor();
      const ok = await copyText(safeJson(list));
      setStatus($("#mon-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
    }
    function monRemove(addr, net){
  const st = $("#mon-status");
  const addrLower = safeLower(String(addr || "").trim());
  const netLower  = safeLower(String(net || "").trim());

  const list = loadMonitor();
  const next = list.filter(it =>
    !(safeLower(it.net) === netLower && safeLower(it.addr) === addrLower)
  );

  saveMonitor(next);
  renderMonitorTable();
  setStatus(st, "ok", "Removed.");
  gtagEvent("sec_mon_remove", { net: netLower });
}

function bindMonRemove(){
  const table = $("#mon-table");
  if (!table || table.__cxBoundRemove) return;
  table.__cxBoundRemove = true;

  table.addEventListener("click", (e) => {
    const btn = e.target.closest('button[data-action="mon-remove"]');
    if (!btn) return;
    e.preventDefault();
    monRemove(btn.getAttribute("data-addr"), btn.getAttribute("data-net"));
  });
}


    function initDevUi(){
      const base = location.href.split("?")[0];
      const el = $("#bm-base");
      if (el) el.value = base;

      $("#bm-generate")?.addEventListener("click", bmGenerate);
      $("#bm-copy")?.addEventListener("click", bmCopy);

      $("#mon-add")?.addEventListener("click", monAdd);
      $("#mon-check")?.addEventListener("click", monCheckAll);
      $("#mon-export")?.addEventListener("click", monExport);

      renderBmHelp();
      renderMonitorTable();
      bindMonRemove();
      // Always enable the "drag to bookmarks" link (default bookmarklet)
try {
  const hubBase = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
  const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${hubBase}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

  const bmDefault = `javascript:${encodeURIComponent(js)}`;

  const drag = $("#bm-drag");
  if (drag) drag.href = bmDefault;
} catch {}

    }

    // =========================
    // URL auto-run (tool=...)
    // =========================
    async function handleAutoRun(){
      const q = parseQuery();
      if (!q.tool) return;

      const tool = q.tool;
      const netRaw = String(q.net || q.chain || "").toLowerCase();
      const net = (netRaw === "eth" || netRaw === "ethereum" || netRaw === "1") ? "eth" : "bsc";

      if (tool === "quick") {
        showPanel("quick");
        if ($("#qs-net")) $("#qs-net").value = net;
        if (q.token && isAddr(q.token)) {
          if ($("#qs-token")) $("#qs-token").value = normAddr(q.token);
          setTimeout(() => {
  const fn = window.CX_QS_V5?.runQuickScan || window.runQuickScan;
  if (typeof fn === "function") fn();
}, 250);

        }
      }

      if (tool === "liq") {
        showPanel("liq");
        if ($("#liq-net")) $("#liq-net").value = net;
        if (q.token && isAddr(q.token)) {
          if ($("#liq-token")) $("#liq-token").value = normAddr(q.token);
          setTimeout(() => runLiqScan(), 250);
        }
      }

      if (tool === "tx") {
  showPanel("tx");

  if (q.tx && /^0x([A-Fa-f0-9]{64})$/.test(q.tx)) {
    if ($("#tx-hash")) $("#tx-hash").value = q.tx;

    setTimeout(() => {
      const sel = $("#tx-net");
      if (sel) {
        sel.value = net; 
        sel.dispatchEvent(new Event("change", { bubbles: true }));
      }
      const btn = $("#tx-run");
      if (btn) btn.click();
    }, 400);
  }
}
      setTimeout(() => {
  const target = `#panel-${tool}`;   
  const el = document.querySelector(target);
  if (!el) return;

  try { history.replaceState(null, "", target); }
  catch { location.hash = target; }

  el.scrollIntoView({ behavior: "smooth", block: "start" });
}, 450);
    }

    // =========================
    // Boot
    // =========================
    function boot(){
      initLang();
      bindLangButtons();

      initPanels();
      initWalletButtons();
      initApiKeysUi();

      initQuickScanUi();
      initLiqUi();
      initWalletSecurityDNAUi();
      initRpcUi();
      if (window.CX && typeof window.CX.initTxUi === "function") {
  window.CX.initTxUi();
}
      initDevUi();

      applyI18n(currentLang);
      renderWalletLabels();
      handleAutoRun();

      // UX: close panels via ESC
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") showPanel(null);
      });
    }

    // Run
    boot();
  </script>
</body>
</html>

        
