<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/logo.png">
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">

  <meta charset="UTF-8" />
  <title>CycleX ‚Äì Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg-main: #05060a;
      --bg-gradient-start: #05060a;
      --bg-gradient-mid: #1a0d3a;
      --bg-gradient-end: #003a4c;

      --text-main: #f4f6ff;
      --text-muted: rgba(244, 246, 255, 0.7);

      --accent-cyan: #00e5ff;
      --accent-green: #5dffb2;
      --accent-purple: #7c5cff;

      --card-bg: rgba(255, 255, 255, 0.06);
      --border-subtle: rgba(255, 255, 255, 0.12);

      --shadow-soft: 0 30px 90px rgba(0, 0, 0, 0.75);
      --radius-xl: 24px;
      --radius-lg: 18px;
      --transition-fast: 0.18s ease-out;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      --maxw: 1160px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: var(--sans);
      background:
        radial-gradient(circle at top left, rgba(124, 92, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at top right, rgba(0, 229, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at bottom, rgba(0, 58, 76, 0.55) 0%, transparent 55%),
        linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
      color: var(--text-main);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      animation: fadeBody 0.7s ease-out forwards;
      opacity: 1;
      overflow-x: hidden;
    }
    @keyframes fadeBody { from { opacity: 0; } to { opacity: 1; } }
    a { color: inherit; text-decoration: none; }

    .page-shell { max-width: var(--maxw); margin: 0 auto; padding: 32px 20px 72px; }

    /* Top bar */
    .top-bar {
      position: sticky;
      top: 14px;
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 18px;
      margin-bottom: 26px;
      border-radius: 999px;
      background: rgba(8, 10, 22, 0.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }
    .brand { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .brand-logo {
      width: 44px; height: 44px; border-radius: 16px; object-fit: contain;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
      flex: 0 0 auto;
    }
    .brand-text { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .brand-title {
      font-weight: 800; letter-spacing: 0.05em; font-size: 18px; text-transform: uppercase;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .brand-sub {
      font-size: 11px; text-transform: uppercase; letter-spacing: 0.16em; color: var(--text-muted);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }

    .lang-switch {
      display: inline-flex;
      align-items: center;
      padding: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.55);
      gap: 2px;
      flex: 0 0 auto;
    }
    .lang-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      padding: 6px 9px;
      border-radius: 999px;
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast), transform var(--transition-fast);
      user-select: none;
      white-space: nowrap;
    }
    .lang-btn:hover { transform: translateY(-1px); }
    .lang-btn.active { background: rgba(0, 229, 255, 0.14); color: var(--accent-cyan); }

    body.lang-switching { animation: langFade 0.28s ease-out; }
    @keyframes langFade { from { opacity: 0.5; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* Hero */
    .hero {
      text-align: center;
      max-width: 980px;
      margin: 0 auto 18px auto;
      animation: fadeUp 0.8s ease-out forwards;
    }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

    .hero-kicker { font-size: 13px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-cyan); margin-bottom: 14px; }
    .hero-title { font-size: clamp(40px, 5vw, 60px); line-height: 1.05; font-weight: 900; margin-bottom: 14px; letter-spacing: -0.02em; }
    .hero-subtitle { max-width: 760px; margin: 0 auto 18px auto; font-size: 16px; line-height: 1.5; color: var(--text-muted); }

    .hero-actions { display: flex; justify-content: center; flex-wrap: wrap; gap: 14px; margin-bottom: 10px; }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 13px 26px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast);
      user-select: none;
      white-space: nowrap;
    }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), #7df2ff);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 229, 255, 0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 229, 255, 0.6); }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-green), #b9ffcf);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 230, 118, 0.4);
    }
    .btn-secondary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 230, 118, 0.7); }

    .btn-ghost {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--text-main);
      box-shadow: 0 12px 34px rgba(0,0,0,0.45);
    }
    .btn-ghost:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }

    .note-line {
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.45;
    }

    /* Tool cubes ‚Äî 3x2 centered */
    .tool-grid-wrap { max-width: 1040px; margin: 0 auto 18px; }
    .tool-grid-title {
      text-align: center;
      margin: 14px 0 8px;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(244,246,255,0.72);
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 18px;
      margin-top: 10px;
      align-items: stretch;
    }
    .tool-card {
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius-xl);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 22px 22px 18px;
      box-shadow: 0 24px 70px rgba(0,0,0,0.65), inset 0 1px 0 rgba(255,255,255,0.05);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: transform var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
      min-width: 0;
      min-height: 178px;
    }
    .tool-card::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(520px 180px at 18% -5%, rgba(0,229,255,.18), transparent 60%),
        radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.18), transparent 60%);
      pointer-events:none;
      opacity: .95;
    }
    .tool-card > * { position: relative; }

    .tool-card:hover { transform: translateY(-3px); border-color: rgba(0,229,255,0.28); background: rgba(255,255,255,0.065); }
    .tool-card.active { border-color: rgba(0,229,255,0.42); background: rgba(0,229,255,0.06); }

    .tool-head { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:10px; }
    .tool-name { font-size: 17px; font-weight: 900; letter-spacing: 0.01em; line-height: 1.25; }
    .tool-desc { font-size: 14px; color: var(--text-muted); line-height: 1.5; }

    .badge-row { display:flex; flex-wrap:wrap; gap:8px; margin-top: 14px; }
    .badge {
      display:inline-flex; align-items:center; gap:8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
      user-select: none;
    }
    .badge strong { color: rgba(244,246,255,0.92); font-weight: 800; }
    .badge.beta { border-color: rgba(255,193,7,0.25); background: rgba(255,193,7,0.08); color: rgba(244,246,255,0.92); }

    /* Risk badges (uniform) */
    .risk-badges { display:flex; flex-wrap:wrap; gap:8px; margin-top: 10px; }
    .risk {
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: rgba(244,246,255,0.88);
      user-select:none;
    }
    .risk .dot{
      width:10px; height:10px; border-radius: 999px;
      background: rgba(255,255,255,0.25);
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06);
      flex: 0 0 auto;
    }
    .risk.ok    { border-color: rgba(0,230,118,0.25); background: rgba(0,230,118,0.08); }
    .risk.ok .dot { background: rgba(0,230,118,0.95); }
    .risk.warn  { border-color: rgba(255,193,7,0.25); background: rgba(255,193,7,0.08); }
    .risk.warn .dot { background: rgba(255,193,7,0.95); }
    .risk.bad   { border-color: rgba(220,53,69,0.25); background: rgba(220,53,69,0.10); }
    .risk.bad .dot { background: rgba(220,53,69,0.95); }

    /* Panels */
    .panel-shell {
      margin-top: 14px;
      padding: 22px 20px;
      border-radius: var(--radius-xl);
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    .panel-shell.hidden { display: none; }

    .panel-head {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .panel-kicker {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--accent-purple);
      margin-bottom: 8px;
    }
    .panel-title { font-size: 28px; font-weight: 900; letter-spacing: -0.01em; line-height: 1.12; }
    .panel-sub { margin-top: 8px; max-width: 900px; color: var(--text-muted); font-size: 14px; line-height: 1.6; }

    .panel-actions { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 14px; }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 16px;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
      min-width: 0;
    }
    .card h3 { font-size: 15px; letter-spacing: 0.02em; margin-bottom: 8px; color: var(--text-main); }
    .muted { color: var(--text-muted); font-size: 13px; line-height: 1.45; }

    .field { margin-top: 10px; }
    .label { font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); margin-bottom: 6px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(5, 7, 18, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    textarea { border-radius: 18px; min-height: 96px; resize: vertical; padding: 12px 12px; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent-cyan); }
    .mono { font-family: var(--mono); }

    .toggle{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      user-select:none;
      width: 100%;
    }
    .toggle input{ width:auto; accent-color: var(--accent-cyan); }

    .status {
      margin-top: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: var(--text-main);
      line-height: 1.5;
      font-size: 13px;
      display: none;
      overflow-wrap: anywhere;
    }
    .status.ok   { display:block; background: rgba(0, 230, 118, 0.10); border-color: rgba(0,230,118,0.35); color: #78ffbf; }
    .status.warn { display:block; background: rgba(255, 193, 7, 0.10); border-color: rgba(255,193,7,0.35); color: #ffd166; }
    .status.bad  { display:block; background: rgba(220, 53, 69, 0.10); border-color: rgba(220,53,69,0.35); color: #ff7a8a; }
    .status.info { display:block; background: rgba(0, 229, 255, 0.10); border-color: rgba(0,229,255,0.30); color: #7df2ff; }

    .small { font-size: 12px; color: var(--text-muted); line-height: 1.45; }

    .table {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      overflow: hidden;
    }
    .trow {
      display: grid;
      grid-template-columns: 1.3fr 1.1fr 0.9fr 0.9fr;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      align-items: center;
      font-size: 13px;
    }
    .trow.head {
      border-top: none;
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(244,246,255,0.75);
    }

    /* RPC table: RPC | latency | chain | block | call | logs | status */
    .trow.rpc { grid-template-columns: 1.55fr 0.62fr 0.62fr 0.62fr 0.62fr 0.62fr 0.6fr; }
    .trow .cell { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .trow .cell.wrap { white-space: normal; overflow: visible; }
    .trow.highlight { background: rgba(0,230,118,0.10); border-top-color: rgba(0,230,118,0.20); }

    .chip {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: rgba(244,246,255,0.88);
      cursor: pointer;
      user-select: none;
      transition: transform var(--transition-fast), border-color var(--transition-fast);
      font-size: 12px;
    }
    .chip:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }

    .share-row { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }

    /* Footer */
    .footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      margin-top: 20px;
      padding-top: 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .footer-tagline { color: var(--accent-cyan); font-weight: 700; }

    /* RTL tweaks */
    html[dir="rtl"] body { direction: rtl; }
    html[dir="rtl"] .top-bar { flex-direction: row-reverse; }
    html[dir="rtl"] .brand { flex-direction: row-reverse; }
    html[dir="rtl"] .panel-head { flex-direction: row-reverse; }
    html[dir="rtl"] .row { flex-direction: row-reverse; }
    html[dir="rtl"] .panel-actions { justify-content: flex-start; }

    /* Responsiveness */
    @media (max-width: 1080px) {
      .tool-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media (max-width: 980px) {
      .grid-2 { grid-template-columns: 1fr; }
      .panel-title { font-size: 24px; }
      .trow.rpc { grid-template-columns: 1.7fr 0.9fr 0.9fr; }
      .trow.rpc .hide-sm { display: none; }
    }
    @media (max-width: 900px) {
      .tool-grid { grid-template-columns: 1fr; }
      .tool-card { min-height: unset; }
    }
    @media (max-width: 640px) {
      .top-bar { top: 10px; padding: 10px 12px; }
      .brand-logo { width: 40px; height: 40px; border-radius: 14px; }
      .btn { padding: 12px 18px; font-size: 13px; }
    }
  </style>
</head>

<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector">
        <button class="lang-btn active" data-lang="en">üá∫üá∏ EN</button>
        <button class="lang-btn" data-lang="zh">üá®üá≥ ‰∏≠Êñá</button>
        <button class="lang-btn" data-lang="ar">üá∏üá¶ ÿπÿ±ÿ®Ÿä</button>
        <button class="lang-btn" data-lang="ru">üá∑üá∫ RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Tools</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          A lightweight, client-side toolkit for safer swaps, approvals hygiene, liquidity checks, RPC health, and transaction decoding across BSC + Ethereum.
        </p>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-quick" data-i18n="btn_quick">Run Quick Scan</button>
        </div>

        <div class="note-line" data-i18n="hero_note">
          Note: These checks are informational and do not guarantee safety. Always verify independently.
        </div>
      </section>

      <section class="tool-grid-wrap">
        <div class="tool-grid-title" data-i18n="tools_kicker">CHOOSE A TOOL</div>

        <div class="tool-grid" id="toolGrid">
          <div class="tool-card active" data-tool="quick">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_quick_title">Quick Scan</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_quick_desc">Fast token sanity-check + shareable report + cache.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_fast">Fast</strong></div>
              <div class="badge"><strong data-i18n="badge_share">Share</strong></div>
              <div class="badge"><strong data-i18n="badge_cache">Cache</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="liq">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_liq_title">Token + Liquidity Scan</div>
              <div class="badge"><strong>V2</strong> + <strong>V3</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_liq_desc">DEX Registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_dex">DEX</strong></div>
              <div class="badge"><strong>USDT</strong></div>
              <div class="badge"><strong data-i18n="badge_pairs">Pairs</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="approvals">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_approvals_title">Approval Guardian</div>
              <div class="badge"><strong data-i18n="badge_wallet">Wallet</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_approvals_desc">Check and revoke ERC-20 allowances safely (approve ‚Üí 0).</div>
            <div class="badge-row">
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
              <div class="badge"><strong data-i18n="badge_safe">Safe</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="rpc">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
              <div class="badge"><strong>‚úÖ</strong> Table</div>
            </div>
            <div class="tool-desc" data-i18n="cube_rpc_desc">Latency + chainId + block + eth_call + read logs + dev custom test.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_copy">Copy</strong></div>
              <div class="badge"><strong data-i18n="badge_dev">Dev</strong></div>
              <div class="badge"><strong>X</strong> Share</div>
            </div>
          </div>

          <div class="tool-card" data-tool="tx">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_tx_title">Tx Decoder</div>
              <div class="badge"><strong data-i18n="badge_decode">Decode</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_tx_desc">Decode inputs + common events (Transfer/Approval) from a tx hash.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_receipt">Receipt</strong></div>
              <div class="badge"><strong data-i18n="badge_events">Events</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="dev">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_dev_title">Dev Tools</div>
              <div class="badge"><strong data-i18n="badge_tools">Tools</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_dev_desc">Bookmarklet generator + local contract monitor (no server).</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_bookmarklet">Bookmarklet</strong></div>
              <div class="badge"><strong data-i18n="badge_local">Local</strong></div>
            </div>
          </div>
        </div>
      </section>
      <!-- PANELS -->
      <section class="panel-shell" id="panel-quick">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
            <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
            <div class="panel-sub" data-i18n="p_quick_sub">
              Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="walletLabel">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseQuick" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="quick_input_title">Token Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="qs-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="qs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="qs_tip">
                Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="options_label">Options</div>
              <label class="toggle">
                <input type="checkbox" id="qs-require-liq">
                <span data-i18n="opt_require_liq">Require liquidity (stricter score)</span>
              </label>
              <label class="toggle" style="margin-top:10px">
                <input type="checkbox" id="qs-show-json" checked>
                <span data-i18n="opt_show_json">Enable JSON report (copy)</span>
              </label>
            </div>

            <div class="field" style="margin-top:14px">
              <div class="label" data-i18n="api_keys_label">Explorer API keys (optional)</div>
              <label class="toggle">
                <input type="checkbox" id="api-use">
                <span data-i18n="opt_use_explorer_apis">Use BscScan/Etherscan (adds Verified + ABI heuristics)</span>
              </label>

              <div class="row" style="margin-top:10px">
                <input id="api-bscscan" class="mono" placeholder="BscScan API key (stored locally)" />
                <input id="api-etherscan" class="mono" placeholder="Etherscan API key (stored locally)" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="api-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="api-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>

              <div class="small" style="margin-top:8px" data-i18n="api_keys_tip">
                Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="qs-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
                <button class="btn btn-ghost" id="qs-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
              </div>
            </div>

            <div class="share-row">
              <button class="btn btn-ghost" id="qs-share-x">Share to X</button>
              <button class="btn btn-ghost" id="qs-share-tg">Share to Telegram</button>
              <button class="btn btn-ghost" id="qs-copy-xtext" data-i18n="btn_copy_xtext">Copy X text</button>
            </div>

            <div id="qs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="results_title">Results</h3>
            <div class="small" data-i18n="results_hint">
              Green / Yellow / Red signals. Not a guarantee ‚Äî just verifiable on-chain checks.
            </div>

            <div id="qs-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="qs-risk" class="risk-badges"></div>
            <div id="qs-pairsWrap" style="margin-top:12px;"></div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-liq">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_liq_kicker">Token + Liquidity Scan</div>
            <div class="panel-title" data-i18n="p_liq_title">DEX Registry liquidity checks</div>
            <div class="panel-sub" data-i18n="p_liq_sub">
              We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="liq-wallet">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseLiq" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="liq_input_title">Token + Network</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="liq-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="liq-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="liq_tip">
                Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="liq_dex_label">DEX registry (checked)</div>
              <div class="small" id="liq-dex-note" style="margin-top:6px;"></div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="liq-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="liq-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="liq-share-x">Share to X</button>
              </div>
            </div>

            <div id="liq-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="liq_results_title">Liquidity Results</h3>
            <div class="small" data-i18n="liq_results_hint">
              V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.
            </div>

            <div id="liq-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="liq-risk" class="risk-badges"></div>
            <div id="liq-tablewrap" style="margin-top:10px;"></div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-approvals">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_app_kicker">Approval Guardian</div>
            <div class="panel-title" data-i18n="p_app_title">Check and revoke allowances</div>
            <div class="panel-sub" data-i18n="p_app_sub">
              Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="ap-wallet">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseApprovals" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="ap_settings_title">Settings</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="ap-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="row" style="justify-content:space-between">
                <div class="pill"><span data-i18n="ap_connected">Connected:</span> <span id="ap-address" class="mono">‚Äî</span></div>
                <button class="btn btn-secondary" id="ap-connect" data-i18n="ap_connect">Connect / Refresh</button>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_spender_label">Spender preset</div>
              <div class="row">
                <select id="ap-spender-preset">
                  <option value="pcs_router">PancakeSwap Router (BSC)</option>
                  <option value="uni_router">Uniswap V2 Router (ETH)</option>
                  <option value="custom">Custom‚Ä¶</option>
                </select>
                <input id="ap-spender" class="mono" placeholder="0x spender..." />
              </div>
              <div class="small" style="margin-top:8px" data-i18n="ap_spender_tip">
                Start with a router preset, then add tokens you want to clean up.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_tokens_label">Token list (one per line)</div>
              <textarea id="ap-tokens" class="mono" placeholder="0x...\n0x...\n0x..."></textarea>
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="ap-seed-common" data-i18n="ap_seed">Seed common tokens</button>
                <button class="btn btn-ghost" id="ap-seed-history" data-i18n="ap_seed_history">Use scan history</button>
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="ap-check" data-i18n="ap_check">Check Allowances</button>
                <button class="btn btn-ghost" id="ap-revoke-all" data-i18n="ap_revoke_all">Revoke All (non-zero)</button>
              </div>
              <div class="small" style="margin-top:8px" data-i18n="safe_mode_note">
                Safe mode: actions that require a signature are disabled until you connect a wallet.
              </div>
            </div>

            <div id="ap-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="ap_results">Allowances</h3>
            <div class="small" data-i18n="ap_results_hint">
              If allowance is ‚Äúinfinite‚Äù, revoke is recommended unless you fully trust the spender.
            </div>

            <div id="ap-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Token</div>
                <div class="cell">Allowance</div>
                <div class="cell hide-sm">Symbol</div>
                <div class="cell">Action</div>
              </div>
              <div class="trow">
                <div class="cell muted">‚Äî</div>
                <div class="cell muted">‚Äî</div>
                <div class="cell muted hide-sm">‚Äî</div>
                <div class="cell muted">‚Äî</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-rpc">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_rpc_kicker">RPC Health Checker</div>
            <div class="panel-title" data-i18n="p_rpc_title">Find the best endpoint</div>
            <div class="panel-sub" data-i18n="p_rpc_sub">
              We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseRpc" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_inputs">Inputs</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="rpc-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_private_label">Private RPC (saved locally)</div>
              <input id="rpc-private" class="mono" placeholder="https://... (stored locally only)" />
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-private-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="rpc-private-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>
              <div class="small" style="margin-top:8px" data-i18n="rpc_private_tip">
                Not embedded in HTML. Stored in your browser only (localStorage).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC (top priority)</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-share-x">Share to X</button>
              </div>
            </div>

            <div class="field" style="margin-top:14px">
              <h3 data-i18n="rpc_dev_title">Developer custom logs test</h3>
              <div class="small" data-i18n="rpc_dev_hint">
                Optional: test logs for a contract. This helps developers verify their own RPC stability.
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_addr">Contract address (optional)</div>
                <input id="rpc-dev-addr" class="mono" placeholder="0x..." />
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_topic">Topic0 (optional)</div>
                <input id="rpc-dev-topic" class="mono" placeholder="0xddf252ad... (Transfer) or leave empty" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-dev-run" style="padding:10px 14px; font-size:12px;" data-i18n="rpc_dev_run">Run custom test</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
              <div class="trow head rpc">
                <div class="cell">RPC</div>
                <div class="cell">ms</div>
                <div class="cell hide-sm">chain</div>
                <div class="cell hide-sm">block</div>
                <div class="cell hide-sm">call</div>
                <div class="cell hide-sm">logs</div>
                <div class="cell">status</div>
              </div>
            </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-tx">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_tx_kicker">Tx Decoder</div>
            <div class="panel-title" data-i18n="p_tx_title">Decode a transaction</div>
            <div class="panel-sub" data-i18n="p_tx_sub">
              Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseTx" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="tx_input_title">Tx Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="tx-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="tx_hash_label">Transaction hash</div>
              <input id="tx-hash" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="tx_tip">
                Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="tx-run" data-i18n="btn_decode">Decode</button>
                <button class="btn btn-ghost" id="tx-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
              </div>
            </div>

            <div id="tx-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="tx_results_title">Decoded Output</h3>
            <div id="tx-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a tx hash and click <b>Decode</b>.
            </div>
            <div id="tx-events" style="margin-top:10px;"></div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-dev">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_dev_kicker">Dev Tools</div>
            <div class="panel-title" data-i18n="p_dev_title">Bookmarklet + Local Monitor</div>
            <div class="panel-sub" data-i18n="p_dev_sub">
              Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseDev" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="bm_title">Bookmarklet Generator</h3>
            <div class="small" data-i18n="bm_hint">
              Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.
            </div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="bm_base_label">Hub URL (this page)</div>
              <input id="bm-base" class="mono" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="bm-generate" data-i18n="bm_generate">Generate</button>
                <button class="btn btn-ghost" id="bm-copy" data-i18n="bm_copy">Copy Bookmarklet</button>
              </div>
            </div>

            <div id="bm-out" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="mon_list_title">Contract Monitor (local)</h3>
            <div class="small" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="mon-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Contract address</div>
              <input id="mon-addr" class="mono" placeholder="0x..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
                <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
                <button class="btn btn-ghost" id="mon-export" data-i18n="mon_export">Copy JSON</button>
              </div>
            </div>

            <div id="mon-status" class="status info"></div>

            <div id="mon-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Contract</div>
                <div class="cell">Network</div>
                <div class="cell hide-sm">Last seen</div>
                <div class="cell">Status</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>

    </main>
  </div>
  <!-- ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <!-- AppKit + App logic -->
  <script type="module">
    "use strict";

    const E = window.ethers;

    // =========================
    // AppKit (Reown)
    // =========================
    import { createAppKit } from "https://esm.sh/@reown/appkit@1.8.15";
    import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@1.8.15";
    import { bsc, mainnet } from "https://esm.sh/@reown/appkit/networks";

    const APPKIT_PROJECT_ID = "7886bcb95105e9e47337cec481d5de75";

    const appkit = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc, mainnet],
      defaultNetwork: bsc,
      projectId: APPKIT_PROJECT_ID,
      analytics: false,
      metadata: {
        name: "CycleX",
        description: "CycleX Security Hub",
        url: window.location.origin,
        icons: [`${window.location.origin}/logo.png`]
      }
    });

    window.CxAppKitModal = appkit;

    async function waitForWalletProvider(timeoutMs = 12000) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const p = window.CxAppKitModal?.getWalletProvider?.();
          if (p) return p;
        } catch {}
        await new Promise(r => setTimeout(r, 250));
      }
      return null;
    }

    // =========================
    // i18n (keep 4 languages)
    // =========================
    const translations = {
      en: {
        brand_sub: "On-Chain Security & Rewards",
        hero_kicker: "Security Hub",
        hero_title: "CycleX Security Tools",
        hero_subtitle: "A lightweight, client-side toolkit for safer swaps, approvals hygiene, liquidity checks, RPC health, and transaction decoding across BSC + Ethereum.",
        btn_back: "Back to Site",
        btn_connect: "Connect Wallet (optional)",
        btn_quick: "Run Quick Scan",
        hero_note: "Note: These checks are informational and do not guarantee safety. Always verify independently.",
        tools_kicker: "CHOOSE A TOOL",

        cube_quick_title: "Quick Scan",
        cube_quick_desc: "Fast token sanity-check + shareable report + cache.",
        cube_liq_title: "Token + Liquidity Scan",
        cube_liq_desc: "DEX Registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.",
        cube_approvals_title: "Approval Guardian",
        cube_approvals_desc: "Check and revoke ERC-20 allowances safely (approve ‚Üí 0).",
        cube_rpc_title: "RPC Health Checker",
        cube_rpc_desc: "Latency + chainId + block + eth_call + read logs + dev custom test.",
        cube_tx_title: "Tx Decoder",
        cube_tx_desc: "Decode inputs + common events (Transfer/Approval) from a tx hash.",
        cube_dev_title: "Dev Tools",
        cube_dev_desc: "Bookmarklet generator + local contract monitor (no server).",

        badge_fast: "Fast",
        badge_share: "Share",
        badge_cache: "Cache",
        badge_dex: "DEX",
        badge_pairs: "Pairs",
        badge_wallet: "Wallet",
        badge_safe: "Safe",
        badge_copy: "Copy",
        badge_dev: "Dev",
        badge_decode: "Decode",
        badge_receipt: "Receipt",
        badge_events: "Events",
        badge_tools: "Tools",
        badge_bookmarklet: "Bookmarklet",
        badge_local: "Local",

        pill_wallet: "Wallet",
        btn_close: "Close",

        p_quick_kicker: "Quick Scan",
        p_quick_title: "Score a token in seconds",
        p_quick_sub: "Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.",
        quick_input_title: "Token Input",
        net_label: "Network",
        addr_label: "Token contract",
        qs_tip: "Tip: open with ?tool=quick&net=bsc&token=0x... to auto-run (rate-limited).",
        options_label: "Options",
        opt_require_liq: "Require liquidity (stricter score)",
        opt_show_json: "Enable JSON report (copy)",
        api_keys_label: "Explorer API keys (optional)",
        opt_use_explorer_apis: "Use BscScan/Etherscan (adds Verified + ABI heuristics)",
        btn_save: "Save",
        btn_clear: "Clear",
        api_keys_tip: "Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.",
        btn_scan: "Scan",
        btn_copy_link: "Copy Share Link",
        btn_copy_json: "Copy JSON",
        btn_copy_md: "Copy Markdown",
        btn_copy_xtext: "Copy X text",
        results_title: "Results",
        results_hint: "Green / Yellow / Red signals. Not a guarantee ‚Äî just verifiable on-chain checks.",

        p_liq_kicker: "Token + Liquidity Scan",
        p_liq_title: "DEX Registry liquidity checks",
        p_liq_sub: "We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.",
        liq_input_title: "Token + Network",
        liq_tip: "Tip: open with ?tool=liq&net=bsc&token=0x... to auto-run.",
        liq_dex_label: "DEX registry (checked)",
        liq_results_title: "Liquidity Results",
        liq_results_hint: "V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.",

        p_app_kicker: "Approval Guardian",
        p_app_title: "Check and revoke allowances",
        p_app_sub: "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
        ap_settings_title: "Settings",
        ap_connected: "Connected:",
        ap_connect: "Connect / Refresh",
        ap_spender_label: "Spender preset",
        ap_spender_tip: "Start with a router preset, then add tokens you want to clean up.",
        ap_tokens_label: "Token list (one per line)",
        ap_seed: "Seed common tokens",
        ap_seed_history: "Use scan history",
        ap_check: "Check Allowances",
        ap_revoke_all: "Revoke All (non-zero)",
        ap_results: "Allowances",
        ap_results_hint: "If allowance is ‚Äúinfinite‚Äù, revoke is recommended unless you fully trust the spender.",
        safe_mode_note: "Safe mode: actions that require a signature are disabled until you connect a wallet.",

        p_rpc_kicker: "RPC Health Checker",
        p_rpc_title: "Find the best endpoint",
        p_rpc_sub: "We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.",
        rpc_inputs: "Inputs",
        rpc_private_label: "Private RPC (saved locally)",
        rpc_private_tip: "Not embedded in HTML. Stored in your browser only (localStorage).",
        rpc_custom_label: "Optional custom RPC (top priority)",
        rpc_test: "Test RPCs",
        rpc_copy_best: "Copy Best RPC",
        rpc_results: "Results",
        rpc_tip: "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",
        rpc_dev_title: "Developer custom logs test",
        rpc_dev_hint: "Optional: test logs for a contract. This helps developers verify their own RPC stability.",
        rpc_dev_addr: "Contract address (optional)",
        rpc_dev_topic: "Topic0 (optional)",
        rpc_dev_run: "Run custom test",

        p_tx_kicker: "Tx Decoder",
        p_tx_title: "Decode a transaction",
        p_tx_sub: "Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).",
        tx_input_title: "Tx Input",
        tx_hash_label: "Transaction hash",
        tx_tip: "Tip: open with ?tool=tx&net=bsc&tx=0x... to auto-run.",
        btn_decode: "Decode",
        tx_results_title: "Decoded Output",

        p_dev_kicker: "Dev Tools",
        p_dev_title: "Bookmarklet + Local Monitor",
        p_dev_sub: "Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).",
        bm_title: "Bookmarklet Generator",
        bm_hint: "Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.",
        bm_base_label: "Hub URL (this page)",
        bm_generate: "Generate",
        bm_copy: "Copy Bookmarklet",

        mon_add_title: "Add to watchlist",
        mon_add: "Add",
        mon_check: "Check all",
        mon_export: "Copy JSON",
        mon_list_title: "Contract Monitor (local)",
        mon_list_hint: "Stored locally only. No server tracking.",

        footer_left: "CycleX Security Hub runs client-side and reads public on-chain data.",
        footer_tagline: "Verify twice. Connect only when you trust the page."
      },

      // concise translations; new strings fall back to EN if missing
      zh: {
        brand_sub: "Èìæ‰∏äÂÆâÂÖ®‰∏éÂ•ñÂä±",
        hero_kicker: "ÂÆâÂÖ®‰∏≠ÂøÉ",
        hero_title: "CycleX ÂÆâÂÖ®Â∑•ÂÖ∑",
        hero_subtitle: "ËΩªÈáèÁ∫ßÂÆ¢Êà∑Á´ØÂ∑•ÂÖ∑ÔºöÊõ¥ÂÆâÂÖ®ÁöÑ Swap„ÄÅÊéàÊùÉÁÆ°ÁêÜ„ÄÅÊµÅÂä®ÊÄßÊ£ÄÊü•„ÄÅRPC ÂÅ•Â∫∑‰∏é‰∫§ÊòìËß£Á†ÅÔºàBSC + ‰ª•Â§™ÂùäÔºâ„ÄÇ",
        btn_back: "ËøîÂõû‰∏ªÁ´ô",
        btn_connect: "ËøûÊé•Èí±ÂåÖÔºàÂèØÈÄâÔºâ",
        btn_quick: "Âø´ÈÄüÊâ´Êèè",
        hero_note: "ÊèêÁ§∫ÔºöËøô‰∫õÊ£ÄÊü•‰ªÖ‰æõÂèÇËÄÉÔºå‰∏ç‰øùËØÅÂÆâÂÖ®ÔºåËØ∑Âä°ÂøÖËá™Ë°åÈ™åËØÅ„ÄÇ",
        tools_kicker: "ÈÄâÊã©Â∑•ÂÖ∑",
        cube_liq_title: "‰ª£Â∏Å+ÊµÅÂä®ÊÄß",
        cube_tx_title: "‰∫§ÊòìËß£Á†Å",
        cube_dev_title: "ÂºÄÂèëÂ∑•ÂÖ∑",
        btn_close: "ÂÖ≥Èó≠",
        btn_scan: "Êâ´Êèè",
        btn_decode: "Ëß£Á†Å",
        btn_copy_md: "Â§çÂà∂ Markdown",
        footer_left: "CycleX ÂÆâÂÖ®‰∏≠ÂøÉÂú®Êú¨Âú∞ËøêË°åÔºåËØªÂèñÂÖ¨ÂºÄÈìæ‰∏äÊï∞ÊçÆ„ÄÇ",
        footer_tagline: "Â§öÈ™åËØÅ‰∏ÄÊ¨°ÔºåÂè™Âú®‰ø°‰ªªÊó∂ËøûÊé•Èí±ÂåÖ„ÄÇ"
      },
      ar: {
        brand_sub: "ÿ£ŸÖŸÜ ŸàŸÖŸÉÿßŸÅÿ¢ÿ™ ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©",
        hero_kicker: "ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ£ŸÖÿßŸÜ",
        hero_title: "ÿ£ÿØŸàÿßÿ™ CycleX",
        hero_subtitle: "ÿ£ÿØŸàÿßÿ™ ÿÆŸÅŸäŸÅÿ© ÿπŸÑŸâ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠: swaps ÿ£ŸÉÿ´ÿ± ÿ£ŸÖÿßŸÜÿßŸãÿå approvalsÿå ŸÅÿ≠ÿµ ÿßŸÑÿ≥ŸäŸàŸÑÿ©ÿå ÿµÿ≠ÿ© RPCÿå ŸàŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖÿπÿßŸÖŸÑÿßÿ™ (BSC + Ethereum).",
        btn_back: "ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÖŸàŸÇÿπ",
        btn_connect: "ÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)",
        btn_quick: "ŸÅÿ≠ÿµ ÿ≥ÿ±Ÿäÿπ",
        hero_note: "ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ÿßŸÑŸÅÿ≠Ÿàÿµÿßÿ™ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿäÿ© ŸàŸÑÿß ÿ™ÿ∂ŸÖŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ. ÿ™ÿ≠ŸÇŸÇ ÿ®ŸÜŸÅÿ≥ŸÉ.",
        tools_kicker: "ÿßÿÆÿ™ÿ± ÿ£ÿØÿßÿ©",
        btn_close: "ÿ•ÿ∫ŸÑÿßŸÇ",
        btn_scan: "ŸÅÿ≠ÿµ",
        btn_decode: "ŸÅŸÉ",
        btn_copy_md: "ŸÜÿ≥ÿÆ Markdown",
        footer_left: "CycleX Security Hub ŸäÿπŸÖŸÑ ŸÖÿ≠ŸÑŸäÿßŸã ŸàŸäŸÇÿ±ÿ£ ÿ®ŸäÿßŸÜÿßÿ™ ÿπÿßŸÖÿ© ŸÖŸÜ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©.",
        footer_tagline: "ÿ™ÿ≠ŸÇŸÇ ŸÖÿ±ÿ™ŸäŸÜ. ŸÑÿß ÿ™ÿ™ÿµŸÑ ÿ•ŸÑÿß ÿπŸÜÿØŸÖÿß ÿ™ÿ´ŸÇ ÿ®ÿßŸÑÿµŸÅÿ≠ÿ©."
      },
      ru: {
        brand_sub: "–û–Ω—á–µ–π–Ω –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –Ω–∞–≥—Ä–∞–¥—ã",
        hero_kicker: "Security Hub",
        hero_title: "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã CycleX",
        hero_subtitle: "–õ—ë–≥–∫–∏–π –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π –Ω–∞–±–æ—Ä: swaps –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ, approvals, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏, RPC –∏ –¥–µ–∫–æ–¥–µ—Ä —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π (BSC + Ethereum).",
        btn_back: "–ù–∞–∑–∞–¥ –Ω–∞ —Å–∞–π—Ç",
        btn_connect: "–ü–æ–¥–∫–ª—é—á–∏—Ç—å –∫–æ—à–µ–ª—ë–∫ (–æ–ø—Ü.)",
        btn_quick: "–ë—ã—Å—Ç—Ä—ã–π —Å–∫–∞–Ω",
        hero_note: "–í–∞–∂–Ω–æ: –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã –∏ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å. –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ —Å–∞–º–∏.",
        tools_kicker: "–í–´–ë–ï–†–ò–¢–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢",
        btn_close: "–ó–∞–∫—Ä—ã—Ç—å",
        btn_scan: "–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å",
        btn_decode: "–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å",
        btn_copy_md: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å Markdown",
        footer_left: "CycleX Security Hub —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –∏ —á–∏—Ç–∞–µ—Ç –ø—É–±–ª–∏—á–Ω—ã–µ –æ–Ω—á–µ–π–Ω-–¥–∞–Ω–Ω—ã–µ.",
        footer_tagline: "–ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –¥–≤–∞–∂–¥—ã. –ü–æ–¥–∫–ª—é—á–∞–π—Ç–µ—Å—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–æ–≤–µ—Ä—è–µ—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü–µ."
      }
    };

    let currentLang = "en";
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    function setDirForLang(lang) {
      const html = document.documentElement;
      if (lang === "ar") { html.setAttribute("dir","rtl"); html.setAttribute("lang","ar"); }
      else { html.setAttribute("dir","ltr"); html.setAttribute("lang",lang); }
    }
    function t(key) {
      return (translations[currentLang] && translations[currentLang][key]) || translations.en[key] || key;
    }
    function applyI18n() {
      document.body.classList.add("lang-switching");
      setTimeout(() => document.body.classList.remove("lang-switching"), 260);
      $$("[data-i18n]").forEach(el => { el.innerHTML = t(el.getAttribute("data-i18n")); });
      setDirForLang(currentLang);
      renderWalletLabels();
    }
    function setLang(lang) {
      currentLang = lang;
      try { localStorage.setItem("cx_sec_lang", lang); } catch {}
      $$(".lang-btn").forEach(b => b.classList.toggle("active", b.dataset.lang === lang));
      applyI18n();
    }
    function initLang() {
      let saved=null; try { saved = localStorage.getItem("cx_sec_lang"); } catch {}
      if (saved && translations[saved]) currentLang = saved;
      setLang(currentLang);
    }

    // =========================
    // Utils
    // =========================
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
    const nowTs = ()=>Math.floor(Date.now()/1000);

    function shortAddr(a){ return (!a || typeof a!=="string") ? "‚Äî" : `${a.slice(0,6)}‚Ä¶${a.slice(-4)}`; }
    function safeJson(obj){ try { return JSON.stringify(obj,null,2); } catch { return "{}"; } }

    async function copyText(text){
      try { await navigator.clipboard.writeText(text); return true; }
      catch {
        try {
          const ta=document.createElement("textarea");
          ta.value=text; document.body.appendChild(ta);
          ta.select(); document.execCommand("copy"); ta.remove(); return true;
        } catch { return false; }
      }
    }

    function setStatus(el,type,html){
      if(!el) return;
      el.classList.remove("ok","warn","bad","info");
      el.classList.add(type);
      el.style.display="block";
      el.innerHTML=html;
    }
    function clearStatus(el){
      if(!el) return;
      el.style.display="none"; el.innerHTML="";
      el.classList.remove("ok","warn","bad","info");
    }

    function gtagEvent(name, params = {}) {
      try { if (typeof window.gtag === "function") window.gtag("event", name, params); } catch {}
    }

    function parseQuery() {
      const u = new URL(location.href);
      return {
        tool: (u.searchParams.get("tool") || "").toLowerCase(),
        net: (u.searchParams.get("net") || "").toLowerCase(),
        token: (u.searchParams.get("token") || ""),
        tx: (u.searchParams.get("tx") || "")
      };
    }

    // =========================
    // Panels / Tiles
    // =========================
    const toolCards = $$("#toolGrid .tool-card");
    const panels = {
      quick: $("#panel-quick"),
      liq: $("#panel-liq"),
      approvals: $("#panel-approvals"),
      rpc: $("#panel-rpc"),
      tx: $("#panel-tx"),
      dev: $("#panel-dev")
    };

    function showPanel(key){
      Object.entries(panels).forEach(([k, el]) => { if (el) el.classList.toggle("hidden", k !== key); });
      toolCards.forEach(c => c.classList.toggle("active", c.dataset.tool === key));
      if (key) gtagEvent("sec_tool_open", { tool: key });
    }

    toolCards.forEach(card => card.addEventListener("click", ()=>showPanel(card.dataset.tool)));
    $("#btnCloseQuick")?.addEventListener("click", ()=>showPanel(null));
    $("#btnCloseLiq")?.addEventListener("click", ()=>showPanel(null));
    $("#btnCloseApprovals")?.addEventListener("click", ()=>showPanel(null));
    $("#btnCloseRpc")?.addEventListener("click", ()=>showPanel(null));
    $("#btnCloseTx")?.addEventListener("click", ()=>showPanel(null));
    $("#btnCloseDev")?.addEventListener("click", ()=>showPanel(null));

    $("#btn-quick")?.addEventListener("click", ()=>{ showPanel("quick"); $("#qs-token")?.focus(); });

    // =========================
    // Wallet (AppKit) ‚Äî single global state
    // =========================
    const wallet = {
      providerRaw: null,     // EIP-1193
      browserProvider: null, // ethers BrowserProvider
      signer: null,
      address: "",
      chainId: 0
    };

    function renderWalletLabels(){
      const label = wallet.address ? wallet.address : "not connected";
      $("#walletLabel") && ($("#walletLabel").textContent = label);
      $("#ap-wallet") && ($("#ap-wallet").textContent = label);
      $("#liq-wallet") && ($("#liq-wallet").textContent = label);
      $("#ap-address") && ($("#ap-address").textContent = wallet.address ? shortAddr(wallet.address) : "‚Äî");
    }

    function attachProviderListeners(p){
      try {
        if (!p || typeof p.on !== "function") return;
        p.removeAllListeners?.("accountsChanged");
        p.removeAllListeners?.("chainChanged");
        p.on("accountsChanged", async (accs) => {
          const a = (accs && accs[0]) ? E.getAddress(accs[0]) : "";
          wallet.address = a;
          renderWalletLabels();
        });
        p.on("chainChanged", async (hex) => {
          try { wallet.chainId = Number(hex); } catch { wallet.chainId = 0; }
          renderWalletLabels();
        });
      } catch {}
    }

    async function cxConnectWallet({ silent=false } = {}) {
      const stQuick = $("#qs-status");
      try {
        // open AppKit modal
        await window.CxAppKitModal?.open?.({ view: "ConnectWallet" });

        const providerRaw = await waitForWalletProvider(12000);
        if (!providerRaw) {
          if (!silent) setStatus(stQuick, "warn", "Wallet provider not ready (timeout). Try again.");
          return false;
        }

        wallet.providerRaw = providerRaw;
        attachProviderListeners(providerRaw);

        const bp = new E.BrowserProvider(providerRaw);
        wallet.browserProvider = bp;

        const signer = await bp.getSigner();
        wallet.signer = signer;

        const addr = await signer.getAddress();
        const net = await bp.getNetwork();

        wallet.address = E.getAddress(addr);
        wallet.chainId = Number(net.chainId || 0);

        renderWalletLabels();
        if (!silent) setStatus(stQuick, "ok", `Wallet connected: <span class="mono">${wallet.address}</span>`);
        gtagEvent("sec_wallet_connected", { chainId: wallet.chainId });

        return true;
      } catch (e) {
        if (!silent) setStatus(stQuick, "bad", `Wallet connect failed: ${String(e?.message || e)}`);
        return false;
      }
    }

    async function ensureChain(targetChainId){
      const p = wallet.providerRaw;
      if (!p?.request) return false;
      try {
        await p.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0x" + Number(targetChainId).toString(16) }] });
        // refresh
        await cxConnectWallet({ silent:true });
        return true;
      } catch {
        return false;
      }
    }

    $("#btn-connect")?.addEventListener("click", async ()=>{ await cxConnectWallet(); });
    $("#ap-connect")?.addEventListener("click", async ()=>{ await cxConnectWallet(); });
    // (liq doesn't need connect but we still show label)

    // =========================
    // Explorer API keys (local)
    // =========================
    const LS_KEYS = "cx_sec_explorer_keys";
    function loadApiKeys(){
      try {
        const raw = localStorage.getItem(LS_KEYS);
        if (!raw) return { bscscan:"", etherscan:"", use:false };
        const o = JSON.parse(raw);
        return { bscscan:o?.bscscan||"", etherscan:o?.etherscan||"", use:!!o?.use };
      } catch { return { bscscan:"", etherscan:"", use:false }; }
    }
    function saveApiKeys(keys){ try { localStorage.setItem(LS_KEYS, JSON.stringify(keys)); } catch {} }
    function initApiKeysUi(){
      const keys=loadApiKeys();
      $("#api-use") && ($("#api-use").checked = keys.use);
      $("#api-bscscan") && ($("#api-bscscan").value = keys.bscscan);
      $("#api-etherscan") && ($("#api-etherscan").value = keys.etherscan);

      $("#api-save")?.addEventListener("click", ()=>{
        const nk = { use: !!$("#api-use")?.checked, bscscan: ($("#api-bscscan")?.value||"").trim(), etherscan: ($("#api-etherscan")?.value||"").trim() };
        saveApiKeys(nk);
        setStatus($("#qs-status"), "ok", "Saved keys to localStorage.");
        gtagEvent("sec_keys_saved", { use: nk.use ? 1 : 0 });
      });

      $("#api-clear")?.addEventListener("click", ()=>{
        saveApiKeys({ use:false, bscscan:"", etherscan:"" });
        $("#api-use") && ($("#api-use").checked=false);
        $("#api-bscscan") && ($("#api-bscscan").value="");
        $("#api-etherscan") && ($("#api-etherscan").value="");
        setStatus($("#qs-status"), "ok", "Cleared keys.");
        gtagEvent("sec_keys_cleared");
      });
    }

    // =========================
    // Network + DEX Registry (BNB / ETH + USDT)
    // =========================
    const CHAINS = {
      bsc: {
        chainId: 56,
        name: "BSC",
        wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // WBNB
        usdt:   "0x55d398326f99059ff775485246999027b3197955", // USDT (BSC)
        explorer: "https://bscscan.com",
        addressUrl: (a)=>`https://bscscan.com/address/${a}`,
        txUrl: (h)=>`https://bscscan.com/tx/${h}`,
        publicRpcs: [
          "https://bsc-dataseed.binance.org",
          "https://bsc-dataseed1.bnbchain.org",
          "https://bsc-dataseed2.bnbchain.org",
          "https://bsc-dataseed3.bnbchain.org",
          "https://bsc.publicnode.com",
          "https://bsc-rpc.publicnode.com"
        ]
      },
      eth: {
        chainId: 1,
        name: "Ethereum",
        wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
        usdt:   "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT (ETH)
        explorer: "https://etherscan.io",
        addressUrl: (a)=>`https://etherscan.io/address/${a}`,
        txUrl: (h)=>`https://etherscan.io/tx/${h}`,
        publicRpcs: [
          "https://cloudflare-eth.com",
          "https://rpc.ankr.com/eth",
          "https://ethereum.publicnode.com",
          "https://eth.llamarpc.com"
        ]
      }
    };

    const DEX = {
      bsc: {
        v2Factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73", // Pancake V2 Factory
        v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865", // Pancake V3 Factory
        routerV2:  "0x10ED43C718714eb63d5aA57B78B54704E256024E", // Pancake V2 Router
        label: "PancakeSwap"
      },
      eth: {
        v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", // Uniswap V2 Factory
        v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984", // Uniswap V3 Factory
        routerV2:  "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2 Router
        label: "Uniswap"
      }
    };

    // =========================
    // ABIs (minimal)
    // =========================
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)"
    ];

    const V2_FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];
    const V2_PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const V3_FACTORY_ABI = [
      "function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)"
    ];
    const V3_POOL_ABI = [
      "function liquidity() view returns (uint128)",
      "function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked)"
    ];

    const TRANSFER_TOPIC0 = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
    const APPROVAL_TOPIC0 = "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";

    // =========================
    // Local storage keys
    // =========================
    const LS_BEST_RPC = (net)=>`cx_sec_best_rpc_${net}`;
    const LS_PRIV_RPC = (net)=>`cx_sec_private_rpc_${net}`;
    const LS_QS_CACHE = "cx_sec_qs_cache_v1";
    const LS_QS_HISTORY = "cx_sec_qs_history_v1";

    // =========================
    // RPC helpers (raw fetch)
    // =========================
    async function rpcRequest(url, method, params = [], timeoutMs = 9000) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      const body = JSON.stringify({ jsonrpc: "2.0", id: 1, method, params });
      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body,
          signal: ctrl.signal
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const j = await res.json();
        if (j.error) throw new Error(j.error.message || "RPC error");
        return j.result;
      } finally {
        clearTimeout(t);
      }
    }

    function uniq(arr) {
      const s = new Set();
      const out = [];
      for (const x of arr) {
        const k = String(x || "").trim();
        if (!k) continue;
        if (s.has(k)) continue;
        s.add(k);
        out.push(k);
      }
      return out;
    }

    function getSavedBestRpc(net){
      try { return localStorage.getItem(LS_BEST_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedBestRpc(net, url){
      try { localStorage.setItem(LS_BEST_RPC(net), url); } catch {}
    }

    function getSavedPrivateRpc(net){
      try { return localStorage.getItem(LS_PRIV_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedPrivateRpc(net, url){
      try { localStorage.setItem(LS_PRIV_RPC(net), url); } catch {}
    }

    function buildRpcCandidates(net){
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const privSaved = getSavedPrivateRpc(net);
      const privInput = ($("#rpc-private")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);

      // Priority: custom input > private saved/input > best saved > public list
      return uniq([
        custom,
        privInput,
        privSaved,
        bestSaved,
        ...(chain?.publicRpcs || [])
      ]);
    }

    function getReadProvider(net){
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      const privSaved = getSavedPrivateRpc(net);

      const url = custom || privSaved || bestSaved || (chain?.publicRpcs?.[0] || "");
      if (!url) return null;

      try { return new E.JsonRpcProvider(url, chain.chainId); } catch { return null; }
    }

    // =========================
    // Explorer APIs (optional)
    // =========================
    function explorerApiBase(net){
      return net === "bsc" ? "https://api.bscscan.com/api" : "https://api.etherscan.io/api";
    }

    async function explorerGetSource(net, addr, apiKey){
      const base = explorerApiBase(net);
      const u = new URL(base);
      u.searchParams.set("module","contract");
      u.searchParams.set("action","getsourcecode");
      u.searchParams.set("address", addr);
      if (apiKey) u.searchParams.set("apikey", apiKey);

      const r = await fetch(u.toString());
      const j = await r.json();
      if (!j || j.status !== "1" || !j.result || !j.result[0]) {
        return { ok:false, raw:j };
      }
      const row = j.result[0];
      return {
        ok:true,
        verified: !!(row.SourceCode && String(row.SourceCode).trim().length > 0),
        contractName: row.ContractName || "",
        isProxy: String(row.Proxy || "").toLowerCase() === "1",
        impl: row.Implementation || "",
        abi: row.ABI || ""
      };
    }

    // =========================
    // Heuristic bytecode checks
    // =========================
    function codeHasSelector(codeHex, selectorNo0x){
      if (!codeHex || codeHex === "0x") return false;
      const s = selectorNo0x.toLowerCase();
      // Solidity selector push: PUSH4 0x???????? => 63???????? in bytecode
      return codeHex.toLowerCase().includes("63" + s);
    }

    const SEL = {
      owner: "8da5cb5b",
      pause: "8456cb59",
      unpause: "3f4ba83a",
      paused: "5c975abb",
      mint: "40c10f19",
      blacklist1: "5c0e5f47", // typical: isBlacklisted(address) (varies)
      blacklist2: "9a5c0d65", // typical: blacklist(address) (varies)
      setTax1: "b21d7b0b"    // typical: setTax(uint256) (varies)
    };

    async function tryReadOwner(provider, addr){
      try {
        const data = "0x" + SEL.owner;
        const r = await provider.call({ to: addr, data });
        if (!r || r === "0x") return "";
        // last 20 bytes
        const a = "0x" + r.slice(-40);
        if (E.isAddress(a)) return E.getAddress(a);
        return "";
      } catch { return ""; }
    }

    async function tryEip1967Impl(provider, addr){
      // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)
      const slot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
      try {
        const v = await provider.getStorage(addr, slot);
        if (!v || v === "0x" || /^0x0+$/.test(v)) return "";
        const a = "0x" + v.slice(-40);
        if (E.isAddress(a) && a !== "0x0000000000000000000000000000000000000000") return E.getAddress(a);
        return "";
      } catch { return ""; }
    }

    // =========================
    // UI helpers: risk badges
    // =========================
    function riskBadge(type, label, detail=""){
      const div = document.createElement("div");
      div.className = `risk ${type}`;
      div.innerHTML = `<span class="dot"></span><span><b>${label}</b>${detail ? ` ‚Äî ${detail}` : ""}</span>`;
      return div;
    }

    function setPairsWrap(el, rowsHtml){
      if (!el) return;
      el.innerHTML = rowsHtml || "";
    }

    function fmtNum(n){
      try {
        if (n === null || n === undefined) return "‚Äî";
        const x = Number(n);
        if (!isFinite(x)) return String(n);
        if (x >= 1e9) return (x/1e9).toFixed(2) + "B";
        if (x >= 1e6) return (x/1e6).toFixed(2) + "M";
        if (x >= 1e3) return (x/1e3).toFixed(2) + "K";
        return x.toFixed(0);
      } catch { return String(n); }
    }

    function netFromSelect(selId){
      const v = ($(selId)?.value || "bsc").toLowerCase();
      return (v === "eth") ? "eth" : "bsc";
    }

    function explorerKeyFor(net){
      const keys = loadApiKeys();
      if (!keys.use) return "";
      if (net === "bsc") return (keys.bscscan || "").trim();
      return (keys.etherscan || "").trim();
    }

    // =========================
    // Quick Scan (score + report + cache)
    // =========================
    function qsCacheGet(key){
      try {
        const raw = localStorage.getItem(LS_QS_CACHE);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        return obj?.[key] || null;
      } catch { return null; }
    }
    function qsCacheSet(key, payload){
      try {
        const raw = localStorage.getItem(LS_QS_CACHE);
        const obj = raw ? JSON.parse(raw) : {};
        obj[key] = payload;
        localStorage.setItem(LS_QS_CACHE, JSON.stringify(obj));
      } catch {}
    }

    function qsAddHistory(net, token){
      try {
        const raw = localStorage.getItem(LS_QS_HISTORY);
        const obj = raw ? JSON.parse(raw) : { bsc: [], eth: [] };
        const arr = Array.isArray(obj[net]) ? obj[net] : [];
        const t = E.getAddress(token);
        const next = [t, ...arr.filter(x => String(x).toLowerCase() !== t.toLowerCase())].slice(0, 30);
        obj[net] = next;
        localStorage.setItem(LS_QS_HISTORY, JSON.stringify(obj));
      } catch {}
    }
    function qsGetHistory(net){
      try {
        const raw = localStorage.getItem(LS_QS_HISTORY);
        const obj = raw ? JSON.parse(raw) : { bsc: [], eth: [] };
        return Array.isArray(obj[net]) ? obj[net] : [];
      } catch { return []; }
    }

    function qsBuildShareLink(net, token){
      const u = new URL(location.href);
      u.searchParams.set("tool","quick");
      u.searchParams.set("net", net);
      u.searchParams.set("token", token);
      return u.toString();
    }

    function qsBuildXText(summary){
      const base = `${summary.title}\nScore: ${summary.score}/100\n${summary.net.toUpperCase()} ‚Ä¢ ${summary.tokenShort}\n` +
                   `${summary.flags.join(" ‚Ä¢ ")}\n` +
                   `Verify on explorers + don't sign blind approvals.`;
      return base.slice(0, 270);
    }

    function qsBuildMarkdown(summary){
      return [
        `## CycleX Quick Scan`,
        ``,
        `- **Network:** ${summary.net.toUpperCase()}`,
        `- **Token:** \`${summary.token}\``,
        `- **Score:** **${summary.score}/100**`,
        `- **Verified:** ${summary.verified ? "Yes" : "No / Unknown"}`,
        `- **Proxy:** ${summary.isProxy ? "Yes" : "No / Unknown"}${summary.impl ? ` (impl: \`${summary.impl}\`)` : ""}`,
        `- **Owner:** ${summary.owner ? `\`${summary.owner}\`` : "Unknown"}`,
        `- **Liquidity (V2/V3):** ${summary.liqHint}`,
        ``,
        `### Flags`,
        `${summary.flags.map(x=>`- ${x}`).join("\n")}`,
        ``,
        `### Notes`,
        `These checks are informational and do not guarantee safety. Always verify independently.`,
      ].join("\n");
    }

    async function runQuickScan({ auto=false } = {}){
      const st = $("#qs-status");
      const out = $("#qs-out");
      const risk = $("#qs-risk");
      const pairsWrap = $("#qs-pairsWrap");

      clearStatus(st);
      if (risk) risk.innerHTML = "";
      if (pairsWrap) pairsWrap.innerHTML = "";

      const net = netFromSelect("#qs-net");
      const tokenRaw = ($("#qs-token")?.value || "").trim();
      if (!E.isAddress(tokenRaw)) {
        setStatus(st, "warn", "Invalid token address.");
        return;
      }
      const token = E.getAddress(tokenRaw);

      const provider = getReadProvider(net);
      if (!provider) {
        setStatus(st, "bad", "No RPC available. Open RPC tool and set a working endpoint.");
        return;
      }

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const cacheKey = `${net}:${token}:${requireLiq ? 1 : 0}:${explorerKeyFor(net) ? 1 : 0}`;
      const cached = qsCacheGet(cacheKey);

      // 10 min cache
      const now = Date.now();
      if (cached && (now - (cached.ts || 0) < 10 * 60 * 1000)) {
        renderQuickScanResult(cached.data, { cached:true });
        setStatus(st, "ok", `Loaded cached result (‚â§10 min).`);
        return;
      }

      setStatus(st, "info", "Scanning‚Ä¶");

      try {
        const code = await provider.getCode(token);
        if (!code || code === "0x") {
          setStatus(st, "bad", "Address has no contract code.");
          return;
        }

        const tokenC = new E.Contract(token, ERC20_ABI, provider);
        let symbol="?", decimals=18, name="";
        try { symbol = await tokenC.symbol(); } catch {}
        try { decimals = await tokenC.decimals(); } catch {}
        try { name = await tokenC.name(); } catch {}

        // proxy + owner
        const impl1967 = await tryEip1967Impl(provider, token);
        const owner = await tryReadOwner(provider, token);

        // explorer (optional)
        const apiKey = explorerKeyFor(net);
        let verified = false, isProxy = !!impl1967, impl = impl1967, contractName = "";
        if (apiKey) {
          const s = await explorerGetSource(net, token, apiKey);
          if (s.ok) {
            verified = !!s.verified;
            contractName = s.contractName || "";
            if (s.isProxy) isProxy = true;
            if (s.impl && E.isAddress(s.impl)) impl = E.getAddress(s.impl);
          }
        }

        // liquidity quick snapshot
        const liq = await liqCheckBasic(net, token, provider);

        // heuristics from bytecode
        const hasMint = codeHasSelector(code, SEL.mint);
        const hasPause = codeHasSelector(code, SEL.pause) || codeHasSelector(code, SEL.paused);
        const hasBlacklist = codeHasSelector(code, SEL.blacklist1) || codeHasSelector(code, SEL.blacklist2);
        const hasTax = codeHasSelector(code, SEL.setTax1);

        // score
        let score = 100;
        const flags = [];

        // Verified bonus / penalty
        if (!apiKey) flags.push("Explorer API keys not enabled (proxy/verified limited).");
        if (apiKey && !verified) { score -= 18; flags.push("Not verified on explorer (or cannot read)."); }
        if (verified) flags.push("Verified source on explorer.");

        // Proxy note
        if (isProxy) { score -= 8; flags.push("Proxy detected (verify implementation)."); }
        else flags.push("No proxy flag detected.");

        // Owner note
        if (!owner) { score -= 6; flags.push("Owner unknown (no owner() or read failed)."); }
        else {
          const zero = "0x0000000000000000000000000000000000000000";
          if (owner.toLowerCase() === zero) flags.push("Owner is renounced (0x0).");
          else { score -= 10; flags.push("Owner is set (centralized control possible)."); }
        }

        // Risky capabilities
        if (hasMint) { score -= 18; flags.push("Mint-like selector detected in bytecode (possible inflation)."); }
        if (hasPause) { score -= 10; flags.push("Pause-like selector detected (trading can be halted)."); }
        if (hasBlacklist) { score -= 10; flags.push("Blacklist-like selectors detected (addresses can be blocked)."); }
        if (hasTax) { score -= 8; flags.push("Tax-setting selector detected (fees can change)."); }

        // Liquidity
        if (!liq.any) {
          score -= requireLiq ? 35 : 18;
          flags.push("No liquidity detected (V2/V3 vs Wrapped/USDT).");
        } else {
          flags.push(`Liquidity detected: ${liq.hint}`);
        }

        score = clamp(score, 0, 100);

        const data = {
          ts: Date.now(),
          net,
          token,
          tokenShort: shortAddr(token),
          symbol,
          decimals,
          name,
          score,
          verified,
          isProxy,
          impl,
          contractName,
          owner,
          hasMint, hasPause, hasBlacklist, hasTax,
          liq
        };

        qsCacheSet(cacheKey, { ts: Date.now(), data });
        qsAddHistory(net, token);

        renderQuickScanResult(data, { cached:false });
        setStatus(st, "ok", `Done. Score: <b>${score}/100</b>`);
        gtagEvent("sec_quick_scan", { net, score });

      } catch (e) {
        setStatus(st, "bad", `Scan failed: ${String(e?.message || e)}`);
      }

      function renderQuickScanResult(d, { cached }){
        // output panel
        const lines = [];
        lines.push(`<b>${d.symbol || "TOKEN"}</b> ${d.name ? `‚Äî ${d.name}` : ""}`);
        lines.push(`<div class="small" style="margin-top:6px">Network: <b>${d.net.toUpperCase()}</b> ‚Ä¢ Score: <b>${d.score}/100</b>${cached ? " ‚Ä¢ <b>(cached)</b>" : ""}</div>`);
        lines.push(`<div class="small" style="margin-top:6px">Token: <span class="mono">${d.token}</span></div>`);
        lines.push(`<div class="small" style="margin-top:6px">Explorer: <a href="${CHAINS[d.net].addressUrl(d.token)}" target="_blank" rel="noopener">open</a></div>`);
        if (out) out.innerHTML = lines.join("");

        // risk badges
        if (risk) {
          risk.innerHTML = "";
          if (d.score >= 75) risk.appendChild(riskBadge("ok", "Overall", "Higher signal"));
          else if (d.score >= 50) risk.appendChild(riskBadge("warn", "Overall", "Mixed signals"));
          else risk.appendChild(riskBadge("bad", "Overall", "High risk signals"));

          risk.appendChild(riskBadge(d.verified ? "ok" : "warn", "Verified", d.verified ? "Yes" : "No/Unknown"));
          risk.appendChild(riskBadge(d.isProxy ? "warn" : "ok", "Proxy", d.isProxy ? "Yes" : "No/Unknown"));
          risk.appendChild(riskBadge(d.owner ? "info" : "warn", "Owner", d.owner ? shortAddr(d.owner) : "Unknown"));
          risk.appendChild(riskBadge(d.liq?.any ? "ok" : "warn", "Liquidity", d.liq?.any ? d.liq.hint : "None"));
          if (d.hasMint) risk.appendChild(riskBadge("bad", "Mint", "Detected"));
          if (d.hasPause) risk.appendChild(riskBadge("warn", "Pause", "Detected"));
          if (d.hasBlacklist) risk.appendChild(riskBadge("warn", "Blacklist", "Detected"));
          if (d.hasTax) risk.appendChild(riskBadge("warn", "Tax", "Detected"));
        }

        // pairs/liquidity details
        if (pairsWrap) {
          const html = `
            <div class="table">
              <div class="trow head">
                <div class="cell">Pair/Pool</div>
                <div class="cell">Type</div>
                <div class="cell hide-sm">Target</div>
                <div class="cell">Result</div>
              </div>
              ${(d.liq?.rows || []).map(r => `
                <div class="trow">
                  <div class="cell wrap"><span class="mono">${r.addr ? shortAddr(r.addr) : "‚Äî"}</span></div>
                  <div class="cell">${r.type}</div>
                  <div class="cell hide-sm">${r.target}</div>
                  <div class="cell">${r.ok ? "‚úÖ" : "‚Äî"} ${r.note || ""}</div>
                </div>
              `).join("")}
            </div>
          `;
          pairsWrap.innerHTML = html;
        }

        // Copy buttons
        $("#qs-copy-link")?.onclick = async ()=>{
          const link = qsBuildShareLink(d.net, d.token);
          const ok = await copyText(link);
          setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
        };

        $("#qs-copy-json")?.onclick = async ()=>{
          const enable = !!$("#qs-show-json")?.checked;
          if (!enable) { setStatus($("#qs-status"), "warn", "JSON report disabled (toggle in options)."); return; }
          const ok = await copyText(safeJson(d));
          setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
        };

        $("#qs-copy-md")?.onclick = async ()=>{
          const md = qsBuildMarkdown({
            net: d.net,
            token: d.token,
            score: d.score,
            verified: d.verified,
            isProxy: d.isProxy,
            impl: d.impl,
            owner: d.owner,
            liqHint: d.liq?.hint || "‚Äî",
            flags: buildFlags(d),
            tokenShort: d.tokenShort,
            title: `CycleX Quick Scan ‚Äî ${d.symbol || "TOKEN"}`
          });
          const ok = await copyText(md);
          setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied Markdown." : "Copy failed.");
        };

        $("#qs-share-x")?.onclick = ()=>{
          const summary = buildSummary(d);
          const text = qsBuildXText(summary);
          const u = new URL("https://twitter.com/intent/tweet");
          u.searchParams.set("text", text);
          u.searchParams.set("url", qsBuildShareLink(d.net, d.token));
          window.open(u.toString(), "_blank", "noopener");
        };

        $("#qs-copy-xtext")?.onclick = async ()=>{
          const summary = buildSummary(d);
          const ok = await copyText(qsBuildXText(summary));
          setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied X text." : "Copy failed.");
        };

        $("#qs-share-tg")?.onclick = ()=>{
          const link = qsBuildShareLink(d.net, d.token);
          const summary = buildSummary(d);
          const text = qsBuildXText(summary);
          const u = new URL("https://t.me/share/url");
          u.searchParams.set("url", link);
          u.searchParams.set("text", text);
          window.open(u.toString(), "_blank", "noopener");
        };

        $("#qs-copy-link")?.disabled = false;
        $("#qs-copy-json")?.disabled = false;
        $("#qs-copy-md")?.disabled = false;
      }

      function buildFlags(d){
        const f = [];
        if (d.verified) f.push("Verified");
        if (d.isProxy) f.push("Proxy");
        if (d.hasMint) f.push("Mint");
        if (d.hasPause) f.push("Pause");
        if (d.hasBlacklist) f.push("Blacklist");
        if (d.hasTax) f.push("Tax");
        if (d.liq?.any) f.push("Liquidity");
        return f.length ? f : ["No strong flags"];
      }

      function buildSummary(d){
        return {
          title: `CycleX Quick Scan ‚Äî ${d.symbol || "TOKEN"}`,
          score: d.score,
          net: d.net,
          tokenShort: d.tokenShort,
          flags: buildFlags(d)
        };
      }
    }

    async function liqCheckBasic(net, token, provider){
      const chain = CHAINS[net];
      const dex = DEX[net];
      const rows = [];
      let any = false;

      // V2
      try {
        const fac = new E.Contract(dex.v2Factory, V2_FACTORY_ABI, provider);
        const targets = [
          { label: "Wrapped", addr: chain.wrapped },
          { label: "USDT", addr: chain.usdt }
        ];
        for (const t of targets) {
          const pair = await fac.getPair(token, t.addr);
          if (pair && pair !== "0x0000000000000000000000000000000000000000") {
            const p = new E.Contract(pair, V2_PAIR_ABI, provider);
            const [r0, r1] = await p.getReserves();
            const ok = (BigInt(r0) > 0n || BigInt(r1) > 0n);
            any = any || ok;
            rows.push({ type: "V2", target: t.label, addr: pair, ok, note: ok ? `reserves: ${fmtNum(r0)} / ${fmtNum(r1)}` : "empty" });
          } else {
            rows.push({ type: "V2", target: t.label, addr: "", ok:false, note:"no pair" });
          }
        }
      } catch (e) {
        rows.push({ type:"V2", target:"Wrapped/USDT", addr:"", ok:false, note:"factory call failed" });
      }

      // V3
      try {
        const fac3 = new E.Contract(dex.v3Factory, V3_FACTORY_ABI, provider);
        const feeTiers = [500, 3000, 10000];
        const targets = [
          { label: "Wrapped", addr: chain.wrapped },
          { label: "USDT", addr: chain.usdt }
        ];

        for (const t of targets) {
          for (const fee of feeTiers) {
            const pool = await fac3.getPool(token, t.addr, fee);
            if (pool && pool !== "0x0000000000000000000000000000000000000000") {
              const p = new E.Contract(pool, V3_POOL_ABI, provider);
              let liq = 0n;
              try { liq = BigInt(await p.liquidity()); } catch {}
              let ok = liq > 0n;
              any = any || ok;
              rows.push({ type: `V3 ${fee}`, target: t.label, addr: pool, ok, note: ok ? `liquidity: ${fmtNum(liq)}` : "0" });
            }
          }
        }
      } catch (e) {
        rows.push({ type:"V3", target:"Wrapped/USDT", addr:"", ok:false, note:"factory call failed" });
      }

      const hint = any ? "V2/V3 pairs exist" : "none";
      return { any, hint, rows };
    }

    // =========================
    // Token + Liquidity Panel (detailed)
    // =========================
    async function runLiqScan({ auto=false } = {}){
      const st = $("#liq-status");
      const out = $("#liq-out");
      const risk = $("#liq-risk");
      const wrap = $("#liq-tablewrap");

      clearStatus(st);
      if (risk) risk.innerHTML="";
      if (wrap) wrap.innerHTML="";

      const net = netFromSelect("#liq-net");
      const tokenRaw = ($("#liq-token")?.value || "").trim();
      if (!E.isAddress(tokenRaw)) { setStatus(st,"warn","Invalid token address."); return; }
      const token = E.getAddress(tokenRaw);

      const provider = getReadProvider(net);
      if (!provider) { setStatus(st,"bad","No RPC available. Set a working endpoint in RPC tool."); return; }

      $("#liq-dex-note") && ($("#liq-dex-note").textContent = `${DEX[net].label} V2+V3 factories ‚Ä¢ targets: Wrapped + USDT`);

      setStatus(st,"info","Scanning liquidity‚Ä¶");

      try {
        const liq = await liqCheckBasic(net, token, provider);

        if (out) {
          out.innerHTML = `<b>${shortAddr(token)}</b><div class="small" style="margin-top:6px">${net.toUpperCase()} ‚Ä¢ ${liq.any ? "‚úÖ liquidity found" : "‚Äî no liquidity found"}</div>`;
        }

        if (risk) {
          risk.appendChild(riskBadge(liq.any ? "ok" : "warn", "Liquidity", liq.any ? "Detected" : "Not detected"));
          risk.appendChild(riskBadge("info", "Targets", "Wrapped + USDT (V2/V3)"));
        }

        if (wrap) {
          wrap.innerHTML = `
            <div class="table">
              <div class="trow head">
                <div class="cell">Pair/Pool</div>
                <div class="cell">Type</div>
                <div class="cell hide-sm">Target</div>
                <div class="cell">Result</div>
              </div>
              ${liq.rows.map(r=>`
                <div class="trow">
                  <div class="cell wrap">${r.addr ? `<a class="mono" href="${CHAINS[net].addressUrl(r.addr)}" target="_blank" rel="noopener">${r.addr}</a>` : `<span class="muted">‚Äî</span>`}</div>
                  <div class="cell">${r.type}</div>
                  <div class="cell hide-sm">${r.target}</div>
                  <div class="cell">${r.ok ? "‚úÖ" : "‚Äî"} ${r.note || ""}</div>
                </div>
              `).join("")}
            </div>
          `;
        }

        $("#liq-copy-link")?.onclick = async ()=>{
          const u = new URL(location.href);
          u.searchParams.set("tool","liq");
          u.searchParams.set("net", net);
          u.searchParams.set("token", token);
          const ok = await copyText(u.toString());
          setStatus(st, ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
        };

        $("#liq-share-x")?.onclick = ()=>{
          const u = new URL("https://twitter.com/intent/tweet");
          u.searchParams.set("text", `Liquidity scan (${net.toUpperCase()}): ${shortAddr(token)} ‚Ä¢ ${liq.any ? "liquidity found" : "no liquidity found"} ‚Äî CycleX Security Hub`);
          const link = new URL(location.href);
          link.searchParams.set("tool","liq");
          link.searchParams.set("net", net);
          link.searchParams.set("token", token);
          u.searchParams.set("url", link.toString());
          window.open(u.toString(), "_blank", "noopener");
        };

        setStatus(st,"ok","Done.");
        gtagEvent("sec_liq_scan", { net, any: liq.any ? 1 : 0 });

      } catch (e) {
        setStatus(st,"bad",`Liquidity scan failed: ${String(e?.message || e)}`);
      }
    }

    // =========================
    // Approval Guardian
    // =========================
    function presetSpender(net, preset){
      if (preset === "pcs_router") return DEX.bsc.routerV2;
      if (preset === "uni_router") return DEX.eth.routerV2;
      return "";
    }

    function parseTokenLines(text){
      const lines = String(text||"").split("\n").map(x=>x.trim()).filter(Boolean);
      const out = [];
      for (const l of lines) {
        if (E.isAddress(l)) out.push(E.getAddress(l));
      }
      return uniq(out);
    }

    async function apCheckAllowances(){
      const st = $("#ap-status");
      clearStatus(st);

      const net = netFromSelect("#ap-net");
      const spenderPreset = ($("#ap-spender-preset")?.value || "");
      const spenderCustom = ($("#ap-spender")?.value || "").trim();
      const spender = E.isAddress(spenderCustom) ? E.getAddress(spenderCustom) : (presetSpender(net, spenderPreset) || "");
      if (!spender || !E.isAddress(spender)) {
        setStatus(st,"warn","Invalid spender. Pick a preset or paste a valid address.");
        return;
      }
      $("#ap-spender").value = spender;

      if (!wallet.address || !wallet.signer || !wallet.browserProvider) {
        setStatus(st,"warn","Connect a wallet first (Safe mode is on).");
        return;
      }

      // ensure chain
      const targetChainId = CHAINS[net].chainId;
      if (wallet.chainId && wallet.chainId !== targetChainId) {
        const ok = await ensureChain(targetChainId);
        if (!ok) { setStatus(st,"warn",`Please switch network to ${CHAINS[net].name} in your wallet.`); return; }
      }

      const tokens = parseTokenLines($("#ap-tokens")?.value || "");
      if (!tokens.length) { setStatus(st,"warn","Paste token addresses (one per line)."); return; }

      setStatus(st,"info","Reading allowances‚Ä¶");

      const table = $("#ap-table");
      if (table) {
        // reset rows keeping header
        table.innerHTML = `
          <div class="trow head">
            <div class="cell">Token</div>
            <div class="cell">Allowance</div>
            <div class="cell hide-sm">Symbol</div>
            <div class="cell">Action</div>
          </div>
        `;
      }

      try {
        const rp = getReadProvider(net);
        if (!rp) { setStatus(st,"bad","No RPC for reads. Set best RPC first."); return; }

        const ownerAddr = wallet.address;
        let nonZero = 0;

        for (const tAddr of tokens) {
          const cRead = new E.Contract(tAddr, ERC20_ABI, rp);
          let sym="?", dec=18;
          try { sym = await cRead.symbol(); } catch {}
          try { dec = await cRead.decimals(); } catch {}

          let allowance = 0n;
          try { allowance = BigInt(await cRead.allowance(ownerAddr, spender)); } catch { allowance = 0n; }

          const isZero = allowance === 0n;
          if (!isZero) nonZero++;

          const human = (allowance > 0n && allowance < 10n**30n) ? allowance.toString() : allowance.toString(); // keep raw
          const inf = (allowance > (2n**255n));

          const row = document.createElement("div");
          row.className = "trow";
          row.innerHTML = `
            <div class="cell wrap"><a href="${CHAINS[net].addressUrl(tAddr)}" target="_blank" rel="noopener" class="mono">${shortAddr(tAddr)}</a></div>
            <div class="cell">${inf ? "‚àû" : `<span class="mono">${human}</span>`}${isZero ? "" : ""}</div>
            <div class="cell hide-sm">${sym}</div>
            <div class="cell">
              <button class="btn btn-ghost" style="padding:10px 14px; font-size:12px;" ${isZero ? "disabled" : ""}>Revoke</button>
            </div>
          `;
          const btn = row.querySelector("button");
          btn?.addEventListener("click", async ()=>{
            await apRevokeOne(net, tAddr, spender);
          });

          table?.appendChild(row);
        }

        setStatus(st,"ok",`Done. Non-zero allowances: <b>${nonZero}</b>`);
        gtagEvent("sec_allowances_checked", { net, count: tokens.length });

      } catch (e) {
        setStatus(st,"bad",`Allowance read failed: ${String(e?.message || e)}`);
      }
    }

    async function apRevokeOne(net, token, spender){
      const st = $("#ap-status");
      try {
        if (!wallet.signer) { setStatus(st,"warn","Connect wallet first."); return; }

        const targetChainId = CHAINS[net].chainId;
        if (wallet.chainId && wallet.chainId !== targetChainId) {
          const ok = await ensureChain(targetChainId);
          if (!ok) { setStatus(st,"warn",`Switch wallet to ${CHAINS[net].name}.`); return; }
        }

        setStatus(st,"info",`Revoking‚Ä¶ ${shortAddr(token)}`);

        const c = new E.Contract(token, ERC20_ABI, wallet.signer);
        const tx = await c.approve(spender, 0);
        setStatus(st,"info",`Sent tx: <a href="${CHAINS[net].txUrl(tx.hash)}" target="_blank" rel="noopener">${tx.hash.slice(0,10)}‚Ä¶</a>`);
        await tx.wait();

        setStatus(st,"ok","Revoke confirmed ‚úÖ");
        gtagEvent("sec_allowance_revoked", { net });

        // refresh view
        await apCheckAllowances();
      } catch (e) {
        setStatus(st,"bad",`Revoke failed: ${String(e?.message || e)}`);
      }
    }

    async function apRevokeAll(){
      const st = $("#ap-status");
      const net = netFromSelect("#ap-net");
      const spender = ($("#ap-spender")?.value || "").trim();
      if (!E.isAddress(spender)) { setStatus(st,"warn","Invalid spender."); return; }

      if (!wallet.address || !wallet.signer) { setStatus(st,"warn","Connect a wallet first."); return; }

      const tokens = parseTokenLines($("#ap-tokens")?.value || "");
      if (!tokens.length) { setStatus(st,"warn","Paste token addresses (one per line)."); return; }

      setStatus(st,"info","Revoking all non-zero allowances‚Ä¶");

      const rp = getReadProvider(net);
      if (!rp) { setStatus(st,"bad","No RPC for reads. Set best RPC first."); return; }

      let did = 0;
      for (const tAddr of tokens) {
        try {
          const cRead = new E.Contract(tAddr, ERC20_ABI, rp);
          const allowance = BigInt(await cRead.allowance(wallet.address, spender));
          if (allowance === 0n) continue;
          await apRevokeOne(net, tAddr, spender);
          did++;
        } catch {}
      }

      setStatus(st,"ok",`Revoke-all done. Updated: ${did}`);
    }

    $("#ap-spender-preset")?.addEventListener("change", ()=>{
      const net = netFromSelect("#ap-net");
      const p = ($("#ap-spender-preset")?.value || "");
      if (p === "custom") return;
      const v = presetSpender(net, p);
      if (v) $("#ap-spender").value = v;
    });

    $("#ap-seed-common")?.addEventListener("click", ()=>{
      const net = netFromSelect("#ap-net");
      const chain = CHAINS[net];
      const common = uniq([chain.wrapped, chain.usdt]);
      $("#ap-tokens").value = common.join("\n");
      setStatus($("#ap-status"), "ok", "Seeded common tokens (Wrapped + USDT).");
    });

    $("#ap-seed-history")?.addEventListener("click", ()=>{
      const net = netFromSelect("#ap-net");
      const hist = qsGetHistory(net);
      if (!hist.length) { setStatus($("#ap-status"), "warn", "No scan history yet."); return; }
      $("#ap-tokens").value = hist.join("\n");
      setStatus($("#ap-status"), "ok", "Loaded tokens from scan history.");
    });

    $("#ap-check")?.addEventListener("click", apCheckAllowances);
    $("#ap-revoke-all")?.addEventListener("click", apRevokeAll);

    // =========================
    // RPC Health Checker
    // =========================
    function rpcRowHtml(r){
      const statusTxt = r.ok ? "OK" : (r.status || "FAIL");
      const msTxt = (r.ms === null || r.ms === undefined) ? "‚Äî" : String(r.ms);
      const chainTxt = r.chainOk ? "‚úÖ" : "‚Äî";
      const blockTxt = r.blockOk ? "‚úÖ" : "‚Äî";
      const callTxt  = r.callOk ? "‚úÖ" : "‚Äî";
      const logsTxt  = r.logsOk ? "‚úÖ" : "‚Äî";

      return `
        <div class="trow rpc ${r.highlight ? "highlight" : ""}">
          <div class="cell wrap"><span class="mono">${r.url}</span></div>
          <div class="cell">${msTxt}</div>
          <div class="cell hide-sm">${chainTxt}</div>
          <div class="cell hide-sm">${blockTxt}</div>
          <div class="cell hide-sm">${callTxt}</div>
          <div class="cell hide-sm">${logsTxt}</div>
          <div class="cell">${r.ok ? "‚úÖ" : "‚Äî"} ${statusTxt}</div>
        </div>
      `;
    }

    async function testOneRpc(url, net){
      const chain = CHAINS[net];
      const start = performance.now();

      let chainOk=false, blockOk=false, callOk=false, logsOk=false;
      let blockNumHex = "0x0";

      try {
        const chainIdHex = await rpcRequest(url, "eth_chainId", [], 6500);
        const chainId = Number(chainIdHex);
        chainOk = (chainId === chain.chainId);

        blockNumHex = await rpcRequest(url, "eth_blockNumber", [], 6500);
        blockOk = !!blockNumHex;

        // eth_call: decimals() on USDT
        const data = "0x313ce567";
        const callRes = await rpcRequest(url, "eth_call", [{ to: chain.usdt, data }, "latest"], 6500);
        callOk = !!callRes;

        // read logs: last 200 blocks for USDT Transfer
        let latest = parseInt(blockNumHex, 16);
        if (!isFinite(latest) || latest <= 0) latest = 0;
        const from = Math.max(0, latest - 200);
        const logs = await rpcRequest(url, "eth_getLogs", [{
          fromBlock: "0x" + from.toString(16),
          toBlock: "0x" + latest.toString(16),
          address: chain.usdt,
          topics: [TRANSFER_TOPIC0]
        }], 8000);

        // logs can be empty but should not error
        logsOk = Array.isArray(logs);

        const ms = Math.round(performance.now() - start);
        const ok = chainOk && blockOk && callOk && logsOk;
        return { url, ms, ok, chainOk, blockOk, callOk, logsOk, blockNumHex };
      } catch (e) {
        const ms = Math.round(performance.now() - start);
        return { url, ms, ok:false, chainOk, blockOk, callOk, logsOk, status: String(e?.message || e) };
      }
    }

    async function runRpcTests(){
      const st = $("#rpc-status");
      clearStatus(st);

      const net = netFromSelect("#rpc-net");
      const candidates = buildRpcCandidates(net);
      if (!candidates.length) { setStatus(st,"warn","No RPC URLs to test."); return; }

      const table = $("#rpc-table");
      if (table) {
        table.innerHTML = `
          <div class="trow head rpc">
            <div class="cell">RPC</div>
            <div class="cell">ms</div>
            <div class="cell hide-sm">chain</div>
            <div class="cell hide-sm">block</div>
            <div class="cell hide-sm">call</div>
            <div class="cell hide-sm">logs</div>
            <div class="cell">status</div>
          </div>
        `;
      }

      setStatus(st,"info",`Testing ${candidates.length} RPCs‚Ä¶`);

      const results = [];
      for (const url of candidates) {
        const r = await testOneRpc(url, net);
        results.push(r);

        // stream results
        table && (table.innerHTML += rpcRowHtml(r));
      }

      const good = results.filter(r => r.ok).sort((a,b)=>a.ms-b.ms);
      if (good.length) {
        const best = good[0];
        setSavedBestRpc(net, best.url);

        // rerender highlight
        if (table) {
          table.innerHTML = `
            <div class="trow head rpc">
              <div class="cell">RPC</div>
              <div class="cell">ms</div>
              <div class="cell hide-sm">chain</div>
              <div class="cell hide-sm">block</div>
              <div class="cell hide-sm">call</div>
              <div class="cell hide-sm">logs</div>
              <div class="cell">status</div>
            </div>
          `;
          for (const r of results) {
            r.highlight = (r.url === best.url);
            table.innerHTML += rpcRowHtml(r);
          }
        }

        setStatus(st,"ok",`Best RPC saved locally ‚úÖ <span class="mono">${best.url}</span>`);
        gtagEvent("sec_rpc_best_saved", { net });
      } else {
        setStatus(st,"warn","No fully working RPC found (CORS/timeouts/logs). Try a different endpoint.");
      }
    }

    async function runRpcDevLogsTest(){
      const st = $("#rpc-status");
      const net = netFromSelect("#rpc-net");
      const url = ( ($("#rpc-custom")?.value || "").trim() || getSavedPrivateRpc(net) || getSavedBestRpc(net) || CHAINS[net].publicRpcs[0] );

      if (!url) { setStatus(st,"warn","Set an RPC first."); return; }

      const addr = ($("#rpc-dev-addr")?.value || "").trim();
      const topic0 = ($("#rpc-dev-topic")?.value || "").trim();

      if (addr && !E.isAddress(addr)) { setStatus(st,"warn","Invalid contract address."); return; }
      if (topic0 && !/^0x[0-9a-fA-F]{64}$/.test(topic0)) { setStatus(st,"warn","Topic0 must be 32 bytes hex (0x + 64)."); return; }

      setStatus(st,"info","Running custom logs test‚Ä¶");

      try {
        const latestHex = await rpcRequest(url, "eth_blockNumber", [], 6500);
        let latest = parseInt(latestHex, 16);
        if (!isFinite(latest) || latest <= 0) latest = 0;
        const from = Math.max(0, latest - 2000);

        const logs = await rpcRequest(url, "eth_getLogs", [{
          fromBlock: "0x" + from.toString(16),
          toBlock: "0x" + latest.toString(16),
          ...(addr ? { address: E.getAddress(addr) } : {}),
          ...(topic0 ? { topics: [topic0] } : {})
        }], 9000);

        setStatus(st,"ok",`Custom logs OK ‚úÖ returned <b>${Array.isArray(logs) ? logs.length : 0}</b> logs`);
        gtagEvent("sec_rpc_dev_logs_ok", { net });

      } catch (e) {
        setStatus(st,"bad",`Custom logs failed: ${String(e?.message || e)}`);
      }
    }

    $("#rpc-test")?.addEventListener("click", runRpcTests);
    $("#rpc-dev-run")?.addEventListener("click", runRpcDevLogsTest);

    $("#rpc-copy-best")?.addEventListener("click", async ()=>{
      const net = netFromSelect("#rpc-net");
      const best = getSavedBestRpc(net);
      if (!best) { setStatus($("#rpc-status"), "warn", "No saved best RPC yet. Run tests first."); return; }
      const ok = await copyText(best);
      setStatus($("#rpc-status"), ok ? "ok" : "warn", ok ? "Copied best RPC." : "Copy failed.");
    });

    $("#rpc-share-x")?.addEventListener("click", ()=>{
      const net = netFromSelect("#rpc-net");
      const best = getSavedBestRpc(net);
      const u = new URL("https://twitter.com/intent/tweet");
      u.searchParams.set("text", `RPC Health (${net.toUpperCase()}): best endpoint found ‚úÖ ${best ? best : "(none yet)"} ‚Äî CycleX Security Hub`);
      window.open(u.toString(), "_blank", "noopener");
    });

    $("#rpc-private-save")?.addEventListener("click", ()=>{
      const net = netFromSelect("#rpc-net");
      const v = ($("#rpc-private")?.value || "").trim();
      if (v && !/^https?:\/\//i.test(v)) { setStatus($("#rpc-status"), "warn", "RPC must start with https://"); return; }
      setSavedPrivateRpc(net, v);
      setStatus($("#rpc-status"), "ok", "Saved private RPC locally.");
    });

    $("#rpc-private-clear")?.addEventListener("click", ()=>{
      const net = netFromSelect("#rpc-net");
      setSavedPrivateRpc(net, "");
      $("#rpc-private") && ($("#rpc-private").value = "");
      setStatus($("#rpc-status"), "ok", "Cleared private RPC.");
    });

    $("#rpc-net")?.addEventListener("change", ()=>{
      const net = netFromSelect("#rpc-net");
      const v = getSavedPrivateRpc(net);
      $("#rpc-private") && ($("#rpc-private").value = v);
    });

    // =========================
    // Tx Decoder
    // =========================
    function decodeErc20Input(data){
      if (!data || data.length < 10) return null;
      const sig = data.slice(0, 10).toLowerCase();
      // transfer(address,uint256) a9059cbb
      if (sig === "0xa9059cbb" && data.length >= 10 + 64 + 64) {
        const to = "0x" + data.slice(10+24, 10+64);
        const val = BigInt("0x" + data.slice(10+64, 10+64+64));
        return { type:"ERC20.transfer", to: E.isAddress(to) ? E.getAddress(to) : to, value: val.toString() };
      }
      // approve(address,uint256) 095ea7b3
      if (sig === "0x095ea7b3" && data.length >= 10 + 64 + 64) {
        const sp = "0x" + data.slice(10+24, 10+64);
        const val = BigInt("0x" + data.slice(10+64, 10+64+64));
        return { type:"ERC20.approve", spender: E.isAddress(sp) ? E.getAddress(sp) : sp, value: val.toString() };
      }
      return { type:"Unknown", selector: sig, bytes: data.length };
    }

    async function runTxDecode({ auto=false } = {}){
      const st = $("#tx-status");
      const out = $("#tx-out");
      const eventsEl = $("#tx-events");

      clearStatus(st);
      if (eventsEl) eventsEl.innerHTML = "";

      const net = netFromSelect("#tx-net");
      const hash = ($("#tx-hash")?.value || "").trim();
      if (!/^0x[0-9a-fA-F]{64}$/.test(hash)) { setStatus(st,"warn","Invalid tx hash."); return; }

      const best = getSavedBestRpc(net);
      const providerUrl = ( ($("#rpc-custom")?.value || "").trim() || getSavedPrivateRpc(net) || best || CHAINS[net].publicRpcs[0] );
      if (!providerUrl) { setStatus(st,"bad","No RPC available. Run RPC tests first."); return; }

      setStatus(st,"info","Fetching tx + receipt‚Ä¶");

      try {
        const tx = await rpcRequest(providerUrl, "eth_getTransactionByHash", [hash], 9000);
        const rc = await rpcRequest(providerUrl, "eth_getTransactionReceipt", [hash], 9000);

        if (!tx) { setStatus(st,"warn","Transaction not found."); return; }

        const decoded = decodeErc20Input(tx.input || "");
        const from = tx.from ? E.getAddress(tx.from) : "";
        const to = tx.to ? E.getAddress(tx.to) : "";
        const status = rc?.status === "0x1" ? "‚úÖ success" : (rc?.status === "0x0" ? "‚ùå failed" : "‚Äî");
        const block = rc?.blockNumber ? parseInt(rc.blockNumber, 16) : null;

        if (out) {
          out.innerHTML = `
            <b>Tx</b>: <a href="${CHAINS[net].txUrl(hash)}" target="_blank" rel="noopener" class="mono">${hash}</a><br>
            <span class="small">Status: <b>${status}</b>${block ? ` ‚Ä¢ Block: <b>${block}</b>` : ""}</span><br><br>
            <div class="small">From: <span class="mono">${from}</span></div>
            <div class="small">To: <span class="mono">${to || "‚Äî"}</span></div>
            <div class="small" style="margin-top:10px"><b>Input</b>: <span class="mono">${decoded?.type || "‚Äî"}</span></div>
            <div class="small" style="margin-top:6px"><span class="mono">${safeJson(decoded)}</span></div>
          `;
        }

        // decode logs (Transfer/Approval)
        const iface = new E.Interface([
          "event Transfer(address indexed from, address indexed to, uint256 value)",
          "event Approval(address indexed owner, address indexed spender, uint256 value)"
        ]);

        const logs = Array.isArray(rc?.logs) ? rc.logs : [];
        const rendered = [];

        for (const lg of logs) {
          try {
            const topic0 = (lg.topics && lg.topics[0]) ? String(lg.topics[0]).toLowerCase() : "";
            if (topic0 !== TRANSFER_TOPIC0 && topic0 !== APPROVAL_TOPIC0) continue;

            const parsed = iface.parseLog({ topics: lg.topics, data: lg.data });
            rendered.push({
              address: lg.address ? E.getAddress(lg.address) : "",
              name: parsed?.name || "",
              args: parsed?.args ? Array.from(parsed.args).map(x=> (typeof x === "bigint" ? x.toString() : String(x))) : []
            });
          } catch {}
        }

        if (eventsEl) {
          if (!rendered.length) {
            eventsEl.innerHTML = `<div class="small muted">No standard Transfer/Approval events decoded.</div>`;
          } else {
            eventsEl.innerHTML = rendered.map(ev => `
              <div class="status info" style="display:block; margin-top:10px;">
                <b>${ev.name}</b><br>
                <span class="small">Contract: <a href="${CHAINS[net].addressUrl(ev.address)}" target="_blank" rel="noopener" class="mono">${ev.address}</a></span><br>
                <span class="mono">${safeJson(ev.args)}</span>
              </div>
            `).join("");
          }
        }

        $("#tx-copy-md")?.onclick = async ()=>{
          const md = [
            `## Tx Decode (CycleX Security Hub)`,
            ``,
            `- Network: ${net.toUpperCase()}`,
            `- Tx: \`${hash}\``,
            `- Explorer: ${CHAINS[net].txUrl(hash)}`,
            `- Status: ${status}`,
            ``,
            `### Decoded Input`,
            "```json",
            safeJson(decoded),
            "```",
            ``,
            `### Decoded Events (Transfer/Approval)`,
            "```json",
            safeJson(rendered),
            "```"
          ].join("\n");
          const ok = await copyText(md);
          setStatus(st, ok ? "ok" : "warn", ok ? "Copied Markdown." : "Copy failed.");
        };

        setStatus(st,"ok","Done.");
        gtagEvent("sec_tx_decode", { net });

      } catch (e) {
        setStatus(st,"bad",`Tx decode failed: ${String(e?.message || e)}`);
      }
    }

    $("#tx-run")?.addEventListener("click", runTxDecode);

    // =========================
    // Dev Tools: Bookmarklet + Monitor
    // =========================
    function buildBookmarklet(baseUrl){
      // bookmarklet tries to read token/tx from explorer URL and opens hub
      const js = `
(function(){
  try{
    var u=location.href;
    var base="${baseUrl.replace(/"/g,'\\"')}";
    var net = (u.includes("bscscan.com") ? "bsc" : "eth");
    var m1 = u.match(/\\/address\\/(0x[a-fA-F0-9]{40})/);
    var m2 = u.match(/\\/token\\/(0x[a-fA-F0-9]{40})/);
    var m3 = u.match(/\\/tx\\/(0x[a-fA-F0-9]{64})/);
    var to="";
    if(m3){
      to = base + "?tool=tx&net=" + net + "&tx=" + m3[1];
    } else {
      var a = (m2 && m2[1]) || (m1 && m1[1]) || "";
      if(!a){ alert("No token address detected"); return; }
      to = base + "?tool=quick&net=" + net + "&token=" + a;
    }
    window.open(to, "_blank");
  }catch(e){ alert("Bookmarklet error: " + e); }
})();`.trim();

      return "javascript:" + encodeURIComponent(js);
    }

    $("#bm-generate")?.addEventListener("click", ()=>{
      const base = ($("#bm-base")?.value || location.origin + location.pathname).trim();
      const bm = buildBookmarklet(base);
      setStatus($("#bm-out"), "ok", `Generated. Copy it using the button below.`);
      $("#bm-out").dataset.bm = bm;
    });

    $("#bm-copy")?.addEventListener("click", async ()=>{
      const bm = $("#bm-out")?.dataset?.bm || "";
      if (!bm) { setStatus($("#bm-out"), "warn", "Generate first."); return; }
      const ok = await copyText(decodeURIComponent(bm.replace(/^javascript:/,"javascript:")));
      // copy the bookmarklet as text (user can paste into bookmark URL)
      setStatus($("#bm-out"), ok ? "ok" : "warn", ok ? "Copied bookmarklet code." : "Copy failed.");
    });

    // Monitor
    const LS_MON = "cx_sec_mon_v1";

    function monLoad(){
      try { return JSON.parse(localStorage.getItem(LS_MON) || "[]"); } catch { return []; }
    }
    function monSave(list){
      try { localStorage.setItem(LS_MON, JSON.stringify(list)); } catch {}
    }

    function monRender(){
      const table = $("#mon-table");
      if (!table) return;
      const list = monLoad();
      table.innerHTML = `
        <div class="trow head">
          <div class="cell">Contract</div>
          <div class="cell">Network</div>
          <div class="cell hide-sm">Last seen</div>
          <div class="cell">Status</div>
        </div>
      `;
      for (const it of list) {
        const row = document.createElement("div");
        row.className = "trow";
        row.innerHTML = `
          <div class="cell wrap"><a href="${CHAINS[it.net].addressUrl(it.addr)}" target="_blank" rel="noopener" class="mono">${shortAddr(it.addr)}</a></div>
          <div class="cell">${it.net.toUpperCase()}</div>
          <div class="cell hide-sm">${it.last || "‚Äî"}</div>
          <div class="cell">${it.status || "‚Äî"}</div>
        `;
        table.appendChild(row);
      }
    }

    async function monAdd(){
      const st = $("#mon-status");
      clearStatus(st);

      const net = netFromSelect("#mon-net");
      const a = ($("#mon-addr")?.value || "").trim();
      if (!E.isAddress(a)) { setStatus(st,"warn","Invalid contract address."); return; }
      const addr = E.getAddress(a);

      const list = monLoad();
      const next = [{ net, addr, last:"‚Äî", status:"pending" }, ...list.filter(x => !(x.net===net && x.addr.toLowerCase()===addr.toLowerCase()))].slice(0, 40);
      monSave(next);
      monRender();
      setStatus(st,"ok","Added.");
      gtagEvent("sec_mon_add", { net });
    }

    async function monCheckAll(){
      const st = $("#mon-status");
      clearStatus(st);

      const list = monLoad();
      if (!list.length) { setStatus(st,"warn","Watchlist empty."); return; }

      setStatus(st,"info","Checking‚Ä¶");

      for (const it of list) {
        try {
          const provider = getReadProvider(it.net);
          if (!provider) { it.status = "no rpc"; continue; }
          const code = await provider.getCode(it.addr);
          it.status = (code && code !== "0x") ? "code ‚úÖ" : "no code";
          it.last = new Date().toLocaleString();
        } catch {
          it.status = "failed";
          it.last = new Date().toLocaleString();
        }
      }
      monSave(list);
      monRender();
      setStatus(st,"ok","Done.");
      gtagEvent("sec_mon_check", { n: list.length });
    }

    $("#mon-add")?.addEventListener("click", monAdd);
    $("#mon-check")?.addEventListener("click", monCheckAll);
    $("#mon-export")?.addEventListener("click", async ()=>{
      const list = monLoad();
      const ok = await copyText(safeJson(list));
      setStatus($("#mon-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
    });

    // =========================
    // Wiring + Auto-run
    // =========================
    $("#qs-run")?.addEventListener("click", ()=>runQuickScan({ auto:false }));
    $("#liq-run")?.addEventListener("click", ()=>runLiqScan({ auto:false }));

    // Quick scan button in header
    $("#btn-quick")?.addEventListener("click", ()=>{
      showPanel("quick");
      $("#qs-token")?.focus();
    });

    // Prefill bookmarklet base URL
    $("#bm-base") && ($("#bm-base").value = location.origin + location.pathname);

    // Initialize RPC private input for current net
    (function initRpcUi(){
      const net = netFromSelect("#rpc-net");
      const v = getSavedPrivateRpc(net);
      $("#rpc-private") && ($("#rpc-private").value = v);
    })();

    // Init language + keys + monitor
    initLang();
    initApiKeysUi();
    monRender();
    renderWalletLabels();

    // Auto-run from query params
    (function autoRunFromQuery(){
      const q = parseQuery();
      if (!q.tool) return;

      const tool = ["quick","liq","approvals","rpc","tx","dev"].includes(q.tool) ? q.tool : "quick";
      showPanel(tool);

      if (q.net === "eth" || q.net === "bsc") {
        // apply to selects
        $("#qs-net") && ($("#qs-net").value = q.net);
        $("#liq-net") && ($("#liq-net").value = q.net);
        $("#ap-net") && ($("#ap-net").value = q.net);
        $("#rpc-net") && ($("#rpc-net").value = q.net);
        $("#tx-net") && ($("#tx-net").value = q.net);
      }

      if (tool === "quick" && q.token && E.isAddress(q.token)) {
        $("#qs-token") && ($("#qs-token").value = E.getAddress(q.token));
        // gentle auto-run (rate-limited)
        setTimeout(()=>runQuickScan({ auto:true }), 350);
      }
      if (tool === "liq" && q.token && E.isAddress(q.token)) {
        $("#liq-token") && ($("#liq-token").value = E.getAddress(q.token));
        setTimeout(()=>runLiqScan({ auto:true }), 350);
      }
      if (tool === "tx" && q.tx && /^0x[0-9a-fA-F]{64}$/.test(q.tx)) {
        $("#tx-hash") && ($("#tx-hash").value = q.tx);
        setTimeout(()=>runTxDecode({ auto:true }), 350);
      }
    })();

    // Buttons that open panels quickly
    $("#btn-quick")?.addEventListener("click", ()=>showPanel("quick"));
    $("#btn-quick")?.addEventListener("click", ()=>gtagEvent("sec_quick_btn"));

    // Quick scan "Run Quick Scan" hero button already wired earlier; keep also:
    $("#btn-quick")?.addEventListener("click", ()=>{ showPanel("quick"); });

    // Close panels to none
    // (already attached above)

  </script>
</body>
</html>

