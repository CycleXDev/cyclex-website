<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

 <!-- <link rel="icon" href="/favicon.ico" sizes="any">-->
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#05060a">
  <meta name="application-name" content="CycleX">
  <meta name="apple-mobile-web-app-title" content="CycleX">
  <title>CycleX – Security Hub</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
   <style>
  :root{
    --bg-main:#05060a;
    --bg-gradient-start:#05060a;
    --bg-gradient-mid:#1a0d3a;
    --bg-gradient-end:#003a4c;

    --text-main:#f4f6ff;
    --text-muted:rgba(244,246,255,.7);

    --accent-cyan:#00e5ff;
    --accent-green:#5dffb2;
    --accent-purple:#7c5cff;
    --green:#3cffb0;

    --card-bg:rgba(255,255,255,.06);
    --border-subtle:rgba(255,255,255,.12);

    --shadow-soft:0 24px 70px rgba(0,0,0,.65);
    --radius-xl:24px;
    --radius-lg:18px;
    --transition-fast:.18s ease-out;

    --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    --sans:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;

    --container: 1160px;
    --container-wide: 1160px;

    /* ✅ single source of truth for grid/panel spacing */
    --tool-panel-gap: 18px;
    --tool-grid-gap: 18px;

    /* sticky bar offset for scrollIntoView (even if we later disable scroll) */
    --scroll-offset: 96px;
  }

 *{box-sizing:border-box;margin:0;padding:0}
  html,body{min-height:100%}
  html{
    font-size:16px;
    -webkit-text-size-adjust:100%;
    text-size-adjust:100%;
    background:
    radial-gradient(circle at top left, rgba(124,92,255,.35) 0%, transparent 45%),
    radial-gradient(circle at top right, rgba(0,229,255,.35) 0%, transparent 45%),
    radial-gradient(circle at bottom, rgba(0,58,76,.55) 0%, transparent 55%),
    linear-gradient(160deg,var(--bg-gradient-start),var(--bg-gradient-mid),var(--bg-gradient-end));
    background-repeat:no-repeat;
    background-attachment: fixed; /* ✅ makes it feel smooth while scrolling */
  }

  body{
    font-family:var(--sans);
    background:transparent;
    color:var(--text-main);
    min-height:100vh;
    -webkit-font-smoothing:antialiased;
    animation:fadeBody .7s ease-out forwards;
    opacity:1;
    overflow-x:hidden;
  }
  @keyframes fadeBody{from{opacity:0}to{opacity:1}}
  a{color:inherit;text-decoration:none}


  .page-shell{
    width:100%;
    max-width:1160px;
    margin:0 auto;
    padding:32px 20px 64px;
    transform:none !important;
  }

  /* helpers */
  .hide-sm{}
  .mono{font-family:var(--mono);font-variant-numeric:tabular-nums;direction:ltr;unicode-bidi:plaintext}
  .muted{color:var(--text-muted);font-size:13px;line-height:1.45}
  .small{font-size:12px;color:var(--text-muted);line-height:1.45}
  .cell{min-width:0}
  .wrap{white-space:normal;overflow-wrap:anywhere}

  /* =========================
   TOP BAR (SECURITY — MAIN SITE STYLE)
   ========================= */
.top-bar{
  position:sticky;
  top:14px;
  z-index:999;

  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;

  padding:12px 16px;
  margin:0 auto 30px;

  width: min(1160px, calc(100% - 24px)); /* feel "edge-to-edge" like home */
  border-radius:999px;

  background: rgba(10,12,22,.50);
  border: 1px solid rgba(255,255,255,.14);
  backdrop-filter: blur(18px) saturate(1.12);
  -webkit-backdrop-filter: blur(18px) saturate(1.12);

  box-shadow: 0 14px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06);
  overflow:hidden;
}

/* premium gradient rim */
.top-bar::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:999px;
  padding:1px;
  background: linear-gradient(120deg,
    rgba(0,229,255,.22),
    rgba(124,92,255,.16),
    rgba(255,255,255,.10)
  );
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
          mask-composite: exclude;
  pointer-events:none;
  opacity:.55;
}

/* Left: brand */
.brand{
  display:flex;
  align-items:center;
  gap:10px;
  position:relative;
  z-index:1;
  min-width:0;
}
.brand-logo{
  width:42px;
  height:42px;
  border-radius:14px;
  object-fit:contain;

  background: rgba(255,255,255,.02);
  border: 1px solid rgba(255,255,255,.06);
  box-shadow: 0 12px 32px rgba(0,0,0,.7);

  flex:0 0 auto;
}
.brand-text{
  display:flex;
  flex-direction:column;
  gap:2px;
  min-width:0;
}
.brand-title{
  font-weight:950;
  letter-spacing:.10em;
  font-size:13px;
  text-transform:uppercase;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.brand-sub{
  font-size:10px;
  letter-spacing:.18em;
  text-transform:uppercase;
  color: var(--dim, rgba(244,246,255,.56));
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

/* Center nav (optional — if exists in this page) */
.top-nav{
  position:relative;
  z-index:1;
  margin: 0 auto;
  display:flex;
  gap:12px;
  align-items:center;
  justify-content:center;
  flex:1 1 auto;

  padding:0;
  background:transparent;
  border:none;
  box-shadow:none;
}
.top-link{
  position:relative;
  font-size:11px;
  letter-spacing:.16em;
  text-transform:uppercase;
  color: rgba(244,246,255,.72);

  padding:8px 12px;
  border-radius:999px;
  border:1px solid transparent;
  background:transparent;

  transition: background .18s var(--ease, ease-out),
              border-color .18s var(--ease, ease-out),
              transform .18s var(--ease, ease-out),
              color .18s var(--ease, ease-out);
  white-space:nowrap;
}
.top-link:hover{
  background: rgba(255,255,255,.04);
  border-color: rgba(255,255,255,.12);
  transform: translateY(-1px);
  color: rgba(244,246,255,.90);
}
.top-link.active{ color: rgba(244,246,255,.90); }
.top-link::after{
  content:"";
  position:absolute;
  left:0; right:0;
  bottom:-6px;
  height:1px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.22), transparent);
  opacity:0;
  transition: opacity .22s var(--ease, ease-out);
}
.top-link:hover::after,
.top-link.active::after{ opacity:1; }

/* Right group wrapper (optional — if exists) */
.top-right{
  position:relative;
  z-index:1;
  display:flex;
  align-items:center;
  gap:10px;
  flex:0 0 auto;
}

/* Lang switch */
.lang-switch{
  position:relative;
  z-index:1;

  display:inline-flex;
  align-items:center;
  padding:4px;
  border-radius:999px;
  background: rgba(255,255,255,.045);
  border: 1px solid rgba(255,255,255,.12);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 10px 26px rgba(0,0,0,.35);
  gap:2px;

  flex:0 0 auto;
}
.lang-btn{
  border:none;
  background:transparent;
  color: var(--dim, rgba(244,246,255,.56));
  font-size:11px;
  padding:6px 10px;
  border-radius:999px;
  cursor:pointer;
  user-select:none;
  white-space:nowrap;
  transition: transform .18s var(--ease, ease-out),
              background .18s var(--ease, ease-out),
              color .18s var(--ease, ease-out);
}
.lang-btn:hover{ transform: translateY(-1px); }
.lang-btn.active{
  background: rgba(0,229,255,.14);
  color: rgba(0,229,255,.95);
}

/* keep your lang fade */
body.lang-switching{ animation: langFade .28s ease-out; }
@keyframes langFade{
  from{opacity:.5;transform:translateY(4px)}
  to{opacity:1;transform:translateY(0)}
}

/* =========================
   HERO (SECURITY HUB — PREMIUM, MAIN-SITE STYLE)
   ========================= */
.hero{
  position:relative;
  max-width:1100px;
  margin:18px auto 16px;
  padding:18px 0 18px;
  text-align:center;
  animation: heroIn .7s var(--ease, ease-out) both;
}

@keyframes heroIn{
  from{opacity:0; transform:translateY(14px)}
  to{opacity:1; transform:translateY(0)}
}

.hero::before{
  content:"";
  position:absolute;
  inset:-70px 0 -40px;
  z-index:-1;
  border-radius:80px;
  background:
    radial-gradient(circle at 50% 18%, rgba(0,229,255,.10), transparent 62%),
    radial-gradient(circle at 26% 40%, rgba(124,92,255,.08), transparent 66%);
  opacity:.65;
  filter: blur(18px);
  pointer-events:none;
}

.hero-kicker{
  font-size:12px;
  letter-spacing:.22em;
  text-transform:uppercase;
  color: rgba(0,229,255,.92);
  margin-bottom:14px;
}

.hero-title{
  font-size: clamp(40px, 4.6vw, 76px);
  line-height: 1.12;
  font-weight: 950;
  letter-spacing: -0.035em;
  margin-bottom: 12px;
  display: inline-block;
  padding-bottom: .10em;
}

@supports (-webkit-background-clip:text){
  .hero-title{
    background: linear-gradient(110deg,
      rgba(244,246,255,1) 0%,
      rgba(0,229,255,.98) 40%,
      rgba(124,92,255,.86) 76%,
      rgba(244,246,255,.92) 100%);
    -webkit-background-clip:text;
    background-clip:text;
    color: transparent;
    animation: titleSheen 6.6s ease-in-out infinite;
    background-size: 220% 220%;
    text-shadow:none;
  }
  @keyframes titleSheen{
    0%{background-position:0% 50%}
    50%{background-position:100% 50%}
    100%{background-position:0% 50%}
  }
}

/* Keep single-line title on wide screens */
@media (min-width:980px){
  .hero-title{
    white-space:nowrap;
    letter-spacing:-0.04em;
    font-size: clamp(46px, 4.4vw, 80px);
  }
  .hero-title br{ display:none; }
}

.hero-subtitle{
  margin-left:auto;
  margin-right:auto;
  max-width:72ch;
  font-size:16px;
  line-height:1.75;
  color: var(--muted, var(--text-muted));
  margin-bottom:16px;
}

/* =========================
   BUTTON ROW (MAIN-SITE CLEAN)
   ========================= */
.hero-actions{
  margin-top:14px;
  width:100%;
  max-width:980px;
  margin-left:auto;
  margin-right:auto;

  display:flex;
  justify-content:center;
  align-items:stretch;
  gap:12px;

  flex-wrap: nowrap;
}

.hero-actions .btn{
  flex: 1 1 0;
  min-width: 0;
  max-width: 520px;
}

/* Buttons — main-site style */
.btn{
  position:relative;
  border-radius:999px;
  border:1px solid transparent;
  padding:13px 26px;
  font-size:13px;
  font-weight:950;
  letter-spacing:.10em;
  text-transform:uppercase;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  transition: transform .32s var(--ease, ease-out),
              box-shadow .32s var(--ease, ease-out),
              background .32s var(--ease, ease-out),
              color .32s var(--ease, ease-out),
              border-color .32s var(--ease, ease-out),
              filter .32s var(--ease, ease-out);
  isolation:isolate;
  min-height:52px; /* premium uniform height */
  user-select:none;
  white-space:nowrap;
}
.btn:focus-visible{ outline:none; box-shadow: 0 0 0 3px rgba(0,229,255,.22); }
.btn:disabled{ opacity:.55; cursor:not-allowed; }

.btn-primary{
  background: linear-gradient(135deg, rgba(0,229,255,1), rgba(125,242,255,1));
  color:#03040a;
  box-shadow: 0 22px 90px rgba(0,229,255,.38);
  border-color: rgba(0,229,255,.18);
}
.btn-primary::after{
  content:"";
  position:absolute; inset:0;
  border-radius:999px;
  background: linear-gradient(120deg,
    transparent 0%,
    rgba(255,255,255,.58) 18%,
    transparent 36%,
    transparent 100%);
  transform: translateX(-120%);
  opacity:.65;
  z-index:-1;
  transition: transform .65s var(--ease, ease-out);
  filter: blur(.2px);
}
.btn-primary:hover{
  transform: translateY(-2px);
  box-shadow: 0 30px 130px rgba(0,229,255,.48);
  filter: saturate(1.05);
}
.btn-primary:hover::after{ transform: translateX(120%); }

/* Use glass secondary for both secondary + ghost in Security Hub */
.btn-secondary,
.btn-ghost{
  background: rgba(255,255,255,.030);
  color: var(--text, var(--text-main));
  border-color: rgba(255,255,255,.16);
  backdrop-filter: blur(14px);
  box-shadow: 0 16px 55px rgba(0,0,0,.34);
}
.btn-secondary:hover,
.btn-ghost:hover{
  transform: translateY(-2px);
  border-color: rgba(0,229,255,.24);
  box-shadow: 0 24px 90px rgba(0,0,0,.56);
}

/* Mobile: stack buttons like main site */
@media (max-width:979px){
  .hero{ text-align:center; }
  .hero-subtitle{ margin-left:auto; margin-right:auto; }
  .hero-actions{
    flex-direction: column;
    max-width: 520px;
    margin-left:auto;
    margin-right:auto;
    flex-wrap: nowrap;
  }
  .hero-actions .btn{
    flex: 1 1 auto;
    width: 100%;
    max-width: 520px;
  }
}

/* =========================
   MICROCOPY + NOTE (SECURITY HUB)
   ========================= */
.hero-micro{
  display:flex;
  justify-content:center;
  align-items:center;
  flex-wrap:wrap;
  gap:10px;
  margin: 8px 0 0;
  font-size:12px;
  line-height:1.35;
  color: rgba(244,246,255,.72);
}
.hero-micro .micro-item{ opacity:.88; }
.hero-micro .micro-dot{
  opacity:.42;
  font-size:13px;
  transform: translateY(-.5px);
  user-select:none;
}
@media (max-width:520px){
  .hero-micro{ gap:8px; }
}

.note-line{
  margin:18px auto 0;
  max-width:820px;
  text-align:center;
  font-size:13px;
  color: var(--dim, var(--text-muted));
  line-height:1.55;
}
     /* ===== SECURITY HERO CTA OVERRIDE (no HTML changes) ===== */
/* Back to Site -> glass (transparent) */
.hero-actions a.btn-primary{
  background: rgba(255,255,255,.030) !important;
  color: var(--text, var(--text-main)) !important;
  border-color: rgba(255,255,255,.16) !important;
  backdrop-filter: blur(14px);
  box-shadow: 0 16px 55px rgba(0,0,0,.34) !important;
}
.hero-actions a.btn-primary:hover{
  transform: translateY(-2px);
  border-color: rgba(0,229,255,.24) !important;
  box-shadow: 0 24px 90px rgba(0,0,0,.56) !important;
}

/* Get Access -> premium colored (cyan) */
.hero-actions #btn-connect.btn-secondary{
  background: linear-gradient(135deg, rgba(0,229,255,1), rgba(125,242,255,1)) !important;
  color:#03040a !important;
  border-color: rgba(0,229,255,.18) !important;
  box-shadow: 0 22px 90px rgba(0,229,255,.38) !important;
}
.hero-actions #btn-connect.btn-secondary::after{
  content:"";
  position:absolute; inset:0;
  border-radius:999px;
  background: linear-gradient(120deg,
    transparent 0%,
    rgba(255,255,255,.58) 18%,
    transparent 36%,
    transparent 100%);
  transform: translateX(-120%);
  opacity:.65;
  z-index:-1;
  transition: transform .65s var(--ease, ease-out);
  filter: blur(.2px);
}
.hero-actions #btn-connect.btn-secondary:hover{
  transform: translateY(-2px);
  box-shadow: 0 30px 130px rgba(0,229,255,.48) !important;
  filter: saturate(1.05);
}
.hero-actions #btn-connect.btn-secondary:hover::after{
  transform: translateX(120%);
}



  /* =========================
     Tool grid (single source of truth)
     ========================= */
  .tool-grid-wrap{
    width:100%;
    max-width:1160px;
    margin:0 auto;
  }
 .tool-grid-title{
  text-align:center;
  margin: -14px 0 6px;  
  font-size:12px;
  letter-spacing:.16em;
  text-transform:uppercase;
  color:rgba(244,246,255,.72);
}


  .tool-grid{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:var(--tool-grid-gap);
    margin-top:6px;
    align-items:stretch;
  }

  .tool-card{
    background:rgba(255,255,255,.05);
    border-radius:var(--radius-xl);
    border:1px solid rgba(255,255,255,.12);
    padding:22px 22px 18px;
    box-shadow:0 20px 55px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.05);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    transition:transform var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
    min-width:0;
    min-height:178px;
  }
    /* ALL tool cards — subtle frame like Quick Scan (safe, no layout change) */


  .tool-card::before{
    content:"";
    position:absolute; inset:-2px;
    background:
      radial-gradient(520px 180px at 18% -5%, rgba(0,229,255,.18), transparent 60%),
      radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.18), transparent 60%);
    pointer-events:none;
    opacity:.95;
  }
/* Wallet Security DNA: keep badges aligned with other cards */
a.tool-card[data-tool="approvals"]{
  display:flex;
  flex-direction:column;
}

a.tool-card[data-tool="approvals"] .badge-row{
  margin-top:auto;
  margin-bottom:14px; 
}


  .tool-card > *{position:relative}
  .tool-card:hover{transform:translateY(-2px);border-color:rgba(0,229,255,.28);background:rgba(255,255,255,.06)}
  .tool-card.active{border-color:rgba(0,229,255,.42);background:rgba(0,229,255,.06)}

  .tool-head{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;margin-bottom:10px}
  .tool-name{font-size:17px;font-weight:900;letter-spacing:.01em;line-height:1.22}
  .tool-desc{font-size:14px;color:var(--text-muted);line-height:1.5}

  .badge-row{display:flex;flex-wrap:wrap;gap:8px;margin-top:14px}
  .badge{
    display:inline-flex;align-items:center;gap:8px;
    font-size:12px;padding:7px 11px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:var(--text-muted);
    white-space:nowrap;user-select:none;
  }
  .badge strong{color:rgba(244,246,255,.92);font-weight:800}
  .badge.beta{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08);color:rgba(244,246,255,.92)}

  /* Risk badges */
  .risk-badges{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .risk{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;font-size:12px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.88);
    user-select:none;
  }
  .risk .dot{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.25);box-shadow:0 0 0 3px rgba(255,255,255,.06);flex:0 0 auto}
  .risk.ok{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .risk.ok .dot{background:rgba(0,230,118,.95)}
  .risk.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .risk.warn .dot{background:rgba(255,193,7,.95)}
  .risk.bad{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}
  .risk.bad .dot{background:rgba(220,53,69,.95)}

  /* =========================
     Panels (same width as cubes)
     ========================= */
  .panel-shell{
    width:100%;
    max-width:1160px;
    margin:var(--tool-panel-gap) auto 0;
    padding:18px 18px;
    border-radius:var(--radius-xl);
    background:rgba(255,255,255,.04);
    backdrop-filter:blur(20px);
    border:1px solid rgba(255,255,255,.12);
    box-shadow:0 26px 70px rgba(0,0,0,.60), inset 0 1px 0 rgba(255,255,255,.05);
    scroll-margin-top: var(--scroll-offset);
  }
  .panel-shell.hidden{display:none}

  .panel-head{
    display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
    margin-bottom:12px;
  }
  .panel-kicker{
    font-size:12px;letter-spacing:.16em;text-transform:uppercase;
    color:var(--accent-purple);margin-bottom:8px;
  }
  .panel-title{
    font-size:clamp(22px,2.2vw,28px);
    font-weight:900;letter-spacing:-.01em;line-height:1.12;
  }
  .panel-sub{margin-top:8px;max-width:900px;color:var(--text-muted);font-size:14px;line-height:1.6}

  .panel-actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;align-items:center}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    font-size:12px;padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:var(--text-muted);
    white-space:nowrap;
  }

  .grid-2{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1fr);gap:12px;margin-top:14px}

  .card{
    background:var(--card-bg);
    border-radius:var(--radius-lg);
    border:1px solid var(--border-subtle);
    padding:14px;
    box-shadow:var(--shadow-soft);
    backdrop-filter:blur(18px);
    min-width:0;
  }
    /* TX Events: make event rows look like premium pills */
#panel-tx #tx-events .card .mono{
  display:block;
  padding:8px 10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
  margin-top:12px;

  white-space:normal;          /* allow wrap */
  overflow-wrap:anywhere;
  line-height:1.25;
}

/* Slightly dim the "raw" part so it doesn't dominate */
#panel-tx #tx-events .card .mono .muted{
  opacity:.85;
}

/* Mobile: keep pills readable */
@media (max-width:640px){
  #panel-tx #tx-events .card .mono{
    padding:9px 11px;
  }
}

  .card h3{font-size:14px;letter-spacing:.02em;margin-bottom:8px;color:var(--text-main)}

  .field{margin-top:10px}
  .label{font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:rgba(244,246,255,.75);margin-bottom:6px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

  input,textarea,select{
    width:100%;
    padding:10px 12px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(5,7,18,.9);
    color:var(--text-main);
    font-size:13px;
    outline:none;
  }
  textarea{border-radius:18px;min-height:96px;resize:vertical;padding:12px 12px}
  input:focus,textarea:focus,select:focus{border-color:var(--accent-cyan)}

  .toggle{
    display:flex;align-items:center;gap:10px;
    padding:10px 12px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04);
    border-radius:14px;
    user-select:none;
    width:100%;
  }
  .toggle input{width:auto;accent-color:var(--accent-cyan)}

  .status{
    margin-top:10px;
    padding:12px 14px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    color:var(--text-main);
    line-height:1.5;
    font-size:13px;
    display:none;
    overflow-wrap:anywhere;
  }
  .status.ok{display:block;background:rgba(0,230,118,.10);border-color:rgba(0,230,118,.35);color:#78ffbf}
  .status.warn{display:block;background:rgba(255,193,7,.10);border-color:rgba(255,193,7,.35);color:#ffd166}
  .status.bad{display:block;background:rgba(220,53,69,.10);border-color:rgba(220,53,69,.35);color:#ff7a8a}
  .status.info{display:block;background:rgba(0,229,255,.10);border-color:rgba(0,229,255,.30);color:#7df2ff}
/* =========================
   TX DECODER — 4-line Security Summary (BADGES)  [FINAL ALIGN]
   ========================= */

#panel-tx .tx-sum{
  display:grid;
  grid-template-columns: 1fr;
  gap:10px;
  padding:12px;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.04);
  box-shadow:0 18px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
  backdrop-filter:blur(16px);
}

/* line layout: label | value-column (value-column is capped so it sits closer to label) */
#panel-tx .tx-sum-line{
  display:grid;
  grid-template-columns: 85px minmax(0, clamp(240px, 42vw, 480px)) !important;
  justify-content:start;   
  align-items:center;
  column-gap:10px;
  row-gap:6px;

  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  min-width:0;
}
#panel-tx .tx-sum .tx-sum-line:first-child .v{
  white-space:normal !important;
  overflow-wrap:anywhere;
  word-break:break-word;

  max-width:100%;
  overflow:hidden;          
  text-overflow:clip;      
  line-height:1.15;
}


#panel-tx .tx-sum-line .k{
  font-size:12px;
  letter-spacing:.10em;
  text-transform:uppercase;
  color:rgba(244,246,255,.72);
  white-space:nowrap;
}

/* ✅ The badge: stays inside the capped column, aligned right, and never paints the whole row */
#panel-tx .tx-sum-line .v{
  justify-self:end;        
  max-width:100%;
  min-width:0;
  box-sizing:border-box;

  display:inline-flex;
  align-items:center;
  gap:8px;

  font-size:12px;
  font-weight:800;
  letter-spacing:.02em;

  padding:7px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  color:rgba(244,246,255,.92);

  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* Dot inside badge */
#panel-tx .tx-sum-line .v .dot{
  width:10px;
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,.25);
  box-shadow:0 0 0 3px rgba(255,255,255,.06);
  flex:0 0 auto;
}

/* States (ONLY the badge is colored) */
#panel-tx .tx-sum-line .v.ok{
  border-color:rgba(0,230,118,.28);
  background:rgba(0,230,118,.10);
}
#panel-tx .tx-sum-line .v.ok .dot{ background:rgba(0,230,118,.95); }

#panel-tx .tx-sum-line .v.warn{
  border-color:rgba(255,193,7,.30);
  background:rgba(255,193,7,.10);
}
#panel-tx .tx-sum-line .v.warn .dot{ background:rgba(255,193,7,.95); }

#panel-tx .tx-sum-line .v.bad{
  border-color:rgba(220,53,69,.30);
  background:rgba(220,53,69,.12);
}
#panel-tx .tx-sum-line .v.bad .dot{ background:rgba(220,53,69,.95); }

#panel-tx .tx-sum-line .v.unk{
  border-color:rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  color:rgba(244,246,255,.78);
}
#panel-tx .tx-sum-line .v.unk .dot{ background:rgba(255,255,255,.25); }

/* Subline under the badge (aligned with badge column) */
#panel-tx .tx-sum-line .tx-sum-sub{
  grid-column:2;
  justify-self:end;
  max-width:100%;
  min-width:0;

  margin-top:2px;
  text-align:right;

  font-size:12px;
  line-height:1.25;
  color:rgba(244,246,255,.62);

  white-space:normal;
  overflow-wrap:anywhere;
  word-break:break-word;
}

/* Action: keep LTR so it truncates nicely (no weird left-cut) */
#tx-sum-action .v{
  direction:ltr;
  unicode-bidi:plaintext;
}

/* Mobile */
@media (max-width:640px){
  #panel-tx .tx-sum-line{
    grid-template-columns: 1fr;
    justify-content:stretch;
    row-gap:8px;
    align-items:start;
  }
  #panel-tx .tx-sum-line .v{
    justify-self:start !important;
    max-width:100%;
  }
  #panel-tx .tx-sum-line .tx-sum-sub{
    grid-column:1;
    justify-self:start;
    text-align:left;
  }
}


    /* Bookmarklet tip under the green status */
.bm-tip{
  margin-top:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  color:rgba(244,246,255,.78);
  font-size:13px;
  line-height:1.45;
}
    /* Drag-to-bookmarks bookmarklet link */
.bm-drag{
  display:flex;
  align-items:center;
  gap:10px;
  padding:12px 14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.05);
  box-shadow:0 14px 40px rgba(0,0,0,.35);
  cursor:grab;
  user-select:none;
  margin-top:10px;
  font-weight:900;
  letter-spacing:.04em;
  text-transform:none;
  width:100%;
}
    /* icon inside the drag-to-bookmarks button */
.bm-drag-icon{
  width:28px;
  height:28px;
  border-radius:10px;
  object-fit:contain;
  flex:0 0 auto;
  box-shadow:0 10px 26px rgba(0,0,0,.35);
}

/* keep the label clean */
.bm-drag span{
  line-height:1;
  min-width:0;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* make sure link doesn't look like a normal link */
#bm-drag{
  text-decoration:none;
  color:inherit;
}

/* optional: nicer hover */
#bm-drag:hover{
  border-color:rgba(0,229,255,.22);
  background:rgba(255,255,255,.07);
  transform:translateY(-1px);
}

.bm-drag:active{ cursor:grabbing; }
.bm-drag.hidden{ display:none; }

  /* =========================
     TABLES — merged in from the "old code" that fixed spacing/readability
     What you asked to carry over:
     ✅ proper cell ellipsis
     ✅ RPC table special grid + 2-line clamp (URL + status)
     ✅ numeric/icon columns centered
     ✅ highlight row style
     ========================= */

  /* generic table shell (keep your look) */
  .table{
    margin-top:10px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    overflow: hidden;                 /* from old code (clean corners) */
    background:rgba(255,255,255,.03);
  }
    /* =========================
   QuickScan — Liquidity table (FORCE wrap + compact rows)
   Target: table rendered inside #qs-liq-tablewrap
   ========================= */

#qs-liq-tablewrap .table .trow.head,
#qs-liq-tablewrap .table .trow{
  /* give RESULT more room */
  grid-template-columns: 1.15fr .75fr .75fr 2.6fr;
  gap: 10px;
}

/* reduce row height a bit */
#qs-liq-tablewrap .table .trow{
  padding: 8px 10px;
}

/* ✅ IMPORTANT: override your global "nowrap + ellipsis" for RESULT column only */
#qs-liq-tablewrap .table .trow .cell:nth-child(4){
  white-space: normal !important;
  overflow: hidden !important;
  text-overflow: clip !important;
  overflow-wrap: anywhere !important;
  line-height: 1.15;
  font-size: 12px;

  /* optional: clamp to 3 lines so it doesn't get tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
}

/* if result uses .sig (your pill), it forces nowrap — cancel it here */
#qs-liq-tablewrap .table .trow .cell:nth-child(4) .sig{
  white-space: normal !important;
  display: block !important;   /* lets it wrap nicely */
}

/* if result uses .mono inside, cancel nowrap too */
#qs-liq-tablewrap .table .trow .cell:nth-child(4) .mono{
  white-space: normal !important;
}

/* on medium screens, your global .trow min-width can break layout — disable for this table */
@media (max-width:980px){
  #qs-liq-tablewrap .table .trow{ min-width: 0 !important; }
}


/* keep head centered, rows top-aligned like your earlier fix */
#qsLiqTable .trow{ align-items: start; }
#qsLiqTable .trow.head{ align-items: center; }

/* result column: allow wrap + compact typography so it stays inside */
#qsLiqTable .trow .cell:nth-child(4),
#qs-liq-tablewrap .table .trow .cell:nth-child(4){
  white-space: normal;
  overflow: hidden;
  text-overflow: clip;
  overflow-wrap: anywhere;
  line-height: 1.18;
  font-size: 12px;
  font-family: var(--mono);
  font-variant-numeric: tabular-nums;

  /* keep it from becoming too tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4;
}

/* Pair/Pool column stays mono + tidy */
#qsLiqTable .trow .cell:nth-child(1){
  font-family: var(--mono);
}

/* on medium screens your global .trow gets min-width:560px (causes weird layout)
   cancel it only for this table */
@media (max-width:980px){
  #qsLiqTable .trow{ min-width: 0 !important; }
}

    /* ===== DNA approvals table: stronger frame + clearer row separation ===== */
#ap-table.table{
  border-color: rgba(242,211,138,.30) !important;            /* gold-ish like DNA */
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08),         /* inner frame */
              0 18px 40px rgba(0,0,0,.25) !important;        /* soft lift */
}

#ap-table .trow{
  border-top: 1px solid rgba(255,255,255,.14) !important;    /* clearer separators */
}

#ap-table .trow.head{
  background: rgba(255,255,255,.06) !important;              /* stronger header bar */
  border-bottom: 1px solid rgba(255,255,255,.14) !important; /* makes it feel “one table” */
}


  /* generic rows */
  .trow{
    display:grid;
    grid-template-columns:1.3fr 1.1fr .9fr .9fr;
    gap:10px;
    padding:10px 12px;
    border-top:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
    align-items:center;
    font-size:13px;
  }
  .trow.head{
    border-top:none;
    background:rgba(255,255,255,.05);
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:rgba(244,246,255,.75);
  }

  /* generic cells (from old code) */
  .trow .cell{
    min-width:0;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  /* optional wrapping cell */
  .trow .cell.wrap{
    white-space:normal;
    text-overflow:clip;
    overflow:hidden;
    overflow-wrap:anywhere;
  }
    /* =========================
   Wallet Security DNA — Approvals table (A)
   Flags go to a second full-width row
   ========================= */

/* Desktop: 7 columns (Token, Spender, Allowance, Verified, Last Updated, Risk, Action) */
#ap-table .trow.head,
#ap-table .trow.ap-main{
  grid-template-columns: 1.15fr 1.15fr 1.35fr .95fr 1.25fr .75fr .75fr;
}

/* Mobile/Tablet: hide-sm disappears => 4 columns (Token, Allowance, Risk, Action) */
@media (max-width: 980px){
  #ap-table .trow.head,
  #ap-table .trow.ap-main{
    grid-template-columns: 1.25fr 1.35fr .75fr .75fr;
  }
}

/* Flags row: single column full-width, nice wrapping */
#ap-table .trow.ap-flags-row{
  grid-template-columns: 1fr;
  padding-top: 8px;
  padding-bottom: 12px;
  background: rgba(255,255,255,.02);
}

#ap-table .ap-flags-cell{
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.25;
  font-size: 12px;
  color: rgba(244,246,255,.78);
}


    /* =========================
   Contract Monitor (mon-table) — add inline X button column
   No "Remove" header text, just an empty last cell like screenshot
   ========================= */

/* Desktop / default: 5th column reserved for X */
#mon-table .trow,
#mon-table .trow.head{
  grid-template-columns: 1.35fr 1fr 1.05fr 1fr 44px;
}
    /* ✅ MON: Last seen should wrap to 2 lines (no ellipsis) */
#mon-table .trow .cell:nth-child(3){
  white-space: normal;
  text-overflow: clip;
  overflow: hidden;
  overflow-wrap: anywhere;
  line-height: 1.15;

  /* optional: limit to 2 lines so row doesn't get too tall */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}


#mon-table .trow.head .cell:last-child{
  visibility:hidden;  /* stays in layout, but truly invisible */
}
    
/* Small clean X (no weird circle) */
.mon-remove{
  width:22px;
  height:22px;
  padding:0;
  margin:0;

  border:none;
  background:transparent;
  box-shadow:none;

  color:rgba(244,246,255,.70);
  cursor:pointer;
  user-select:none;

  line-height:1;
  font-size:18px;
  font-weight:900;

  display:inline-flex;
  align-items:center;
  justify-content:center;

  transition:transform var(--transition-fast), color var(--transition-fast), opacity var(--transition-fast);
  opacity:.9;
}

.mon-remove:hover{
  opacity:1;
  color:rgba(255,120,138,.95);  /* red-ish but subtle */
  transform:translateY(-1px);
}

.mon-remove:active{
  transform:translateY(0);
}


.mon-remove:focus-visible{
  outline:2px solid rgba(0,229,255,.55);
  outline-offset:2px;
}
/* =========================
   RPC Results — Card rows (B)
   No horizontal scroll. Domain on top, metrics in one compact line.
   ========================= */

#rpc-table{
  overflow-x:hidden;   /* ✅ no swipe */
  overflow-y:hidden;
}

/* header */
#rpc-table .trow.head.rpc{
  display:grid;
  grid-template-columns: 1fr 240px 120px; /* RPC | Metrics | Status */
  gap:12px;
  align-items:center;
}

/* each result row becomes a 2-line "card" */
#rpc-table .trow.rpc{
  display:grid;
  grid-template-columns: 1fr auto; /* top row: RPC left, status right */
  grid-template-rows: auto auto;   /* row 1: rpc+status | row 2: meta */
  gap:10px 12px;
  align-items:center;

  padding:12px 12px;
  border-top:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
}

/* RPC cell (top-left) */
#rpc-table .rpc-url{
  grid-column:1;
  grid-row:1;
  min-width:0;
}

#rpc-table .rpc-url .rpc-host{
  font-weight:900;
  letter-spacing:.01em;
  color:rgba(244,246,255,.92);
  line-height:1.15;
}

#rpc-table .rpc-url .rpc-full{
  margin-top:6px;
  color:rgba(244,246,255,.62);
  line-height:1.15;

  /* allow up to 3 lines */
  display:-webkit-box;
  -webkit-box-orient:vertical;
  -webkit-line-clamp:3;
  overflow:hidden;
  overflow-wrap:anywhere;

  direction:ltr;
  unicode-bidi:plaintext;
}

/* STATUS (top-right) */
#rpc-table .rpc-status{
  grid-column:2;
  grid-row:1;
  justify-self:end;
  white-space:nowrap;
}

/* META line (bottom full width) */
#rpc-table .rpc-meta{
  grid-column:1 / -1;
  grid-row:2;

  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:center;

  color:rgba(244,246,255,.85);
  font-size:12px;
}

/* compact metric pills */
#rpc-table .m{
  display:inline-flex;
  align-items:center;
  gap:8px;

  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);

  white-space:nowrap;
}

#rpc-table .m b{
  font-weight:900;
  color:rgba(244,246,255,.92);
}



/* Responsive: tighter header */
@media (max-width:980px){
  #rpc-table .trow.head.rpc{
    grid-template-columns: 1fr 140px; /* RPC | Status */
  }
  #rpc-table .trow.head.rpc .cell:nth-child(2){ display:none; } /* hide "Metrics" header label */
}

/* Small screens: status under host if needed */
@media (max-width:640px){
  #rpc-table .trow.rpc{
    grid-template-columns: 1fr; /* stack */
  }
  #rpc-table .rpc-status{
    grid-column:1;
    justify-self:start;
  }
}
  /* keep highlight style */
  .trow.highlight{
    background:rgba(0,230,118,.10);
    border-top-color:rgba(0,230,118,.20);
  }

  /* chips */
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.88);
    cursor:pointer;user-select:none;
    transition:transform var(--transition-fast), border-color var(--transition-fast);
    font-size:12px;
  }
  .chip:hover{transform:translateY(-1px);border-color:rgba(0,229,255,.26)}
  .chip-danger{border-color:rgba(255,80,80,.25);background:rgba(255,80,80,.08)}
  .chip-danger:hover{border-color:rgba(255,80,80,.45);transform:translateY(-1px)}
  .share-row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}

  /* QuickScan actions */
  #panel-quick .row.qs-actions,
  #panel-quick .qs-share{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:10px;
    align-items:stretch;
  }
  #panel-quick .qs-share{margin-top:12px}
  #panel-quick .qs-actions .btn,
  #panel-quick .qs-share .btn{
    width:100%;
    min-width:0;
    padding:12px 14px;
    font-size:12px;
    letter-spacing:.03em;
    white-space:normal;
    line-height:1.15;
    min-height:44px;
    overflow:hidden;text-overflow:ellipsis;
  }
  #panel-quick .qs-actions #qs-run{grid-column:1/-1}
  #panel-quick .qs-actions #qs-copy-md{grid-column:1/-1}
  #panel-quick .qs-share #qs-copy-xtext{grid-column:1/-1}

  @media (min-width:1280px){
    #panel-quick .row.qs-actions{grid-template-columns:repeat(4,minmax(0,1fr))}
    #panel-quick .qs-actions #qs-run,
    #panel-quick .qs-actions #qs-copy-md{grid-column:auto}
    #panel-quick .qs-share{grid-template-columns:repeat(3,minmax(0,1fr))}
    #panel-quick .qs-share #qs-copy-xtext{grid-column:auto}
  }
   
  /* QuickScan risk table */
  #qs-riskTable{margin-top:12px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}
  #qs-riskTable .trow.head.risk,
  #qs-riskTable .trow.risk{
    display:grid;
    grid-template-columns:.95fr .95fr .95fr .95fr .95fr .95fr .85fr 1.5fr;
    gap:10px;padding:10px 12px;align-items:center;min-width:980px;
  }
  #qs-riskTable .trow.head.risk{
    background:rgba(255,255,255,.05);
    font-size:12px;letter-spacing:.08em;text-transform:uppercase;
    color:rgba(244,246,255,.75);
    border-top:none;
  }
  #qs-riskTable .trow.risk{background:rgba(255,255,255,.03);border-top:1px solid rgba(255,255,255,.10)}
  #qs-riskTable .cell{min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  #qs-riskTable .cell:not(:last-child){text-align:center;justify-self:center}
  #qs-riskTable .cell:last-child{
    text-align:left;white-space:normal;overflow-wrap:anywhere;line-height:1.15;
    display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3;
  }

  /* signals (QuickScan top row UI) */
  .sig{
    display:inline-flex;align-items:center;justify-content:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    color:rgba(244,246,255,.92);
    font-size:12px;white-space:nowrap;
  }
  .sig .dot{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.25);box-shadow:0 0 0 3px rgba(255,255,255,.06)}
  .sig.ok{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .sig.ok .dot{background:rgba(0,230,118,.95)}
  .sig.warn{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .sig.warn .dot{background:rgba(255,193,7,.95)}
  .sig.bad{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}
  .sig.bad .dot{background:rgba(220,53,69,.95)}
  .sig.unk{border-color:rgba(255,255,255,.10);background:rgba(255,255,255,.04);color:rgba(244,246,255,.75)}
  .sig.unk .dot{background:rgba(255,255,255,.25)}

  .qs-scoreRow{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:10px}
  .score-pill{
    display:inline-flex;align-items:center;gap:10px;
    padding:8px 12px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05);
    font-size:12px;color:rgba(244,246,255,.92);
  }
  .score-pill strong{font-weight:900;letter-spacing:.02em}
  .score-pill.low{border-color:rgba(0,230,118,.25);background:rgba(0,230,118,.08)}
  .score-pill.med{border-color:rgba(255,193,7,.25);background:rgba(255,193,7,.08)}
  .score-pill.high{border-color:rgba(220,53,69,.25);background:rgba(220,53,69,.10)}

  .flags-box{
    margin-top:10px;padding:12px 14px;border-radius:16px;
    border:1px solid rgba(255,193,7,.25);
    background:rgba(255,193,7,.08);
    color:#ffd166;font-size:13px;line-height:1.45;display:none;
  }
  .flags-box ul{margin-top:8px;padding-left:18px}
  .flags-box li{margin:4px 0}
  .qs-disclaimer{margin-top:10px;font-size:12px;color:var(--text-muted);line-height:1.45}

  /* Bookmarklet help */
  .h3-row{display:flex;align-items:center;gap:10px}
  .h3-row img{width:22px;height:22px;border-radius:8px;box-shadow:0 10px 24px rgba(0,0,0,.6)}
  .help-box{
    margin-top:10px;padding:12px 14px;border-radius:16px;
    border:1px solid rgba(0,229,255,.20);
    background:rgba(0,229,255,.08);
    color:#7df2ff;font-size:13px;line-height:1.45;display:none;
  }
  .help-box ol{margin-top:8px;padding-left:18px}
  .help-box li{margin:4px 0}

  /* Footer */
  .footer{
    border-top:1px solid rgba(255,255,255,.06);
    margin-top:20px;padding-top:16px;
    display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:10px;
    font-size:12px;color:var(--text-muted);
  }
  .footer-tagline{color:var(--accent-cyan);font-weight:700}

  /* RTL */
  html[dir="rtl"] body{direction:rtl}
  html[dir="rtl"] .top-bar{flex-direction:row-reverse}
  html[dir="rtl"] .brand{flex-direction:row-reverse}
  html[dir="rtl"] .panel-head{flex-direction:row-reverse}
  html[dir="rtl"] .row{flex-direction:row-reverse}
  html[dir="rtl"] .panel-actions{justify-content:flex-start}

  /* ✅ responsive */
  @media (max-width:980px){
    .grid-2{grid-template-columns:1fr}
    .hide-sm{display:none!important}

    .tool-grid{grid-template-columns:repeat(2, minmax(0, 1fr))}

    /* generic table swipe width on medium screens */
    #qs-riskTable .trow{ min-width:560px; }

    #mon-table .trow,
#mon-table .trow.head{
  grid-template-columns:1.7fr 1fr 1fr 44px; /* contract | net | status | X */
  min-width:520px;
}

  }

  @media (max-width:640px){
    .top-bar{top:10px;padding:10px 12px}
    .brand-logo{width:40px;height:40px;border-radius:14px}
    .btn{padding:12px 18px;font-size:13px}

    .tool-grid{grid-template-columns:1fr; gap:14px}
  }
    /* ===== CycleX — Wallet Security DNA (SAFE PATCH) ===== */

/* DNA cube: subtle gold frame + glow */
a.tool-card[data-tool="approvals"]{
  border-color: rgba(242,211,138,.42) !important;
  background: linear-gradient(165deg, rgba(242,211,138,.06), rgba(255,255,255,.04)) !important;
  box-shadow:
    0 20px 55px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 0 2px rgba(242,211,138,.22),
    0 0 28px rgba(242,211,138,.20) !important;
}
/* Wallet DNA cube — make subtitle a bit more prominent (ONLY this cube) */
a.tool-card[data-tool="approvals"] .tool-desc{
  font-size: 15px !important;
  font-weight: 700 !important;
  color: rgba(244,246,255,.86) !important;
  letter-spacing: .01em !important;
  text-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
  margin-top: 2px !important;
}
    /* ===== DNA table: Verified / Unverified colors (ONLY in approvals table) ===== */
#ap-table .chip.chip-ok{
  border-color: rgba(0,230,118,.32) !important;
  background: rgba(0,230,118,.12) !important;
  color: #a8ffd5 !important;
}

/* In DNA you currently output Unverified as chip-warn → make it RED only here */
#ap-table .chip.chip-warn{
  border-color: rgba(220,53,69,.34) !important;
  background: rgba(220,53,69,.14) !important;
  color: #ffb3bd !important;
}



/* Optional: tiny spacing so it breathes under the title */
.tool-card[data-tool="approvals"] .tool-desc{
  margin-top: 2px !important;
}

a.tool-card[data-tool="approvals"]::before{
  background:
    radial-gradient(520px 180px at 18% -5%, rgba(242,211,138,.16), transparent 62%),
    radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.14), transparent 62%) !important;
}
    /* DNA cube — top light hit (premium highlight) */
a.tool-card[data-tool="approvals"]{
  position: relative; /* safe, for ::after */
}

a.tool-card[data-tool="approvals"]::after{
  content:"";
  position:absolute;
  left:10px;
  right:10px;
  top:10px;
  height:46px;
  border-radius:18px;
  pointer-events:none;

  /* subtle "light hit" only on top */
  background: linear-gradient(
    180deg,
    rgba(255,255,255,.14),
    rgba(242,211,138,.10) 45%,
    rgba(255,255,255,0) 100%
  );

  /* keeps it premium, not loud */
  opacity:.75;
  mix-blend-mode: screen;
}



/* DNA panel: subtle gold outline */
#panel-approvals.panel-shell,
#panel-approvals{
  border-color: rgba(242,211,138,.30) !important;
  box-shadow:
    0 26px 70px rgba(0,0,0,.60),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 0 1px rgba(242,211,138,.16),
    0 0 34px rgba(242,211,138,.14) !important;
}

/* Score/Risk pills (hooks) */
#dna-score,
#dna-risk{
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  padding: 7px 11px !important;
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.05) !important;
  color: rgba(244,246,255,.92) !important;
  font-size: 12px !important;
  font-weight: 800 !important;
  letter-spacing: .02em !important;
  white-space: nowrap !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05) !important;
}


/* Color states (only if classes exist) */
#dna-score.score-low,  #dna-score.score-ok,
#dna-risk.risk-low,    #dna-risk.risk-ok{
  border-color: rgba(0,230,118,.28) !important;
  background: rgba(0,230,118,.10) !important;
  color: #a8ffd5 !important;
}

#dna-score.score-med,  #dna-score.score-warn,
#dna-risk.risk-med,    #dna-risk.risk-warn{
  border-color: rgba(255,193,7,.30) !important;
  background: rgba(255,193,7,.10) !important;
  color: #ffe29a !important;
}

#dna-score.score-high, #dna-score.score-bad,
#dna-risk.risk-high,   #dna-risk.risk-bad{
  border-color: rgba(220,53,69,.30) !important;
  background: rgba(220,53,69,.12) !important;
  color: #ffb3bd !important;
}

#dna-score.score-unk,
#dna-risk.risk-unk{
  opacity: .88 !important;
}

/* DNA approvals table: card rows */
#ap-table .trow{
  display: grid !important;
  grid-template-columns: 1fr auto !important;
  grid-template-rows: auto auto !important;
  gap: 10px 12px !important;
  align-items: center !important;
  padding: 12px 12px !important;
  min-width: 0 !important;
}

#ap-table .trow.head{
  display: grid !important;
  grid-template-columns: 1fr auto !important;
  padding: 10px 12px !important;
  min-width: 0 !important;
}

#ap-table .ap-main{ grid-column: 1; grid-row: 1; min-width: 0; }
#ap-table .ap-actions{
  grid-column: 2; grid-row: 1;
  justify-self: end;
  display: flex;
  gap: 10px;
  align-items: center;
  white-space: nowrap;
}
#ap-table .ap-meta{
  grid-column: 1 / -1; grid-row: 2;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  color: rgba(244,246,255,.78);
  font-size: 12px;
}

#ap-table .ap-sub{
  margin-top: 6px;
  color: rgba(244,246,255,.62);
  line-height: 1.15;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}
#ap-table .ap-sub .m{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  white-space: nowrap;
}


/* ===== DNA: lock Score/Risk position (no wrap jump) ===== */
/*#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child{
  flex-wrap: nowrap !important;
  align-items: flex-start !important;
}*/

/*#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row{
  margin-left: auto !important;
  flex-wrap: nowrap !important;
  justify-content: flex-end !important;
  align-items: center !important;
}*/

#panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row .pill{
  flex: 0 0 auto !important;
}
    /* Mobile fix: long connected address shouldn't shift layout */
#dna-address,
#dna-wallet,
#dna-status .mono{
  max-width:100%;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
     /* =========================
   DNA – small, controlled tweaks
   ========================= */

/* Tips: same size, just bold */
#panel-approvals #dna-tips li{
  font-weight: 700;
}
/* Meta line above tips (Approvals detected...) */
#panel-approvals #dna-tips .dna-meta{
  opacity: .92;
  font-size: .95em;
  letter-spacing: .2px;
  list-style: none; /* no bullet for meta */
  margin-bottom: .25rem;
}

/* Keep meta not as bold as tips */
#panel-approvals #dna-tips .dna-meta{
  font-weight: 600;
}

#panel-approvals #dna-tips .dna-meta .k{ opacity: .85; }
#panel-approvals #dna-tips .dna-meta .sep{ margin: 0 .45em; opacity: .55; }
#panel-approvals #dna-tips .dna-meta .dna-meta-count{ font-weight: 800; }


/* Locked card: slightly clearer + bolder, tiny size bump */
#panel-approvals #dna-approvals-locked .small{
  font-weight: 650;
  line-height: 1.55;
  font-size: 14.5px; /* ממש טיפה */
}

/* spacing between lines in the locked card */
#panel-approvals #dna-approvals-locked .small + .small{
  margin-top: 8px;
}

/* Eligibility message line */
#panel-approvals #dna-elig-msg{
  margin-top: 10px;
  font-weight: 800;
  font-size: 14.5px;
}

/* Red / Green states */
#panel-approvals #dna-elig-msg.elig-ok{ color: var(--green) !important; }
#panel-approvals #dna-elig-msg.elig-bad{ color: #ff6a6a !important; }
#panel-approvals #dna-elig-msg.elig-warn{ color: #ffd36a !important; }
.hidden{ display:none !important; }
     
@media (min-width: 901px){
  html{ zoom: 1.10; }
  html, body{ overflow-x: hidden; }

  /* =========================================================
     DESKTOP ONLY — Equal action buttons in tool panels
     ========================================================= */

  /* בסיס: יישור אנכי */
  #panel-dev .row,
  #panel-tx .row,
  #panel-liq .row,
  #panel-rpc .row,
  #panel-dna .row{
    align-items: stretch;
  }

  /* =========================================================
     DEV TOOLS
     ========================================================= */
  #panel-dev #bm-generate,
  #panel-dev #bm-copy{
    flex: 1 1 0 !important;
    width: calc(50% - 5px) !important;
    max-width: calc(50% - 5px) !important;
    min-width: 0 !important;
  }

  #panel-dev #mon-add,
  #panel-dev #mon-check,
  #panel-dev #mon-copy{
    flex: 1 1 0 !important;
    width: calc((100% - 20px)/3) !important;
    max-width: calc((100% - 20px)/3) !important;
    min-width: 0 !important;
  }

  /* =========================================================
     TX DECODER
     ========================================================= */
  #panel-tx .tx-actions,
  #panel-tx .row:has(#tx-decode),
  #panel-tx .row:has(#btn-tx-decode),
  #panel-tx .row:has(#tx-run),
  #panel-tx .row:has(#tx-copy-md),
  #panel-tx .row:has(#btn-tx-copy),
  #panel-tx .row:has(#tx-copy-markdown){
    display: flex !important;
    flex-wrap: nowrap !important;
    gap: 10px !important;
    align-items: stretch !important;
  }

  #panel-tx #tx-decode,
  #panel-tx #btn-tx-decode,
  #panel-tx #tx-run,
  #panel-tx [data-action="tx-decode"],
  #panel-tx [data-action="decode-tx"],
  #panel-tx #tx-copy-md,
  #panel-tx #btn-tx-copy,
  #panel-tx #tx-copy-markdown,
  #panel-tx [data-action="tx-copy-markdown"],
  #panel-tx [data-action="copy-markdown"]{
    flex: 1 1 0 !important;
    width: calc(50% - 5px) !important;
    max-width: calc(50% - 5px) !important;
    min-width: 0 !important;
  }

  /* =========================================================
     LIQUIDITY
     ========================================================= */
  #panel-liq #liq-run,
  #panel-liq #liq-copy-link,
  #panel-liq #liq-share-x{
    flex: 1 1 0 !important;
    width: calc((100% - 20px)/3) !important;
    max-width: calc((100% - 20px)/3) !important;
    min-width: 0 !important;
  }

  /* =========================================================
     RPC — TEST / COPY BEST / SHARE X on one row
     ========================================================= */
  #panel-rpc .row:has(#rpc-test):has(#rpc-copy-best),
  #panel-rpc .row:has(#rpc-test):has(#rpc-share-x),
  #panel-rpc .row:has(#rpc-copy-best):has(#rpc-share-x),
  #panel-rpc :is(.row,.actions,.btn-row,.controls,div):has(> #rpc-test):has(> #rpc-copy-best):has(> #rpc-share-x){
    display: flex !important;
    flex-wrap: nowrap !important;
    gap: 10px !important;
    align-items: stretch !important;
  }

  #panel-rpc #rpc-test,
  #panel-rpc #rpc-copy-best,
  #panel-rpc #rpc-share-x{
    flex: 1 1 0 !important;
    width: calc((100% - 20px)/3) !important;
    max-width: calc((100% - 20px)/3) !important;
    min-width: 0 !important;
    margin: 0 !important;
  }

}


 /* =========================
   ACCESS MODAL (PASS / CYCX) — Premium centered
   ========================= */
.cx-modal{
  position: fixed;
  inset: 0;
  display: none;
  z-index: 9999;

  /* ✅ always center dialog in viewport */
  align-items: center;
  justify-content: center;

  padding: 22px;
}

.cx-modal.is-open{ display: flex; }

.cx-modal__backdrop{
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.42);
  backdrop-filter: blur(7px);
}

/* ✅ Bigger, solid, premium */
.cx-modal__dialog{
  position: relative;
  z-index: 1;

  width: min(860px, 100%);
  border-radius: 26px;

  /* slightly lighter, still premium */
  background: #13213a;

  border: 1px solid rgba(255,255,255,.14);
  box-shadow:
    0 26px 92px rgba(0,0,0,.44),
    0 0 0 1px rgba(255,255,255,.07) inset;

  overflow: hidden;
}


/* Top bar */
.cx-modal__top{
  display: flex;
  align-items: center;
  justify-content: space-between;

  padding: 18px 20px;
  border-bottom: 1px solid rgba(255,255,255,.10);

  background: rgba(255,255,255,.03);
}

.cx-modal__title{
  font-weight: 900;
  letter-spacing: .3px;
  font-size: 18px;
}

.cx-modal__close{
  border: 0;
  background: rgba(255,255,255,.08);
  color: rgba(255,255,255,.92);

  width: 42px;
  height: 42px;
  border-radius: 14px;
  cursor: pointer;
}

.cx-modal__close:hover{
  background: rgba(255,255,255,.14);
}

/* Body — more space + scroll if long */
.cx-modal__body{
  padding: 20px 20px 22px;
  max-height: min(72vh, 760px);
  overflow: auto;
}

.cx-modal__desc{
  line-height: 1.65;
  font-size: 16px;
  color: rgba(255,255,255,.92);
}

/* Note box */
.cx-modal__note{
  margin-top: 14px;
  padding: 12px 14px;
  border-radius: 16px;

  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.12);

  font-size: 14px;
  line-height: 1.55;
  color: rgba(255,255,255,.88);
}

/* Buttons row */
.cx-modal__actions{
  display: flex;
  gap: 12px;
  margin-top: 18px;
  flex-wrap: wrap;
}

.cx-modal__actions .btn{
  flex: 1 1 260px;
  justify-content: center;
  min-height: 54px;
  font-weight: 800;
  letter-spacing: .2px;
}

/* Footer */
.cx-modal__foot{
  margin-top: 14px;
  font-size: 13.5px;
  line-height: 1.45;
  color: rgba(255,255,255,.72);
}

/* Mobile refinement */
@media (max-width: 520px){
  .cx-modal{ padding: 14px; }
  .cx-modal__title{ font-size: 16px; }
  .cx-modal__actions .btn{ flex-basis: 100%; }
}
/* ✅ Center + make price inside the buttons */
.cx-modal__actions{
  display:flex;
  gap: 14px;
  justify-content: center;
  align-items: stretch;
  flex-wrap: wrap;
}

.cx-modal__actions .btn{
  flex: 0 1 360px;
  min-height: 74px;
  padding: 16px 18px;
  display:flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align:center;
}

.cx-modal__actions .btn .btn-main{
  font-weight: 900;
  letter-spacing: .6px;
}

.cx-modal__actions .btn .btn-sub{
  margin-top: 8px;
  font-size: 13px;
  font-weight: 700;
  opacity: .85;
}

/* ✅ BNB orange / coin vibe */
#access-modal #btn-pay-bnb{
  background: linear-gradient(135deg, #f3ba2f 0%, #ff8a00 100%);
  color: #061018;
  border: 1px solid rgba(255,255,255,.12);
}

#access-modal #btn-pay-bnb:hover{
  filter: brightness(1.02);
}

#access-modal #btn-pay-bnb:disabled{
  opacity: .78;
}
     .cx-modal__actions .btn.is-busy{
  opacity:.75;
  cursor:progress;
  filter:saturate(.9);
}
     .cx-modal__status{
  margin-top: 12px;
  font-size: 13px;
  opacity: .85;
  text-align: center;
}
/* ===== SAFE BACKGROUND OVERRIDE ===== */
html{ background:#05060a !important; }

body{
  background:
    radial-gradient(1200px 720px at 14% 10%, rgba(124,92,255,.18), transparent 58%),
    radial-gradient(1200px 720px at 86% 12%, rgba(0,229,255,.16), transparent 56%),
    radial-gradient(980px 680px at 55% 120%, rgba(0,58,76,.40), transparent 62%),
    linear-gradient(160deg, #05060a, #0b0a18, #021b24) !important;
  background-repeat:no-repeat !important;
  background-attachment:fixed !important;
  background-size:cover !important;
}

body::before{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background:
    radial-gradient(740px 640px at 20% 14%, rgba(0,229,255,.12), transparent 60%),
    radial-gradient(940px 780px at 78% 18%, rgba(124,92,255,.11), transparent 62%),
    radial-gradient(820px 700px at 52% 78%, rgba(93,255,178,.07), transparent 64%),
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
  background-size:auto,auto,auto,260px 260px;
  background-repeat:no-repeat,no-repeat,no-repeat,repeat;
  opacity:.10;
  mix-blend-mode:overlay;
  z-index:0;
}

body::after{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background: radial-gradient(circle at 50% 18%, transparent 0%, rgba(0,0,0,.18) 55%, rgba(0,0,0,.60) 100%);
  opacity:.74;
  z-index:0;
}

/* keep content above overlays */
.page-shell,.top-bar,.hero,.tool-grid-wrap,.panel-shell{
  position:relative;
  z-index:1;
}

/* =========================================================
   FINAL CTA COLORS — GREEN + CYAN (DROP-IN, LAST IN FILE)
   ========================================================= */

/* 1) HERO */
.hero-actions #btn-connect.btn-secondary{
  background: linear-gradient(135deg, #22e6a7 0%, #63f5bf 100%) !important;
  color: #04130e !important;
  border: 1px solid rgba(34,230,167,.42) !important;
  box-shadow: 0 16px 46px rgba(34,230,167,.28), inset 0 1px 0 rgba(255,255,255,.28) !important;
  text-shadow: none !important;
}
.hero-actions #btn-connect.btn-secondary:hover{
  transform: translateY(-1px);
  filter: saturate(1.05) brightness(1.02);
  box-shadow: 0 24px 64px rgba(34,230,167,.34), inset 0 1px 0 rgba(255,255,255,.30) !important;
}

/* RUN QUICK SCAN -> cyan like SCAN */
.hero-actions .btn-ghost,
.hero-actions [data-action="quick-scan"],
.hero-actions a[href*="#panel-quick"],
.hero-actions a[href*="quick-scan"]{
  background: linear-gradient(135deg, #21d4ee 0%, #67e8f9 100%) !important;
  color: #041022 !important;
  border: 1px solid rgba(33,212,238,.42) !important;
  box-shadow: 0 16px 46px rgba(33,212,238,.28), inset 0 1px 0 rgba(255,255,255,.25) !important;
  text-shadow: none !important;
}
.hero-actions .btn-ghost:hover,
.hero-actions [data-action="quick-scan"]:hover,
.hero-actions a[href*="#panel-quick"]:hover,
.hero-actions a[href*="quick-scan"]:hover{
  transform: translateY(-1px);
  filter: saturate(1.05) brightness(1.02);
  box-shadow: 0 24px 64px rgba(33,212,238,.34) !important;
}

/* 2) DNA PANEL (FIXED IDS) */
#panel-approvals #dna-connect,
#panel-approvals #dna-full-access{
  background: linear-gradient(135deg, #22e6a7 0%, #63f5bf 100%) !important;
  color: #04130e !important;
  border: 1px solid rgba(34,230,167,.42) !important;
  box-shadow: 0 16px 46px rgba(34,230,167,.28), inset 0 1px 0 rgba(255,255,255,.28) !important;
  text-shadow: none !important;
}
#panel-approvals #dna-connect:hover,
#panel-approvals #dna-full-access:hover{
  transform: translateY(-1px);
  filter: saturate(1.05) brightness(1.02);
  box-shadow: 0 24px 64px rgba(34,230,167,.34), inset 0 1px 0 rgba(255,255,255,.30) !important;
}
#panel-approvals #dna-connect:disabled,
#panel-approvals #dna-full-access:disabled{
  opacity: .62 !important;
  cursor: not-allowed !important;
}

/* 3) ACCESS MODAL USDT */
#access-modal #btn-pay-usdt{
  background: linear-gradient(135deg, #22e6a7 0%, #63f5bf 100%) !important;
  color: #04130e !important;
  border: 1px solid rgba(34,230,167,.42) !important;
  box-shadow: 0 16px 46px rgba(34,230,167,.28), inset 0 1px 0 rgba(255,255,255,.28) !important;
  text-shadow: none !important;
}
#access-modal #btn-pay-usdt:hover{
  transform: translateY(-1px);
  filter: saturate(1.05) brightness(1.02);
  box-shadow: 0 24px 64px rgba(34,230,167,.34), inset 0 1px 0 rgba(255,255,255,.30) !important;
}

/* =========================================================
   MOBILE FEATURE TEXT PATCH (FEATURES ONLY)
   no modal / no cards / no overlay changes
   put LAST in CSS
   ========================================================= */
@media (max-width: 900px){

  /* header container */
  .tool-head,
  .panel-head,
  .feature-head{
    display: block !important;
    position: relative !important;
    min-width: 0 !important;
  }

  /* CLOSE button: small pill, right side */
  .tool-head .btn-close,
  .panel-head .btn-close,
  .feature-head .btn-close,
  .tool-head .close-btn,
  .panel-head .close-btn,
  .feature-head .close-btn,
  .tool-head .btn[data-action="close"],
  .panel-head .btn[data-action="close"],
  .feature-head .btn[data-action="close"]{
    float: right !important;
    width: auto !important;
    min-width: 100px !important;
    height: 42px !important;
    padding: 0 16px !important;
    margin: 4px 0 8px 10px !important;
    border-radius: 999px !important;
    font-size: 15px !important;
    letter-spacing: .06em !important;
    white-space: nowrap !important;
    line-height: 42px !important;
  }

  /* wallet chip: right, trimmed, does not crush title */
  .wallet-chip,
  .wallet-pill,
  .tool-head .wallet-chip,
  .panel-head .wallet-chip,
  .feature-head .wallet-chip,
  .tool-head .wallet-pill,
  .panel-head .wallet-pill,
  .feature-head .wallet-pill{
    float: right !important;
    clear: right !important;
    max-width: 62% !important;
    margin: 0 0 8px 10px !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
  }

  /* clear floats before title/desc */
  .tool-head::after,
  .panel-head::after,
  .feature-head::after{
    content: "" !important;
    display: block !important;
    clear: both !important;
  }

  /* titles: normal rows (no vertical letters) */
  .tool-title,
  .panel-title,
  .feature-title,
  .tool-head h1,
  .tool-head h2,
  .panel-head h1,
  .panel-head h2,
  .feature-head h1,
  .feature-head h2{
    display: block !important;
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
    margin: 0 0 10px 0 !important;
    font-size: clamp(34px, 8.4vw, 46px) !important;
    line-height: 1.08 !important;
    letter-spacing: -0.01em !important;
    white-space: normal !important;
    word-break: normal !important;
    overflow-wrap: normal !important;
    hyphens: none !important;
  }

  /* body text: proper line flow */
  .tool-subtitle,
  .panel-subtitle,
  .feature-subtitle,
  .tool-desc,
  .panel-desc,
  .feature-desc,
  .tool-panel p,
  .panel p{
    display: block !important;
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
    margin: 0 0 12px 0 !important;
    font-size: 16px !important;
    line-height: 1.48 !important;
    white-space: normal !important;
    word-break: normal !important;
    overflow-wrap: break-word !important;
    hyphens: auto !important;
  }

  /* prevent accidental desktop columns in open tool content */
  .tool-layout,
  .panel-layout,
  .feature-layout{
    min-width: 0 !important;
  }
}

/* very small phones */
@media (max-width: 390px){
  .tool-title,
  .panel-title,
  .feature-title,
  .tool-head h1,
  .tool-head h2,
  .panel-head h1,
  .panel-head h2,
  .feature-head h1,
  .feature-head h2{
    font-size: clamp(30px, 9vw, 40px) !important;
    line-height: 1.1 !important;
  }

  .tool-head .btn-close,
  .panel-head .btn-close,
  .feature-head .btn-close,
  .tool-head .close-btn,
  .panel-head .close-btn,
  .feature-head .close-btn{
    min-width: 92px !important;
    height: 40px !important;
    font-size: 14px !important;
    line-height: 40px !important;
  }
}
/* =========================================================
   DNA MOBILE FIX PATCH (paste LAST)
   ========================================================= */
@media (max-width: 900px){

  /* 1) Header in DNA card: title full width, pills below */
  #panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child{
    display:flex !important;
    flex-direction:column !important;
    align-items:stretch !important;
    gap:10px !important;
    flex-wrap:wrap !important;
    min-width:0 !important;
  }

  #panel-approvals .grid-2 > .card:nth-child(2) > .row:first-child > .row{
    margin-left:0 !important;
    width:100% !important;
    display:flex !important;
    justify-content:space-between !important;
    align-items:center !important;
    flex-wrap:nowrap !important;
    gap:8px !important;
    min-width:0 !important;
  }

  #panel-approvals #dna-score,
  #panel-approvals #dna-risk{
    flex:1 1 0 !important;
    min-width:0 !important;
    max-width:calc(50% - 4px) !important;
    padding:6px 9px !important;
    font-size:12px !important;
    white-space:nowrap !important;
    overflow:hidden !important;
    text-overflow:ellipsis !important;
  }

  /* 2) Wallet text / address never breaks layout */
  #panel-approvals #dna-wallet,
  #panel-approvals #dna-address,
  #panel-approvals .pill .mono,
  #panel-approvals #dna-status .mono{
    max-width:100% !important;
    min-width:0 !important;
    display:inline-block !important;
    white-space:nowrap !important;
    overflow:hidden !important;
    text-overflow:ellipsis !important;
    vertical-align:middle !important;
  }

  /* 3) Buttons layout: Connect full row, Scan+Reset in one row */
  #panel-approvals #dna-connect{
    width:100% !important;
    max-width:100% !important;
    flex:1 1 100% !important;
    order:1 !important;
  }

  #panel-approvals #dna-scan,
  #panel-approvals #dna-run,
  #panel-approvals [data-action="dna-scan"],
  #panel-approvals #dna-reset,
  #panel-approvals [data-action="dna-reset"]{
    flex:1 1 calc(50% - 6px) !important;
    max-width:calc(50% - 6px) !important;
    min-width:0 !important;
    order:2 !important;
  }

  /* 4) Unlock button stays one line */
  #panel-approvals #dna-full-access{
    width:100% !important;
    max-width:100% !important;
    white-space:nowrap !important;
    overflow:hidden !important;
    text-overflow:ellipsis !important;
    letter-spacing:.02em !important;
    font-size:clamp(12px, 3.6vw, 15px) !important;
  }

  /* 5) Locked text paragraph flows normally */
  #panel-approvals #dna-approvals-locked .small{
    white-space:normal !important;
    word-break:normal !important;
    overflow-wrap:anywhere !important;
    line-height:1.45 !important;
  }
}

/* =========================================================
   RPC MOBILE LAYOUT + RESULTS FIX (paste LAST)
   ========================================================= */
@media (max-width: 900px){

  /* ---------- Buttons layout ---------- */

  /* Make known action wrappers wrap nicely (safe + scoped) */
  #panel-rpc .share-row,
  #panel-rpc .rpc-actions,
  #panel-rpc .rpc-share,
  #panel-rpc .rpc-btns,
  #panel-rpc .row:has(#rpc-save),
  #panel-rpc .row:has(#rpc-clear),
  #panel-rpc .row:has(#rpc-clean),
  #panel-rpc .row:has(#rpc-test),
  #panel-rpc .row:has(#btn-rpc-test),
  #panel-rpc .row:has(#rpc-copy-best),
  #panel-rpc .row:has(#btn-rpc-copy),
  #panel-rpc .row:has(#rpc-share-x),
  #panel-rpc .row:has(#btn-rpc-share),
  #panel-rpc .row:has(#rpc-run-custom),
  #panel-rpc .row:has(#btn-rpc-custom){
    display:flex !important;
    flex-wrap:wrap !important;
    gap:10px !important;
    align-items:stretch !important;
  }

  /* Base button sizing in RPC panel */
  #panel-rpc .btn{
    min-width:0 !important;
    white-space:nowrap !important;
    overflow:hidden !important;
    text-overflow:ellipsis !important;
  }

  /* SAVE + CLEAR together */
  #panel-rpc #rpc-save,
  #panel-rpc #rpc-clear,
  #panel-rpc #rpc-clean{
    flex:1 1 calc(50% - 5px) !important;
    max-width:calc(50% - 5px) !important;
    width:calc(50% - 5px) !important;
    order:1 !important;
  }

  /* TEST RPCS full row */
  #panel-rpc #rpc-test,
  #panel-rpc #btn-rpc-test,
  #panel-rpc [data-action="test-rpcs"],
  #panel-rpc [data-action="rpc-test"]{
    flex:1 1 100% !important;
    max-width:100% !important;
    width:100% !important;
    order:2 !important;
  }

  /* COPY BEST RPC + SHARE TO X on same row */
  #panel-rpc #rpc-copy-best,
  #panel-rpc #btn-rpc-copy,
  #panel-rpc [data-action="copy-best-rpc"],
  #panel-rpc #rpc-share-x,
  #panel-rpc #btn-rpc-share,
  #panel-rpc [data-action="share-rpc-x"]{
    flex:1 1 calc(50% - 5px) !important;
    max-width:calc(50% - 5px) !important;
    width:calc(50% - 5px) !important;
    order:3 !important;
  }

  /* RUN CUSTOM TEST full row */
  #panel-rpc #rpc-run-custom,
  #panel-rpc #btn-rpc-custom,
  #panel-rpc [data-action="rpc-custom-run"],
  #panel-rpc [data-action="run-custom-test"]{
    flex:1 1 100% !important;
    max-width:100% !important;
    width:100% !important;
    order:4 !important;
  }

  /* ---------- Results table clarity ---------- */

  #rpc-table{
    overflow:hidden !important;
  }

  /* Header cleaner on mobile */
  #rpc-table .trow.head.rpc{
    grid-template-columns:1fr 110px !important; /* RPC | STATUS */
    gap:10px !important;
  }
  #rpc-table .trow.head.rpc .cell:nth-child(2){ display:none !important; } /* hide "Metrics" label */
  #rpc-table .trow.head.rpc .cell:nth-child(3){
    text-align:right !important;
    justify-self:end !important;
  }

  /* Each result row stacked cleanly: URL -> status -> metrics */
  #rpc-table .trow.rpc{
    grid-template-columns:1fr !important;
    grid-template-rows:auto auto auto !important;
    gap:8px !important;
    align-items:start !important;
    padding:11px 10px !important;
  }

  #rpc-table .rpc-url{
    grid-column:1 !important;
    grid-row:1 !important;
    min-width:0 !important;
  }

  #rpc-table .rpc-url .rpc-host{
    display:block !important;
    font-size:clamp(16px, 4.6vw, 20px) !important;
    line-height:1.12 !important;
    white-space:nowrap !important;
    overflow:hidden !important;
    text-overflow:ellipsis !important;
  }

  #rpc-table .rpc-url .rpc-full{
    margin-top:4px !important;
    font-size:12px !important;
    line-height:1.2 !important;
    color:rgba(244,246,255,.68) !important;
    white-space:normal !important;
    overflow-wrap:anywhere !important;
    word-break:break-word !important;
    display:-webkit-box !important;
    -webkit-box-orient:vertical !important;
    -webkit-line-clamp:2 !important;
    overflow:hidden !important;
  }

  #rpc-table .rpc-status{
    grid-column:1 !important;
    grid-row:2 !important;
    justify-self:start !important;
    white-space:nowrap !important;
  }

  #rpc-table .rpc-meta{
    grid-column:1 !important;
    grid-row:3 !important;
    display:grid !important;
    grid-template-columns:repeat(2, minmax(0,1fr)) !important; /* MS + Block / Call + Logs */
    gap:8px !important;
    align-items:stretch !important;
  }

  #rpc-table .rpc-meta .m{
    min-width:0 !important;
    width:100% !important;
    justify-content:center !important;
    white-space:nowrap !important;
    overflow:hidden !important;
    text-overflow:ellipsis !important;
    padding:7px 8px !important;
  }
}

/* Extra-small phones */
@media (max-width: 420px){
  #rpc-table .rpc-meta{
    grid-template-columns:1fr !important;
  }
}
/* =========================================================
   RPC MOBILE HOTFIX — SAVE/CLEAR + RUN CUSTOM ONLY
   paste AFTER your last patch
   ========================================================= */
@media (max-width: 900px){

  /* ---------- SAVE + CLEAR on one row ---------- */
  #panel-rpc .row:has(#rpc-save):has(#rpc-clear),
  #panel-rpc .row:has(#rpc-save):has(#rpc-clean),
  #panel-rpc .row:has([id*="save"]):has([id*="clear"]),
  #panel-rpc .row:has([data-action*="save"]):has([data-action*="clear"]){
    display:grid !important;
    grid-template-columns:repeat(2, minmax(0,1fr)) !important;
    gap:10px !important;
    align-items:stretch !important;
  }

  #panel-rpc #rpc-save,
  #panel-rpc #rpc-clear,
  #panel-rpc #rpc-clean,
  #panel-rpc [id*="save"].btn,
  #panel-rpc [id*="clear"].btn,
  #panel-rpc [id*="clean"].btn{
    width:100% !important;
    max-width:100% !important;
    min-width:0 !important;
    flex:1 1 auto !important;
  }

/* =========================================================
   MOBILE FINAL — SINGLE CLEAN BLOCK (paste LAST)
   כולל:
   - Access popup fixed
   - TX buttons row
   - LIQ buttons layout
   - Dev tools buttons layout
   - Monitor table like RPC (horizontal scroll, no clipping)
   - Text polish
   ========================================================= */
@media (max-width: 900px){

  /* -----------------------------------------------
     0) Global mobile safety
     ----------------------------------------------- */
  html, body{
    overflow-x: hidden !important;
  }

  /* RUN CUSTOM TEST — keep custom run full row */
  #panel-rpc .row > .btn:only-child,
  #panel-rpc .row > button.btn:only-child,
  #panel-rpc .rpc-actions > .btn:only-child,
  #panel-rpc .rpc-btns > .btn:only-child,
  #panel-rpc .share-row > .btn:only-child,
  #panel-rpc [id*="custom"].btn,
  #panel-rpc [id*="run-custom"].btn,
  #panel-rpc [id*="rpc-custom"].btn,
  #panel-rpc [data-action*="custom"]{
    display:flex !important;
    width:100% !important;
    max-width:100% !important;
    flex:0 0 100% !important;
    min-width:0 !important;
  }

 

  /* -----------------------------------------------
     B) TX Decoder: Decode + Copy markdown same row
     ----------------------------------------------- */
  #panel-tx .tx-actions,
  #panel-tx .row:has(#tx-decode),
  #panel-tx .row:has(#btn-tx-decode),
  #panel-tx .row:has(#tx-run),
  #panel-tx .row:has(#tx-copy-md),
  #panel-tx .row:has(#btn-tx-copy),
  #panel-tx .row:has(#tx-copy-markdown){
    display: flex !important;
    flex-wrap: wrap !important;
    gap: 10px !important;
    align-items: stretch !important;
  }

  #panel-tx #tx-decode,
  #panel-tx #btn-tx-decode,
  #panel-tx #tx-run,
  #panel-tx [data-action="tx-decode"],
  #panel-tx [data-action="decode-tx"],
  #panel-tx #tx-copy-md,
  #panel-tx #btn-tx-copy,
  #panel-tx #tx-copy-markdown,
  #panel-tx [data-action="tx-copy-markdown"],
  #panel-tx [data-action="copy-markdown"]{
    flex: 1 1 calc(50% - 5px) !important;
    width: calc(50% - 5px) !important;
    max-width: calc(50% - 5px) !important;
    min-width: 0 !important;
  }

  /* -----------------------------------------------
     C) Liquidity:
     Scan full row, Copy + Share side by side
     ----------------------------------------------- */
  #panel-liq .row:has(#liq-run),
  #panel-liq .row:has(#liq-scan),
  #panel-liq .row:has([id^="liq-copy"]),
  #panel-liq .row:has([id^="liq-share"]),
  #panel-liquidity .row:has(#liq-run),
  #panel-liquidity .row:has(#liq-scan),
  #panel-liquidity .row:has([id^="liq-copy"]),
  #panel-liquidity .row:has([id^="liq-share"]){
    display:flex !important;
    flex-wrap:wrap !important;
    gap:10px !important;
    align-items:stretch !important;
  }

  /* SCAN */
  #panel-liq #liq-run,
  #panel-liq #liq-scan,
  #panel-liq [id^="liq-run"],
  #panel-liq [data-action*="scan"],
  #panel-liquidity #liq-run,
  #panel-liquidity #liq-scan,
  #panel-liquidity [id^="liq-run"],
  #panel-liquidity [data-action*="scan"]{
    order:1 !important;
    flex:1 1 100% !important;
    width:100% !important;
    max-width:100% !important;
    min-width:0 !important;
  }

  /* COPY SHARE LINK + SHARE TO X */
  #panel-liq [id^="liq-copy"],
  #panel-liq [id^="liq-share"],
  #panel-liq [data-action*="copy"],
  #panel-liq [data-action*="share"],
  #panel-liquidity [id^="liq-copy"],
  #panel-liquidity [id^="liq-share"],
  #panel-liquidity [data-action*="copy"],
  #panel-liquidity [data-action*="share"]{
    order:2 !important;
    flex:1 1 calc(50% - 5px) !important;
    width:calc(50% - 5px) !important;
    max-width:calc(50% - 5px) !important;
    min-width:0 !important;
  }

  /* -----------------------------------------------
     D) Dev Tools buttons
     Generate/Copy full row
     Add full row
     Check all + Copy JSON side by side
     ----------------------------------------------- */

  /* Bookmarklet buttons */
  #panel-dev #bm-generate,
  #panel-dev #btn-bm-generate,
  #panel-dev [data-action="bm-generate"],
  #panel-dev #bm-copy,
  #panel-dev #btn-bm-copy,
  #panel-dev [data-action="bm-copy"],
  #panel-bookmark #bm-generate,
  #panel-bookmark #btn-bm-generate,
  #panel-bookmark [data-action="bm-generate"],
  #panel-bookmark #bm-copy,
  #panel-bookmark #btn-bm-copy,
  #panel-bookmark [data-action="bm-copy"]{
    flex: 1 1 100% !important;
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
  }

  /* Monitor Add */
  #panel-dev #mon-add,
  #panel-dev #btn-mon-add,
  #panel-dev [id^="mon-add"],
  #panel-dev [data-action*="mon-add"],
  #panel-monitor #mon-add,
  #panel-monitor #btn-mon-add,
  #panel-monitor [id^="mon-add"],
  #panel-monitor [data-action*="mon-add"]{
    order: 1 !important;
    flex: 1 1 100% !important;
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
  }

  /* Monitor Check + Copy JSON */
  #panel-dev [id^="mon-check"],
  #panel-dev [id^="mon-expor"],
  #panel-dev [id^="mon-copy"],
  #panel-monitor [id^="mon-check"],
  #panel-monitor [id^="mon-expor"],
  #panel-monitor [id^="mon-copy"]{
    order: 2 !important;
    flex: 1 1 calc(50% - 5px) !important;
    width: calc(50% - 5px) !important;
    max-width: calc(50% - 5px) !important;
    min-width: 0 !important;
  }

  /* -----------------------------------------------
     E) Tables — mon-table same behavior as RPC table
     (scroll horizontally, no clipping)
     ----------------------------------------------- */
  #rpc-table, #liq-table, #mon-table, #tx-table,
  #panel-rpc .table, #panel-liq .table, #panel-dev .table, #panel-monitor .table, #panel-tx .table{
    width: 100% !important;
    max-width: 100% !important;
    display: block !important;
    overflow-x: auto !important;
    overflow-y: hidden !important;
    -webkit-overflow-scrolling: touch !important;
  }

  #rpc-table .table, #liq-table .table, #mon-table .table, #tx-table .table,
  #rpc-table table, #liq-table table, #mon-table table, #tx-table table,
  #panel-rpc .table table, #panel-liq .table table, #panel-dev .table table, #panel-monitor .table table, #panel-tx .table table{
    width: max-content !important;
    min-width: 100% !important;
    table-layout: auto !important;
    border-collapse: collapse !important;
  }

  #rpc-table .trow, #liq-table .trow, #mon-table .trow, #tx-table .trow,
  #panel-rpc .table .trow, #panel-liq .table .trow, #panel-dev .table .trow, #panel-monitor .table .trow, #panel-tx .table .trow{
    min-width: max-content !important;
  }

  #rpc-table th, #rpc-table td, #rpc-table .cell,
  #liq-table th, #liq-table td, #liq-table .cell,
  #mon-table th, #mon-table td, #mon-table .cell,
  #tx-table th, #tx-table td, #tx-table .cell,
  #panel-rpc .table .cell, #panel-liq .table .cell, #panel-dev .table .cell, #panel-monitor .table .cell, #panel-tx .table .cell{
    white-space: nowrap !important;
    overflow: visible !important;
    text-overflow: clip !important;
    min-width: 0 !important;
  }

  /* -----------------------------------------------
     F) Text polish (mobile)
     ----------------------------------------------- */
  #access-modal p, #modal-access p, [id*="access-modal"] p,
  #panel-tx p, #panel-liq p, #panel-liquidity p, #panel-dev p, #panel-monitor p,
  #panel-tx .small, #panel-liq .small, #panel-liquidity .small, #panel-dev .small, #panel-monitor .small,
  #panel-tx .tip, #panel-liq .tip, #panel-liquidity .tip, #panel-dev .tip, #panel-monitor .tip{
    line-height: 1.42 !important;
    white-space: normal !important;
    overflow-wrap: anywhere !important;
    word-break: break-word !important;
  }

  #panel-liq [id*="liq-dex"], 
  #panel-liq [id*="liq-note"],
  #panel-liquidity [id*="liq-dex"], 
  #panel-liquidity [id*="liq-note"],
  #panel-dev #bm-tip,
  #panel-bookmark #bm-tip{
    white-space: normal !important;
    overflow-wrap: anywhere !important;
    word-break: break-word !important;
  }

  #panel-dev .mono, #panel-bookmark .mono, #panel-tx .mono,
  #panel-dev input, #panel-bookmark input, #panel-tx input, #panel-liq input{
    text-overflow: ellipsis !important;
    overflow: hidden !important;
    min-width: 0 !important;
  }

  :is(#access-modal, #modal-access, [id*="access-modal"]) :is(.small, .tip, .hint){
    line-height: 1.45 !important;
  }
}
/* HOTFIX: Access modal should open only when app marks it open */
@media (max-width: 900px){

  /* Base modal box styling only (NO forced display) */
  :is(#access-modal, #modal-access, .access-modal, .popup-access, [id*="access-modal"]){
    position: fixed !important;
    inset: 0 !important;
    padding: 12px !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    transform: none !important;
    z-index: 10000 !important;
    box-sizing: border-box !important;
  }

  /* CLOSED state (default) */
  :is(#access-modal, #modal-access, .access-modal, .popup-access, [id*="access-modal"]):not(.open):not(.is-open):not([open="true"]):not([aria-hidden="false"]){
    display: none !important;
    opacity: 0 !important;
    pointer-events: none !important;
  }

/* OPEN state only */
:is(
  #access-modal.open, #access-modal.is-open, #access-modal[open="true"], #access-modal[aria-hidden="false"],
  #modal-access.open, #modal-access.is-open, #modal-access[open="true"], #modal-access[aria-hidden="false"],
  .access-modal.open, .access-modal.is-open, .access-modal[open="true"], .access-modal[aria-hidden="false"],
  .popup-access.open, .popup-access.is-open, .popup-access[open="true"], .popup-access[aria-hidden="false"],
  [id*="access-modal"].open, [id*="access-modal"].is-open, [id*="access-modal"][open="true"], [id*="access-modal"][aria-hidden="false"]
){
  display: flex !important;              
  align-items: center !important;
  justify-content: center !important;
  opacity: 1 !important;
  pointer-events: auto !important;
}

  /* Card */
  :is(#access-modal, #modal-access, .access-modal, .popup-access, [id*="access-modal"])
  > :is(.card,.modal-card,.access-card,.popup-card,.dialog-card,.sheet,.panel,.content,.inner){
    width: min(94vw, 640px) !important;
    max-width: min(94vw, 640px) !important;
    max-height: calc(100dvh - 24px) !important;
    margin: 0 auto !important;
    overflow: auto !important;
    box-sizing: border-box !important;
  }
}
/* AppKit must be above Access modal */
:root{
  --z-access-modal: 10000;
  --z-appkit: 2147483000;
}

/* Your Access modal layer */
@media (max-width: 900px){
  :is(#access-modal, #modal-access, .access-modal, .popup-access, [id*="access-modal"]){
    z-index: var(--z-access-modal) !important;
  }
}
  /* AppKit / Web3Modal containers (common selectors) */
w3m-modal,
w3m-router,
w3m-overlay,
w3m-modal-backdrop,
wui-modal,
wui-dialog,
.w3m-modal,
.w3m-overlay,
.walletconnect-modal,
.walletconnect-modal__base,
[data-testid="w3m-modal"]{
  z-index: var(--z-appkit) !important;
  position: fixed !important;
}




</style>
   
   
</head>
<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX" data-i18n-title="title_back_to_cyclex">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector" data-i18n-aria-label="aria_lang_selector">
        <button class="lang-btn active" data-lang="en">🇺🇸 EN</button>
        <button class="lang-btn" data-lang="zh">🇨🇳 中文</button>
        <button class="lang-btn" data-lang="ar">🇸🇦 عربي</button>
        <button class="lang-btn" data-lang="ru">🇷🇺 RU</button>
      </div>
    </header>

    <main>
     <section class="hero">
  <div class="hero-kicker" data-i18n="hero_kicker">CycleX Security Hub</div>

  <h1 class="hero-title" data-i18n="hero_title">Advanced Approval Intelligence</h1>

  <p class="hero-subtitle" data-i18n="hero_subtitle">
    Understand your approvals, spot risky spenders, and unlock advanced revoke tools — across BSC + Ethereum.
  </p>

  <div class="hero-actions">
    <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
    <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_access">Get Access (PASS / CYCX)</button>
    <button class="btn btn-ghost" id="btn-quick" data-i18n="btn_quick">Run Quick Scan</button>
  </div>
       <div class="hero-micro">
  <span class="micro-item" data-i18n="hero_micro_access">Unlock advanced approvals + revoke tools.</span>
</div>


  <div class="note-line" data-i18n="hero_note">
    Note: These checks are informational and do not guarantee safety. No signatures. No transactions. Always verify contracts and URLs independently.
  </div>
</section>

      <section class="tool-grid-wrap">
        <div class="tool-grid-title" data-i18n="tools_kicker">CHOOSE A TOOL</div>

        <div class="tool-grid" id="toolGrid">
          <a class="tool-card active" data-tool="quick" href="#panel-quick">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_quick_title">Quick Scan</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_quick_desc">Fast token sanity-check + shareable report + cache.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_fast">Fast</strong></div>
              <div class="badge"><strong data-i18n="badge_share">Share</strong></div>
              <div class="badge"><strong data-i18n="badge_cache">Cache</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="approvals" href="#panel-approvals">
  <div class="tool-head">
    <div class="tool-name" data-i18n="cube_walletdna_title">Wallet Security DNA</div>
    <div class="badge"><strong data-i18n="badge_wallet">Wallet</strong></div>
  </div>

  <div class="tool-desc" data-i18n="cube_walletdna_desc">
    Approval &amp; Permission Risk Snapshot
  </div>

  <div class="badge-row">
    <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
    <div class="badge"><strong data-i18n="badge_safe">Safe</strong></div>
  </div>
</a>

          <a class="tool-card" data-tool="liq" href="#panel-liq">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_liq_title">Token + Liquidity Scan</div>
              <div class="badge"><strong>V2</strong> + <strong>V3</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_liq_desc">DEX Registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_dex">DEX</strong></div>
              <div class="badge"><strong>USDT</strong></div>
              <div class="badge"><strong data-i18n="badge_pairs">Pairs</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="rpc" href="#panel-rpc">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
              <div class="badge"><strong>✅</strong> <span data-i18n="badge_table">Table</span></div>
            </div>
            <div class="tool-desc" data-i18n="cube_rpc_desc">Latency + chainId + block + eth_call + read logs + dev custom test.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_copy">Copy</strong></div>
              <div class="badge"><strong data-i18n="badge_dev">Dev</strong></div>
              <div class="badge"><strong>X</strong> <span data-i18n="badge_share">Share</span></div>
            </div>
          </a>

          <a class="tool-card" data-tool="tx" href="#panel-tx">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_tx_title">Tx Decoder</div>
              <div class="badge"><strong data-i18n="badge_decode">Decode</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_tx_desc">Decode inputs + common events (Transfer/Approval) from a tx hash.</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_receipt">Receipt</strong></div>
              <div class="badge"><strong data-i18n="badge_events">Events</strong></div>
            </div>
          </a>

          <a class="tool-card" data-tool="dev" href="#panel-dev">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_dev_title">Dev Tools</div>
              <div class="badge"><strong data-i18n="badge_tools">Tools</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_dev_desc">Bookmarklet generator + local contract monitor (no server).</div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_bookmarklet">Bookmarklet</strong></div>
              <div class="badge"><strong data-i18n="badge_local">Local</strong></div>
            </div>
          </a>
        </div>
      </section>

      <!-- PANELS -->
      <section class="panel-shell" id="panel-quick">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
            <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
            <div class="panel-sub" data-i18n="p_quick_sub">
              Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="walletLabel" data-i18n="wallet_not_connected">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseQuick" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="quick_input_title">Token Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="qs-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="qs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="qs_tip">
                Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="options_label">Options</div>
              <label class="toggle">
                <input type="checkbox" id="qs-require-liq">
                <span data-i18n="opt_require_liq">Require liquidity (stricter score)</span>
              </label>
              <label class="toggle" style="margin-top:10px">
                <input type="checkbox" id="qs-show-json" checked>
                <span data-i18n="opt_show_json">Enable JSON report (copy)</span>
              </label>
            </div>

            <div class="field" style="margin-top:14px">
              <div class="label" data-i18n="api_keys_label">Explorer API keys (optional)</div>
              <label class="toggle">
                <input type="checkbox" id="api-use">
                <span data-i18n="opt_use_explorer_apis">Use BscScan/Etherscan (adds Verified + ABI heuristics)</span>
              </label>

              <div class="row" style="margin-top:10px">
                <input id="api-bscscan" class="mono" placeholder="BscScan API key (stored locally)" data-i18n-placeholder="ph_bscscan_key" />
                <input id="api-unified" class="mono" placeholder="Unified API key (stored locally)" data-i18n-placeholder="ph_unified_key" />
                <input id="api-etherscan" class="mono" placeholder="Etherscan API key (stored locally)" data-i18n-placeholder="ph_etherscan_key" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="api-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="api-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>

              <div class="small" style="margin-top:8px" data-i18n="api_keys_tip">
                Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.
              </div>
            </div>

            <div class="field">
              <div class="row qs-actions">
                <button class="btn btn-primary" id="qs-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
                <button class="btn btn-ghost" id="qs-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
              </div>
            </div>

            <div class="qs-share">
              <button class="btn btn-ghost" id="qs-share-x">Share to X</button>
              <button class="btn btn-ghost" id="qs-share-tg">Share to Telegram</button>
              <button class="btn btn-ghost" id="qs-copy-xtext" data-i18n="btn_copy_xtext">Copy X text</button>
            </div>

            <div id="qs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="results_title">Results</h3>
            <div class="small" data-i18n="results_hint">
              Green / Yellow / Red signals. Not a guarantee — just verifiable on-chain checks.
            </div>

            <div id="qs-out" class="status info" style="display:block; margin-top:10px;" data-i18n="qs_ready_html">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="qs-risk" class="risk-badges"></div>
            <div id="qs-pairsWrap" style="margin-top:12px;"></div>
          </div>
        </div>
        
      </section>
     <section class="panel-shell hidden" id="panel-approvals">
  <div class="panel-head">
    <div>
      <div class="panel-kicker" data-i18n="p_dna_kicker">WALLET SECURITY DNA</div>
      <div class="panel-title" data-i18n="p_dna_title">Wallet Security DNA</div>
      <div class="panel-sub" data-i18n="p_dna_sub">
        Approval &amp; Permission Risk Snapshot
      </div>
    </div>

    <div class="panel-actions">
      <div class="pill">
        <span data-i18n="pill_wallet">Wallet</span>:
        <span class="mono" id="dna-wallet" data-i18n="wallet_not_connected">not connected</span>
      </div>
      <button class="btn btn-ghost" id="btnCloseApprovals" data-i18n="btn_close">Close</button>
    </div>
  </div>

  <div class="grid-2">
    <!-- LEFT -->
    <div class="card">
      <h3 data-i18n="dna_controls_title">DNA Scan</h3>

      <div class="field">
        <div class="label" data-i18n="dna_wallet_address_label">Wallet Address</div>
        <input
          id="dna-walletAddress"
          class="mono"
          placeholder="0x... (optional if you connect)"
          data-i18n-placeholder="dna_wallet_address_ph"
        />
        <div class="small" style="margin-top:8px" data-i18n="dna_wallet_address_tip">
          You can scan by address first. Connect a wallet only when you want to revoke.
        </div>
      </div>

      <div class="field">
        <div class="label" data-i18n="net_label">Network</div>
        <select id="dna-net">
          <option value="bsc" data-i18n="net_bsc">BSC (BNB Chain)</option>
          <option value="eth" data-i18n="net_eth">Ethereum</option>
          <option value="polygon" data-i18n="net_polygon">Polygon</option>
        </select>
      </div>

      <div class="field">
        <div class="row" style="justify-content:space-between; gap:10px; flex-wrap:wrap">
          <div class="pill">
            <span data-i18n="dna_connected">Connected:</span>
            <span id="dna-address" class="mono">—</span>
          </div>
          <button class="btn btn-secondary" id="dna-connect" data-i18n="dna_connect">Connect Wallet</button>
        </div>
      </div>

      <div class="field">
        <div class="row" style="gap:10px; flex-wrap:wrap">
          <button class="btn btn-primary" id="dna-run" data-i18n="dna_run">Scan</button>
          <button class="btn btn-ghost" id="dna-reset" data-i18n="dna_reset">Reset</button>
        </div>
        <div class="small" style="margin-top:8px" data-i18n="safe_mode_note">
          Safe mode: revoke actions require a connected wallet.
        </div>
      </div>

      <div id="dna-status" class="status info"></div>

      <div class="field" style="margin-top:14px">
        <div class="label" data-i18n="dna_tokens_label">Token list (optional)</div>
        <textarea
          id="dna-tokens"
          class="mono"
          placeholder="0x...\n0x...\n0x..."
          data-i18n-placeholder="ph_token_list"
        ></textarea>
        <div class="row" style="margin-top:10px">
          <button class="btn btn-ghost" id="dna-seed-common" data-i18n="ap_seed">Seed common tokens</button>
          <button class="btn btn-ghost" id="dna-seed-history" data-i18n="ap_seed_history">Use scan history</button>
        </div>
      </div>

      <!-- Compatibility hooks (hidden) -->
      <div style="display:none">
        <select id="ap-net"></select>
        <button id="ap-connect"></button>
        <button id="ap-revoke-all"></button>
        <div id="ap-status"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap">
        <div>
          <h3 data-i18n="dna_results_title">Wallet Security DNA</h3>
          <div class="small" data-i18n="dna_results_hint">
            Score is a snapshot. Always verify before signing.
          </div>
        </div>

        <div class="row dna-metrics">
          <div class="pill">
            <span data-i18n="dna_score">Score</span>:
            <span class="mono" id="dna-score">—</span>
          </div>
          <div class="pill">
            <span data-i18n="dna_risk_level">Risk</span>:
            <span class="mono" id="dna-risk">—</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px; padding:12px">
        <div class="small" style="margin-bottom:8px" data-i18n="dna_tips_title">Tips</div>
        <ul id="dna-tips" class="small" style="margin:0; padding-left:18px">
          <li class="muted" data-i18n="dna_tips_placeholder">—</li>
        </ul>

        <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap">
          <button class="btn btn-ghost" id="dna-share" data-i18n="dna_share">Share score</button>
        </div>
      </div>

      <div style="margin-top:14px">
  <div class="row" style="justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap">
    <h3 style="margin:0" data-i18n="dna_allowances_title">Approvals</h3>

    <!-- RIGHT ACTIONS (gated) -->
    <div class="row" style="gap:10px; flex-wrap:wrap">
      <!-- New: Full access button (default visible) -->
      <button class="btn btn-secondary" id="dna-full-access" data-i18n="dna_full_access_btn">
        UNLOCK ADVANCED (PASS / CYCX)
      </button>

      <!-- Existing: Revoke all (default hidden; becomes visible only if eligible) -->
      <button class="btn btn-ghost hidden" id="dna-revoke-all" data-i18n="ap_revoke_all">
        Revoke All (non-zero)
      </button>
    </div>
  </div>
<!-- Locked notice (default visible) -->
<div id="dna-approvals-locked" class="card" style="margin-top:10px; padding:14px 14px 12px; line-height:1.55;">

  <!-- Title -->
  <div class="small" data-i18n="dna_locked_title"
       style="font-weight:650; letter-spacing:.2px;">
    Unlock to see who can spend your tokens — and revoke in 1 click.
  </div>

  <!-- Body -->
  <div class="small muted" data-i18n="dna_locked_body" style="margin-top:8px;">
    Full access (spender details + revoke tools) is available for:
    <div style="margin-top:8px; padding-left:14px;">
      • <span style="font-weight:650; opacity:.98;" data-i18n="dna_locked_body_fp">Founder Pass holders</span>, or<br>
      • <span style="font-weight:650; opacity:.98;" data-i18n="dna_locked_body_cycx">CYCX holders (after launch)</span>.
    </div>
  </div>

  <!-- Dynamic eligibility msg -->
  <div id="dna-elig-msg" class="small" style="margin-top:10px;"></div>

  <!-- Safe check -->
  <div class="small" data-i18n="dna_locked_safe"
       style="margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,.08); opacity:.95;">
    <div style="font-weight:700; opacity:.98; margin-bottom:6px;" data-i18n="dna_locked_safe_title">
      Safe check:
    </div>
    <div data-i18n="dna_locked_safe_body">
      Connect to check eligibility (public address + on-chain balance).<br>
      <span style="font-weight:750;">No signature. No transactions.</span><br>
      We only read on-chain data. Any revoke requires your explicit approval in-wallet.
    </div>
  </div>

  <!-- CTA line -->
  <div class="small muted" data-i18n="dna_locked_cta"
       style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,.08); opacity:.85;">
    Unlock includes spender reveal, revoke buttons, and Revoke All (non-zero).
  </div>

</div>



  <!-- Approvals content (default hidden) -->
  <div id="dna-approvals-content" class="hidden">
    <div id="ap-table" class="table ap-table" style="margin-top:10px;">
      <div class="trow head">
        <div class="cell">Token</div>
        <div class="cell hide-sm">Spender</div>
        <div class="cell">Allowance</div>
        <div class="cell hide-sm">Verified</div>
        <div class="cell hide-sm">Last Updated</div>
        <div class="cell">Risk</div>
        <div class="cell">Action</div>
      </div>

      <div class="trow">
        <div class="cell muted">—</div>
        <div class="cell muted hide-sm">—</div>
        <div class="cell muted">—</div>
        <div class="cell muted hide-sm">—</div>
        <div class="cell muted hide-sm">—</div>
        <div class="cell muted hide-sm">—</div>
        <div class="cell muted">—</div>
        <div class="cell muted">—</div>
      </div>
    </div>

    <div class="small" style="margin-top:8px" data-i18n="dna_table_note">
      Tip: revoke “infinite” approvals you don’t fully trust. Verified status and flags are informational only.
    </div>
  </div>
</div>

  </div>
</section>


      <section class="panel-shell hidden" id="panel-liq">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_liq_kicker">Token + Liquidity Scan</div>
            <div class="panel-title" data-i18n="p_liq_title">DEX Registry liquidity checks</div>
            <div class="panel-sub" data-i18n="p_liq_sub">
              We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="liq-wallet" data-i18n="wallet_not_connected">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseLiq" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="liq_input_title">Token + Network</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="liq-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="liq-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="liq_tip">
                Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="liq_dex_label">DEX registry (checked)</div>
              <div class="small" id="liq-dex-note" style="margin-top:6px;"></div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="liq-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="liq-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="liq-share-x" data-i18n="btn_share_x">Share to X</button>
              </div>
            </div>

            <div id="liq-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="liq_results_title">Liquidity Results</h3>
            <div class="small" data-i18n="liq_results_hint">
              V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.
            </div>

            <div id="liq-out" class="status info" style="display:block; margin-top:10px;" data-i18n="liq_ready_html">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="liq-risk" class="risk-badges"></div>
            <div id="liq-tablewrap" style="margin-top:10px;"></div>
          </div>
        </div>
      </section>
      <section class="panel-shell hidden" id="panel-rpc">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_rpc_kicker">RPC Health Checker</div>
            <div class="panel-title" data-i18n="p_rpc_title">Find the best endpoint</div>
            <div class="panel-sub" data-i18n="p_rpc_sub">
              We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseRpc" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_inputs">Inputs</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="rpc-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_private_label">Private RPC (saved locally)</div>
              <input id="rpc-private" class="mono" placeholder="https://... (stored locally only)" data-i18n-placeholder="ph_rpc_private" />
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-private-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="rpc-private-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>
              <div class="small" style="margin-top:8px" data-i18n="rpc_private_tip">
                Not embedded in HTML. Stored in your browser only (localStorage).
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC (top priority)</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." data-i18n-placeholder="ph_rpc_custom" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-share-x" data-i18n="btn_share_x">Share to X</button>
              </div>
            </div>

            <div class="field" style="margin-top:14px">
              <h3 data-i18n="rpc_dev_title">Developer custom logs test</h3>
              <div class="small" data-i18n="rpc_dev_hint">
                Optional: test logs for a contract. This helps developers verify their own RPC stability.
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_addr">Contract address (optional)</div>
                <input id="rpc-dev-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
              </div>

              <div class="field">
                <div class="label" data-i18n="rpc_dev_topic">Topic0 (optional)</div>
                <input id="rpc-dev-topic" class="mono" placeholder="0xddf252ad... (Transfer) or leave empty" data-i18n-placeholder="ph_rpc_dev_topic" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="rpc-dev-run" style="padding:10px 14px; font-size:12px;" data-i18n="rpc_dev_run">Run custom test</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
             <div class="trow head rpc">
             <div class="cell">RPC</div>
             <div class="cell">Metrics</div>
             <div class="cell">Status</div>
             </div>
           </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-tx">
  <div class="panel-head">
    <div>
      <div class="panel-kicker" data-i18n="p_tx_kicker">Tx Decoder</div>
      <div class="panel-title" data-i18n="p_tx_title">Decode a transaction</div>
      <div class="panel-sub" data-i18n="p_tx_sub">
        Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).
      </div>
    </div>
    <div class="panel-actions">
      <button class="btn btn-ghost" id="btnCloseTx" data-i18n="btn_close">Close</button>
    </div>
  </div>

  <div class="grid-2">
    <!-- LEFT: INPUT -->
    <div class="card">
      <h3 data-i18n="tx_input_title">Tx Input</h3>

      <div class="field">
        <div class="label" data-i18n="net_label">Network</div>
        <select id="tx-net">
          <option value="bsc">BSC (BNB Chain)</option>
          <option value="eth">Ethereum</option>
        </select>
      </div>

      <div class="field">
        <div class="label" data-i18n="tx_hash_label">Transaction hash</div>
        <input id="tx-hash" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
        <div class="small" style="margin-top:8px" data-i18n="tx_tip">
          Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.
        </div>
      </div>

      <div class="field">
        <div class="row">
          <button class="btn btn-primary" id="tx-run" data-i18n="btn_decode">Decode</button>
          <button class="btn btn-ghost" id="tx-copy-md" data-i18n="btn_copy_md">Copy Markdown</button>
        </div>
      </div>

      <div id="tx-status" class="status info"></div>
    </div>

    <!-- RIGHT: OUTPUT -->
    <div class="card">
      <h3 data-i18n="tx_results_title">Decoded Output</h3>
      
<!-- 4-line Security Summary (always visible) -->
<div id="tx-sum" class="tx-sum" style="margin-top:10px;">
  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_action_k">Action</span>
    <span class="tx-sum-v" id="tx-sum-action">—</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_risk_k">Risk</span>
    <span class="tx-sum-v" id="tx-sum-risk">—</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_target_k">Target</span>
    <span class="tx-sum-v mono" id="tx-sum-target">—</span>
  </div>

  <div class="tx-sum-line">
    <span class="tx-sum-k" data-i18n="tx_sum_impact_k">Max impact</span>
    <span class="tx-sum-v" id="tx-sum-impact">—</span>
  </div>
</div>
      <!-- Main decoded text / ready state -->
      <div id="tx-out" class="status info" style="display:block; margin-top:10px;" data-i18n="tx_ready_html">
        <strong>Ready.</strong><br>
        Paste a tx hash and click <b>Decode</b>.
      </div>

      <!-- Parsed events / extra cards -->
      <div id="tx-events" style="margin-top:10px;"></div>
    </div>
  </div>
</section>
            <section class="panel-shell hidden" id="panel-dev">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_dev_kicker">Dev Tools</div>
            <div class="panel-title" data-i18n="p_dev_title">Bookmarklet + Local Monitor</div>
            <div class="panel-sub" data-i18n="p_dev_sub">
              Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseDev" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="bm_title">Bookmarklet Generator</h3>
            <div class="small" data-i18n="bm_hint">
              Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.
            </div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="bm_base_label">Hub URL (this page)</div>
              <input id="bm-base" class="mono" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="bm-generate" data-i18n="bm_generate">Generate</button>
                <button class="btn btn-ghost" id="bm-copy" data-i18n="bm_copy">Copy Bookmarklet</button>
              </div>
            </div>
            <a id="bm-drag" class="bm-drag" href="#">
  <img class="bm-drag-icon" src="/logo.png" alt="CycleX">
  <span data-i18n="bm_drag_label">CycleX – Security Hub</span>
</a>

            <div id="bm-out" class="status info"></div>
            <div id="bm-tip" class="bm-tip" data-i18n="bm_tip">
  Add the bookmarklet to your browser, then check any contract from any site with one click.
</div>
          </div>

          <div class="card">
            <h3 data-i18n="mon_list_title">Contract Monitor (local)</h3>
            <div class="small" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>

            <div class="field" style="margin-top:12px">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="mon-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Contract address</div>
              <input id="mon-addr" class="mono" placeholder="0x..." data-i18n-placeholder="ph_0x" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
                <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
                <button class="btn btn-ghost" id="mon-export" data-i18n="mon_export">Copy JSON</button>
              </div>
            </div>

            <div id="mon-status" class="status info"></div>

            <div id="mon-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell" data-i18n="th_contract">Contract</div>
                <div class="cell" data-i18n="th_network">Network</div>
                <div class="cell hide-sm" data-i18n="th_last_seen">Last seen</div>
                <div class="cell" data-i18n="th_status">Status</div>
                <div class="cell" aria-hidden="true"></div>
              </div>

              <!-- ✅ placeholder row (JS will replace/append real rows) -->
              <div class="trow">
                <div class="cell muted">—</div>
                <div class="cell muted">—</div>
                <div class="cell muted hide-sm">—</div>
                <div class="cell muted">—</div>
                <div class="cell">
                  <button class="mon-remove" type="button"
                          data-action="mon-remove"
                          data-addr=""
                          data-i18n-title="remove"
                          data-i18n-aria-label="remove"
                          title="Remove"
                          aria-label="Remove">×</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>

    </main>
  </div>
 <!-- =========================
     ACCESS MODAL (PASS / CYCX)
     ========================= -->
<div class="cx-modal" id="access-modal" aria-hidden="true">
  <div class="cx-modal__backdrop" data-close-access></div>

  <div class="cx-modal__dialog" role="dialog" aria-modal="true" aria-labelledby="access-title">
    <div class="cx-modal__top">
      <div class="cx-modal__title" id="access-title" data-i18n="access_title">Get Access</div>
      <button class="cx-modal__close" type="button" data-close-access aria-label="Close">✕</button>
    </div>

    <div class="cx-modal__body">
      <div class="cx-modal__desc" data-i18n="access_desc">
        Unlock Advanced DNA tools in seconds. Your pass is non-tradable, and later you can convert it to CYCX when the public sale begins.
      </div>

      <div class="cx-modal__note">
        <span data-i18n="access_note">
          No signature needed to unlock. Revoke actions always require your approval in-wallet.
        </span>
      </div>

     <div class="cx-modal__actions">
  <button class="btn btn-primary" id="btn-pay-bnb" type="button" disabled>
    <span class="btn-main" data-i18n="access_pay_bnb">Buy Access Pass (BNB)</span>
    <span class="btn-sub">
      <span data-i18n="access_price_label">Price:</span>
      <span id="access-price-bnb">—</span>
    </span>
  </button>

  <button class="btn btn-secondary" id="btn-pay-usdt" type="button" disabled>
    <span class="btn-main" data-i18n="access_pay_usdt">Buy Access Pass (USDT)</span>
    <span class="btn-sub">
      <span data-i18n="access_price_label">Price:</span>
      <span id="access-price-usdt">—</span>
    </span>
  </button>
</div>

<div class="cx-modal__status muted" id="access-status" aria-live="polite"></div>

      <div class="cx-modal__foot muted" data-i18n="access_foot">
        Early access: $9 for first 500 access passes, then $19. 1 pass per wallet.
      </div>
    </div>
  </div>
</div>


</body>

  <!-- ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <!-- AppKit + App logic -->
  <script type="module">
    "use strict";

    var E = window.E || window.ethers;
    window.E = E;


    // =========================
    // AppKit (Reown)
    // =========================
    import { createAppKit } from "https://esm.sh/@reown/appkit@1.8.15";
    import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@1.8.15";
    import { bsc, mainnet } from "https://esm.sh/@reown/appkit/networks";

    const APPKIT_PROJECT_ID = "7886bcb95105e9e47337cec481d5de75";

    const appkit = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc, mainnet],
      defaultNetwork: bsc,
      projectId: APPKIT_PROJECT_ID,
      analytics: false,
      metadata: {
        name: "CycleX",
        description: "CycleX Security Hub",
        url: window.location.origin,
        icons: [`${window.location.origin}/logo.png`]
      }
    });

    window.CxAppKitModal = appkit;

    async function waitForWalletProvider(timeoutMs = 12000) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const p = window.CxAppKitModal?.getWalletProvider?.();
          if (p) return p;
        } catch {}
        await new Promise(r => setTimeout(r, 250));
      }
      return null;
    }

   // =========================
// i18n (4 languages)
// =========================
const translations = {
  en: {
    // header / hero
    brand_sub: "On-Chain Security & Rewards",
    hero_kicker: "CycleX Security Hub",
    hero_title: "Advanced Approval Intelligence",
    hero_subtitle: "Understand your approvals, spot risky spenders, and unlock advanced revoke tools — across BSC + Ethereum.",
    btn_back: "Back to Site",
    btn_access: "Get Access (PASS / CYCX)",
    wallet_not_connected: "not connected",
    btn_quick: "Run Quick Scan",
    hero_note: "Note: These checks are informational and do not guarantee safety. No signatures. No transactions. Always verify contracts and URLs independently.",
    hero_micro_quick: "Start here — no wallet needed.",
    hero_micro_access: "Unlock advanced approvals + revoke tools.",
    tools_kicker: "CHOOSE A TOOL",

    // tiles
    cube_quick_title: "Quick Scan",
    cube_quick_desc: "Fast token sanity-check + shareable report + cache.",
    cube_liq_title: "Token + Liquidity Scan",
    cube_liq_desc: "DEX registry checks (Pancake/Uni): token vs WBNB/WETH and USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc: "Check and revoke ERC-20 allowances safely (approve → 0).",
    cube_rpc_title: "RPC Health Checker",
    cube_rpc_desc: "Latency + chainId + block + eth_call + read logs + dev custom test.",
    cube_tx_title: "Tx Decoder",
    cube_tx_desc: "Decode inputs + common events (Transfer/Approval) from a tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc: "Bookmarklet generator + local contract monitor (no server).",
    cube_walletdna_title: "Wallet Security DNA",
    cube_walletdna_desc: "Approval & Permission Risk Snapshot",

    // tile badges
    badge_fast: "Fast",
    badge_share: "Share",
    badge_cache: "Cache",
    badge_dex: "DEX",
    badge_pairs: "Pairs",
    badge_wallet: "Wallet",
    badge_safe: "Safe",
    badge_copy: "Copy",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",
    badge_safe: "Safe",

    // generic
    pill_wallet: "Wallet",
    btn_close: "Close",
    btn_save: "Save",
    btn_clear: "Clear",
    btn_scan: "Scan",
    btn_decode: "Decode",
    btn_copy_md: "Copy Markdown",
    btn_copy_link: "Copy Share Link",
    btn_copy_json: "Copy JSON",
    btn_copy_xtext: "Copy X text",

    // quick panel
    p_quick_kicker: "Quick Scan",
    p_quick_title: "Score a token in seconds",
    p_quick_sub:
      "Paste a token address, choose network, run scan. Cached for 10 minutes. Generate shareable text + JSON + Markdown.",
    quick_input_title: "Token Input",
    net_label: "Network",
    addr_label: "Token contract",
    qs_tip:
      'Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run (rate-limited).',
    options_label: "Options",
    opt_require_liq: "Require liquidity (stricter score)",
    opt_show_json: "Enable JSON report (copy)",
    api_keys_label: "Explorer API keys (optional)",
    opt_use_explorer_apis: "Use BscScan/Etherscan (adds Verified + ABI heuristics)",
    api_keys_tip:
      "Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.",
    results_title: "Results",
    results_hint:
      "Green / Yellow / Red signals. Not a guarantee — just verifiable on-chain checks.",

    // liquidity panel
    p_liq_kicker: "Token + Liquidity Scan",
    p_liq_title: "DEX registry liquidity checks",
    p_liq_sub:
      "We check PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 factories. Pairs tested: token vs WBNB/WETH and token vs USDT.",
    liq_input_title: "Token + Network",
    liq_tip:
      'Tip: open with <span class="mono">?tool=liq&net=bsc&token=0x...</span> to auto-run.',
    liq_dex_label: "DEX registry (checked)",
    liq_results_title: "Liquidity Results",
    liq_results_hint:
      "V2: pair + reserves snapshot. V3: pool existence + liquidity() + slot0 tick snapshot.",

    
    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "Check and revoke allowances",
    p_app_sub:
      "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
    ap_settings_title: "Settings",
    ap_connected: "Connected:",
    ap_connect: "Connect / Refresh",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "Start with a router preset, then add tokens you want to clean up.",
    ap_tokens_label: "Token list (one per line)",
    ap_seed: "Seed common tokens",
    ap_seed_history: "Use scan history",
    ap_check: "Check Allowances",
    ap_revoke_all: "Revoke All (non-zero)",
    ap_results: "Allowances",
    ap_results_hint:
      "If allowance is “infinite”, revoke is recommended unless you fully trust the spender.",
    safe_mode_note:
      "Safe mode: actions that require a signature are disabled until you connect a wallet.",
    // DNA (Wallet Security DNA)
p_dna_kicker: "WALLET SECURITY DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Approval & Permission Risk Snapshot",

pill_wallet: "Wallet",
wallet_not_connected: "not connected",
btn_close: "Close",

dna_controls_title: "DNA Scan",
dna_wallet_address_label: "Wallet Address",
dna_wallet_address_ph: "0x... (optional if you connect)",
dna_wallet_address_tip: "You can scan by address first. Connect a wallet only when you want to revoke.",

net_label: "Network",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Connected:",
dna_connect: "Connect Wallet",
dna_run: "Scan",
dna_reset: "Reset",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "Score is a snapshot. Always verify before signing.",

dna_score: "Score",
dna_risk_level: "Risk",

dna_tips_title: "Tips",
dna_tips_placeholder: "—",
dna_share: "Share score",

dna_allowances_title: "Approvals",
dna_table_note: "Tip: revoke “infinite” approvals you don’t fully trust. Verified status and flags are informational only.",

dna_full_access_btn: "UNLOCK ADVANCED (PASS / CYCX)",
 dna_locked_title: "Unlock to see who can spend your tokens — and revoke in 1 click.",
    dna_locked_body: "Full access (spender details + revoke tools) is available for:",
    dna_locked_body_fp: "Founder Pass holders",
    dna_locked_body_cycx: "CYCX holders (after launch).",
    dna_locked_safe_title: "Safe check:",
    dna_locked_safe_body:
      "Connect to check eligibility (public address + on-chain balance).<br>" +
      "<span style=\"font-weight:750;\">No signature. No transactions.</span><br>" +
      "We only read on-chain data. Any revoke requires your explicit approval in-wallet.",
    dna_locked_cta: "Unlock includes spender reveal, revoke buttons, and Revoke All (non-zero).",
dna_elig_checking: "Checking eligibility (PASS / CYCX)…",
dna_elig_ok: "Eligible — unlocking approvals",
dna_elig_no: "Not eligible for full access (need 1 PASS or at least 100 CYCX).",
dna_elig_wrong_net: "Please switch to BSC (BNB Chain) to check PASS / CYCX eligibility.",
dna_elig_error: "Could not check eligibility. Please try again.",
    dna_meta_approvals_detected: "Approvals detected:",
dna_meta_spenders_hidden: "Spender details hidden until unlock",

    access_title: "Get Access",
access_desc: "Unlock Advanced DNA tools in seconds. Your access pass is non-tradable (soulbound), and later you can convert it to CYCX when the public sale begins.",
access_note: "No signature needed to unlock. Revoke actions always require your approval in-wallet.",
access_pay_bnb: "Buy Access Pass (BNB)",
access_pay_usdt: "Buy Access Pass (USDT)",
access_foot: "Early access: $9 for first 500 access passes, then $19. 1 pass per wallet.",
    access_price_label: "Price:",

    // rpc panel
    p_rpc_kicker: "RPC Health Checker",
    p_rpc_title: "Find the best endpoint",
    p_rpc_sub:
      "We test RPCs with latency + chainId + block + eth_call + read logs. Includes a developer custom logs test and saves the best RPC locally.",
    rpc_inputs: "Inputs",
    rpc_private_label: "Private RPC (saved locally)",
    rpc_private_tip:
      "Not embedded in HTML. Stored in your browser only (localStorage).",
    rpc_custom_label: "Optional custom RPC (top priority)",
    rpc_test: "Test RPCs",
    rpc_copy_best: "Copy Best RPC",
    rpc_results: "Results",
    rpc_tip:
      "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",
    rpc_dev_title: "Developer custom logs test",
    rpc_dev_hint:
      "Optional: test logs for a contract. This helps developers verify their own RPC stability.",
    rpc_dev_addr: "Contract address (optional)",
    rpc_dev_topic: "Topic0 (optional)",
    rpc_dev_run: "Run custom test",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Decode a transaction",
    p_tx_sub:
      "Paste a tx hash. We fetch tx + receipt and decode common inputs and events (Transfer / Approval + common swap calls).",
    tx_input_title: "Tx Input",
    tx_hash_label: "Transaction hash",
    tx_tip:
      'Tip: open with <span class="mono">?tool=tx&net=bsc&tx=0x...</span> to auto-run.',
    tx_results_title: "Decoded Output",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + Local Monitor",
    p_dev_sub:
      "Generate a bookmarklet that sends token/tx from explorers to CycleX Hub. Also includes a local contract monitor (watchlist stored in your browser).",
    bm_title: "Bookmarklet Generator",
    bm_hint:
      "Drag to bookmarks bar or copy the generated bookmarklet. Use it on BscScan/Etherscan pages.",
    bm_base_label: "Hub URL (this page)",
    bm_generate: "Generate",
    bm_copy: "Copy Bookmarklet",

    mon_add_title: "Add to watchlist",
    mon_list_title: "Contract Monitor (local)",
    mon_list_hint: "Stored locally only. No server tracking.",
    mon_add: "Add",
    mon_check: "Check all",
    mon_export: "Copy JSON",

    // footer
    footer_left:
      "CycleX Security Hub runs client-side and reads public on-chain data.",
    footer_tagline: "Verify twice. Connect only when you trust the page.",
    // --- ADD THESE KEYS (EN) ---
title_back_to_cyclex: "Back to CycleX",
aria_lang_selector: "Language selector",
badge_table: "Table",
btn_share_x: "Share to X",
btn_share_tg: "Share to Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "Custom…",

th_token: "Token",
th_allowance: "Allowance",
th_symbol: "Symbol",
th_action: "Action",
th_rpc: "RPC",
th_ms: "ms",
th_chain: "chain",
th_block: "block",
th_call: "call",
th_logs: "logs",
th_status: "status",
th_contract: "Contract",
th_network: "Network",
th_last_seen: "Last seen",
    th_remove: "Remove",
    bm_tip: "Add the bookmarklet to your browser, then check any contract from any site with one click.",
bm_drag_label: "CycleX – Security Hub",

qs_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
liq_ready_html: "<strong>Ready.</strong><br>Paste a token address and click <b>Scan</b>.",
tx_ready_html: "<strong>Ready.</strong><br>Paste a tx hash and click <b>Decode</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (stored locally)",
ph_unified_key: "Unified API Key (Stored Locally)",
ph_etherscan_key: "Etherscan API key (stored locally)",
ph_rpc_private: "https://... (stored locally only)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) or leave empty"

    
  },

  zh: {
    // header / hero
    brand_sub: "链上安全与奖励",
    hero_kicker: "CycleX 安全中心",
    hero_title: "高级授权洞察",
    hero_subtitle: "了解你的授权，识别高风险 spender，并解锁高级撤销工具 —— 覆盖 BSC 与以太坊。",
    btn_back: "返回主站",
    btn_access: "获取访问权限（PASS / CYCX)",
    wallet_not_connected: "未连接",
    btn_quick: "运行快速扫描",
    hero_note: "提示：这些检查仅供参考，不能保证安全。无需签名，无需交易。请务必自行核对合约与链接（URL）。",
    hero_micro_quick: "从这里开始 — 无需连接钱包。",
    hero_micro_access: "解锁高级授权分析 + 撤销工具。",
    tools_kicker: "选择工具",

    // tiles
    cube_quick_title: "快速扫描",
    cube_quick_desc: "快速代币体检 + 可分享报告 + 缓存。",
    cube_liq_title: "代币 + 流动性扫描",
    cube_liq_desc: "DEX 检查（Pancake/Uni）：代币 vs WBNB/WETH 与 USDT。",
    cube_approvals_title: "授权卫士",
    cube_approvals_desc: "检查并安全撤销 ERC-20 授权（approve → 0）。",
    cube_rpc_title: "RPC 健康检测",
    cube_rpc_desc: "延迟 + chainId + 区块 + eth_call + 读取 logs + 开发自定义测试。",
    cube_tx_title: "交易解码",
    cube_tx_desc: "从交易哈希解码输入与常见事件（Transfer/Approval）。",
    cube_dev_title: "开发工具",
    cube_dev_desc: "书签脚本生成器 + 本地合约监控（无服务器）。",
    cube_walletdna_title: "钱包安全 DNA",
    cube_walletdna_desc: "授权与权限风险概览",

    // tile badges
    badge_fast: "快速",
    badge_share: "分享",
    badge_cache: "缓存",
    badge_dex: "DEX",
    badge_pairs: "交易对",
    badge_wallet: "钱包",
    badge_safe: "安全",
    badge_copy: "复制",
    badge_dev: "开发",
    badge_decode: "解码",
    badge_receipt: "回执",
    badge_events: "事件",
    badge_tools: "工具",
    badge_bookmarklet: "书签脚本",
    badge_local: "本地",
    badge_safe: "安全",

    // generic
    pill_wallet: "钱包",
    btn_close: "关闭",
    btn_save: "保存",
    btn_clear: "清除",
    btn_scan: "扫描",
    btn_decode: "解码",
    btn_copy_md: "复制 Markdown",
    btn_copy_link: "复制分享链接",
    btn_copy_json: "复制 JSON",
    btn_copy_xtext: "复制 X 文案",

    // quick panel
    p_quick_kicker: "快速扫描",
    p_quick_title: "几秒内给代币打分",
    p_quick_sub:
      "粘贴代币地址，选择网络并扫描。缓存 10 分钟。可生成可分享文本 + JSON + Markdown。",
    quick_input_title: "代币输入",
    net_label: "网络",
    addr_label: "代币合约",
    qs_tip:
      '提示：可用 <span class="mono">?tool=quick&net=bsc&token=0x...</span> 打开自动运行（限速）。',
    options_label: "选项",
    opt_require_liq: "要求有流动性（更严格评分）",
    opt_show_json: "启用 JSON 报告（可复制）",
    api_keys_label: "区块浏览器 API Key（可选）",
    opt_use_explorer_apis: "使用 BscScan/Etherscan（增加 Verified + ABI 规则）",
    api_keys_tip:
      "Key 仅保存在浏览器本地（localStorage）。不要把 Key 写进公开 HTML。",
    results_title: "结果",
    results_hint:
      "绿色 / 黄色 / 红色信号。不是保证——只是可验证的链上检查。",

    // liquidity panel
    p_liq_kicker: "代币 + 流动性扫描",
    p_liq_title: "DEX 注册表流动性检查",
    p_liq_sub:
      "检查 PancakeSwap（BSC）/ Uniswap（ETH）V2 + V3 工厂。测试交易对：代币 vs WBNB/WETH 与代币 vs USDT。",
    liq_input_title: "代币 + 网络",
    liq_tip:
      '提示：可用 <span class="mono">?tool=liq&net=bsc&token=0x...</span> 打开自动运行。',
    liq_dex_label: "DEX 注册表（已检查）",
    liq_results_title: "流动性结果",
    liq_results_hint:
      "V2：交易对 + 储备快照。V3：池子存在性 + liquidity() + slot0 tick 快照。",

    // approvals panel
    p_app_kicker: "授权卫士",
    p_app_title: "检查并撤销授权",
    p_app_sub:
      "填写 spender + 代币列表（或一键填入常用代币）。读取 allowance(owner, spender)，并用 approve(spender, 0) 撤销。",
    ap_settings_title: "设置",
    ap_connected: "已连接：",
    ap_connect: "连接 / 刷新",
    ap_spender_label: "Spender 预设",
    ap_spender_tip: "先选路由预设，再添加你想清理的代币。",
    ap_tokens_label: "代币列表（每行一个）",
    ap_seed: "填入常用代币",
    ap_seed_history: "使用扫描历史",
    ap_check: "检查授权",
    ap_revoke_all: "撤销全部（非零）",
    ap_results: "授权列表",
    ap_results_hint:
      "若授权为“无限”，除非你完全信任该 spender，否则建议撤销。",
    safe_mode_note:
      "安全模式：需要签名的操作会在连接钱包前被禁用。",
    // DNA（钱包安全 DNA）
p_dna_kicker: "钱包安全 DNA",
p_dna_title: "钱包安全 DNA",
p_dna_sub: "授权与权限风险快照",

pill_wallet: "钱包",
wallet_not_connected: "未连接",
btn_close: "关闭",

dna_controls_title: "DNA 扫描",
dna_wallet_address_label: "钱包地址",
dna_wallet_address_ph: "0x...（可选，连接钱包后可自动填入）",
dna_wallet_address_tip: "可先用地址扫描。仅在需要撤销时再连接钱包。",

net_label: "网络",
net_bsc: "BSC（BNB Chain）",
net_eth: "以太坊",
net_polygon: "Polygon",

dna_connected: "已连接：",
dna_connect: "连接钱包",
dna_run: "扫描",
dna_reset: "重置",

dna_results_title: "钱包安全 DNA",
dna_results_hint: "评分是快照。签名前请务必自行核实。",

dna_score: "评分",
dna_risk_level: "风险",

dna_tips_title: "提示",
dna_tips_placeholder: "—",
dna_share: "分享评分",

dna_allowances_title: "授权",
dna_table_note: "提示：不完全信任的“无限”授权建议撤销。Verified 与 Flags 仅供参考。",
        dna_full_access_btn: "解锁高级功能（通行证 / CYCX）",
   dna_locked_title: "解锁以查看谁能动用你的代币，并一键撤销授权。",
    dna_locked_body: "完整权限（授权方详情 + 撤销工具）适用于：",
    dna_locked_body_fp: "Founder Pass 持有者",
    dna_locked_body_cycx: "CYCX 持有者（上线后）。",
    dna_locked_safe_title: "安全检查：",
    dna_locked_safe_body:
      "连接钱包以检查资格（公开地址 + 链上余额）。<br>" +
      "<span style=\"font-weight:750;\">无需签名。无任何交易。</span><br>" +
      "我们只读取链上数据。任何撤销操作都需要你在钱包内明确确认。",
    dna_locked_cta: "解锁包含：显示授权方、撤销按钮，以及“一键撤销（非零）”。",
    dna_elig_checking: "正在检查资格（PASS / CYCX）…",
    dna_elig_ok: "符合资格 — 正在解锁授权信息",
    dna_elig_no: "不符合完整访问资格（需要 1 个 PASS 或至少 100 CYCX）。",
    dna_elig_wrong_net: "请切换到 BSC（BNB Chain）以检查 PASS / CYCX 资格。",
    dna_elig_error: "无法检查资格，请重试。",
    dna_meta_approvals_detected: "检测到授权：",
dna_meta_spenders_hidden: "解锁前隐藏授权方详情",

    access_title: "获取访问权限",
access_note: "解锁无需签名。任何撤销操作都需要你在钱包中确认。",
access_pay_bnb: "购买访问通行证（BNB）",
access_pay_usdt: "购买访问通行证（USDT）",
access_desc: "几秒内解锁高级 DNA 工具。你的 Access Pass 不可转让（Soulbound），并且仅在公开发售开始时可转换为 CYCX。",
access_foot: "早鸟：前 500 个 Access Pass 仅 $9，之后 $19。每个钱包限 1 个。",
    access_price_label: "价格：",

    // rpc panel
    p_rpc_kicker: "RPC 健康检测",
    p_rpc_title: "找到最佳节点",
    p_rpc_sub:
      "测试 RPC：延迟 + chainId + 区块 + eth_call + 读取 logs。包含开发者自定义 logs 测试，并把最佳 RPC 存到本地。",
    rpc_inputs: "输入",
    rpc_private_label: "私有 RPC（本地保存）",
    rpc_private_tip:
      "不会写进 HTML，只保存在你的浏览器（localStorage）。",
    rpc_custom_label: "可选自定义 RPC（优先级最高）",
    rpc_test: "测试 RPC",
    rpc_copy_best: "复制最佳 RPC",
    rpc_results: "结果",
    rpc_tip:
      "提示：部分 RPC 会因 CORS/超时失败。运行测试并选择稳定且最快的。",
    rpc_dev_title: "开发者自定义 logs 测试",
    rpc_dev_hint:
      "可选：对某合约测试 logs，帮助开发者验证 RPC 的稳定性。",
    rpc_dev_addr: "合约地址（可选）",
    rpc_dev_topic: "Topic0（可选）",
    rpc_dev_run: "运行自定义测试",

    // tx panel
    p_tx_kicker: "交易解码",
    p_tx_title: "解码一笔交易",
    p_tx_sub:
      "粘贴交易哈希。获取 tx + receipt，并解码常见输入与事件（Transfer / Approval + 常见 swap 调用）。",
    tx_input_title: "交易输入",
    tx_hash_label: "交易哈希",
    tx_tip:
      '提示：可用 <span class="mono">?tool=tx&net=bsc&tx=0x...</span> 打开自动运行。',
    tx_results_title: "解码输出",

    // dev panel
    p_dev_kicker: "开发工具",
    p_dev_title: "书签脚本 + 本地监控",
    p_dev_sub:
      "生成书签脚本，把浏览器页面上的代币/交易一键发送到 CycleX Hub。也包含本地合约监控（列表保存在浏览器）。",
    bm_title: "书签脚本生成器",
    bm_hint:
      "拖到书签栏或复制生成的书签脚本。在 BscScan/Etherscan 页面使用。",
    bm_base_label: "Hub URL（当前页面）",
    bm_generate: "生成",
    bm_copy: "复制书签脚本",

    mon_add_title: "加入监控列表",
    mon_list_title: "合约监控（本地）",
    mon_list_hint: "仅本地保存。无服务器跟踪。",
    mon_add: "添加",
    mon_check: "全部检查",
    mon_export: "复制 JSON",

    // footer
    footer_left: "CycleX 安全中心在本地运行，读取公开链上数据。",
    footer_tagline: "多验证一次。只在信任页面时连接钱包。",
    // --- ADD THESE KEYS (ZH) ---
title_back_to_cyclex: "返回 CycleX",
aria_lang_selector: "语言选择",
badge_table: "表格",
btn_share_x: "分享到 X",
btn_share_tg: "分享到 Telegram",
net_bsc: "BSC（BNB Chain）",
net_eth: "以太坊",
spender_pcs_router: "PancakeSwap 路由器（BSC）",
spender_uni_router: "Uniswap V2 路由器（ETH）",
spender_custom: "自定义…",

th_token: "代币",
th_allowance: "授权额度",
th_symbol: "符号",
th_action: "操作",
th_rpc: "RPC",
th_ms: "毫秒",
th_chain: "链",
th_block: "区块",
th_call: "调用",
th_logs: "日志",
th_status: "状态",
th_contract: "合约",
th_network: "网络",
th_last_seen: "上次出现",
    th_remove: "移除",
    bm_tip: "将书签小工具添加到浏览器，然后一键从任何网站检查任何合约。",
bm_drag_label: "CycleX – 安全中心",

qs_ready_html: "<strong>准备就绪。</strong><br>粘贴代币地址并点击 <b>扫描</b>。",
liq_ready_html: "<strong>准备就绪。</strong><br>粘贴代币地址并点击 <b>扫描</b>。",
tx_ready_html: "<strong>准备就绪。</strong><br>粘贴交易哈希并点击 <b>解码</b>。",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API Key（本地保存）",
ph_unified_key: "Unified API Key (本地保存)",
ph_etherscan_key: "Etherscan API Key（本地保存）",
ph_rpc_private: "https://...（仅本地保存）",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad...（Transfer）或留空"

  },

  ar: {
    // header / hero
    brand_sub: "أمان ومكافآت على السلسلة",
    hero_kicker: "مركز أمان CycleX",
    hero_title: "ذكاء متقدم للأذونات",
    hero_subtitle: "افهم أذوناتك، اكتشف الجهات عالية المخاطر، وافتح أدوات إلغاء متقدمة — عبر BSC وEthereum.",
    btn_back: "العودة للموقع",
    btn_access: "الحصول على الوصول (PASS / CYCX)",
    wallet_not_connected: "غير متصل",
    btn_quick: "تشغيل فحص سريع",
    hero_note: "ملاحظة: هذه الفحوصات معلوماتية ولا تضمن السلامة. بدون توقيع. بدون معاملات. تحقّق دائمًا من العقود والروابط (URL) بنفسك.",
    hero_micro_quick: "ابدأ من هنا — لا حاجة لربط المحفظة.",
    hero_micro_access: "افتح تحليلات أذونات متقدمة + أدوات الإلغاء.",
    tools_kicker: "اختر أداة",

    // tiles
    cube_quick_title: "فحص سريع",
    cube_quick_desc: "فحص سريع للتوكن + تقرير قابل للمشاركة + كاش.",
    cube_liq_title: "فحص التوكن + السيولة",
    cube_liq_desc: "فحص DEX (Pancake/Uni): التوكن مقابل WBNB/WETH و USDT.",
    cube_approvals_title: "حارس الصلاحيات",
    cube_approvals_desc: "تحقق وألغِ صلاحيات ERC-20 بأمان (approve → 0).",
    cube_rpc_title: "فحص صحة RPC",
    cube_rpc_desc: "زمن الاستجابة + chainId + بلوك + eth_call + قراءة logs + اختبار مطوّر.",
    cube_tx_title: "فك تشفير Tx",
    cube_tx_desc: "فك تشفير المدخلات + أحداث شائعة (Transfer/Approval) من tx hash.",
    cube_dev_title: "أدوات المطوّر",
    cube_dev_desc: "مولّد Bookmarklet + مراقبة عقد محلية (بدون سيرفر).",
    cube_walletdna_title: "بصمة أمان المحفظة (DNA)",
    cube_walletdna_desc: "ملخص مخاطر الأذونات والتفويضات",

    // tile badges
    badge_fast: "سريع",
    badge_share: "مشاركة",
    badge_cache: "كاش",
    badge_dex: "DEX",
    badge_pairs: "أزواج",
    badge_wallet: "محفظة",
    badge_safe: "آمن",
    badge_copy: "نسخ",
    badge_dev: "مطوّر",
    badge_decode: "فك",
    badge_receipt: "إيصال",
    badge_events: "أحداث",
    badge_tools: "أدوات",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "محلي",
    badge_safe: "آمن",

    // generic
    pill_wallet: "محفظة",
    btn_close: "إغلاق",
    btn_save: "حفظ",
    btn_clear: "مسح",
    btn_scan: "فحص",
    btn_decode: "فك التشفير",
    btn_copy_md: "نسخ Markdown",
    btn_copy_link: "نسخ رابط المشاركة",
    btn_copy_json: "نسخ JSON",
    btn_copy_xtext: "نسخ نص X",

    // quick panel
    p_quick_kicker: "فحص سريع",
    p_quick_title: "قيّم توكن خلال ثوانٍ",
    p_quick_sub:
      "ألصق عنوان التوكن، اختر الشبكة، شغّل الفحص. يُحفظ بالكاش لمدة 10 دقائق. أنشئ نصاً قابلاً للمشاركة + JSON + Markdown.",
    quick_input_title: "إدخال التوكن",
    net_label: "الشبكة",
    addr_label: "عقد التوكن",
    qs_tip:
      'نصيحة: افتح <span class="mono">?tool=quick&net=bsc&token=0x...</span> للتشغيل التلقائي (محدود).',
    options_label: "الخيارات",
    opt_require_liq: "يتطلب سيولة (تقييم أكثر صرامة)",
    opt_show_json: "تفعيل تقرير JSON (نسخ)",
    api_keys_label: "مفاتيح API للمستكشف (اختياري)",
    opt_use_explorer_apis: "استخدام BscScan/Etherscan (يزيد Verified + قواعد ABI)",
    api_keys_tip:
      "المفاتيح تُحفظ محلياً في المتصفح (localStorage) فقط. لا تضعها داخل HTML عام.",
    results_title: "النتائج",
    results_hint:
      "إشارات خضراء/صفراء/حمراء. ليست ضماناً — مجرد فحوصات على السلسلة قابلة للتحقق.",

    // liquidity panel
    p_liq_kicker: "فحص التوكن + السيولة",
    p_liq_title: "فحص سيولة DEX",
    p_liq_sub:
      "نُجري فحص PancakeSwap (BSC) / Uniswap (ETH) V2 + V3. الأزواج: التوكن مقابل WBNB/WETH و USDT.",
    liq_input_title: "توكن + شبكة",
    liq_tip:
      'نصيحة: افتح <span class="mono">?tool=liq&net=bsc&token=0x...</span> للتشغيل التلقائي.',
    liq_dex_label: "سجل DEX (مفحوص)",
    liq_results_title: "نتائج السيولة",
    liq_results_hint:
      "V2: زوج + لقطة الاحتياطي. V3: وجود الحوض + liquidity() + لقطة slot0/tick.",

    // approvals panel
    p_app_kicker: "حارس الصلاحيات",
    p_app_title: "تحقق وألغِ الصلاحيات",
    p_app_sub:
      "أدخل spender + قائمة التوكنات (أو أضف الشائعة). نقرأ allowance(owner, spender) ونلغي عبر approve(spender, 0).",
    ap_settings_title: "الإعدادات",
    ap_connected: "متصل:",
    ap_connect: "اتصال / تحديث",
    ap_spender_label: "إعداد spender",
    ap_spender_tip:
      "ابدأ باختيار راوتر جاهز، ثم أضف التوكنات التي تريد تنظيفها.",
    ap_tokens_label: "قائمة التوكنات (كل سطر عنوان)",
    ap_seed: "إضافة توكنات شائعة",
    ap_seed_history: "استخدام سجل الفحص",
    ap_check: "فحص الصلاحيات",
    ap_revoke_all: "إلغاء الكل (غير الصفرية)",
    ap_results: "الصلاحيات",
    ap_results_hint:
      "إذا كانت الصلاحية “غير محدودة”، يُنصح بالإلغاء ما لم تكن تثق تماماً بالـ spender.",
    safe_mode_note:
      "الوضع الآمن: العمليات التي تتطلب توقيعاً معطلة حتى تتصل بالمحفظة.",
    // DNA (بصمة أمان المحفظة)
p_dna_kicker: "بصمة أمان المحفظة",
p_dna_title: "بصمة أمان المحفظة",
p_dna_sub: "لقطة لمخاطر الصلاحيات والأذونات",

pill_wallet: "المحفظة",
wallet_not_connected: "غير متصل",
btn_close: "إغلاق",

dna_controls_title: "فحص DNA",
dna_wallet_address_label: "عنوان المحفظة",
dna_wallet_address_ph: "0x... (اختياري إذا قمت بالاتصال)",
dna_wallet_address_tip: "يمكنك الفحص بالعنوان أولاً. اتصل بالمحفظة فقط عند رغبتك في الإلغاء.",

net_label: "الشبكة",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "متصل:",
dna_connect: "اتصال بالمحفظة",
dna_run: "فحص",
dna_reset: "إعادة ضبط",

dna_results_title: "بصمة أمان المحفظة",
dna_results_hint: "النتيجة لقطة سريعة. تحقّق دائماً قبل التوقيع.",

dna_score: "النتيجة",
dna_risk_level: "المخاطر",

dna_tips_title: "نصائح",
dna_tips_placeholder: "—",
dna_share: "مشاركة النتيجة",

dna_allowances_title: "الصلاحيات",
dna_table_note: "نصيحة: ألغِ الصلاحيات “غير المحدودة” التي لا تثق بها تماماً. حالة Verified و Flags معلوماتية فقط.",
    dna_full_access_btn: "فتح الميزات المتقدمة (PASS / CYCX)",
    dna_locked_title: "افتح الميزات لرؤية من يمكنه إنفاق رموزك — وإلغاء الصلاحيات بنقرة واحدة.",
    dna_locked_body: "الوصول الكامل (تفاصيل الجهة المُنفقِة + أدوات الإلغاء) متاح لـ:",
    dna_locked_body_fp: "حاملي Founder Pass",
    dna_locked_body_cycx: "حاملي CYCX (بعد الإطلاق).",
    dna_locked_safe_title: "فحص آمن:",
    dna_locked_safe_body:
      "اتصل للتحقق من الأهلية (العنوان العام + الرصيد على السلسلة).<br>" +
      "<span style=\"font-weight:750;\">لا يوجد توقيع. لا توجد معاملات.</span><br>" +
      "نحن نقرأ بيانات على السلسلة فقط. أي إلغاء يتطلب موافقتك الصريحة داخل المحفظة.",
    dna_locked_cta: "فتح القفل يتضمن: كشف الجهة المُنفقِة، أزرار الإلغاء، و\"إلغاء الكل (غير الصفري)\".",
    dna_elig_checking: "جارٍ التحقق من الأهلية (PASS / CYCX)…",
    dna_elig_ok: "مؤهل — جارٍ فتح قسم الموافقات",
    dna_elig_no: "غير مؤهل للوصول الكامل (تحتاج PASS واحد أو 100 CYCX على الأقل).",
    dna_elig_wrong_net: "يرجى التحويل إلى BSC (BNB Chain) للتحقق من أهلية PASS / CYCX.",
    dna_elig_error: "تعذر التحقق من الأهلية. يرجى المحاولة مرة أخرى.",
    dna_meta_approvals_detected: "عدد الموافقات المكتشفة:",
dna_meta_spenders_hidden: "تفاصيل المُنفق مخفية حتى فتح الوصول",

    access_title: "الحصول على الوصول",
access_note: "لا يلزم توقيع لفتح الوصول. أي عملية إلغاء تتطلب موافقتك داخل المحفظة.",
access_pay_bnb: "شراء بطاقة وصول (BNB)",
access_pay_usdt: "شراء بطاقة وصول (USDT)",
access_desc: "افتح أدوات DNA المتقدمة خلال ثوانٍ. بطاقة الوصول الخاصة بك غير قابلة للتداول (Soulbound)، ويمكنك لاحقًا تحويلها إلى CYCX عند بدء البيع العام.",
access_foot: "وصول مبكر: 9$ لأول 500 بطاقة وصول، ثم 19$. بطاقة واحدة لكل محفظة.",
    access_price_label: "السعر:",

    // rpc panel
    p_rpc_kicker: "فحص صحة RPC",
    p_rpc_title: "اعثر على أفضل Endpoint",
    p_rpc_sub:
      "نختبر RPC: زمن الاستجابة + chainId + بلوك + eth_call + قراءة logs. يتضمن اختبار logs للمطور ويحفظ أفضل RPC محلياً.",
    rpc_inputs: "المدخلات",
    rpc_private_label: "RPC خاص (محفوظ محلياً)",
    rpc_private_tip:
      "غير مدمج في HTML. محفوظ في متصفحك فقط (localStorage).",
    rpc_custom_label: "RPC مخصص (أولوية أعلى)",
    rpc_test: "اختبار RPCs",
    rpc_copy_best: "نسخ أفضل RPC",
    rpc_results: "النتائج",
    rpc_tip:
      "نصيحة: بعض RPCs تفشل بسبب CORS/مهلة. شغّل الاختبار واختر الأسرع والأكثر استقراراً.",
    rpc_dev_title: "اختبار logs مخصص للمطور",
    rpc_dev_hint:
      "اختياري: اختبر logs لعقد محدد للتأكد من استقرار الـ RPC.",
    rpc_dev_addr: "عنوان العقد (اختياري)",
    rpc_dev_topic: "Topic0 (اختياري)",
    rpc_dev_run: "تشغيل الاختبار",

    // tx panel
    p_tx_kicker: "فك تشفير Tx",
    p_tx_title: "فك تشفير معاملة",
    p_tx_sub:
      "ألصق tx hash. نجلب tx + receipt ونفك تشفير المدخلات والأحداث الشائعة (Transfer / Approval + استدعاءات swap).",
    tx_input_title: "إدخال Tx",
    tx_hash_label: "هاش المعاملة",
    tx_tip:
      'نصيحة: افتح <span class="mono">?tool=tx&net=bsc&tx=0x...</span> للتشغيل التلقائي.',
    tx_results_title: "المخرجات",

    // dev panel
    p_dev_kicker: "أدوات المطوّر",
    p_dev_title: "Bookmarklet + مراقبة محلية",
    p_dev_sub:
      "أنشئ Bookmarklet يرسل التوكن/المعاملة من المستكشف إلى CycleX Hub. ويتضمن مراقبة عقد محلية (قائمة محفوظة في متصفحك).",
    bm_title: "مولّد Bookmarklet",
    bm_hint:
      "اسحب إلى شريط الإشارات أو انسخ الـ Bookmarklet. استخدمه في صفحات BscScan/Etherscan.",
    bm_base_label: "رابط Hub (هذه الصفحة)",
    bm_generate: "إنشاء",
    bm_copy: "نسخ Bookmarklet",

    mon_add_title: "إضافة لقائمة المراقبة",
    mon_list_title: "مراقبة العقود (محلي)",
    mon_list_hint: "محفوظ محلياً فقط. بدون تتبع سيرفر.",
    mon_add: "إضافة",
    mon_check: "فحص الكل",
    mon_export: "نسخ JSON",

    // footer
    footer_left:
      "CycleX Security Hub يعمل على المتصفح ويقرأ بيانات عامة على السلسلة.",
    footer_tagline: "تحقق مرتين. لا تتصل إلا عندما تثق بالصفحة.",
    // --- ADD THESE KEYS (AR) ---
title_back_to_cyclex: "العودة إلى CycleX",
aria_lang_selector: "اختيار اللغة",
badge_table: "جدول",
btn_share_x: "مشاركة على X",
btn_share_tg: "مشاركة على تيليجرام",
net_bsc: "BSC (BNB Chain)",
net_eth: "إيثريوم",
spender_pcs_router: "راوتر PancakeSwap (BSC)",
spender_uni_router: "راوتر Uniswap V2 (ETH)",
spender_custom: "مخصص…",

th_token: "التوكن",
th_allowance: "الصلاحية",
th_symbol: "الرمز",
th_action: "إجراء",
th_rpc: "RPC",
th_ms: "مللي ثانية",
th_chain: "السلسلة",
th_block: "بلوك",
th_call: "استدعاء",
th_logs: "سجلات",
th_status: "الحالة",
th_contract: "العقد",
th_network: "الشبكة",
th_last_seen: "آخر ظهور",
    th_remove: "إزالة",
    bm_tip: "أضِف أداة الإشارة المرجعية إلى متصفحك، ثم افحص أي عقد من أي موقع بنقرة واحدة.",
bm_drag_label: "CycleX – مركز الأمان",

qs_ready_html: "<strong>جاهز.</strong><br>ألصق عنوان التوكن ثم اضغط <b>فحص</b>.",
liq_ready_html: "<strong>جاهز.</strong><br>ألصق عنوان التوكن ثم اضغط <b>فحص</b>.",
tx_ready_html: "<strong>جاهز.</strong><br>ألصق tx hash ثم اضغط <b>فك التشفير</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "مفتاح BscScan API (محفوظ محلياً)",
ph_unified_key: "Unified API Key (محفوظ محلياً)",
ph_etherscan_key: "مفتاح Etherscan API (محفوظ محلياً)",
ph_rpc_private: "https://... (محفوظ محلياً فقط)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) أو اتركه فارغاً"

  },

  ru: {
    // header / hero
    brand_sub: "Ончейн безопасность и награды",
    hero_kicker: "Центр безопасности CycleX",
    hero_title: "Продвинутая аналитика разрешений",
    hero_subtitle: "Понимайте свои approvals, выявляйте рискованных spender’ов и открывайте продвинутые инструменты revoke — для BSC и Ethereum.",
    btn_back: "Назад на сайт",
    btn_access: "Получить доступ (PASS / CYCX)",
    wallet_not_connected: "не подключен",
    btn_quick: "Запустить быстрый скан",
    hero_note: "Примечание: эти проверки носят информационный характер и не гарантируют безопасность. Без подписей. Без транзакций. Всегда проверяйте контракты и ссылки (URL) самостоятельно.",
    hero_micro_quick: "Начните здесь — кошелёк не нужен.",
    hero_micro_access: "Откройте продвинутый анализ approvals + инструменты revoke.",

    tools_kicker: "ВЫБЕРИТЕ ИНСТРУМЕНТ",

    // tiles
    cube_quick_title: "Быстрый скан",
    cube_quick_desc: "Быстрая проверка токена + шаримый отчёт + кэш.",
    cube_liq_title: "Токен + ликвидность",
    cube_liq_desc: "Проверка DEX (Pancake/Uni): токен vs WBNB/WETH и USDT.",
    cube_approvals_title: "Approval Guardian",
    cube_approvals_desc:
      "Проверка и безопасный отзыв ERC-20 allowance (approve → 0).",
    cube_rpc_title: "Проверка RPC",
    cube_rpc_desc:
      "Latency + chainId + block + eth_call + чтение logs + dev custom test.",
    cube_tx_title: "Декодер Tx",
    cube_tx_desc:
      "Декодирует input и события (Transfer/Approval) по tx hash.",
    cube_dev_title: "Dev Tools",
    cube_dev_desc:
      "Генератор bookmarklet + локальный монитор контрактов (без сервера).",
    cube_walletdna_title: "Security DNA кошелька",
    cube_walletdna_desc: "Снимок рисков разрешений и прав доступа",

    // tile badges
    badge_fast: "Быстро",
    badge_share: "Поделиться",
    badge_cache: "Кэш",
    badge_dex: "DEX",
    badge_pairs: "Пары",
    badge_wallet: "Кошелёк",
    badge_safe: "Безопасно",
    badge_copy: "Копировать",
    badge_dev: "Dev",
    badge_decode: "Decode",
    badge_receipt: "Receipt",
    badge_events: "Events",
    badge_tools: "Tools",
    badge_bookmarklet: "Bookmarklet",
    badge_local: "Local",
    badge_safe: "Безопасно",

    // generic
    pill_wallet: "Кошелёк",
    btn_close: "Закрыть",
    btn_save: "Сохранить",
    btn_clear: "Очистить",
    btn_scan: "Сканировать",
    btn_decode: "Декодировать",
    btn_copy_md: "Копировать Markdown",
    btn_copy_link: "Копировать ссылку",
    btn_copy_json: "Копировать JSON",
    btn_copy_xtext: "Копировать текст для X",

    // quick panel
    p_quick_kicker: "Быстрый скан",
    p_quick_title: "Оцените токен за секунды",
    p_quick_sub:
      "Вставьте адрес токена, выберите сеть и запустите скан. Кэш на 10 минут. Генерация текста для шаринга + JSON + Markdown.",
    quick_input_title: "Ввод токена",
    net_label: "Сеть",
    addr_label: "Контракт токена",
    qs_tip:
      'Совет: откройте <span class="mono">?tool=quick&net=bsc&token=0x...</span> для авто-старта (лимитировано).',
    options_label: "Опции",
    opt_require_liq: "Требовать ликвидность (строже)",
    opt_show_json: "Включить JSON отчёт (копирование)",
    api_keys_label: "API ключи Explorer (опционально)",
    opt_use_explorer_apis:
      "Использовать BscScan/Etherscan (Verified + ABI эвристики)",
    api_keys_tip:
      "Ключи сохраняются только в вашем браузере (localStorage). Не вставляйте ключи в публичный HTML.",
    results_title: "Результаты",
    results_hint:
      "Зелёные / жёлтые / красные сигналы. Это не гарантия — только проверяемые ончейн-проверки.",

    // liquidity panel
    p_liq_kicker: "Токен + ликвидность",
    p_liq_title: "Проверка ликвидности DEX",
    p_liq_sub:
      "Проверяем PancakeSwap (BSC) / Uniswap (ETH) V2 + V3 фабрики. Пары: токен vs WBNB/WETH и токен vs USDT.",
    liq_input_title: "Токен + сеть",
    liq_tip:
      'Совет: откройте <span class="mono">?tool=liq&net=bsc&token=0x...</span> для авто-старта.',
    liq_dex_label: "DEX реестр (проверяется)",
    liq_results_title: "Результаты ликвидности",
    liq_results_hint:
      "V2: пара + snapshot резервов. V3: наличие пула + liquidity() + slot0/tick snapshot.",

    // approvals panel
    p_app_kicker: "Approval Guardian",
    p_app_title: "Проверка и отзыв allowance",
    p_app_sub:
      "Укажите spender + токены (или добавьте популярные). Читаем allowance(owner, spender) и отзываем через approve(spender, 0).",
    ap_settings_title: "Настройки",
    ap_connected: "Подключено:",
    ap_connect: "Подключить / Обновить",
    ap_spender_label: "Spender preset",
    ap_spender_tip:
      "Начните с роутера, затем добавьте токены для очистки.",
    ap_tokens_label: "Список токенов (по одному в строке)",
    ap_seed: "Добавить популярные токены",
    ap_seed_history: "Использовать историю сканов",
    ap_check: "Проверить allowance",
    ap_revoke_all: "Отозвать все (ненулевые)",
    ap_results: "Allowances",
    ap_results_hint:
      "Если allowance “бесконечный”, лучше отозвать, если вы не полностью доверяете spender.",
    safe_mode_note:
      "Safe mode: действия, требующие подпись, отключены до подключения кошелька.",
    // DNA (Безопасность кошелька)
p_dna_kicker: "БЕЗОПАСНОСТЬ КОШЕЛЬКА DNA",
p_dna_title: "Wallet Security DNA",
p_dna_sub: "Снимок рисков разрешений и прав",

pill_wallet: "Кошелёк",
wallet_not_connected: "не подключен",
btn_close: "Закрыть",

dna_controls_title: "DNA-сканирование",
dna_wallet_address_label: "Адрес кошелька",
dna_wallet_address_ph: "0x... (необязательно, если подключите кошелёк)",
dna_wallet_address_tip: "Можно сначала сканировать по адресу. Подключайте кошелёк только когда хотите отзывать разрешения.",

net_label: "Сеть",
net_bsc: "BSC (BNB Chain)",
net_eth: "Ethereum",
net_polygon: "Polygon",

dna_connected: "Подключено:",
dna_connect: "Подключить кошелёк",
dna_run: "Сканировать",
dna_reset: "Сброс",

dna_results_title: "Wallet Security DNA",
dna_results_hint: "Оценка — это снимок. Всегда проверяйте перед подписью.",

dna_score: "Оценка",
dna_risk_level: "Риск",

dna_tips_title: "Советы",
dna_tips_placeholder: "—",
dna_share: "Поделиться оценкой",

dna_allowances_title: "Разрешения",
dna_table_note: "Совет: отзывайте “бесконечные” approvals, если не доверяете им полностью. Verified и Flags — только справочная информация.",
dna_full_access_btn: "ОТКРЫТЬ РАСШИРЕННОЕ (PASS / CYCX)",
    dna_locked_title: "Разблокируйте доступ, чтобы увидеть, кто может тратить ваши токены — и отозвать в 1 клик.",
    dna_locked_body: "Полный доступ (детали spender + инструменты отзыва) доступен для:",
    dna_locked_body_fp: "владельцев Founder Pass",
    dna_locked_body_cycx: "владельцев CYCX (после запуска).",
    dna_locked_safe_title: "Безопасная проверка:",
    dna_locked_safe_body:
      "Подключитесь, чтобы проверить доступ (публичный адрес + on-chain баланс).<br>" +
      "<span style=\"font-weight:750;\">Без подписи. Без транзакций.</span><br>" +
      "Мы только читаем данные из блокчейна. Любой revoke требует вашего явного подтверждения в кошельке.",
    dna_locked_cta: "Разблокировка включает: показ spender, кнопки revoke и Revoke All (non-zero).",
    dna_elig_checking: "Проверяем право доступа (PASS / CYCX)…",
    dna_elig_ok: "Доступ разрешён — открываем approvals",
    dna_elig_no: "Нет права на полный доступ (нужен 1 PASS или минимум 100 CYCX).",
    dna_elig_wrong_net: "Переключитесь на BSC (BNB Chain), чтобы проверить право PASS / CYCX.",
    dna_elig_error: "Не удалось проверить доступ. Попробуйте ещё раз.",
    dna_meta_approvals_detected: "Обнаружено разрешений:",
dna_meta_spenders_hidden: "Детали spender скрыты до разблокировки",

    access_title: "Получить доступ",
access_note: "Для открытия доступа подпись не требуется. Любое действие Revoke всегда требует подтверждения в кошельке.",
access_pay_bnb: "Купить access pass (BNB)",
access_pay_usdt: "Купить access pass (USDT)",
access_desc: "Разблокируйте продвинутые инструменты DNA за секунды. Ваш Access Pass не передаётся (soulbound), а позже вы сможете конвертировать его в CYCX, когда начнётся публичная продажа.",
access_foot: "Ранний доступ: $9 за первые 500 Access Pass, затем $19. 1 pass на кошелёк.",
    access_price_label: "Цена:",

    // rpc panel
    p_rpc_kicker: "Проверка RPC",
    p_rpc_title: "Найдите лучший endpoint",
    p_rpc_sub:
      "Тестируем RPC: latency + chainId + block + eth_call + чтение logs. Есть dev custom logs test, лучший RPC сохраняется локально.",
    rpc_inputs: "Ввод",
    rpc_private_label: "Приватный RPC (локально)",
    rpc_private_tip:
      "Не встраивается в HTML. Хранится только в вашем браузере (localStorage).",
    rpc_custom_label: "Кастомный RPC (высший приоритет)",
    rpc_test: "Тестировать RPC",
    rpc_copy_best: "Копировать лучший RPC",
    rpc_results: "Результаты",
    rpc_tip:
      "Совет: некоторые RPC падают из-за CORS/timeout. Запустите тест и выберите стабильный и быстрый.",
    rpc_dev_title: "Dev custom logs test",
    rpc_dev_hint:
      "Опционально: тест logs по контракту, чтобы проверить стабильность RPC.",
    rpc_dev_addr: "Адрес контракта (опционально)",
    rpc_dev_topic: "Topic0 (опционально)",
    rpc_dev_run: "Запустить тест",

    // tx panel
    p_tx_kicker: "Tx Decoder",
    p_tx_title: "Декодировать транзакцию",
    p_tx_sub:
      "Вставьте tx hash. Получим tx + receipt и декодируем input и события (Transfer / Approval + популярные swap вызовы).",
    tx_input_title: "Ввод Tx",
    tx_hash_label: "Хэш транзакции",
    tx_tip:
      'Совет: откройте <span class="mono">?tool=tx&net=bsc&tx=0x...</span> для авто-старта.',
    tx_results_title: "Декодированный вывод",

    // dev panel
    p_dev_kicker: "Dev Tools",
    p_dev_title: "Bookmarklet + локальный монитор",
    p_dev_sub:
      "Создайте bookmarklet, который отправляет token/tx со страниц explorer в CycleX Hub. Также есть локальный монитор контрактов (список хранится в браузере).",
    bm_title: "Генератор Bookmarklet",
    bm_hint:
      "Перетащите в панель закладок или скопируйте bookmarklet. Используйте на BscScan/Etherscan.",
    bm_base_label: "Hub URL (эта страница)",
    bm_generate: "Сгенерировать",
    bm_copy: "Копировать Bookmarklet",

    mon_add_title: "Добавить в список",
    mon_list_title: "Монитор контрактов (локально)",
    mon_list_hint: "Хранится локально. Без серверного трекинга.",
    mon_add: "Добавить",
    mon_check: "Проверить все",
    mon_export: "Копировать JSON",

    // footer
    footer_left:
      "CycleX Security Hub работает на клиенте и читает публичные ончейн-данные.",
    footer_tagline: "Проверяйте дважды. Подключайтесь только если доверяете странице.",
    // --- ADD THESE KEYS (RU) ---
title_back_to_cyclex: "Назад к CycleX",
aria_lang_selector: "Выбор языка",
badge_table: "Таблица",
btn_share_x: "Поделиться в X",
btn_share_tg: "Поделиться в Telegram",
net_bsc: "BSC (BNB Chain)",
net_eth: "Эфириум",
spender_pcs_router: "PancakeSwap Router (BSC)",
spender_uni_router: "Uniswap V2 Router (ETH)",
spender_custom: "Пользовательский…",

th_token: "Токен",
th_allowance: "Лимит",
th_symbol: "Символ",
th_action: "Действие",
th_rpc: "RPC",
th_ms: "мс",
th_chain: "сеть",
th_block: "блок",
th_call: "call",
th_logs: "логи",
th_status: "статус",
th_contract: "Контракт",
th_network: "Сеть",
th_last_seen: "Последний раз",
th_remove: "Удалить",
    bm_tip: "Добавьте букмарклет в браузер и проверяйте любой контракт с любого сайта одним кликом.",
bm_drag_label: "CycleX – Security Hub",

qs_ready_html: "<strong>Готово.</strong><br>Вставьте адрес токена и нажмите <b>Сканировать</b>.",
liq_ready_html: "<strong>Готово.</strong><br>Вставьте адрес токена и нажмите <b>Сканировать</b>.",
tx_ready_html: "<strong>Готово.</strong><br>Вставьте tx hash и нажмите <b>Декодировать</b>.",

ph_0x: "0x...",
ph_spender: "0x spender...",
ph_token_list: "0x...\n0x...\n0x...",
ph_bscscan_key: "BscScan API key (локально)",
ph_unified_key: "Unified API Key (локально)",
ph_etherscan_key: "Etherscan API key (локально)",
ph_rpc_private: "https://... (только локально)",
ph_rpc_custom: "https://...",
ph_rpc_dev_topic: "0xddf252ad... (Transfer) или оставьте пустым"

  }
};
// =========================
// i18n (after translations)
// =========================
let currentLang = "en";
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

function normalizeLang(x){
  const v = String(x || "").trim().toLowerCase();
  const map = { "cn":"zh", "zh-cn":"zh", "zh-hans":"zh" };
  return map[v] || v;
}

function setDirForLang(lang) {
  const html = document.documentElement;
  html.setAttribute("lang", lang === "zh" ? "zh" : lang);
  html.setAttribute("dir", lang === "ar" ? "rtl" : "ltr");
}

// ✅ t(lang,key) with EN fallback
function t(lang, key) {
  return (translations?.[lang]?.[key] ?? translations?.en?.[key] ?? "");
}

function applyI18n(lang) {
  const L = normalizeLang(lang || currentLang);
  currentLang = translations?.[L] ? L : "en";

  if (document.body) {
    document.body.classList.add("lang-switching");
    setTimeout(() => document.body && document.body.classList.remove("lang-switching"), 260);
  }

  // normal text/HTML
  $$("[data-i18n]").forEach((el) => {
    const key = el.getAttribute("data-i18n");
    const val = t(currentLang, key);
    if (val) el.innerHTML = val;
  });

  // placeholders
  $$("[data-i18n-placeholder]").forEach((el) => {
    const key = el.getAttribute("data-i18n-placeholder");
    const val = t(currentLang, key);
    if (val) el.setAttribute("placeholder", val);
  });

  // title attr
  $$("[data-i18n-title]").forEach((el) => {
    const key = el.getAttribute("data-i18n-title");
    const val = t(currentLang, key);
    if (val) el.setAttribute("title", val);
  });

  // aria-label attr
  $$("[data-i18n-aria-label]").forEach((el) => {
    const key = el.getAttribute("data-i18n-aria-label");
    const val = t(currentLang, key);
    if (val) el.setAttribute("aria-label", val);
  });

  setDirForLang(currentLang);

  // keep your existing behavior
  try { renderWalletLabels && renderWalletLabels(); } catch {}
}

function setLang(lang) {
  const picked = normalizeLang(lang);
  currentLang = translations?.[picked] ? picked : "en";

  try { localStorage.setItem("cx_sec_lang", currentLang); } catch {}

  $$(".lang-btn").forEach((b) => {
    const bl = normalizeLang(b.dataset?.lang || b.getAttribute("data-lang") || "");
    b.classList.toggle("active", bl === currentLang);
  });

  applyI18n(currentLang);
}

function initLang() {
  let saved = null;
  try { saved = localStorage.getItem("cx_sec_lang"); } catch {}

  const s = normalizeLang(saved);
  setLang(translations?.[s] ? s : "en");
}

// =========================
// i18n buttons wiring (FIX)
// =========================
function bindLangButtons(){
  $$(".lang-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      try { e.preventDefault(); } catch {}

      const raw = btn.dataset?.lang || btn.getAttribute("data-lang") || "";
      const lang = normalizeLang(raw);

      setLang(lang);
      try { gtagEvent && gtagEvent("sec_lang_change", { lang }); } catch {}
    }, { passive: false });
  });
}
    // =========================
    // Utils (dedup, single source of truth)
    // =========================
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const nowTs = () => Math.floor(Date.now() / 1000);

    const DEAD = "0x000000000000000000000000000000000000dEaD";
    const ZERO = "0x0000000000000000000000000000000000000000";

    function shortAddr(a) {
      return (!a || typeof a !== "string") ? "—" : `${a.slice(0, 6)}…${a.slice(-4)}`;
    }
    function safeJson(obj) {
      try { return JSON.stringify(obj, null, 2); } catch { return "{}"; }
    }
    function isAddr(x){
      try { return E.isAddress(String(x||"").trim()); } catch { return false; }
    }
    function normAddr(x){
      return E.getAddress(String(x||"").trim());
    }
    function isBurnAddr(a){
      if (!a) return false;
      const z = String(a).toLowerCase();
      return z === ZERO.toLowerCase() || z === DEAD.toLowerCase();
    }
    function dnaFormatLastUpdated(ts) {
  const s = String(ts ?? "").trim();
  if (!s || s === "—") return `<span class="muted">—</span>`;

  const d = new Date(s);
  if (!isNaN(d.getTime())) {
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mi = String(d.getMinutes()).padStart(2, "0");
    const nice = `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    return `<span class="mono" title="${window.escapeHtml(s)}">${window.escapeHtml(nice)}</span>`;
  }

  return `<span class="mono">${window.escapeHtml(s)}</span>`;
}


    async function copyText(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
          return true;
        } catch {
          return false;
        }
      }
    }
    function dnaEscAttr(s){
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}


    function setStatus(el, type, html) {
      if (!el) return;
      el.classList.remove("ok", "warn", "bad", "info");
      el.classList.add(type);
      el.style.display = "block";
      el.innerHTML = html;
    }
    function clearStatus(el) {
      if (!el) return;
      el.style.display = "none";
      el.innerHTML = "";
      el.classList.remove("ok", "warn", "bad", "info");
    }

    function gtagEvent(name, params = {}) {
      try { if (typeof window.gtag === "function") window.gtag("event", name, params); } catch {}
    }

    function parseQuery() {
      const u = new URL(location.href);
      return {
        tool: (u.searchParams.get("tool") || "").toLowerCase(),
        net: (u.searchParams.get("net") || "").toLowerCase(),
        token: (u.searchParams.get("token") || ""),
        tx: (u.searchParams.get("tx") || "")
      };
    }

    // =========================
    // Panels / Tiles
    // =========================
    let toolCards = [];
    let panels = {};

    function initPanels() {
      toolCards = $$("#toolGrid .tool-card");
      panels = {
        quick: $("#panel-quick"),
        liq: $("#panel-liq"),
        approvals: $("#panel-approvals"),
        rpc: $("#panel-rpc"),
        tx: $("#panel-tx"),
        dev: $("#panel-dev")
      };

      function showPanel(key) {
        Object.entries(panels).forEach(([k, el]) => {
          if (el) el.classList.toggle("hidden", k !== key);
        });
        toolCards.forEach((c) => c.classList.toggle("active", c.dataset.tool === key));
        if (key) gtagEvent("sec_tool_open", { tool: key });
      }
      window.showPanel = showPanel;

      toolCards.forEach((card) => card.addEventListener("click", () => showPanel(card.dataset.tool)));

      $("#btnCloseQuick")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseLiq")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseApprovals")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseRpc")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseTx")?.addEventListener("click", () => showPanel(null));
      $("#btnCloseDev")?.addEventListener("click", () => showPanel(null));

      $("#btn-quick")?.addEventListener("click", () => {
        showPanel("quick");
        $("#qs-token")?.focus();
        gtagEvent("sec_quick_btn");
      });
    }

// =========================
// Wallet (AppKit) — single global state
// =========================
const wallet = {
  providerRaw: null,     // EIP-1193
  browserProvider: null, // ethers BrowserProvider
  signer: null,
  address: "",
  chainId: 0
};

window.wallet = wallet;
window.__wallet = wallet;

// Keep references to bound handlers so we can safely detach/re-attach
const __walletProviderHandlers = {
  provider: null,
  accountsChanged: null,
  chainChanged: null
};

function safeGetAddress(a) {
  try { return E.getAddress(a); } catch { return ""; }
}

function parseChainIdAny(v) {
  try {
    if (typeof v === "number") return v;
    if (typeof v === "bigint") return Number(v);
    if (typeof v === "string") {
      return v.startsWith("0x") ? parseInt(v, 16) : Number(v);
    }
  } catch {}
  return 0;
}

function renderWalletLabels() {
  const notConn = t(currentLang, "wallet_not_connected") || "not connected";
  const labelTxt = wallet.address || notConn;

  const w1 = $("#walletLabel");
  if (w1) w1.textContent = labelTxt;

  const w2 = $("#ap-wallet");
  if (w2) w2.textContent = labelTxt;

  const w3 = $("#liq-wallet");
  if (w3) w3.textContent = labelTxt;

  const w4 = $("#ap-address");
  if (w4) w4.textContent = wallet.address ? shortAddr(wallet.address) : "—";
}

function detachProviderListeners() {
  const p = __walletProviderHandlers.provider;
  if (!p) return;

  try {
    if (typeof p.removeListener === "function") {
      if (__walletProviderHandlers.accountsChanged) {
        p.removeListener("accountsChanged", __walletProviderHandlers.accountsChanged);
      }
      if (__walletProviderHandlers.chainChanged) {
        p.removeListener("chainChanged", __walletProviderHandlers.chainChanged);
      }
    } else if (typeof p.removeAllListeners === "function") {
      p.removeAllListeners("accountsChanged");
      p.removeAllListeners("chainChanged");
    }
  } catch {}

  __walletProviderHandlers.provider = null;
  __walletProviderHandlers.accountsChanged = null;
  __walletProviderHandlers.chainChanged = null;
}

function attachProviderListeners(p) {
  try {
    if (!p || typeof p.on !== "function") return;

    // Detach old listeners first
    detachProviderListeners();

    const onAccountsChanged = async (accs) => {
      const a = (accs && accs[0]) ? safeGetAddress(accs[0]) : "";
      wallet.address = a;
      renderWalletLabels();
    };

    const onChainChanged = async (cid) => {
      wallet.chainId = parseChainIdAny(cid);
      renderWalletLabels();
    };

    p.on("accountsChanged", onAccountsChanged);
    p.on("chainChanged", onChainChanged);

    __walletProviderHandlers.provider = p;
    __walletProviderHandlers.accountsChanged = onAccountsChanged;
    __walletProviderHandlers.chainChanged = onChainChanged;
  } catch {}
}

async function cxConnectWallet({ silent = false } = {}) {
  const stQuick = $("#qs-status");

  // Already connected
  if (wallet?.address && wallet?.signer && (wallet?.providerRaw || wallet?.browserProvider)) {
    renderWalletLabels();
    if (!silent) {
      setStatus(stQuick, "ok", `Wallet already connected: <span class="mono">${wallet.address}</span>`);
    }
    try { await window.CxAppKitModal?.close?.(); } catch {}
    return true;
  }

  if (silent) return false;

  try {
    if (!silent) {
      await window.CxAppKitModal?.open?.({ view: "ConnectWallet" });
    }

    // Mobile round-trip can take longer
    const providerRaw = await waitForWalletProvider(45000);
    if (!providerRaw) {
      if (!silent) setStatus(stQuick, "warn", "Wallet provider not ready (timeout). Try again.");
      try { await window.CxAppKitModal?.close?.(); } catch {}
      return false;
    }

    wallet.providerRaw = providerRaw;
    attachProviderListeners(providerRaw);

    // Ensure session authorized
    try {
      const accs = await providerRaw.request({ method: "eth_requestAccounts" });
      if (!accs || !accs[0]) {
        if (!silent) setStatus(stQuick, "warn", "No wallet account returned. Try connect again.");
        try { await window.CxAppKitModal?.close?.(); } catch {}
        return false;
      }
    } catch (e) {
      if (!silent) setStatus(stQuick, "warn", `Wallet authorization failed: ${String(e?.message || e)}`);
      try { await window.CxAppKitModal?.close?.(); } catch {}
      return false;
    }

    const bp = new E.BrowserProvider(providerRaw);
    wallet.browserProvider = bp;

    const signer = await bp.getSigner();
    wallet.signer = signer;

    const addr = await signer.getAddress();
    const net = await bp.getNetwork();

    wallet.address = safeGetAddress(addr);
    wallet.chainId = parseChainIdAny(net?.chainId);

    renderWalletLabels();
    if (!silent) setStatus(stQuick, "ok", `Wallet connected: <span class="mono">${wallet.address}</span>`);
    gtagEvent("sec_wallet_connected", { chainId: wallet.chainId });

    try { await window.CxAppKitModal?.close?.(); } catch {}
    return true;
  } catch (e) {
    try { await window.CxAppKitModal?.close?.(); } catch {}
    if (!silent) setStatus(stQuick, "bad", `Wallet connect failed: ${String(e?.message || e)}`);
    return false;
  }
}

window.cxConnectWallet = cxConnectWallet;
window.connectWallet = cxConnectWallet;

async function ensureChain(targetChainId) {
  const p = wallet.providerRaw;
  if (!p?.request) return false;

  try {
    await p.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: "0x" + Number(targetChainId).toString(16) }]
    });

    // Refresh wallet state (do not force modal)
    await cxConnectWallet({ silent: true });
    return true;
  } catch {
    return false;
  }
}

function initWalletButtons() {
  // Hero button opens Access modal (not AppKit directly)
  $("#btn-connect")?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    openAccessModal();
  });

  // DNA connect keeps AppKit flow
  $("#ap-connect")?.addEventListener("click", async () => {
    await cxConnectWallet();
  });
}

// ---- Live price helpers (BNB/USDT) ----
let ACCESS_PRICE_CACHE = { ts: 0, bnbUsd: null };

async function accessFetchBnbUsd() {
  const now = Date.now();

  // cache 60s
  if (ACCESS_PRICE_CACHE.bnbUsd && (now - ACCESS_PRICE_CACHE.ts) < 60000) {
    return ACCESS_PRICE_CACHE.bnbUsd;
  }

  const r = await fetch("https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT", { cache: "no-store" });
  if (!r.ok) throw new Error("BNB_PRICE_FETCH_FAILED");

  const j = await r.json();
  const px = Number(j.price);
  if (!isFinite(px) || px <= 0) throw new Error("BNB_PRICE_BAD");

  ACCESS_PRICE_CACHE = { ts: now, bnbUsd: px };
  return px;
}

async function accessReadEthCall(to, data) {
  let lastErr = null;

  for (const url of ACCESS_READ_RPCS) {
    try {
      const body = {
        jsonrpc: "2.0",
        id: 1,
        method: "eth_call",
        params: [{ to, data }, "latest"]
      };

      const r = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(body),
      });

      const j = await r.json().catch(() => ({}));
      if (!r.ok) throw new Error(`HTTP_${r.status}`);
      if (j.error) throw new Error(j.error.message || "RPC_ERROR");
      if (!j.result) throw new Error("NO_RESULT");

      return j.result; // hex
    } catch (e) {
      lastErr = e;
    }
  }

  throw lastErr || new Error("ALL_RPCS_FAILED");
}

async function accessQuoteBNBWeiOnchain() {
  const SALE = ACCESS_SALE_OR_RECEIVER;
  const QUOTE_BNB_WEI_SELECTOR = "0x42773499"; // quoteBNBWei()

  const out = await accessReadEthCall(SALE, QUOTE_BNB_WEI_SELECTOR);
  const wei = BigInt(out);

  if (wei <= 0n) throw new Error("QUOTE_ZERO");
  return wei;
}

function accessSetBusy(on) {
  const bnbBtn = document.getElementById("btn-pay-bnb");
  const usdtBtn = document.getElementById("btn-pay-usdt");

  if (bnbBtn) bnbBtn.disabled = !!on;
  if (usdtBtn) usdtBtn.disabled = !!on;

  if (bnbBtn) bnbBtn.classList.toggle("is-busy", !!on);
  if (usdtBtn) usdtBtn.classList.toggle("is-busy", !!on);
}

async function accessUpdatePricesUI(usdPrice) {
  accessSetBusy(true);

  try {
    const bnbBtn = document.getElementById("btn-pay-bnb");
    const usdtBtn = document.getElementById("btn-pay-usdt");

    if (bnbBtn) bnbBtn.disabled = true;
    if (usdtBtn) usdtBtn.disabled = true;

    // USDT exact display
    const usdtEl = document.getElementById("access-price-usdt");
    if (usdtEl) usdtEl.textContent = `${usdPrice} USDT`;

    // BNB display
    const bnbEl = document.getElementById("access-price-bnb");
    if (bnbEl) bnbEl.textContent = "…";

    try {
      // Prefer on-chain quote
      const quoteWei = await accessQuoteBNBWeiOnchain();
      const quoteBnb = Number(quoteWei) / 1e18;

      const bnbText = quoteBnb.toFixed(6).replace(/0+$/, "").replace(/\.$/, "");
      if (bnbEl) bnbEl.textContent = `~${bnbText} BNB`;

      window.__ACCESS_BNB_WEI = quoteWei;
      window.__ACCESS_BNB_TEXT = bnbText;

      if (bnbBtn) bnbBtn.disabled = false;
      if (usdtBtn) usdtBtn.disabled = false;
      return;
    } catch (e) {
      console.warn("on-chain quote failed, fallback to Binance:", e);
    }

    // Fallback: Binance
    const bnbUsd = await accessFetchBnbUsd();
    const bnbAmt = usdPrice / bnbUsd;

    const bnbText = bnbAmt.toFixed(6).replace(/0+$/, "").replace(/\.$/, "");
    if (bnbEl) bnbEl.textContent = `~${bnbText} BNB`;

    if (window.ethers?.parseUnits) {
      const preciseStr = bnbAmt.toFixed(18);
      window.__ACCESS_BNB_WEI = window.ethers.parseUnits(preciseStr, 18);
      window.__ACCESS_BNB_TEXT = bnbText;
    } else {
      window.__ACCESS_BNB_WEI = null;
      window.__ACCESS_BNB_TEXT = bnbText;
    }

    if (bnbBtn) bnbBtn.disabled = false;
    if (usdtBtn) usdtBtn.disabled = false;
  } catch (e) {
    console.error("BNB price load failed:", e);

    const bnbEl = document.getElementById("access-price-bnb");
    const usdtBtn = document.getElementById("btn-pay-usdt");

    if (bnbEl) bnbEl.textContent = "—";
    if (usdtBtn) usdtBtn.disabled = false;
  } finally {
    accessSetBusy(false);
  }
}

function accessSetStatus(msg) {
  const el = document.getElementById("access-status");
  if (!el) return;
  el.textContent = msg || "";
}
    // =========================
// Mobile resume checkout helpers
// =========================
const ACCESS_PENDING_KEY = "cx_access_pending_kind";

function isMobileLike() {
  try {
    return window.matchMedia?.("(max-width: 900px)")?.matches ||
      /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent || "");
  } catch {
    return false;
  }
}

function setPendingCheckoutKind(kind) {
  try {
    if (kind) sessionStorage.setItem(ACCESS_PENDING_KEY, kind);
    else sessionStorage.removeItem(ACCESS_PENDING_KEY);
  } catch {}
}

function getPendingCheckoutKind() {
  try { return sessionStorage.getItem(ACCESS_PENDING_KEY) || ""; } catch { return ""; }
}

function clearPendingCheckoutKind() {
  try { sessionStorage.removeItem(ACCESS_PENDING_KEY); } catch {}
}

function renderContinueCheckoutButton(kind) {
  const st = document.getElementById("access-status");
  if (!st || !kind) return;

  // avoid duplicate button
  if (document.getElementById("btn-continue-checkout")) return;

  const wrap = document.createElement("div");
  wrap.id = "continue-checkout-wrap";
  wrap.style.marginTop = "10px";

  const btn = document.createElement("button");
  btn.id = "btn-continue-checkout";
  btn.type = "button";
  btn.className = "btn btn-primary";
  btn.textContent = "Continue checkout";
  btn.style.width = "100%";

  btn.addEventListener("click", async () => {
    btn.disabled = true;
    try {
      await accessBuyFlow(kind);
    } finally {
      // if flow didn't finish, we'll re-render as needed
      btn.disabled = false;
    }
  });

  wrap.appendChild(btn);
  st.parentNode?.insertBefore(wrap, st.nextSibling);
}

function removeContinueCheckoutButton() {
  const n = document.getElementById("continue-checkout-wrap");
  if (n) n.remove();
}

// called when app regains focus/visibility after wallet round-trip
function tryResumeCheckoutUI() {
  const kind = getPendingCheckoutKind();
  if (!kind) return;

  // only show helper on mobile-like UX
  if (!isMobileLike()) return;

  // require connected wallet first
  const hasWallet = !!(wallet?.address && (wallet?.providerRaw || wallet?.browserProvider));
  if (!hasWallet) return;

  // make sure modal is open so user sees action
  const m = document.getElementById("access-modal");
  if (m && m.getAttribute("aria-hidden") === "true") {
    openAccessModal();
  }

  accessSetStatus("Wallet connected. Continue checkout to complete payment.");
  renderContinueCheckoutButton(kind);
}


function openAccessModal() {
  accessSetStatus("");

  const m = document.getElementById("access-modal");
  if (!m) return;

  m.classList.add("is-open");
  m.setAttribute("aria-hidden", "false");

  // fire-and-forget, but catch to avoid unhandled promise
  accessUpdatePricesUI(ACCESS_USD_PRICE).catch((e) => {
    console.error("accessUpdatePricesUI failed:", e);
  });
}

function closeAccessModal() {
  const m = $("#access-modal");
  if (!m) return;
  m.classList.remove("is-open");
  m.setAttribute("aria-hidden", "true");
  clearPendingCheckoutKind();
  removeContinueCheckoutButton();
}


// =========================
// ACCESS PASS — TEMP CONFIG
// =========================
const ACCESS_USD_PRICE = 9; // later: 19 after sold count
const ACCESS_USDT = "0x55d398326f99059fF775485246999027B3197955"; // BSC USDT
const ACCESS_SALE_OR_RECEIVER = "0x1993b2D333713cdA3C6166bb02F71E304A14471f";

// Read-only RPC pool for quote calls
const ACCESS_READ_RPCS = [
  "https://bsc-rpc.publicnode.com",
  "https://bsc.publicnode.com",
  "https://bsc.rpc.blxrbdn.com",
  "https://1rpc.io/bnb",
  "https://rpc.ankr.com/bsc",
  "https://bsc-dataseed.binance.org/",
  "https://bsc-dataseed1.defibit.io/",
  "https://bsc-dataseed1.ninicoin.io/"
];

// NOTE: old fixed BNB constants intentionally removed to avoid confusion
// const ACCESS_BNB_PRICE_WEI = ...
// const ACCESS_BNB_PRICE_TEXT = ...

async function waitForAccounts(provider, maxMs = 30000) {
  if (!provider?.request) return "";

  const start = Date.now();
  while (Date.now() - start < maxMs) {
    try {
      const accs = await provider.request({ method: "eth_accounts" });
      const a = accs?.[0] || "";
      if (a) return a;
    } catch {}

    await new Promise(r => setTimeout(r, 350));
  }
  return "";
}

async function accessWaitForConfirm(provider, txHash, maxMs = 120000) {
  if (!provider?.request) return false;

  const start = Date.now();
  while (Date.now() - start < maxMs) {
    try {
      const receipt = await provider.request({
        method: "eth_getTransactionReceipt",
        params: [txHash],
      });

      if (receipt && receipt.status != null) {
        return receipt.status === "0x1" || receipt.status === 1 || receipt.status === true;
      }
    } catch {}

    await new Promise(r => setTimeout(r, 2000));
  }

  return false;
}

async function accessBuyFlow(kind) {
  try {
    accessSetBusy(true);
    // mark pending checkout for mobile deep-link resume
setPendingCheckoutKind(kind);
removeContinueCheckoutButton();


    const modalEl = document.getElementById("access-modal");
    const wasOpen = !!(modalEl && (
      modalEl.classList.contains("is-open") ||
      modalEl.classList.contains("open") ||
      modalEl.getAttribute("aria-hidden") === "false"
    ));

    if (typeof cxConnectWallet !== "function") {
      console.warn("cxConnectWallet is missing - AppKit connect not available.");
      accessSetStatus("Wallet connector is not ready.");
      return;
    }

    const connected = await cxConnectWallet();
    if (!connected) {
      if (wasOpen) openAccessModal();
      accessSetStatus("Wallet connection was not completed. Try again.");
      return;
    }

    let provider =
      (wallet?.providerRaw?.request && wallet.providerRaw) ||
      (wallet?.browserProvider?.provider?.request && wallet.browserProvider.provider) ||
      window.ethereum;

    let from = String(wallet?.address || "").trim();

    if (!from && provider?.request) {
      try {
        const accs = await provider.request({ method: "eth_requestAccounts" });
        from = accs?.[0] || "";
      } catch {}
    }

    if (!provider?.request || !from) {
      if (wasOpen) openAccessModal();
      accessSetStatus("Wallet not connected yet. Tap Buy once more.");
      console.warn("provider/from timeout", { hasProvider: !!provider, from, walletAddress: wallet?.address || "" });
      return;
    }

    // Ensure BSC mainnet
    const TARGET_CHAIN = "0x38";
    try {
      const chainId = await provider.request({ method: "eth_chainId" });
      if (chainId !== TARGET_CHAIN) {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: TARGET_CHAIN }],
        });
      }
    } catch (err) {
      if (err && (err.code === 4902 || String(err.message || "").includes("4902"))) {
        await provider.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: TARGET_CHAIN,
            chainName: "BNB Smart Chain",
            nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
            rpcUrls: ["https://bsc-dataseed.binance.org/"],
            blockExplorerUrls: ["https://bscscan.com/"],
          }],
        });
      } else if (err && err.code === 4001) {
        // user canceled switch
        accessSetStatus("Network switch was canceled.");
        return;
      } else {
        throw err;
      }
    }

    if (kind === "bnb") {
      const PASS_CONTRACT = ACCESS_SALE_OR_RECEIVER;
      if (!PASS_CONTRACT || !/^0x[a-fA-F0-9]{40}$/.test(String(PASS_CONTRACT))) {
        accessSetStatus("PASS_CONTRACT missing/invalid. Check ACCESS_SALE_OR_RECEIVER.");
        console.warn("Invalid PASS_CONTRACT:", PASS_CONTRACT, "ACCESS_SALE_OR_RECEIVER:", ACCESS_SALE_OR_RECEIVER);
        return;
      }

      // Use cached quote first
      let PRICE_WEI = window.__ACCESS_BNB_WEI;

      // fallback if cache missing
      if (!PRICE_WEI) {
        try {
          PRICE_WEI = await accessQuoteBNBWeiOnchain();
          window.__ACCESS_BNB_WEI = PRICE_WEI;
        } catch {}
      }

      if (!PRICE_WEI || BigInt(PRICE_WEI) <= 0n) {
        accessSetStatus("Couldn't fetch live BNB quote. Try again.");
        return;
      }

      const BUY_WITH_BNB_SELECTOR = "0x20f1fc61";
     // ---- BNB tx with small price buffer + gas buffer ----
const baseWei = BigInt(PRICE_WEI);

const valueWei = (baseWei * 101n) / 100n;

const txForEstimate = {
  from,
  to: PASS_CONTRACT,
  value: "0x" + valueWei.toString(16),
  data: BUY_WITH_BNB_SELECTOR
};

let gasHex = null;
try {
  const estGas = await provider.request({
    method: "eth_estimateGas",
    params: [txForEstimate]
  });

  // +20% gas buffer
  const gasBuffered = (BigInt(estGas) * 120n) / 100n;
  gasHex = "0x" + gasBuffered.toString(16);

} catch (e) {
  console.warn("estimateGas failed, fallback to wallet auto gas:", e);
}


const txParams = {
  from,
  to: PASS_CONTRACT,
  value: "0x" + valueWei.toString(16),
  data: BUY_WITH_BNB_SELECTOR,
  ...(gasHex ? { gas: gasHex } : {})
};


const txHash = await provider.request({
  method: "eth_sendTransaction",
  params: [txParams],
});

      accessSetStatus("Transaction sent ✅ Waiting for confirmation…");

      const ok = await accessWaitForConfirm(provider, txHash);
      if (ok) {
  clearPendingCheckoutKind();
  removeContinueCheckoutButton();
  accessSetStatus("Confirmed ✅");
  setTimeout(() => {
    closeAccessModal();
    accessSetStatus("");
  }, 900);
} else {

        accessSetStatus("Pending on-chain… You can close this window.");
        setTimeout(() => {
          closeAccessModal();
          accessSetStatus("");
        }, 3500);
      }
      return;
    }

    if (kind === "usdt") {
      const USDT = ACCESS_USDT;
      const PASS_CONTRACT = ACCESS_SALE_OR_RECEIVER;

      const ERC20_ABI = [
        { constant: true, inputs: [], name: "decimals", outputs: [{ name: "", type: "uint8" }], type: "function" },
        { constant: false, inputs: [{ name: "spender", type: "address" }, { name: "amount", type: "uint256" }], name: "approve", outputs: [{ name: "", type: "bool" }], type: "function" }
      ];

      const SALE_ABI = [
        { constant: false, inputs: [], name: "buyWithUSDT", outputs: [], type: "function" }
      ];

      accessSetStatus("Preparing USDT checkout…");

      if (!window.ethers) {
        accessSetStatus("USDT checkout needs ethers.js.");
        return;
      }

      const ethers = window.ethers;
      const web3Provider = new ethers.BrowserProvider(provider);
      const signer = await web3Provider.getSigner();

      const usdPrice = ACCESS_USD_PRICE;
      const usdtContract = new ethers.Contract(USDT, ERC20_ABI, signer);
      const sale = new ethers.Contract(PASS_CONTRACT, SALE_ABI, signer);

      const decimals = Number(await usdtContract.decimals());
      const amount = ethers.parseUnits(String(usdPrice), decimals);

      accessSetStatus("Approve USDT…");
      const tx1 = await usdtContract.approve(PASS_CONTRACT, amount);
      await tx1.wait();

      accessSetStatus("Buying pass…");
      const tx2 = await sale.buyWithUSDT();

      accessSetStatus("Transaction sent ✅ Waiting for confirmation…");
      const ok = await tx2.wait().then(r => r && r.status === 1).catch(() => false);

     if (ok) {
  clearPendingCheckoutKind();
  removeContinueCheckoutButton();
  accessSetStatus("Confirmed ✅");
  setTimeout(() => {
    closeAccessModal();
    accessSetStatus("");
  }, 900);
} else {

        accessSetStatus("Pending on-chain… You can close this window.");
        setTimeout(() => {
          closeAccessModal();
          accessSetStatus("");
        }, 3500);
      }

      return;
    }

    accessSetStatus("Unsupported payment method.");
  } catch (e) {
    console.error("accessBuyFlow error:", e);
    accessSetStatus(`Checkout failed: ${String(e?.message || e)}`);
  } finally {
    accessSetBusy(false);
  }
}

function bindAccessModal() {
  const m = $("#access-modal");
  if (!m) return;

  // close buttons + backdrop
  m.querySelectorAll("[data-close-access]").forEach((el) => {
    el.addEventListener("click", closeAccessModal);
  });

  // buy buttons
  const bnbBtn = document.getElementById("btn-pay-bnb");
  const usdtBtn = document.getElementById("btn-pay-usdt");

  bnbBtn?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    accessBuyFlow("bnb");
  });

  usdtBtn?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    accessBuyFlow("usdt");
  });

  // ESC to close — bind once
  if (!window.__accessEscBound) {
    window.__accessEscBound = true;
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeAccessModal();
    });
  }

  // mobile wallet round-trip resume hooks (bind once)
  if (!window.__accessResumeBound) {
    window.__accessResumeBound = true;

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        // slight delay to let provider/session settle
        setTimeout(tryResumeCheckoutUI, 250);
      }
    });

    window.addEventListener("focus", () => {
      setTimeout(tryResumeCheckoutUI, 250);
    });

    window.addEventListener("pageshow", () => {
      setTimeout(tryResumeCheckoutUI, 250);
    });
  }
}


// Expose for console/tests
window.openAccessModal = openAccessModal;
window.closeAccessModal = closeAccessModal;
window.accessBuyFlow = accessBuyFlow;
window.accessSetStatus = accessSetStatus;
window.ACCESS_SALE_OR_RECEIVER = ACCESS_SALE_OR_RECEIVER;
window.ACCESS_RECEIVER = ACCESS_SALE_OR_RECEIVER;

window.accessUpdatePricesUI = accessUpdatePricesUI;
window.accessWaitForConfirm = accessWaitForConfirm;
window.accessQuoteBNBWeiOnchain = accessQuoteBNBWeiOnchain;



    // =========================
    // Explorer API keys (local)
    // =========================
    const LS_KEYS = "cx_sec_explorer_keys";
    function loadApiKeys() {
    try {
    const raw = localStorage.getItem(LS_KEYS);
    if (!raw) return { use: false, unified: "", bscscan: "", etherscan: "" };

    const o = JSON.parse(raw) || {};
    return {
      use: !!o.use,
      unified: String(o.unified || "").trim(),
      bscscan: String(o.bscscan || "").trim(),
      etherscan: String(o.etherscan || "").trim()
    };
  } catch {
    return { use: false, unified: "", bscscan: "", etherscan: "" };
  }
}

    function saveApiKeys(keys) {
  try { localStorage.setItem(LS_KEYS, JSON.stringify(keys || {})); } catch {}
}
    
    function initApiKeysUi() {
      const keys = loadApiKeys();
      const useEl = $("#api-use"); if (useEl) useEl.checked = keys.use;
      const b1 = $("#api-bscscan"); if (b1) b1.value = keys.bscscan;
      const b2 = $("#api-etherscan"); if (b2) b2.value = keys.etherscan;
      const u1 = $("#api-unified"); if (u1) u1.value = keys.unified || "";

      $("#api-save")?.addEventListener("click", () => {
        const nk = {
        use: !!$("#api-use")?.checked,
        unified: ($("#api-unified")?.value || "").trim(),   
        bscscan: ($("#api-bscscan")?.value || "").trim(),   
        etherscan: ($("#api-etherscan")?.value || "").trim()
      };
        saveApiKeys(nk);
        setStatus($("#qs-status"), "ok", "Saved keys to localStorage.");
        gtagEvent("sec_keys_saved", { use: nk.use ? 1 : 0 });
      });

      $("#api-clear")?.addEventListener("click", () => {
        saveApiKeys({ use: false, unified: "", bscscan: "", etherscan: "" });
        const iu = $("#api-unified"); if (iu) iu.value = "";
        const u = $("#api-use"); if (u) u.checked = false;
        const i1 = $("#api-bscscan"); if (i1) i1.value = "";
        const i2 = $("#api-etherscan"); if (i2) i2.value = "";
        setStatus($("#qs-status"), "ok", "Cleared keys.");
        gtagEvent("sec_keys_cleared");
      });
    }

    // =========================
    // Network config (✅ fix ETH everywhere)
    // =========================
    const CHAINS = {
      bsc: {
        chainId: 56,
        name: "BSC",
        wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
        usdt: "0x55d398326f99059ff775485246999027b3197955",
        explorer: "https://bscscan.com",
        addressUrl: (a) => `https://bscscan.com/address/${a}`,
        txUrl: (h) => `https://bscscan.com/tx/${h}`,
        publicRpcs: [
  "https://bsc-rpc.publicnode.com",
  "https://bsc.publicnode.com",
  "https://bsc-dataseed1.bnbchain.org",
  "https://bsc-dataseed2.bnbchain.org",
          "https://bsc-rpc.publicnode.com",
          "https://1rpc.io/bnb",
          "https://endpoints.omniatech.io/v1/bsc/mainnet/",
          "https://api-bsc-mainnet-full.dwellir.com/",
          "https://binance.llamarpc.com",
          "https://bsc.meowrpc.com",
  "https://bsc-dataseed3.bnbchain.org",
  "https://bsc-dataseed4.bnbchain.org",
  "https://bsc-dataseed1.ninicoin.io",
  "https://bsc-dataseed2.ninicoin.io",
  "https://bsc-dataseed3.ninicoin.io",
  "https://bsc-dataseed4.ninicoin.io",
  "https://bsc-mainnet.gateway.pokt.network/v1/lb/6136201a7bad1500343e248d",
  "https://binance.nodereal.io",
  "https://rpc.ankr.com/bsc",
  "https://bsc.rpc.blxrbdn.com"
]

      },

      eth: {
        chainId: 1,
        name: "Ethereum",
        wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        usdt: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        explorer: "https://etherscan.io",
        addressUrl: (a) => `https://etherscan.io/address/${a}`,
        txUrl: (h) => `https://etherscan.io/tx/${h}`,
        publicRpcs: [
          "https://cloudflare-eth.com",
          "https://rpc.ankr.com/eth",
          "https://ethereum.publicnode.com",
          "https://eth.llamarpc.com"
        ]
      }
    };

    const DEX = {
      bsc: {
        v2Factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73",
        v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865",
        routerV2: "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        label: "PancakeSwap"
      },
      eth: {
        v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
        v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
        routerV2: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
        label: "Uniswap"
      }
    };

    // =========================
    // ABIs (minimal) — ✅ V3 token0/token1 added
    // =========================
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)"
    ];

    const V2_FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];
    const V2_PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const V3_FACTORY_ABI = [
      "function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)"
    ];
    const V3_POOL_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function liquidity() view returns (uint128)",
      "function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked)"
    ];

    const TRANSFER_TOPIC0 = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
    const APPROVAL_TOPIC0 = "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";

    // =========================
    // Local storage keys
    // =========================
    const LS_BEST_RPC = (net) => `cx_sec_best_rpc_${net}`;
    const LS_PRIV_RPC = (net) => `cx_sec_private_rpc_${net}`;
    const LS_QS_CACHE = "cx_sec_qs_cache_v2";
    const LS_QS_HISTORY = "cx_sec_qs_history_v1";
    const LS_MON = "cx_sec_monitor_v1";

    // =========================
    // Unified RPC layer (✅ item #1 + #2)
    // =========================
    function uniq(arr) {
      const s = new Set();
      const out = [];
      for (const x of arr) {
        const k = String(x || "").trim();
        if (!k) continue;
        if (s.has(k)) continue;
        s.add(k);
        out.push(k);
      }
      return out;
    }

    function getSavedBestRpc(net) {
      try { return localStorage.getItem(LS_BEST_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedBestRpc(net, url) {
      try { localStorage.setItem(LS_BEST_RPC(net), url); } catch {}
    }

    function getSavedPrivateRpc(net) {
      try { return localStorage.getItem(LS_PRIV_RPC(net)) || ""; } catch { return ""; }
    }
    function setSavedPrivateRpc(net, url) {
      try { localStorage.setItem(LS_PRIV_RPC(net), url); } catch {}
    }

    async function rpcRequest(url, method, params = [], timeoutMs = 9000) {
      const ctrl = new AbortController();
      const tmr = setTimeout(() => ctrl.abort(), timeoutMs);
      const body = JSON.stringify({ jsonrpc: "2.0", id: 1, method, params });

      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body,
          signal: ctrl.signal
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const j = await res.json();
        if (j.error) throw new Error(j.error.message || "RPC error");
        return j.result;
      } finally {
        clearTimeout(tmr);
      }
    }

    function buildRpcCandidates(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const privSaved = getSavedPrivateRpc(net);
      const privInput = ($("#rpc-private")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      return uniq([custom, privInput, privSaved, bestSaved, ...(chain?.publicRpcs || [])]);
    }

    const _providerCache = new Map(); // key: net|url
    function getProviderForUrl(net, url){
  const key = `${net}|${url}`;
  if (_providerCache.has(key)) return _providerCache.get(key);

  const n = E.Network.from({
  name: CHAINS[net].name.toLowerCase(),
  chainId: CHAINS[net].chainId
});
const p = new E.JsonRpcProvider(url, n, { staticNetwork: n });


  _providerCache.set(key, p);
  return p;
}


    async function withRpcFallback(net, fn, { timeoutMs = 9500, preferUrls = null } = {}) {
      const urls = preferUrls && preferUrls.length ? preferUrls : buildRpcCandidates(net);
      let lastErr = null;
      for (const url of urls) {
        try {
          const provider = getProviderForUrl(net, url);
          const res = await Promise.race([
            fn(provider, url),
            new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), timeoutMs))
          ]);
          return { ok: true, url, res };
        } catch (e) {
          lastErr = e;
          continue;
        }
      }
      return { ok: false, url: "", err: lastErr || new Error("All RPCs failed") };
    }

    async function getCodeSafe(net, addr){
      const a = normAddr(addr);
      // Use raw eth_getCode (faster + abortable) with fallback
      const urls = buildRpcCandidates(net);
      let last = null;
      for (const url of urls) {
        try {
          const code = await rpcRequest(url, "eth_getCode", [a, "latest"], 9000);
          if (typeof code === "string") {
            // mark as “best” if it works well
            return { ok: true, url, code };
          }
        } catch (e) { last = e; }
      }
      return { ok: false, url: "", err: last || new Error("eth_getCode failed"), code: "0x" };
    }

    function getReadProvider(net) {
      const chain = CHAINS[net];
      const custom = ($("#rpc-custom")?.value || "").trim();
      const bestSaved = getSavedBestRpc(net);
      const privSaved = getSavedPrivateRpc(net);
      const url = custom || privSaved || bestSaved || (chain?.publicRpcs?.[0] || "");
      if (!url) return null;
      try { return new E.JsonRpcProvider(url, chain.chainId); } catch { return null; }
    }
    // --- Debug exports (safe) ---
window.CX = window.CX || {};
window.CX.getReadProvider = getReadProvider;


    function netFromSelect(selId) {
      const v = ($(selId)?.value || "bsc").toLowerCase();
      return (v === "eth") ? "eth" : "bsc";
    }

    // =========================
    // Explorer API (optional)
    // =========================
    function explorerApiBase(net) {
  return net === "bsc" ? "https://api.bscscan.com/api" : "https://api.etherscan.io/api";
}

async function explorerGetSource(net, addr, apiKey, isUnified) {
  const keyTrim = String(apiKey || "").trim();

  const v2Base = "https://api.etherscan.io/v2/api";
  const chainid = (net === "bsc") ? "56" : "1"; 

  const useV2 = !!isUnified; 

  const u = new URL(useV2 ? v2Base : explorerApiBase(net));
  if (useV2) u.searchParams.set("chainid", chainid);

  u.searchParams.set("module", "contract");
  u.searchParams.set("action", "getsourcecode");
  u.searchParams.set("address", addr);
  if (keyTrim) u.searchParams.set("apikey", keyTrim);

  const r = await fetch(u.toString());
  const j = await r.json().catch(() => null);
  if (!j || j.status !== "1" || !j.result || !j.result[0]) return { ok: false, raw: j };

  const row = j.result[0];

  const abiRaw = String(row.ABI || "").trim();
  const isVerified =
    !!abiRaw &&
    abiRaw !== "Contract source code not verified" &&
    abiRaw !== "[]" &&
    abiRaw.startsWith("[");

  let abiJson = null;
  if (isVerified) {
    try { abiJson = JSON.parse(abiRaw); } catch { abiJson = null; }
  }

  const isProxy = String(row.Proxy || row.proxy || "").trim() === "1";
  const impl = String(row.Implementation || row.implementation || "").trim();
  const contractName = String(row.ContractName || row.contractName || "").trim();

  return {
    ok: true,
    verified: isVerified,
    abi: abiJson,
    isProxy,
    implementation: impl,
    contractName,
    raw: row
  };
}



    // =========================
    // Formatting helpers
    // =========================
    function fmtNum(x, digits = 2){
      const n = Number(x);
      if (!Number.isFinite(n)) return "—";
      const d = clamp(digits, 0, 8);
      return n.toLocaleString(undefined, { maximumFractionDigits: d });
    }
    function fmtBig(bn, decimals = 18, digits = 4){
      try {
        const v = Number(E.formatUnits(bn, decimals));
        if (!Number.isFinite(v)) return "—";
        return fmtNum(v, digits);
      } catch { return "—"; }
    }
    function looksInfiniteAllowance(v){
      try {
        // ethers v6 returns bigint
        const x = BigInt(v);
        return x > (BigInt(2) ** BigInt(255)); // "practically infinite"
      } catch { return false; }
    }
    function safeLower(x){ return String(x || "").toLowerCase(); }

// =========================
// Quick Scan (client-only) ✅ FIXED: no collisions, no TDZ, clean table
// =========================
(function () {
  "use strict";

  // ✅ Unique LS keys (avoid collisions with other features)
  const QS_LS_CACHE    = "cx_sec_qs_cache_safe_v6";
  const QS_LS_HISTORY  = "cx_sec_qs_history_safe_v6";
  const QS_LS_API_KEYS = "cx_sec_explorer_keys"; // {use,bscscan,etherscan} if exists

  // EIP-1967 implementation slot
  const EIP1967_IMPL_SLOT =
    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";

  // Minimal ABIs (self-contained — does NOT depend on Liquidity Scan script)
  const ERC20_MIN_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)"
  ];
  const OWNER_ABI = ["function owner() view returns (address)"];
  const PAUSABLE_ABI = ["function paused() view returns (bool)"];

  // V2/V3 minimal ABIs for the small liquidity table
  const QS_V2_FACTORY_ABI = ["function getPair(address,address) view returns (address)"];
  const QS_V2_PAIR_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function getReserves() view returns (uint112,uint112,uint32)"
  ];
  const QS_V3_FACTORY_ABI = ["function getPool(address,address,uint24) view returns (address)"];
  const QS_V3_POOL_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function liquidity() view returns (uint128)",
    "function slot0() view returns (uint160,int24,uint16,uint16,uint16,uint8,bool)"
  ];

  // PUSH4 selector scan (bytecode heuristic)
  const SEL = {
    mint: ["40c10f19", "a0712d68"],         // mint(address,uint256), mint(uint256)
    pause: ["8456cb59"],                   // pause()
    unpause: ["3f4ba83a"],                 // unpause()
    paused: ["5c975abb"],                  // paused()
    owner: ["8da5cb5b"],                   // owner()
    transferOwnership: ["f2fde38b"]         // transferOwnership(address)
  };

  const DEAD_ADDRESSES = new Set([
    "0x0000000000000000000000000000000000000000",
    "0x000000000000000000000000000000000000dead"
  ]);

  // QuickScan DEX targets (single “main” DEX for the compact table)
  const QS_NET = {
    bsc: {
      name: "BSC (BNB Chain)",
      wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // WBNB
      usdt:    "0x55d398326f99059fF775485246999027B3197955", // USDT (BSC)
      v2Factory: "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73", // Pancake V2
      v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865", // Pancake V3
      addressUrl: (a)=> `https://bscscan.com/address/${a}`
    },
    eth: {
      name: "Ethereum",
      wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
      usdt:    "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT (ETH)
      v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", // Uniswap V2
      v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984", // Uniswap V3
      addressUrl: (a)=> `https://etherscan.io/address/${a}`
    }
  };

  // -------------------------
  // Tiny safe helpers (local)
  // -------------------------
  function qsLower(x) { return String(x || "").toLowerCase(); }
  function qsClamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function qsNowTs() { return Math.floor(Date.now() / 1000); }

  function qsEscapeHtml(s){
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function qsIsAddr(a){
    try {
      if (typeof isAddr === "function") return !!isAddr(a);
      if (typeof E !== "undefined" && E?.isAddress) return E.isAddress(a);
    } catch {}
    return false;
  }
  function qsNormAddr(a){
    try {
      if (typeof normAddr === "function") return normAddr(a);
      if (typeof E !== "undefined" && E?.getAddress) return E.getAddress(a);
    } catch {}
    return String(a || "");
  }
  function qsShortAddr(a){
    try { if (typeof shortAddr === "function") return shortAddr(a); } catch {}
    const s = String(a || "");
    return s.length > 12 ? (s.slice(0, 6) + "…" + s.slice(-4)) : s;
  }

  function qsFmtNum(x, digits = 2){
    const n = Number(x);
    if (!Number.isFinite(n)) return "—";
    const d = qsClamp(digits, 0, 8);
    try { return n.toLocaleString(undefined, { maximumFractionDigits: d }); } catch { return String(n); }
  }
  function qsFmtBig(bn, decimals = 18, digits = 4){
    try {
      if (typeof E === "undefined" || !E?.formatUnits) return "—";
      const v = Number(E.formatUnits(bn, decimals));
      if (!Number.isFinite(v)) return "—";
      return qsFmtNum(v, digits);
    } catch { return "—"; }
  }

  function loadQsCache(){
    try { return JSON.parse(localStorage.getItem(QS_LS_CACHE) || "{}"); } catch { return {}; }
  }
  function saveQsCache(obj){
    try { localStorage.setItem(QS_LS_CACHE, JSON.stringify(obj || {})); } catch {}
  }
  function loadQsHistory(){
    try { return JSON.parse(localStorage.getItem(QS_LS_HISTORY) || "[]"); } catch { return []; }
  }
  function saveQsHistory(arr){
    try { localStorage.setItem(QS_LS_HISTORY, JSON.stringify(arr || [])); } catch {}
  }

  function qsCacheKey(net, token, requireLiq, useApis){
    return `${net}:${qsLower(token)}:${requireLiq ? 1 : 0}:${useApis ? 1 : 0}`;
  }
  function addQsHistory(net, token){
    try{
      const arr = loadQsHistory();
      const key = `${net}:${qsLower(token)}`;
      const filtered = arr.filter(x => x?.key !== key);
      filtered.unshift({ key, net, token: qsNormAddr(token), ts: qsNowTs() });
      saveQsHistory(filtered.slice(0, 80));
    } catch {}
  }
  function qsBuildShareLink(net, token){
    const u = new URL(location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", net);
    u.searchParams.set("token", token);
    return u.toString();
  }

 // ✅ safe explorer key read
function qsExplorerKeyFor(net){
  // 1) optional legacy helper
  try{
    if (typeof explorerKeyFor === "function") {
      const k = String(explorerKeyFor(net) || "").trim();
      return { key: k, isUnified: false };
    }
  } catch {}

  // 2) localStorage (V2 unified first, then per-net)
  try{
    const raw = localStorage.getItem(QS_LS_API_KEYS) || "";
    if (!raw) return { key: "", isUnified: false };

    const o = JSON.parse(raw) || {};

    // ✅ FIRST: if user disabled API usage
    if (typeof o.use === "boolean" && o.use === false) {
      return { key: "", isUnified: false };
    }

    // ✅ THEN: unified key has priority
    const unified = String(o.unified || "").trim();
    if (unified) return { key: unified, isUnified: true };

    // ✅ fallback: per-network keys
    if (net === "bsc") return { key: String(o.bscscan || "").trim(), isUnified: false };
    if (net === "eth") return { key: String(o.etherscan || "").trim(), isUnified: false };

    return { key: "", isUnified: false };
  } catch {
    return { key: "", isUnified: false };
  }
}
  // ✅ UI (TEMP) explorer key read (no-save)
// Supports unified V2 key OR per-network keys if present in the UI.
function qsUiExplorerKeyFor(net){
  try{
    const unifiedEl = $("#api-unified");
    const bscEl = $("#api-bscscan");
    const ethEl = $("#api-etherscan");

    const unified = String(unifiedEl?.value || "").trim();
    if (unified) return { key: unified, isUnified: true };

    if (net === "bsc") {
      const k = String(bscEl?.value || "").trim();
      if (k) return { key: k, isUnified: false };
    }
    if (net === "eth") {
      const k = String(ethEl?.value || "").trim();
      if (k) return { key: k, isUnified: false };
    }

    return { key: "", isUnified: false };
  } catch {
    return { key: "", isUnified: false };
  }
}



  // Chip UI
  function qsMiniChip(type, title, value){
    const map = { ok:"ok", warn:"warn", bad:"bad", info:"warn" };
    const cls = map[type] || "warn";
    return `<div class="risk ${cls}"><span class="dot"></span><span><b>${qsEscapeHtml(title)}</b> — ${qsEscapeHtml(value)}</span></div>`;
  }

  function codeHasSelector(bytecode, selHex){
    try{
      const code = qsLower(bytecode || "");
      const sel = qsLower(selHex || "").replace(/^0x/,"");
      if (!sel || sel.length !== 8) return false;
      return code.includes("63" + sel); // PUSH4 <selector>
    } catch { return false; }
  }
  function anySelector(bytecode, sels){
    for (const s of (sels || [])) if (codeHasSelector(bytecode, s)) return true;
    return false;
  }

  async function tryReadOwner(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return "";
    try{
      const c = new E.Contract(token, OWNER_ABI, read);
      const o = await c.owner();
      return qsIsAddr(o) ? qsNormAddr(o) : "";
    } catch { return ""; }
  }

  async function tryReadPaused(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return null;
    try{
      const c = new E.Contract(token, PAUSABLE_ABI, read);
      const p = await c.paused();
      return !!p;
    } catch { return null; }
  }

  async function tryEip1967Impl(net, token){
    const read = (typeof getReadProvider === "function") ? getReadProvider(net) : null;
    if (!read) return "";
    try{
      const raw = await read.getStorage(token, EIP1967_IMPL_SLOT);
      const hex = String(raw || "0x");
      if (!hex || hex === "0x") return "";
      const addr = "0x" + hex.slice(-40);
      if (!qsIsAddr(addr)) return "";
      const norm = qsNormAddr(addr);
      if (qsLower(norm) === "0x0000000000000000000000000000000000000000") return "";
      return norm;

    } catch { return ""; }
  }

  // =========================
  // Compact Liquidity table (ONLY QuickScan)
  // - shows ONLY existing pairs/pools (reduces rows)
  // - does NOT touch Liquidity Scan panel
  // =========================
  const QS_ERC20_META_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)"
  ];
  const _qsErc20MetaCache = new Map();

  function _qsToBI(x){
    try { return (typeof x === "bigint") ? x : BigInt(x); } catch { return 0n; }
  }
  async function _qsGetErc20Meta(addr, provider){
    const key = String(addr || "").toLowerCase();
    if (_qsErc20MetaCache.has(key)) return _qsErc20MetaCache.get(key);

    const c = new E.Contract(addr, QS_ERC20_META_ABI, provider);
    let decimals = 18;
    let symbol = qsShortAddr(addr);

    try { decimals = Number(await c.decimals()); } catch {}
    try {
      const s = await c.symbol();
      if (s && String(s).trim()) symbol = String(s).trim();
    } catch {}

    const meta = { decimals, symbol };
    _qsErc20MetaCache.set(key, meta);
    return meta;
  }

  function _qsCompactDecimalString(str, dp = 2){
    if (str == null) return "0";
    let s = String(str).trim();
    if (!s) return "0";

    let neg = false;
    if (s[0] === "-") { neg = true; s = s.slice(1); }

    const parts = s.split(".");
    let intp = (parts[0] || "0").replace(/^0+(?=\d)/, "");
    const frac = parts[1] || "";

    const len = intp.length;
    let pow = 0, suf = "";
    if (len >= 16) { pow = 15; suf = "Q"; }
    else if (len >= 13) { pow = 12; suf = "T"; }
    else if (len >= 10) { pow = 9;  suf = "B"; }
    else if (len >= 7)  { pow = 6;  suf = "M"; }
    else if (len >= 4)  { pow = 3;  suf = "K"; }

    if (pow === 0){
      const frac6 = frac.slice(0, 6).replace(/0+$/,"");
      const out = frac6 ? `${intp}.${frac6}` : intp;
      return (neg ? "-" : "") + out;
    }

    const wholeLen = len - pow;
    const whole = intp.slice(0, wholeLen) || "0";
    const rest = intp.slice(wholeLen);

    const dec = (rest + "0".repeat(dp)).slice(0, dp).replace(/0+$/,"");
    const out = dec ? `${whole}.${dec}${suf}` : `${whole}${suf}`;
    return (neg ? "-" : "") + out;
  }

  function _qsFmtUnits(amount, decimals, dp = 2){
    try {
      const s = E.formatUnits(amount, decimals);
      return _qsCompactDecimalString(s, dp);
    } catch {
      return "0";
    }
  }

  async function qsLiqCheckBasic(net, token, provider) {
    const cfg = QS_NET?.[net];
    if (!cfg || !provider) return { any:false, hint:"none", rows:[] };

    const rows = [];
    let any = false;
    const ZERO = "0x0000000000000000000000000000000000000000";

    const targets = [
      { label: "Wrapped", addr: cfg.wrapped },
      { label: "USDT", addr: cfg.usdt }
    ];

    // ---------- V2 ----------
    try {
      const fac = new E.Contract(cfg.v2Factory, QS_V2_FACTORY_ABI, provider);
      for (const t of targets) {
        const pair = await fac.getPair(token, t.addr).catch(()=> ZERO);
if (!pair || pair === ZERO) {
  rows.push({
    type: "V2",
    target: t.label,
    addr: "—",
    ok: false,
    note: "pair not found"
  });
  continue;
}


        const p = new E.Contract(pair, QS_V2_PAIR_ABI, provider);

        let token0 = token, token1 = t.addr;
        try { token0 = await p.token0(); } catch {}
        try { token1 = await p.token1(); } catch {}

        const [r0Raw, r1Raw] = await p.getReserves().catch(()=> [0n,0n,0n]);
        const r0 = _qsToBI(r0Raw), r1 = _qsToBI(r1Raw);

        const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
        const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

        const ok = (r0 > 0n || r1 > 0n);
        any = any || ok;

        const a0 = _qsFmtUnits(r0, m0.decimals, 2);
        const a1 = _qsFmtUnits(r1, m1.decimals, 2);

        rows.push({
          type: "V2",
          target: t.label,
          addr: pair,
          ok,
          note: ok ? `reserves: ${a0} ${m0.symbol} / ${a1} ${m1.symbol}` : "reserves: 0"
        });
      }
    } catch {
      // ignore (don’t spam rows)
    }

    // ---------- V3 ----------
    try {
      const fac3 = new E.Contract(cfg.v3Factory, QS_V3_FACTORY_ABI, provider);
      const feeTiers = [500, 3000, 10000];

      for (const t of targets) {
        for (const fee of feeTiers) {
          const pool = await fac3.getPool(token, t.addr, fee).catch(()=> ZERO);
if (!pool || pool === ZERO) {
  rows.push({
    type: `V3 ${fee}`,
    target: t.label,
    addr: "—",
    ok: false,
    note: "pool not found"
  });
  continue;
}


          const p = new E.Contract(pool, QS_V3_POOL_ABI, provider);

          let token0 = token, token1 = t.addr;
          try { token0 = await p.token0(); } catch {}
          try { token1 = await p.token1(); } catch {}

          const m0 = await _qsGetErc20Meta(token0, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token0)}));
          const m1 = await _qsGetErc20Meta(token1, provider).catch(()=>({decimals:18,symbol:qsShortAddr(token1)}));

          const c0 = new E.Contract(token0, QS_ERC20_META_ABI, provider);
          const c1 = new E.Contract(token1, QS_ERC20_META_ABI, provider);

          let b0 = 0n, b1 = 0n;
          try { b0 = _qsToBI(await c0.balanceOf(pool)); } catch {}
          try { b1 = _qsToBI(await c1.balanceOf(pool)); } catch {}

          let liq = 0n;
          try { liq = _qsToBI(await p.liquidity()); } catch {}

          const ok = (b0 > 0n || b1 > 0n || liq > 0n);
          any = any || ok;

          const fb0 = _qsFmtUnits(b0, m0.decimals, 2);
          const fb1 = _qsFmtUnits(b1, m1.decimals, 2);

          rows.push({
            type: `V3 ${fee}`,
            target: t.label,
            addr: pool,
            ok,
            note: ok ? `balances: ${fb0} ${m0.symbol} / ${fb1} ${m1.symbol}` : "balances: 0"
          });
        }
      }
    } catch {
      // ignore
    }

    return { any, hint: any ? "V2/V3 pairs exist" : "none", rows };
  }

  function qsRenderLiquidityTable(container, liqRes){
    if (!container) return;

    const rows = (liqRes?.rows || []);
    const body = rows.length ? rows.map(r => `
      <div class="trow ${r.ok ? "highlight" : ""}">
        <div class="cell wrap"><span class="mono">${r.addr ? qsEscapeHtml(qsShortAddr(r.addr)) : "—"}</span></div>
        <div class="cell">${qsEscapeHtml(r.type)}</div>
        <div class="cell">${qsEscapeHtml(r.target)}</div>
        <div class="cell">${r.ok ? "✅" : "—"} ${qsEscapeHtml(r.note || "")}</div>
      </div>
    `).join("") : `
      <div class="trow">
        <div class="cell muted">—</div>
        <div class="cell muted">—</div>
        <div class="cell muted">—</div>
        <div class="cell muted">No pairs/pools detected</div>
      </div>
    `;

    container.innerHTML = `
      <div id="qsLiqTable" class="table">
        <div class="trow head">
          <div class="cell">PAIR/POOL</div>
          <div class="cell">TYPE</div>
          <div class="cell">TARGET</div>
          <div class="cell">RESULT</div>
        </div>
        ${body}
      </div>
    `;
  }

  function qsBuildMarkdownReport(rep){
    const lines = [];
    lines.push(`## Quick Scan — ${rep.chainName || rep.net}`);
    lines.push(`Token: \`${rep.token}\``);
    lines.push(`Explorer: ${rep.explorer}`);
    lines.push(`Score: **${rep.score}/100** (${rep.overallText})`);
    lines.push("");
    lines.push(`### Signals`);
    for (const c of (rep.mini || [])) lines.push(`- ${c.title}: ${c.value}`);
    if (rep.redFlags?.length) {
      lines.push("");
      lines.push(`### Red Flags`);
      for (const f of rep.redFlags) lines.push(`- ❗ ${f}`);
    }
    lines.push("");
    lines.push(`> ${rep.disclaimer}`);
    return lines.join("\n");
  }

  function qsBuildXText(rep){
    const base = `Quick Scan (${rep.chainName || rep.net})\nToken: ${qsShortAddr(rep.token)}\nScore: ${rep.score}/100 (${rep.overallText})\n`;
    return `${base}${rep.shareLink || ""}`.trim();
  }

  async function runQuickScan(){
    const st = $("#qs-status");
    const out = $("#qs-out");
    const chipsWrap = $("#qs-risk");
    const pairsWrap = $("#qs-pairsWrap");

    clearStatus(st);

    const net = netFromSelect("#qs-net");
    const tokenRaw = ($("#qs-token")?.value || "").trim();
    const requireLiq = !!$("#qs-require-liq")?.checked;
    const uiKey = ($("#api-unified")?.value || "").trim();
    const useApis = !!$("#api-use")?.checked;

    if (!tokenRaw || !qsIsAddr(tokenRaw)) {
      setStatus(st, "warn", "Please paste a valid token address.");
      return;
    }
    const token = qsNormAddr(tokenRaw);

    if (typeof E === "undefined" || !E?.Contract) {
      setStatus(st, "bad", "Ethers not loaded.");
      return;
    }
    if (typeof getReadProvider !== "function") {
      setStatus(st, "bad", "RPC provider missing (getReadProvider not found).");
      return;
    }

    setStatus(st, "info", "Scanning…");

    const cache = loadQsCache();
    const ckey = qsCacheKey(net, token, requireLiq, useApis);
    const cached = cache?.[ckey];

    // ✅ Render is SAFE now (no TDZ vars)
    if (cached?.rep && cached?.ts && (qsNowTs() - cached.ts) < 600) {
      setStatus(st, "ok", "Loaded cached result (≤10 min).");
      render(cached.rep);
      return;
    }

    const cfg = QS_NET?.[net];
    const read = getReadProvider(net);
    if (!cfg || !read) {
      setStatus(st, "bad", "No network config / RPC available.");
      return;
    }

    const rep = {
      ts: qsNowTs(),
      net,
      chainName: cfg.name,
      token,
      explorer: cfg.addressUrl(token),
      shareLink: qsBuildShareLink(net, token),
      disclaimer: "Informational checks only. Not an audit. No safety guarantee.",
      score: 0,
      overallText: "Unknown",
      meta: {},
      liq: { any:false, hint:"none", rows:[] },
      mini: [],
      redFlags: [],
      json: ""
    };

    // 1) Bytecode exists
    let code = "0x";
    try {
      if (typeof getCodeSafe === "function") {
        const codeRes = await getCodeSafe(net, token);
        code = codeRes?.code || "0x";
      } else {
        code = await read.getCode(token);
      }
    } catch {}

    const hasCode = !!(code && code !== "0x");
    if (!hasCode) {
      rep.score = 0;
      rep.overallText = "Invalid";
      rep.redFlags.push("No contract code (EOA or invalid address).");
      rep.json = safeJson(rep);
      cache[ckey] = { ts: qsNowTs(), rep };
      saveQsCache(cache);
      addQsHistory(net, token);
      setStatus(st, "bad", "No contract code detected.");
      render(rep);
      return;
    }

    // 2) ERC-20 basics
    let name = "", symbol = "", decimals = 18, totalSupply = 0n;
    try {
      const c = new E.Contract(token, ERC20_MIN_ABI, read);
      const r = await Promise.all([
        c.name().catch(()=> ""),
        c.symbol().catch(()=> ""),
        c.decimals().catch(()=> 18),
        c.totalSupply().catch(()=> 0n)
      ]);
      name = String(r[0] || "");
      symbol = String(r[1] || "");
      decimals = Number(r[2] ?? 18);
      totalSupply = BigInt(r[3] ?? 0n);
      rep.meta = { name, symbol, decimals, totalSupply: totalSupply.toString() };
    } catch {}

    // 3) Liquidity rows (compact table)
    try {
      rep.liq = await qsLiqCheckBasic(net, token, read);
    } catch {}

    // 4) Proxy
    let impl = await tryEip1967Impl(net, token);
    let isProxy = !!impl;

    // 5) Owner
    const owner = await tryReadOwner(net, token);
    const ownerIsRenounced = owner && DEAD_ADDRESSES.has(qsLower(owner));
    const ownerShown = owner ? qsShortAddr(owner) : "No/Unknown";

    // 6) Pause (INFO)
    const pausedState = await tryReadPaused(net, token);
    const pauseDetected =
      (pausedState !== null) ||
      anySelector(code, SEL.pause) ||
      anySelector(code, SEL.unpause) ||
      anySelector(code, SEL.paused);
    const pauseText = pausedState === true ? "Detected (paused)" : pauseDetected ? "Detected" : "No/Unknown";

    // 7) Mint
    const mintDetected = anySelector(code, SEL.mint);

    // 8) Verified (optional)
let verified = null;

if (useApis) {
  const ui = qsUiExplorerKeyFor(net);
  let apiKey = ui.key;
  let isUnified = ui.isUnified;

  if (!apiKey) {
    const k = qsExplorerKeyFor(net);
    apiKey = k.key;
    isUnified = k.isUnified;
  }

  if (typeof explorerGetSource === "function") {
    try {
      const src = await explorerGetSource(net, token, apiKey, isUnified);
      if (src?.ok) {
        verified = (src.verified === true) ? true : (src.verified === false) ? false : null;
        if (!isProxy && src.isProxy) isProxy = true;
        if (!impl && src.implementation) impl = String(src.implementation || "");
      }
    } catch {}
  }

  // B) fallback: direct explorer call (ONLY if still unknown)
  if (verified === null && typeof qsExplorerGetSourceDirect === "function") {
    try {
      const src2 = await qsExplorerGetSourceDirect(net, token, apiKey);
      if (src2?.ok) {
        verified = (src2.verified === true) ? true : (src2.verified === false) ? false : null;
        if (!isProxy && src2.isProxy) isProxy = true;
        if (!impl && src2.implementation) impl = String(src2.implementation || "");
      }
    } catch {}
  }
}

    // Score model
    let score = 75;

    if (rep.liq?.any) score += 10;
    else score -= (requireLiq ? 30 : 20);

    if (mintDetected) score -= 22;

    if (isProxy) score -= 12;
    else score += 3;

    if (!owner) score += 0;
    else if (ownerIsRenounced) score += 5;
    else score -= 6;

    if (verified === true) score += 8;
    if (verified === false) score -= 6;

    if (!symbol && !name) score -= 5;

    score = qsClamp(score, 0, 100);

    const overallText =
      score >= 85 ? "Good" :
      score >= 70 ? "Mixed signals" :
      score >= 50 ? "Caution" :
      "High risk";

    rep.score = score;
    rep.overallText = overallText;

    rep.mini = [
      { type: score >= 85 ? "ok" : score >= 70 ? "warn" : score >= 50 ? "warn" : "bad", title: "Overall", value: overallText },
      { type: verified === true ? "ok" : "warn", title: "Verified", value: verified === true ? "Yes" : "No/Unknown" },
      { type: isProxy ? "warn" : "ok", title: "Proxy", value: isProxy ? "Detected" : "No/Unknown" },
      { type: owner ? (ownerIsRenounced ? "ok" : "warn") : "warn", title: "Owner", value: ownerShown },
      { type: rep.liq?.any ? "ok" : "warn", title: "Liquidity", value: rep.liq?.any ? "V2/V3 pairs exist" : "No/Unknown" },
      { type: mintDetected ? "bad" : "ok", title: "Mint", value: mintDetected ? "Detected" : "No/Unknown" },
      { type: pauseDetected ? "warn" : "ok", title: "Pause", value: pauseText }
    ];

    if (mintDetected) rep.redFlags.push("Mint surface detected (supply risk).");
    if (isProxy) rep.redFlags.push("Proxy detected (upgrade risk).");
    if (!rep.liq?.any) rep.redFlags.push("No clear DEX liquidity signal detected.");

    rep.json = safeJson(rep);

    cache[ckey] = { ts: qsNowTs(), rep };
    saveQsCache(cache);
    addQsHistory(net, token);

    setStatus(st, score >= 70 ? "ok" : score >= 50 ? "warn" : "bad", `Done. Score: <b>${score}/100</b> (${overallText}).`);
    render(rep);
    // ✅ Activity counter: count "High-risk contract" when score is 0..80
try {
  if (typeof cxActivitySend === "function" && Number(score) <= 80) {
    cxActivitySend("high_risk_contract", 1);
  }
} catch {}

    function render(rep){
      const sym = rep.meta?.symbol || "Token";
      const nm = rep.meta?.name ? ` — ${rep.meta.name}` : "";

      // ✅ compute supply inside render (no TDZ, safe for cached rep)
      let supplyTxt = "—";
      try {
        const ts = rep?.meta?.totalSupply;
        const dec = Number(rep?.meta?.decimals ?? 18);
        if (ts != null) supplyTxt = qsFmtBig(BigInt(ts), dec, 4);
      } catch {}

      out.className = "status info";
      out.style.display = "block";
      out.innerHTML = `
        <div style="font-size:18px;font-weight:900;letter-spacing:-0.01em;">
          ${qsEscapeHtml(sym)}${qsEscapeHtml(nm)}
        </div>
        <div class="small" style="margin-top:6px;">
          Network: <b>${qsEscapeHtml(rep.chainName || rep.net)}</b> • Score: <b>${rep.score}/100</b> (${qsEscapeHtml(rep.overallText)})
        </div>
        <div class="small" style="margin-top:8px;">
          Token: <span class="mono">${qsEscapeHtml(rep.token)}</span>
        </div>
        <div class="small" style="margin-top:8px;">
          Supply: <span class="mono">${qsEscapeHtml(supplyTxt)}</span>
        </div>
        <div class="small" style="margin-top:8px;">
          Explorer: <a href="${qsEscapeHtml(rep.explorer)}" target="_blank" rel="noopener">open</a>
        </div>
      `;

      if (chipsWrap){
        chipsWrap.innerHTML = (rep.mini || []).map(x => qsMiniChip(x.type, x.title, x.value)).join("");
      }

      if (pairsWrap){
        qsRenderLiquidityTable(pairsWrap, rep.liq);
      }
    }
  }

  function initQuickScanUi(){
    if (window.__cx_qs_bound_v6) return;
    window.__cx_qs_bound_v6 = true;
    
    // ✅ Auto checkbox UX (TEMP key without saving)
// Works for unified OR per-network keys, and supports manual override.
// ✅ Auto checkbox UX (works for unified + per-net, supports manual override)
(function qsBindApiAutoCheckbox(){
  const useEl = $("#api-use");
  if (!useEl) return;

  const unifiedEl = $("#api-unified");   
  const bscEl = $("#api-bscscan");       
  const ethEl = $("#api-etherscan");     
  const netEl = $("#qs-net");

  let userOverrode = false;

  function currentNet(){
    try { return netFromSelect("#qs-net"); } catch { return ""; }
  }

  function hasRelevantKey(){
  const u = String(unifiedEl?.value || "").trim();
  const b = String(bscEl?.value || "").trim();
  const e = String(ethEl?.value || "").trim();
  return !!(u || b || e);
}

  function apply(){
    const hasKey = hasRelevantKey();

    if (!hasKey) {
      useEl.checked = false;
      userOverrode = false;
      return;
    }

    if (!userOverrode) useEl.checked = true;
  }

  apply();

  useEl.addEventListener("change", () => { userOverrode = true; });

  const onInput = () => apply();
  unifiedEl?.addEventListener("input", onInput);
  bscEl?.addEventListener("input", onInput);
  ethEl?.addEventListener("input", onInput);
  netEl?.addEventListener("change", onInput);
})();

    $("#qs-run")?.addEventListener("click", () => {
      runQuickScan();
      try { gtagEvent("sec_qs_run"); } catch {}
    });

    $("#qs-copy-link")?.addEventListener("click", async () => {
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");
      const link = qsBuildShareLink(net, qsNormAddr(token));
      const ok = await copyText(link);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_link"); } catch {}
    });

    $("#qs-copy-json")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const ok = await copyText(rep.json || safeJson(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_json"); } catch {}
    });

    $("#qs-copy-md")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");
      const md = qsBuildMarkdownReport(rep);
      const ok = await copyText(md);
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied Markdown report." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_md"); } catch {}
    });

    $("#qs-share-x")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const text = qsBuildXText(rep);
      const u = new URL("https://twitter.com/intent/tweet");
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_x"); } catch {}
    });

    $("#qs-share-tg")?.addEventListener("click", () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const link = rep.shareLink || qsBuildShareLink(net, qsNormAddr(token));
      const text = qsBuildXText(rep);
      const u = new URL("https://t.me/share/url");
      u.searchParams.set("url", link);
      u.searchParams.set("text", text);
      window.open(u.toString(), "_blank", "noopener,noreferrer");
      try { gtagEvent("sec_qs_share_tg"); } catch {}
    });

    $("#qs-copy-xtext")?.addEventListener("click", async () => {
      const cache = loadQsCache();
      const net = netFromSelect("#qs-net");
      const token = ($("#qs-token")?.value || "").trim();
      if (!qsIsAddr(token)) return setStatus($("#qs-status"), "warn", "Enter token address first.");

      const requireLiq = !!$("#qs-require-liq")?.checked;
      const useApis = !!$("#api-use")?.checked;
      const key = qsCacheKey(net, qsNormAddr(token), requireLiq, useApis);
      const rep = cache?.[key]?.rep;
      if (!rep) return setStatus($("#qs-status"), "warn", "Run scan first.");

      const ok = await copyText(qsBuildXText(rep));
      setStatus($("#qs-status"), ok ? "ok" : "warn", ok ? "Copied X text." : "Copy failed.");
      try { gtagEvent("sec_qs_copy_xtext"); } catch {}
    });
  }

  // expose safely
  window.CX_QS_V6 = window.CX_QS_V6 || {};
  window.CX_QS_V6.initQuickScanUi = initQuickScanUi;
  window.CX_QS_V6.runQuickScan = runQuickScan;

  // keep compatibility
  window.initQuickScanUi = initQuickScanUi;
  window.runQuickScan = window.runQuickScan || runQuickScan;


})();


// ✅ Compatibility helper (do NOT remove) — used by Liquidity Scan
window.qsRiskChip = window.qsRiskChip || function(type, text){
  const cls = (type === "ok" ? "ok" : type === "bad" ? "bad" : "warn");
  const esc = (s)=> String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  return `<div class="risk ${cls}"><span class="dot"></span><span>${esc(text)}</span></div>`;
};
 // =========================
// Liquidity Scan panel (Multi-DEX Sources) — FINAL DROP-IN
// =========================

/**
 * DEX_SOURCES:
 * - v2Factory: UniswapV2-style factory (getPair)
 * - v3Type:
 *    - "univ3"   => UniswapV3-style factory (getPool(tokenA, tokenB, fee))
 *    - "algebra" => Algebra-style factory (poolByPair(tokenA, tokenB))
 *    - "registry"=> not checked (Curve/Balancer style)
 */
const DEX_SOURCES = {
  bsc: [
    { id: "pancake", label: "PancakeSwap", v2Factory: "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73", v3Type: "univ3",  v3Factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865" },
    { id: "apeswap", label: "ApeSwap",      v2Factory: "0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6", v3Type: null,     v3Factory: null },
    { id: "biswap",  label: "BiSwap",       v2Factory: "0x858E3312ed3A876947EA49d572A7C42DE08af7EE", v3Type: null,     v3Factory: null },
    { id: "bakery",  label: "BakerySwap",   v2Factory: "0x01bF7C66c6BD861915CdaaE475042d3c4BaE16A7", v3Type: null,     v3Factory: null },
    { id: "sushi",   label: "SushiSwap",    v2Factory: "0xc35DADB65012eC5796536bD9864eD8773aBc74C4", v3Type: "univ3",  v3Factory: "0x126555dd55a39328F69400d6aE4F782Bd4C34ABb" },
    { id: "thena",   label: "THENA V3 (Algebra)", v2Factory: null, v3Type: "algebra", v3Factory: "0x306F06C147f064A010530292A1EB6737c3e378e4" }
  ],

  eth: [
    { id: "uniswap", label: "Uniswap",     v2Factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", v3Type: "univ3",  v3Factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984" },
    { id: "sushi",   label: "SushiSwap",   v2Factory: "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac", v3Type: "univ3",  v3Factory: "0xbACEB8eC6b9355Dfc0269C18bac9d6E2Bdc29C4F" },
    { id: "pancake", label: "PancakeSwap", v2Factory: "0x1097053Fd2ea711dad45caCcc45EfF7548fCB362", v3Type: "univ3",  v3Factory: "0x13f4EA83D0bd40E75C8222255bc855a974568Dd4" },

    { id: "curve",   label: "Curve",       v2Factory: null, v3Type: "registry", v3Factory: null, infoUrl: "https://curve.fi" },
    { id: "balancer",label: "Balancer",    v2Factory: null, v3Type: "registry", v3Factory: null, infoUrl: "https://balancer.fi" }
  ]
};

// --- Minimal ABIs (safe even if unused) ---
const ALG_FACTORY_ABI = [
  "function poolByPair(address tokenA, address tokenB) view returns (address pool)"
];
const ALG_POOL_ABI = [
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function liquidity() view returns (uint128)"
];

// ---- stability helpers ----
function liqWithTimeout(promise, ms, label){
  let t;
  const timeout = new Promise((_, rej) => {
    t = setTimeout(() => rej(new Error(`timeout:${label||"call"}`)), ms);
  });
  return Promise.race([promise, timeout]).finally(() => clearTimeout(t));
}

async function liqPoolMap(items, limit, fn){
  const out = new Array(items.length);
  let i = 0;
  const workers = new Array(Math.max(1, limit)).fill(0).map(async () => {
    while (true) {
      const idx = i++;
      if (idx >= items.length) break;
      out[idx] = await fn(items[idx], idx);
    }
  });
  await Promise.all(workers);
  return out;
}

function liqBuildShareLink(net, token){
  const u = new URL(location.href);
  u.searchParams.set("tool", "liq");
  u.searchParams.set("net", net);
  u.searchParams.set("token", token);
  return u.toString();
}

function liqGetSources(net){
  const src = Array.isArray(DEX_SOURCES?.[net]) ? DEX_SOURCES[net] : [];
  // Dedup by id/label to avoid duplicate checks
  const seen = new Set();
  const out = [];
  for (const s of src) {
    const key = String(s.id || s.label || "").toLowerCase();
    if (!key || seen.has(key)) continue;
    seen.add(key);
    out.push(s);
  }
  return out;
}

async function runLiqScan(){
  const st = $("#liq-status");
  const out = $("#liq-out");
  const risk = $("#liq-risk");
  const wrap = $("#liq-tablewrap");

  clearStatus(st);
  risk.innerHTML = "";

  const net = netFromSelect("#liq-net");
  const tokenRaw = ($("#liq-token")?.value || "").trim();
  if (!isAddr(tokenRaw)) {
    setStatus(st, "warn", "Please paste a valid token address.");
    return;
  }
  const token = normAddr(tokenRaw);

  setStatus(st, "info", "Scanning liquidity…");
  const chain = CHAINS[net];
  const read = getReadProvider(net);
  if (!read) {
    setStatus(st, "bad", "No RPC available.");
    return;
  }

  const sources = liqGetSources(net);
  const res = {
    net, token,
    sources: sources.map(s => s.label),
    v2: [],
    v3: [],
    unknown: [],
    ts: nowTs()
  };

  // Config (safe defaults for public RPC)
  const CALL_TIMEOUT_MS = 6500;   // prevents hanging
  const V3_CONCURRENCY  = 3;      // avoid rate limit
  const v2PairsToCheck = [
    { other: chain.wrapped, label: "Wrapped" },
    { other: chain.usdt,    label: "USDT" }
  ];
  const v3Fees = [500, 3000, 10000];

  const pushUnknown = (s, kind, detail, link) => {
    res.unknown.push({
      source: s.label || s.id || "Source",
      kind,
      detail,
      link: link || ""
    });
  };

  for (const s of sources) {
    // Registry DEXes => explicit not checked
    if (s.v3Type === "registry") {
      pushUnknown(s, "Registry", "Not checked (registry model not supported in this scanner yet).", s.infoUrl || "");
      continue;
    }

    // ---------- V2 ----------
    if (s.v2Factory && isAddr(s.v2Factory)) {
      try {
        const f = new E.Contract(s.v2Factory, V2_FACTORY_ABI, read);

        // Only 2 getPair calls; add timeout
        const pairAddrs = await Promise.all(
          v2PairsToCheck.map(p =>
            liqWithTimeout(f.getPair(token, p.other).catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.getPair")
          )
        );

        for (let i = 0; i < v2PairsToCheck.length; i++) {
          const p = v2PairsToCheck[i];
          const pair = pairAddrs[i];

          if (pair && pair !== ZERO) {
            const pairC = new E.Contract(pair, V2_PAIR_ABI, read);
            const [t0, t1, r] = await Promise.all([
              liqWithTimeout(pairC.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.token0"),
              liqWithTimeout(pairC.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "v2.token1"),
              liqWithTimeout(pairC.getReserves().catch(()=>[0n,0n,0n]), CALL_TIMEOUT_MS, "v2.reserves")
            ]);

            res.v2.push({
              source: s.label,
              pair,
              token0: t0,
              token1: t1,
              reserve0: String(r[0]),
              reserve1: String(r[1]),
              otherLabel: p.label,
              other: p.other
            });
          }
        }
      } catch (e) {
        pushUnknown(s, "V2", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v2Factory));
      }
    } else if (s.v2Factory === null) {
      // intentionally no V2
    } else {
      pushUnknown(s, "V2", "Not checked (no V2 factory configured).", "");
    }

    // ---------- V3 UniswapV3 style ----------
    if (s.v3Type === "univ3") {
      if (s.v3Factory && isAddr(s.v3Factory)) {
        try {
          const vf = new E.Contract(s.v3Factory, V3_FACTORY_ABI, read);

          // Build (pair x fee) tasks
          const tasks = [];
          for (const p of v2PairsToCheck) {
            for (const fee of v3Fees) tasks.push({ p, fee });
          }

          const pools = await liqPoolMap(tasks, V3_CONCURRENCY, async ({p, fee}) => {
            const pool = await liqWithTimeout(
              vf.getPool(token, p.other, fee).catch(()=>ZERO),
              CALL_TIMEOUT_MS,
              "v3.getPool"
            );
            return { p, fee, pool };
          });

          for (const x of pools) {
            if (!x.pool || x.pool === ZERO) continue;

            const vp = new E.Contract(x.pool, V3_POOL_ABI, read);
            const [t0, t1, liq, slot0] = await Promise.all([
              liqWithTimeout(vp.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "v3.token0"),
              liqWithTimeout(vp.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "v3.token1"),
              liqWithTimeout(vp.liquidity().catch(()=>0n), CALL_TIMEOUT_MS, "v3.liquidity"),
              liqWithTimeout(vp.slot0().catch(()=>null), CALL_TIMEOUT_MS, "v3.slot0")
            ]);

            res.v3.push({
              source: s.label,
              fee: x.fee,
              otherLabel: x.p.label,
              other: x.p.other,
              pool: x.pool,
              token0: t0,
              token1: t1,
              liquidity: String(liq),
              tick: slot0 ? String(slot0[1]) : "—"
            });
          }
        } catch (e) {
          pushUnknown(s, "V3", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v3Factory));
        }
      } else {
        pushUnknown(s, "V3", "Not checked (no V3 factory configured).", "");
      }
    }

    // ---------- V3 Algebra style (THENA) ----------
    if (s.v3Type === "algebra") {
      if (s.v3Factory && isAddr(s.v3Factory)) {
        try {
          const af = new E.Contract(s.v3Factory, ALG_FACTORY_ABI, read);

          const poolAddrs = await Promise.all(
            v2PairsToCheck.map(p =>
              liqWithTimeout(af.poolByPair(token, p.other).catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.poolByPair")
            )
          );

          for (let i = 0; i < v2PairsToCheck.length; i++) {
            const p = v2PairsToCheck[i];
            const pool = poolAddrs[i];
            if (!pool || pool === ZERO) continue;

            const ap = new E.Contract(pool, ALG_POOL_ABI, read);
            const [t0, t1, liq] = await Promise.all([
              liqWithTimeout(ap.token0().catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.token0"),
              liqWithTimeout(ap.token1().catch(()=>ZERO), CALL_TIMEOUT_MS, "alg.token1"),
              liqWithTimeout(ap.liquidity().catch(()=>0n), CALL_TIMEOUT_MS, "alg.liquidity")
            ]);

            res.v3.push({
              source: s.label,
              fee: "—",
              otherLabel: p.label,
              other: p.other,
              pool,
              token0: t0,
              token1: t1,
              liquidity: String(liq),
              tick: "—"
            });
          }
        } catch (e) {
          pushUnknown(s, "V3", "Checked but failed (RPC/ABI/timeout).", chain.addressUrl(s.v3Factory));
        }
      } else {
        pushUnknown(s, "V3", "Not checked (no Algebra factory configured).", "");
      }
    }
  }

  // Render chips (avoid false green)
  const chips = [];
  const v2n = res.v2.length;
  const v3n = res.v3.length;
  const un = res.unknown.length;

  if (v2n) chips.push(qsRiskChip("ok", `V2 pairs found: ${v2n}`));
  else chips.push(qsRiskChip("warn", "No V2 pairs found (wrapped/USDT)."));

  if (v3n) chips.push(qsRiskChip("ok", `V3 pools found: ${v3n}`));
  else chips.push(qsRiskChip("warn", "No V3 pools found (wrapped/USDT, fee tiers)."));

  if (un) chips.push(qsRiskChip("warn", `Unknown / not checked: ${un}`));
  risk.innerHTML = chips.join("");

  const rows = [];
  rows.push(`
    <div class="trow head">
      <div class="cell">Pool / Pair</div>
      <div class="cell">Type</div>
      <div class="cell">Detail</div>
      <div class="cell">Link</div>
    </div>
  `);

  // V2 rows
  for (const v of res.v2) {
    const hasRes = (BigInt(v.reserve0) > 0n && BigInt(v.reserve1) > 0n);
    rows.push(`
      <div class="trow ${hasRes ? "highlight" : ""}">
        <div class="cell mono">${shortAddr(v.pair)}</div>
        <div class="cell">V2</div>
        <div class="cell">${escapeHtml(v.source)} • Reserves: ${hasRes ? "✅" : "—"} • ${escapeHtml(v.otherLabel)}</div>
        <div class="cell"><a href="${chain.addressUrl(v.pair)}" target="_blank" rel="noopener">Explorer</a></div>
      </div>
    `);
  }

  // V3 rows
  for (const v of res.v3) {
    const liqOk = (() => { try { return BigInt(v.liquidity) > 0n; } catch { return false; } })();
    const feeTxt = (v.fee === "—") ? "Fee: —" : `Fee: ${v.fee}`;
    rows.push(`
      <div class="trow ${liqOk ? "highlight" : ""}">
        <div class="cell mono">${shortAddr(v.pool)}</div>
        <div class="cell">V3</div>
        <div class="cell">${escapeHtml(v.source)} • ${escapeHtml(v.otherLabel)} • ${feeTxt} • Liquidity: ${liqOk ? "✅" : "—"}${v.tick ? ` • Tick: ${escapeHtml(v.tick)}` : ""}</div>
        <div class="cell"><a href="${chain.addressUrl(v.pool)}" target="_blank" rel="noopener">Explorer</a></div>
      </div>
    `);
  }

  // Unknown / Not checked rows
  for (const u of res.unknown) {
    const link = u.link ? `<a href="${u.link}" target="_blank" rel="noopener">Link</a>` : "—";
    rows.push(`
      <div class="trow">
        <div class="cell mono">—</div>
        <div class="cell">${escapeHtml(u.kind)}</div>
        <div class="cell">${escapeHtml(u.source)} • ${escapeHtml(u.detail)}</div>
        <div class="cell">${link}</div>
      </div>
    `);
  }

  wrap.innerHTML = `<div class="table">${rows.join("")}</div>`;

  out.innerHTML = `
    <b>Multi-source liquidity scan</b> completed.<br>
    Network: ${escapeHtml(chain.name)}<br>
    Token: <span class="mono">${token}</span><br>
    Sources: ${escapeHtml(res.sources.join(", "))}<br>
    Share: <span class="mono">${liqBuildShareLink(net, token)}</span>
  `;
  out.style.display = "block";

  setStatus(st, (v2n || v3n) ? "ok" : "warn", "Done.");
  gtagEvent("sec_liq_run", { net, sources: sources.length, unknown: un });
}

function initLiqUi(){
  const updateDexNote = () => {
    const net = netFromSelect("#liq-net");
    const src = liqGetSources(net).map(s => s.label);
    const el = $("#liq-dex-note");
    if (el) el.textContent = `Sources: ${src.join(", ")} (V2: wrapped+USDT • V3: wrapped+USDT + fee tiers • Algebra supported • Registry DEXes shown as not checked)`;
  };
  $("#liq-net")?.addEventListener("change", updateDexNote);
  updateDexNote();

  $("#liq-run")?.addEventListener("click", runLiqScan);

  $("#liq-copy-link")?.addEventListener("click", async () => {
    const net = netFromSelect("#liq-net");
    const token = ($("#liq-token")?.value || "").trim();
    if (!isAddr(token)) return setStatus($("#liq-status"), "warn", "Enter token address first.");
    const link = liqBuildShareLink(net, normAddr(token));
    const ok = await copyText(link);
    setStatus($("#liq-status"), ok ? "ok" : "warn", ok ? "Copied share link." : "Copy failed.");
  });

  $("#liq-share-x")?.addEventListener("click", () => {
    const net = netFromSelect("#liq-net");
    const token = ($("#liq-token")?.value || "").trim();
    if (!isAddr(token)) return setStatus($("#liq-status"), "warn", "Enter token address first.");
    const link = liqBuildShareLink(net, normAddr(token));
    const u = new URL("https://twitter.com/intent/tweet");
    u.searchParams.set("text", `Liquidity scan (${CHAINS[net].name})\nToken: ${shortAddr(token)}\n${link}`);
    window.open(u.toString(), "_blank", "noopener,noreferrer");
  });
}

// ---- Safe HTML escape (global) ----
window.escapeHtml = window.escapeHtml || function (s) {
  if (s === null || s === undefined) return "";
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
};

// =========================
// Wallet Security DNA (replaces Approval Guardian)
// =========================

function dnaNet() {
  // dna-net is the new select; fallback to ap-net if exists
  return netFromSelect("#dna-net") || netFromSelect("#ap-net") || "bsc";
}

function dnaInputAddress() {
  const raw = ($("#dna-walletAddress")?.value || "").trim();
  if (raw && isAddr(raw)) return normAddr(raw);
  if (wallet?.address && isAddr(wallet.address)) return normAddr(wallet.address);
  return "";
}

function dnaSetWalletBadges() {
  const w = wallet?.address ? shortAddr(wallet.address) : "not connected";
  const addr = wallet?.address ? shortAddr(wallet.address) : "—";
  const net = dnaNet();

  const elWallet = $("#dna-wallet");
  const elAddr = $("#dna-address");

  if (elWallet) elWallet.textContent = w;
  if (elAddr) elAddr.textContent = addr;

  // optional: keep legacy ap-wallet/ap-address if you still have them somewhere
  if ($("#ap-wallet")) $("#ap-wallet").textContent = w;
  if ($("#ap-address")) $("#ap-address").textContent = addr;

  gtagEvent?.("sec_dna_wallet_badge", { net, connected: !!wallet?.address });
}

function dnaClearOutputs() {
  dnaApplyPills(null, "—");

  const tips = $("#dna-tips");
  if (tips) tips.innerHTML = `<li class="muted" data-i18n="dna_tips_placeholder">—</li>`;

  // clear approvals table but keep header
  const table = $("#ap-table");
  const head = table?.querySelector(".trow.head");
  if (table) table.innerHTML = "";
  if (table && head) table.appendChild(head);

  clearStatus?.($("#dna-status"));
  clearStatus?.($("#ap-status"));
}

function dnaRiskLevelFromScore(score) {
  const s = Number(score);
  if (!Number.isFinite(s)) return "—";
  if (s >= 80) return "Low";
  if (s >= 50) return "Medium";
  return "High";
}
// Score tier -> ok (green) | warn (orange) | bad (red) | unk
function dnaScoreTierFromScore(score){
  const s = Number(score);
  if (!Number.isFinite(s)) return "unk";
  if (s >= 80) return "ok";
  if (s >= 50) return "warn";
  return "bad";
}

// Apply text + color classes to the pills
function dnaApplyPills(score, riskText){
  const scoreEl = $("#dna-score");
  const riskEl  = $("#dna-risk");

  // --- SCORE ---
  if (scoreEl){
    const s = Number(score);
    scoreEl.textContent = Number.isFinite(s) ? String(Math.round(s)) : "—";

    scoreEl.classList.remove("score-ok","score-warn","score-bad","score-unk");
    scoreEl.classList.add("score-" + dnaScoreTierFromScore(s));
  }

  // --- RISK ---
  if (riskEl){
    const txt = (riskText == null ? "—" : String(riskText));
    riskEl.textContent = txt;

    riskEl.classList.remove("risk-low","risk-med","risk-high","risk-unk");
    const t = txt.toLowerCase();
    let lvl = "unk";
    if (t.includes("low")) lvl = "low";
    else if (t.includes("med")) lvl = "med";
    else if (t.includes("high")) lvl = "high";
    riskEl.classList.add("risk-" + lvl);
  }
}


function dnaNormalizeApiRow(row) {
  // Moralis-like keys (common)
  const tokenRaw =
    row?.token || row?.token_address || row?.tokenAddress || row?.contract_address || row?.contractAddress || "";
  const spenderRaw =
    row?.spender || row?.spender_address || row?.spenderAddress || row?.operator || "";

  const token = isAddr(tokenRaw) ? normAddr(tokenRaw) : "";
  const spender = isAddr(spenderRaw) ? normAddr(spenderRaw) : "";

  const symbol = row?.symbol || row?.token_symbol || row?.tokenSymbol || row?.token_name || "—";

  const allowanceRaw =
    row?.allowance ?? row?.value ?? row?.amount ?? row?.approved_amount ?? row?.approvedAmount ?? "0";
  const allowanceStr = String(allowanceRaw);

  const verified =
    row?.verified === true ? "Verified" :
    row?.verified === false ? "Unverified" :
    row?.verifiedStatus || row?.verification || row?.verified || "—";

  const lastUpdated =
    row?.lastUpdated || row?.updatedAt || row?.block_timestamp || row?.blockTimestamp || "—";

  let flags = row?.flags ?? row?.suspicious ?? row?.risk_flags ?? "—";
  if (Array.isArray(flags)) flags = flags.length ? flags.join(", ") : "—";

  const risk = row?.risk || row?.riskLevel || "—";
  const decRaw = row?.decimals ?? row?.token_decimals ?? row?.tokenDecimals ?? row?.tokenDecimals ?? null;
  const decimals = Number.isFinite(Number(decRaw)) ? Number(decRaw) : null;
  return { token, spender, symbol, allowanceStr, verified, lastUpdated, flags, risk, decimals };

}
function dnaFormatAllowance(rawStr, decimals = null) {
  let s0 = String(rawStr ?? "").trim();
  if (!s0 || s0 === "—") return "—";

  // Normalize ".1" -> "0.1"
  if (s0.startsWith(".")) s0 = "0" + s0;
  if (s0.startsWith("-.")) s0 = "-0" + s0.slice(1);

  const low0 = s0.toLowerCase();

  // Unlimited hints
  if (s0 === "∞" || low0 === "infinite" || low0 === "unlimited" || low0.includes("inf")) {
    return `<span class="mono" title="Unlimited" data-copy="Unlimited">Unlimited</span>`;
  }

  // ✅ FIX for broken MaxUint256 coming as "0.<huge digits>"
  // Example: "0.1157920...(70+ digits)" => treat as integer "1157920..." and detect MaxUint256
  const brokenDec = /^-?0?\.\d{25,}$/; // 25+ digits after dot = suspicious/broken
  if (brokenDec.test(s0) && !s0.startsWith("0x")) {
    const neg = s0.startsWith("-");
    const digits = s0.replace("-", "").replace(/^0?\./, ""); // remove "0."
    s0 = (neg ? "-" : "") + digits; // now integer string
  }

  // If it's a normal human decimal (not broken) -> show SHORT (6 decimals) but keep full in title/copy
  if (s0.includes(".") && !s0.startsWith("0x")) {
    const full = s0;

    // shorten display to max 6 fraction digits without rounding (string cut)
    const m = full.match(/^(-?\d+)\.(\d+)/);
    let display = full;
    if (m) {
      const ip = m[1];
      const frac = m[2].slice(0, 6).replace(/0+$/, ""); // trim trailing zeros
      display = frac ? `${ip}.${frac}` : ip;
    }

    // extra safety: don't let it get too long
    if (display.length > 16) display = display.slice(0, 12) + "…";

    const safeDisplay = window.escapeHtml(display);
    const safeFull = window.escapeHtml(full);
    return `<span class="mono" title="Value: ${safeFull}" data-copy="${safeFull}">${safeDisplay}</span>`;
  }

  // Parse bigint (hex or integer string)
  let raw;
  try {
    raw = s0.startsWith("0x") ? BigInt(s0) : BigInt(s0);
  } catch {
    const safe = window.escapeHtml(s0);
    return `<span class="mono" title="${safe}" data-copy="${safe}">${safe}</span>`;
  }

  if (raw === 0n) {
    return `<span class="mono" title="Raw: 0" data-copy="0">0</span>`;
  }

  const MAX_UINT256 = (1n << 256n) - 1n;
  const NEAR_MAX = MAX_UINT256 - 1000n;

  // ✅ Turn MaxUint256 into Unlimited
  if (raw === MAX_UINT256 || raw >= NEAR_MAX) {
    return `<span class="mono" title="Unlimited (MaxUint256)\nRaw: ${MAX_UINT256.toString()}" data-copy="${MAX_UINT256.toString()}">Unlimited</span>`;
  }

  // If decimals known -> format to human + shorten
  if (Number.isInteger(decimals) && decimals >= 0 && decimals <= 36) {
    const pad = decimals;

    const neg = raw < 0n;
    const v = neg ? (-raw) : raw;
    const str = v.toString().padStart(pad + 1, "0");
    const intPart = str.slice(0, -pad) || "0";
    let frac = str.slice(-pad).replace(/0+$/, "");
    const full = (neg ? "-" : "") + intPart + (frac ? "." + frac : "");

    // shorten display (K/M/B…)
    const ip = intPart.replace(/^0+/, "") || "0";
    const intLen = ip.length;
    const suffixes = ["", "K", "M", "B", "T", "Q"];
    const group = Math.floor((intLen - 1) / 3);

    let display = full;
    if (group > 0 && group < suffixes.length) {
      const cut = intLen - group * 3;
      const head = ip.slice(0, cut);
      const tail = ip.slice(cut, cut + 2);
      display = `${head}${tail ? "." + tail : ""}${suffixes[group]}`;
      if (neg) display = "-" + display;
    } else if (group >= suffixes.length) {
      display = `${ip.slice(0, 3)}e+${intLen - 3}`;
      if (neg) display = "-" + display;
    }

    const title = `Value: ${full}\nRaw: ${raw.toString()}`;
    return `<span class="mono" title="${window.escapeHtml(title)}" data-copy="${raw.toString()}">${window.escapeHtml(display)}</span>`;
  }

  // No decimals: show raw shortened
  const rawDec = raw.toString();
  const abs = rawDec.startsWith("-") ? rawDec.slice(1) : rawDec;
  let display = rawDec;
  if (abs.length > 10) display = `${rawDec.slice(0, 6)}…${rawDec.slice(-4)}`;

  return `<span class="mono" title="${window.escapeHtml("Raw: " + rawDec)}" data-copy="${rawDec}">${window.escapeHtml(display)}</span>`;
}

// optional - for console testing/debug
window.dnaFormatAllowance = dnaFormatAllowance;

function dnaRowRiskChip(risk) {
  const r = String(risk || "—").toLowerCase();
  if (r.includes("high")) return `<span class="chip chip-danger">High</span>`;
  if (r.includes("med")) return `<span class="chip chip-warn">Medium</span>`;
  if (r.includes("low")) return `<span class="chip chip-ok">Low</span>`;
  if (r === "—") return `<span class="muted">—</span>`;
  return `<span class="chip">${window.escapeHtml(String(risk))}</span>`;
}

// ✅ FIX: "unverified" includes "verif" so must check UNVERIFIED first
function dnaVerifiedChip(verified) {
  const v = String(verified || "—").toLowerCase();
  if (v.includes("unver")) return `<span class="chip chip-warn">Unverified</span>`;
  if (v.includes("verif")) return `<span class="chip chip-ok">Verified</span>`;
  return `<span class="muted">—</span>`;
}

function dnaBindRevokeButtons(net) {
  const table = document.getElementById("ap-table");
  if (!table || table.__revokeBound) return;
  table.__revokeBound = true;

  table.addEventListener("click", async (e) => {
    const btn = e.target.closest?.("[data-revoke]");
    if (!btn) return;

    const tk = btn.getAttribute("data-token");
    const sp = btn.getAttribute("data-spender");
    await dnaRevokeOne(net, tk, sp);
  });
}

// -------------------------
// API fetch (handles 429 + JSON error bodies) ✅
// -------------------------
const DNA_API_BASE =
  (window.CYCLEX_API_BASE && String(window.CYCLEX_API_BASE).trim()) || location.origin;

    // -------------------------
// Live Activity ping (Home counters) ✅
// -------------------------
function cxActivitySend(t, n = 1) {
  try {
    const payload = JSON.stringify({ t, n });

    if (navigator.sendBeacon) {
      navigator.sendBeacon("/api/activity", new Blob([payload], { type: "application/json" }));
      return;
    }

    fetch("/api/activity", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: payload,
      keepalive: true,
    }).catch(() => {});
  } catch (e) {}
}


async function dnaFetchApprovals(net, address) {
  const u = new URL("/api/getApprovals", DNA_API_BASE);
  u.searchParams.set("net", net);
  u.searchParams.set("address", address);

  // optional timeout (keeps UI responsive)
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), 15000);

  let res;
  try {
    res = await fetch(u.toString(), { method: "GET", signal: ctrl.signal });
  } finally {
    clearTimeout(t);
  }

  // Try read json, else text
  const ct = (res.headers.get("content-type") || "").toLowerCase();
  const readBody = async () => {
    if (ct.includes("application/json")) {
      try { return await res.json(); } catch { /* ignore */ }
    }
    const txt = await res.text().catch(() => "");
    return txt;
  };

  if (res.status === 429) {
    const body = await readBody();
    const err = new Error("RATE_LIMIT");
    err.status = 429;
    err.body = body;
    return Promise.reject(err);
  }

  if (!res.ok) {
    const body = await readBody();
    const err = new Error(`API_ERROR_${res.status}`);
    err.status = res.status;
    err.body = body;
    return Promise.reject(err);
  }

  return await res.json();
}

function dnaRenderTips(input) {
  const el = $("#dna-tips");
  if (!el) return;

  // -------------------------
  // Option A object: { total, tips, ... }
  // -------------------------
  const isInfoObj =
    input &&
    typeof input === "object" &&
    !Array.isArray(input) &&
    Array.isArray(input.tips);

  if (isInfoObj) {
    const total = Number(input.total || 0);

    const metaHtml = (total > 0)
      ? `<li class="muted dna-meta">
           <span class="k" data-i18n="dna_meta_approvals_detected">Approvals detected:</span>
           <strong class="dna-meta-count">${total}</strong>
           <span class="sep" aria-hidden="true">•</span>
           <span data-i18n="dna_meta_spenders_hidden">Spender details hidden until unlock</span>
         </li>`
      : "";

    const tipsHtml = (input.tips && input.tips.length)
      ? input.tips.map(t => `<li>${window.escapeHtml(String(t))}</li>`).join("")
      : `<li class="muted">—</li>`;

    el.innerHTML = metaHtml + tipsHtml;

    return;
  }

  if (Array.isArray(input) && (input.length === 0 || typeof input[0] === "string")) {
    if (!input.length) {
      el.innerHTML = `<li class="muted">—</li>`;
      return;
    }
    el.innerHTML = input.map(t => `<li>${window.escapeHtml(String(t))}</li>`).join("");
    return;
  }

 
  if (Array.isArray(input)) {
    const info = dnaComputeFallbackTips(input);
    dnaRenderTips(info);
    return;
  }

  el.innerHTML = `<li class="muted">—</li>`;
}


function dnaRenderTable(rows) {
  if (!dnaFullAccess) {
    dnaClearApprovalsTable();
    return;
  }
  const table = $("#ap-table");
  const head = table?.querySelector(".trow.head");
  if (table) table.innerHTML = "";
  if (table && head) table.appendChild(head);

  if (!table) return;

  if (!rows.length) {
  table.insertAdjacentHTML("beforeend", `
    <div class="trow ap-main">
      <div class="cell muted">—</div>
      <div class="cell muted hide-sm">—</div>
      <div class="cell muted">—</div>
      <div class="cell muted hide-sm">—</div>
      <div class="cell muted hide-sm">—</div>
      <div class="cell muted">—</div>
      <div class="cell muted">—</div>
    </div>
  `);
  return;
}

    const html = rows.map(r => {
    const tkTxt = r.token ? shortAddr(r.token) : "—";
    const spTxt = r.spender ? shortAddr(r.spender) : "—";
    const tkFull = r.token || "";
    const spFull = r.spender || "";
    const alwHtml = dnaFormatAllowance(r.allowanceStr, r.decimals);
    const verTxt = dnaVerifiedChip(r.verified);
    const riskChip = dnaRowRiskChip(r.risk);

    const flagsTxtRaw = (r.flags && r.flags !== "—") ? String(r.flags) : "";
    const flagsTxt = flagsTxtRaw ? window.escapeHtml(flagsTxtRaw) : "—";

    const allowanceRawStr = String(r.allowanceStr ?? "0").trim();
    const low = allowanceRawStr.toLowerCase();
    const isUnlimited = (allowanceRawStr === "∞" || low === "infinite" || low === "unlimited" || low.includes("inf"));

    const allowanceIsNonZero = isUnlimited || (
    allowanceRawStr.startsWith("0x")
    ? !/^0x0+$/i.test(allowanceRawStr)
    : allowanceRawStr !== "" && allowanceRawStr !== "0" && allowanceRawStr !== "0.0"
);


const canRevoke =
  dnaFullAccess &&
  r.token && r.spender &&
  allowanceIsNonZero;

      const actionHtml = (dnaFullAccess && canRevoke)
  ? `<button class="chip chip-danger" data-revoke="1"
      data-token="${dnaEscAttr(r.token)}"
      data-spender="${dnaEscAttr(r.spender)}">Revoke</button>`
  : `<span class="muted">—</span>`;


    return `
      <!-- MAIN ROW (no Flags column) -->
      <div class="trow ap-main">
        <div class="cell mono">
  <span class="addr-short">${tkTxt}</span>
  ${tkFull ? `<button class="chip chip-ghost ap-copy" data-copy="${dnaEscAttr(tkFull)}" title="Copy token">Copy</button>` : ``}
</div>

<div class="cell mono hide-sm">
  <span class="addr-short">${spTxt}</span>
  ${spFull ? `<button class="chip chip-ghost ap-copy" data-copy="${dnaEscAttr(spFull)}" title="Copy spender">Copy</button>` : ``}
</div>

        <div class="cell">${alwHtml}</div>
        <div class="cell hide-sm">${verTxt}</div>
        <div class="cell hide-sm">${dnaFormatLastUpdated(r.lastUpdated)}</div>
        <div class="cell">${riskChip}</div>
        <div class="cell">${actionHtml}</div>
      </div>

      <!-- FLAGS ROW (full width; only visible on desktop where flags exist in head) -->
      <div class="trow ap-flags-row hide-sm">
        <div class="cell ap-flags-cell">
          <span class="muted" style="margin-right:10px;">Flags:</span>
          <span class="mono">${flagsTxt}</span>
        </div>
      </div>
    `;
  }).join("");

  table.insertAdjacentHTML("beforeend", html);

}
    (function bindApprovalsCopyOnce(){
  const table = document.getElementById("ap-table");
  if (!table || table.__copyBound) return;
  table.__copyBound = true;

  table.addEventListener("click", async (e) => {
    const btn = e.target.closest?.("[data-copy]");
    if (!btn) return;

    const text = String(btn.getAttribute("data-copy") || "").trim();
    if (!text) return;

    const ok = await copyText(text);
    if (ok) {
      const prev = btn.textContent;
      btn.textContent = "Copied";
      setTimeout(()=> (btn.textContent = prev), 900);
    }
  });
})();


function dnaComputeFallbackTips(rows) {
  const high = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
  const unverified = rows.filter(r => String(r.verified).toLowerCase().includes("unver")).length;
  const flagged = rows.filter(r => r.flags && r.flags !== "—").length;
  const infinite = rows.filter(r => String(r.allowanceStr).toLowerCase().includes("inf") || String(r.allowanceStr) === "∞").length;

  const total = Array.isArray(rows) ? rows.length : 0;

  const tips = [];
  if (high) tips.push(`Revoke high-risk approvals first (${high}).`);
  if (infinite) tips.push(`Consider revoking infinite approvals you don’t fully trust (${infinite}).`);
  if (unverified) tips.push(`Review unverified spender contracts before keeping approvals (${unverified}).`);
  if (flagged) tips.push(`Check flagged interactions and bridges before signing again (${flagged}).`);
  if (!tips.length) tips.push("No major red flags detected. Keep monitoring regularly.");

  return { total, high, unverified, flagged, infinite, tips };
}



async function dnaScan() {
  const st = $("#dna-status");
  clearStatus?.(st);

  const net = dnaNet();
  const address = dnaInputAddress();

  if (!address) return setStatus(st, "warn", "Enter a valid wallet address or connect a wallet.");

  setStatus(st, "info", "Scanning approvals…");

  try {
    const data = await dnaFetchApprovals(net, address);

    const approvals =
  Array.isArray(data) ? data :
  Array.isArray(data?.approvals) ? data.approvals :
  Array.isArray(data?.result) ? data.result :
  Array.isArray(data?.data) ? data.data :
  [];

    const rows = approvals.map(dnaNormalizeApiRow);
   dnaRenderTable(rows);

    // ✅ Count a real completed wallet scan
cxActivitySend("wallet_scan", 1);
const riskyCount = rows.filter(r => {
  const rr = String(r.risk || "").toLowerCase();
  return rr.includes("high") || rr.includes("med");
}).length;

if (riskyCount > 0) cxActivitySend("risky_approvals", riskyCount);


if (dnaFullAccess) {
  dnaBindRevokeButtons(net);
}


    const score = (Array.isArray(data) ? null : data?.score);
    const riskLevel = (Array.isArray(data) ? null : data?.riskLevel);

    if (score != null || riskLevel) {
  dnaApplyPills(score, riskLevel || dnaRiskLevelFromScore(score));
}

    if (score == null) {
      let s = 100;
      const high = rows.filter(r => String(r.risk).toLowerCase().includes("high")).length;
      const unverified = rows.filter(r => String(r.verified).toLowerCase().includes("unver")).length;
      const flagged = rows.filter(r => r.flags && r.flags !== "—").length;
      const infinite = rows.filter(r => String(r.allowanceStr).toLowerCase().includes("inf") || String(r.allowanceStr) === "∞").length;

      s -= high * 20;
      s -= unverified * 10;
      s -= flagged * 8;
      s -= infinite * 12;
      s = Math.max(0, Math.min(100, s));

      dnaApplyPills(s, dnaRiskLevelFromScore(s));

    }
    //try {
  //const scoreNow = Number(($("#dna-score")?.textContent || "0").trim());
  //const u = new URL("/api/saveScore", DNA_API_BASE);
  //await fetch(u.toString(), {
    //method: "POST",
    //headers: { "content-type": "application/json" },
    //body: JSON.stringify({ net, score: scoreNow })
  //});
//} catch {}

    // Best-effort: save score (ignore failures)
// Best-effort: save score (ignore failures)
try {
  const scoreNow = Number(($("#dna-score")?.textContent || "0").trim());
  const u = new URL("/api/saveScore", DNA_API_BASE);
  const resp = await fetch(u.toString(), {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ net, score: scoreNow })
  });
  if (!resp.ok) throw new Error(`saveScore ${resp.status}`);
} catch {}

    const tips = (Array.isArray(data) ? null : data?.tips);
    dnaRenderTips(Array.isArray(rows) ? rows : []);

    setStatus(st, "ok", "Done.");
    gtagEvent?.("sec_dna_scan", { net });

  } catch (e) {
    // ✅ Friendly 429 handling
    if (e?.status === 429) {
      return setStatus(
        st,
        "warn",
        "Rate limit: max 2 checks per hour per IP. Please try again later."
      );
    }

    // other errors
    const msg = e?.status
      ? `Scan failed (${e.status}). Make sure /api/getApprovals works.`
      : `Scan failed: ${String(e?.message || e)}`;

    setStatus(st, "bad", msg);
    // optional debug
    // console.log("dnaScan error:", e);
  }
}

async function dnaConnectWallet() {
  const st = $("#dna-status");
  clearStatus?.(st);

  try {
    // 1) Prefer AppKit/Web3Modal connect (interactive)
    if (typeof window.cxConnectWallet === "function") {
      const ok = await window.cxConnectWallet({ silent: false }); // ✅ MUST be false to open modal
      if (!ok) {
        setStatus(st, "warn", "Wallet connect cancelled. Try again.");
        return;
      }
    }
    // 2) If you have another global connect function
    else if (typeof window.connectWallet === "function") {
      await window.connectWallet();
    }
    // 3) Fallback: click the TOPBAR connect button if it exists
    else {
      const topBtn =
        document.querySelector("#btn-connect, #connectWallet, [data-cx-connect], [data-w3m-connect]");

      if (topBtn) {
        topBtn.click(); // opens the same modal as topbar
      } else {
        setStatus(st, "warn", "No wallet connect entrypoint found (cxConnectWallet / top button).");
        return;
      }
    }

    await new Promise(r => setTimeout(r, 50));

    dnaSetWalletBadges();

    setStatus(
      st,
      "ok",
      wallet?.address
        ? `Wallet connected: <span class="mono">${shortAddr(wallet.address)}</span>`
        : "Wallet connected."
    );

    gtagEvent?.("sec_dna_connect", { net: dnaNet(), chainId: wallet?.chainId || 0 });
  } catch (e) {
    setStatus(st, "bad", `Connect failed: ${String(e?.message || e)}`);
  }
}

// --- Minimal ERC20 ABI (only what revoke needs) ---
// Safe: no redeclare, and works even if scripts load twice
if (!Array.isArray(window.ERC20_ABI) || window.ERC20_ABI.length === 0) {
  window.ERC20_ABI = [
    "function approve(address spender, uint256 amount) returns (bool)"
  ];
}


async function dnaRevokeOne(net, token, spender) {
  const st = $("#dna-status");
  if (!dnaFullAccess) {
    return setStatus(
      st,
      "warn",
      dnaTr("dna_revoke_requires_full_access", "Full access is required for revoke actions.")
    );
  }

  if (!wallet?.signer || !wallet?.address) {
    setStatus(st, "warn", "Connect a wallet first to revoke.");
    return;
  }

  const typed = ($("#dna-walletAddress")?.value || "").trim();
  if (typed && isAddr(typed) && normAddr(typed) !== normAddr(wallet.address)) {
    setStatus(st, "warn", "You are connected with a different wallet than the address you scanned. Revoke affects ONLY the connected wallet.");
    return;
  }

  const chainId = CHAINS[net]?.chainId;
  if (chainId && wallet.chainId && wallet.chainId !== chainId) {
    const ok = await ensureChain(chainId);
    if (!ok) return setStatus(st, "warn", `Please switch network to ${CHAINS[net].name}.`);
  }

  try {
    setStatus(st, "info", "Sending revoke tx (approve → 0)…");
    const ABI = window.ERC20_ABI || ERC20_ABI;
    const c = new E.Contract(normAddr(token), window.ERC20_ABI, wallet.signer);

    const tx = await c.approve(normAddr(spender), 0n);
    setStatus(st, "info", `Pending: <span class="mono">${tx.hash}</span>`);
    await tx.wait();
    setStatus(st, "ok", "Revoke confirmed.");

    gtagEvent?.("sec_dna_revoke_one", { net });

    await dnaScan();

  } catch (e) {
    setStatus(st, "bad", `Revoke failed: ${String(e?.message || e)}`);
  }
}
    window.dnaRevokeOne = dnaRevokeOne;

async function dnaRevokeAll() {
  const st = $("#dna-status");
  const net = dnaNet();
  if (!dnaFullAccess) {
    return setStatus(
      st,
      "warn",
      dnaTr("dna_revoke_requires_full_access", "Full access is required for revoke actions.")
    );
  }

  if (!wallet?.signer || !wallet?.address) return setStatus(st, "warn", "Connect a wallet first to revoke.");

  const typed = ($("#dna-walletAddress")?.value || "").trim();
  if (typed && isAddr(typed) && normAddr(typed) !== normAddr(wallet.address)) {
    return setStatus(st, "warn", "You are connected with a different wallet than the address you scanned. Revoke affects ONLY the connected wallet.");
  }

  const btns = $$("#ap-table [data-revoke]");
  if (!btns.length) return setStatus(st, "ok", "Nothing to revoke.");

  const chainId = CHAINS[net]?.chainId;
  if (chainId && wallet.chainId && wallet.chainId !== chainId) {
    const ok = await ensureChain(chainId);
    if (!ok) return setStatus(st, "warn", `Please switch network to ${CHAINS[net].name}.`);
  }

  setStatus(st, "info", `Revoking ${btns.length} approval(s)…`);

  for (let i = 0; i < btns.length; i++) {
    const tk = btns[i].getAttribute("data-token");
    const sp = btns[i].getAttribute("data-spender");
    try {
      const ABI = window.ERC20_ABI || ERC20_ABI;
      const c = new E.Contract(normAddr(tk), window.ERC20_ABI, wallet.signer);

      const tx = await c.approve(normAddr(sp), 0n);
      setStatus(st, "info", `(${i + 1}/${btns.length}) Pending: <span class="mono">${tx.hash}</span>`);
      await tx.wait();
    } catch (e) {
      setStatus(st, "warn", `(${i + 1}/${btns.length}) Failed: ${shortAddr(tk)} — ${String(e?.message || e)}`);
    }
  }
 
  setStatus(st, "ok", "Revoke-all finished.");
  gtagEvent?.("sec_dna_revoke_all", { net });

  await dnaScan();
}
    window.dnaRevokeAll = dnaRevokeAll;

function dnaSeedCommon() {
  const net = dnaNet();
  const chain = CHAINS[net];
  const list = [chain?.wrapped, chain?.usdt].filter(Boolean);
  const ta = $("#dna-tokens");
  if (ta) ta.value = list.join("\n");
  setStatus($("#dna-status"), "ok", "Seeded common tokens (wrapped + USDT).");
}

function dnaSeedHistory() {
  const hist = loadQsHistory?.() || [];
  const net = dnaNet();
  const tokens = hist.filter(x => x?.net === net).slice(0, 20).map(x => x.token).filter(Boolean);
  const ta = $("#dna-tokens");
  if (ta) ta.value = tokens.join("\n");
  setStatus($("#dna-status"), tokens.length ? "ok" : "warn", tokens.length ? "Seeded from scan history." : "No scan history found for this network.");
}

function dnaShareScore() {
  const score = ($("#dna-score")?.textContent || "—").trim();
  const risk = ($("#dna-risk")?.textContent || "—").trim();
  const net = dnaNet();
  const addr = dnaInputAddress() ? shortAddr(dnaInputAddress()) : "wallet";

  const text = `Wallet Security DNA (${net.toUpperCase()}): ${addr} — Score: ${score}/100, Risk: ${risk}.`;
  const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(location.href)}`;
  window.open(shareUrl, "_blank", "noopener,noreferrer");
  gtagEvent?.("sec_dna_share", { net });
}

//async function dnaShowLeaderboard() {
  //const st = $("#dna-status");
  //const net = dnaNet();
  //setStatus(st, "info", "Loading leaderboard…");

  //try {
    //const u = new URL("/api/leaderboard", DNA_API_BASE);
//u.searchParams.set("net", net);
//const res = await fetch(u.toString());

  //  if (!res.ok) throw new Error(`API error: ${res.status}`);
   // const data = await res.json();

    //const top = Array.isArray(data) ? data : (data?.top || []);
    //if (!top.length) return setStatus(st, "warn", "Leaderboard is empty.");

    //const lines = top.slice(0, 10).map((x, i) => {
      //const s = x?.score ?? "—";
      //return `${i + 1}) ${s}`;
    //}).join(" · ");

    //setStatus(st, "ok", `Leaderboard: ${lines}`);
    //gtagEvent?.("sec_dna_leaderboard", { net });

  //} catch (e) {
    //setStatus(st, "warn", `Leaderboard unavailable: ${String(e?.message || e)}`);
  //}
//}

    // =========================
// CYCX Gate — RIGHT side only (Approvals section)
// Paste BETWEEN: dnaShareScore()  and  initWalletSecurityDNAUi()
// =========================

let dnaFullAccess = false;
  // expose dnaFullAccess for console debugging (kept in sync)
Object.defineProperty(window, "dnaFullAccess", {
  get() { return dnaFullAccess; },
  set(v) { dnaFullAccess = !!v; }
});


// CYCX token address on BSC
const CYCX_BSC_ADDRESS = "0xda63b65825AE30532a507B0C091B0bD9F8204F7E";

// PASS token (set your real Pass contract address here)
const PASS_BSC_ADDRESS = "0x718bc4E915fF66249C1eB86Eb566Ce4fefCA801e";

// Eligibility thresholds:
const PASS_MIN_TOKENS = 1;   // must hold >= 1 pass
const CYCX_MIN_TOKENS = 100; // OR must hold >= 100 CYCX


const CYCX_GATE_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function decimals() view returns (uint8)"
];
    const GATE_ERC20_ABI = CYCX_GATE_ABI;

function dnaTr(key, fallback) {
  try {
    if (typeof window.t === "function") {
      const v = window.t(key);
      if (v != null && String(v).trim() !== "") return v; 
    }
  } catch {}
  return fallback; 
}


function dnaSetEligMsg(text, state = "info") {
  const el = $("#dna-elig-msg");
  if (!el) return;

  el.textContent = text || "";
  el.classList.remove("elig-ok", "elig-bad", "elig-warn", "muted");

  if (state === "ok") el.classList.add("elig-ok");
  else if (state === "bad") el.classList.add("elig-bad");
  else if (state === "warn") el.classList.add("elig-warn");
  else el.classList.add("muted");
}


function dnaLockApprovalsUI(msgKey) {
  dnaFullAccess = false;

  // Show locked card, hide content/table
  $("#dna-approvals-locked")?.classList.remove("hidden");
  $("#dna-approvals-content")?.classList.add("hidden");

  // Buttons: show Full Access, hide Revoke All
  $("#dna-full-access")?.classList.remove("hidden");
  $("#dna-revoke-all")?.classList.add("hidden");
  dnaClearApprovalsTable();

  if (msgKey) {
  if (msgKey === "checking") {
    dnaSetEligMsg(dnaTr("dna_elig_checking", "Checking eligibility (PASS / CYCX)…"), "warn");
  } else if (msgKey === "wrong_net") {
    dnaSetEligMsg(dnaTr("dna_elig_wrong_net", "Please switch to BSC (BNB Chain) to check CYCX eligibility."), "warn");
  } else if (msgKey === "no") {
    dnaSetEligMsg(dnaTr("dna_elig_no", "Not eligible for full access."), "bad"); 
  } else {
    dnaSetEligMsg(dnaTr("dna_elig_error", "Could not check eligibility. Please try again."), "warn");
  }
} else {
  dnaSetEligMsg("", "info");
}

}
    function dnaClearApprovalsTable() {
  const table = $("#ap-table");
  if (!table) return;

  const head = table.querySelector(".trow.head");
  table.innerHTML = "";
  if (head) table.appendChild(head);

  table.insertAdjacentHTML("beforeend", `
    <div class="trow ap-main">
      <div class="cell muted">—</div>
      <div class="cell muted hide-sm">—</div>
      <div class="cell muted">—</div>
      <div class="cell muted hide-sm">—</div>
      <div class="cell muted hide-sm">—</div>
      <div class="cell muted">—</div>
      <div class="cell muted">—</div>
    </div>
  `);
}


function dnaUnlockApprovalsUI() {
  dnaFullAccess = true;

  $("#dna-approvals-locked")?.classList.add("hidden");
  $("#dna-approvals-content")?.classList.remove("hidden");

  $("#dna-full-access")?.classList.add("hidden");
  $("#dna-revoke-all")?.classList.remove("hidden");

  // אל תמחק מיד את ההודעה הירוקה
  // אופציה 1: להשאיר אותה עד פעולה הבאה:
  // (כלום כאן)

  // אופציה 2: למחוק אחרי 2.5 שניות:
  // setTimeout(() => dnaSetEligMsg("", "info"), 2500);
}
async function dnaCheckCycxEligibility_BSC() {
  if (!wallet?.address) return { ok: false, reason: "no_wallet" };

  const r = await withRpcFallback("bsc", async (provider) => {
    // Read BOTH tokens
    const cycx = new E.Contract(CYCX_BSC_ADDRESS, CYCX_GATE_ABI, provider);
    const pass = new E.Contract(PASS_BSC_ADDRESS, GATE_ERC20_ABI, provider);

    // CYCX decimals (ERC20)
    let cycxDecimals = 18;
    try { cycxDecimals = Number(await cycx.decimals()); } catch {}

    // balances
    const [cycxBalRaw, passBalRaw] = await Promise.all([
      cycx.balanceOf(wallet.address),
      pass.balanceOf(wallet.address)
    ]);

    // thresholds
    const cycxMinRaw = BigInt(CYCX_MIN_TOKENS) * (10n ** BigInt(cycxDecimals));
    const passMinRaw = BigInt(PASS_MIN_TOKENS); // PASS is usually 0 decimals (NFT-like or 1 unit per pass)

    const hasCycx = (BigInt(cycxBalRaw) >= cycxMinRaw);
    const hasPass = (BigInt(passBalRaw) >= passMinRaw);

    const eligible = hasPass || hasCycx;

    return {
      eligible,
      hasPass,
      hasCycx,
      passBal: BigInt(passBalRaw),
      cycxBal: BigInt(cycxBalRaw),
      cycxDecimals
    };
  }, { timeoutMs: 9000 });

  if (!r.ok) return { ok: false, reason: "rpc_failed" };
  return { ok: true, ...r.res };
}




async function dnaRequestFullAccess() {
  try {
    dnaLockApprovalsUI("checking");

if (!wallet?.address) {
  const ok = await window.cxConnectWallet?.({ silent: false }); // user asked for full access => ok to prompt
  if (!ok || !wallet?.address) {
    dnaLockApprovalsUI("error");
    return;
  }
}


    const res = await dnaCheckCycxEligibility_BSC();

    if (!res.ok) {
      if (res.reason === "wrong_net") dnaLockApprovalsUI("wrong_net");
      else dnaLockApprovalsUI("error");
      return;
    }

    if (!res.eligible) {
      dnaLockApprovalsUI("no");
      return;
    }

   dnaSetEligMsg(dnaTr("dna_elig_ok", "Eligible — unlocking approvals"), "ok");
   dnaUnlockApprovalsUI();
   await dnaScan();


  } catch (e) {
    console.error("dnaRequestFullAccess error:", e);
    dnaLockApprovalsUI("error");
  }
}

function initDnaCycxGate() {
  // Default state: locked
  dnaLockApprovalsUI();

  // Button click
  $("#dna-full-access")?.addEventListener("click", dnaRequestFullAccess);

  // Safety: if someone forces click on revoke-all while locked
  $("#dna-revoke-all")?.addEventListener("click", (e) => {
    if (!dnaFullAccess) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  }, true);

  // When reset pressed → lock again
  $("#dna-reset")?.addEventListener("click", () => dnaLockApprovalsUI());

  // When network changes → lock again
  $("#dna-net")?.addEventListener("change", () => dnaLockApprovalsUI());
}


function initWalletSecurityDNAUi() {
  dnaSetWalletBadges();
    initDnaCycxGate();

  $("#dna-run")?.addEventListener("click", dnaScan);
  $("#dna-reset")?.addEventListener("click", dnaClearOutputs);
  $("#dna-connect")?.addEventListener("click", dnaConnectWallet);

  $("#dna-revoke-all")?.addEventListener("click", dnaRevokeAll);

  $("#dna-seed-common")?.addEventListener("click", dnaSeedCommon);
  $("#dna-seed-history")?.addEventListener("click", dnaSeedHistory);

  $("#dna-share")?.addEventListener("click", dnaShareScore);
  //$("#dna-leaderboard")?.addEventListener("click", dnaShowLeaderboard);

  $("#dna-net")?.addEventListener("change", () => {
    dnaClearOutputs();
    dnaSetWalletBadges();
  });

  window.initApprovalsUi = initWalletSecurityDNAUi;

}



    // =========================
    // RPC Health Checker
    // =========================
    function rpcRowHtml(url, ms, chain, block, callOk, logsOk, status){
  const ok = status === "ok";
  const cls = ok ? "highlight" : "";

  // Host label
  let host = url;
  try { host = new URL(url).host; } catch {}

  const msTxt    = (ms ?? "—");
  const blockTxt = (block ?? "—");
  const callTxt  = (callOk ?? "—");
  const logsTxt  = (logsOk ?? "—");

  return `
    <div class="trow rpc ${cls}">
      <div class="cell rpc-url">
        <div class="rpc-host mono">${host}</div>
        <div class="rpc-full mono" title="${url}">${url}</div>
      </div>

      <div class="cell rpc-status">
        <span class="sig ${ok ? "ok" : "unk"}">
          <span class="dot"></span>
          ${ok ? "ok" : "fail"}
        </span>
      </div>

      <div class="cell rpc-meta">
        <span class="m"><b>MS</b> ${msTxt}</span>
        <span class="m"><b>Block</b> ${blockTxt}</span>
        <span class="m"><b>Call</b> ${callTxt}</span>
        <span class="m"><b>Logs</b> ${logsTxt}</span>
      </div>
    </div>
  `;
}


    async function rpcTestOne(net, url){
      const chainIdExpected = CHAINS[net].chainId;

      const t0 = performance.now();
      let chainId = null;
      let block = null;
      let callOk = "—";
      let logsOk = "—";

      try{
        const cid = await rpcRequest(url, "eth_chainId", [], 8000);
        chainId = parseInt(cid, 16);
        if (chainId !== chainIdExpected) throw new Error(`wrong chainId ${chainId}`);
      } catch (e){
        const ms = Math.round(performance.now() - t0);
        return { ok: false, url, ms, chainId: chainId ?? "—", block: "—", callOk: "—", logsOk: "—", err: e };
      }

      try{
        const bn = await rpcRequest(url, "eth_blockNumber", [], 8000);
        block = parseInt(bn, 16);
      } catch {}

      try{
        // simple eth_call to get WETH/WBNB decimals (cheap)
        const wrapped = CHAINS[net].wrapped;
        const dataDecimals = "0x313ce567"; // decimals()
        const res = await rpcRequest(url, "eth_call", [{ to: wrapped, data: dataDecimals }, "latest"], 8000);
        callOk = (res && res !== "0x") ? "✅" : "—";
      } catch {
        callOk = "—";
      }

      try{
        // lightweight logs read: last 200 blocks, Transfer topic on wrapped
        const latest = block || (parseInt(await rpcRequest(url, "eth_blockNumber", [], 8000), 16));
        const from = Math.max(0, latest - 200);
        const filter = {
          address: CHAINS[net].wrapped,
          fromBlock: "0x" + from.toString(16),
          toBlock: "0x" + latest.toString(16),
          topics: [TRANSFER_TOPIC0]
        };
        const logs = await rpcRequest(url, "eth_getLogs", [filter], 8500);
        logsOk = Array.isArray(logs) ? "✅" : "—";
      } catch {
        logsOk = "—";
      }

      const ms = Math.round(performance.now() - t0);
      return { ok: true, url, ms, chainId, block, callOk, logsOk };
    }

    async function runRpcTest(){
      const st = $("#rpc-status");
      clearStatus(st);

      const net = netFromSelect("#rpc-net");
      const table = $("#rpc-table");

      // reset table head
      if (table) {
        const head = table.querySelector(".trow.head.rpc");
        table.innerHTML = "";
        if (head) table.appendChild(head);
      }

      const urls = buildRpcCandidates(net);
      if (!urls.length) return setStatus(st, "warn", "No RPCs available.");

      setStatus(st, "info", `Testing ${urls.length} RPC(s)…`);

      let best = null;
      for (const url of urls) {
        const r = await rpcTestOne(net, url);
        if (table) {
          table.insertAdjacentHTML("beforeend", rpcRowHtml(
            url,
            r.ms ?? "—",
            r.chainId ?? "—",
            r.block ?? "—",
            r.callOk ?? "—",
            r.logsOk ?? "—",
            r.ok ? "ok" : "fail"
          ));
        }
        if (r.ok) {
          if (!best || (r.ms < best.ms)) best = r;
        }
      }

      if (best) {
        setSavedBestRpc(net, best.url);
        setStatus(st, "ok", `Best RPC saved: <span class="mono">${best.url}</span>`);
        gtagEvent("sec_rpc_best_saved", { net });
      } else {
        setStatus(st, "bad", "All RPCs failed (CORS/timeout/blocked). Try adding a custom RPC.");
      }
      gtagEvent("sec_rpc_test", { net });
    }

    async function rpcCopyBest(){
      const net = netFromSelect("#rpc-net");
      const best = getSavedBestRpc(net);
      if (!best) return setStatus($("#rpc-status"), "warn", "No saved best RPC yet. Run test first.");
      const ok = await copyText(best);
      setStatus($("#rpc-status"), ok ? "ok" : "warn", ok ? "Copied best RPC." : "Copy failed.");
    }

    function initRpcUi(){
      const netSel = $("#rpc-net");
      const privInput = $("#rpc-private");

      const loadPrivToInput = () => {
        const net = netFromSelect("#rpc-net");
        const saved = getSavedPrivateRpc(net);
        if (privInput) privInput.value = saved;
      };

      netSel?.addEventListener("change", loadPrivToInput);
      loadPrivToInput();

      $("#rpc-private-save")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const v = ($("#rpc-private")?.value || "").trim();
        if (v) setSavedPrivateRpc(net, v);
        setStatus($("#rpc-status"), "ok", "Saved private RPC locally.");
      });

      $("#rpc-private-clear")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        setSavedPrivateRpc(net, "");
        if ($("#rpc-private")) $("#rpc-private").value = "";
        setStatus($("#rpc-status"), "ok", "Cleared private RPC.");
      });

      $("#rpc-test")?.addEventListener("click", runRpcTest);
      $("#rpc-copy-best")?.addEventListener("click", rpcCopyBest);

      $("#rpc-share-x")?.addEventListener("click", () => {
        const net = netFromSelect("#rpc-net");
        const best = getSavedBestRpc(net) || "—";
        const u = new URL("https://twitter.com/intent/tweet");
        u.searchParams.set("text", `RPC Health (${CHAINS[net].name})\nBest: ${best}\nCycleX Security Hub`);
        window.open(u.toString(), "_blank", "noopener,noreferrer");
      });

      // Dev custom logs test
      $("#rpc-dev-run")?.addEventListener("click", async () => {
        const net = netFromSelect("#rpc-net");
        const addrRaw = ($("#rpc-dev-addr")?.value || "").trim();
        const topic0 = ($("#rpc-dev-topic")?.value || "").trim() || TRANSFER_TOPIC0;
        if (!addrRaw) return setStatus($("#rpc-status"), "warn", "Enter a contract address for the dev test.");
        if (!isAddr(addrRaw)) return setStatus($("#rpc-status"), "warn", "Invalid contract address.");

        const addr = normAddr(addrRaw);
        const urls = buildRpcCandidates(net);
        if (!urls.length) return setStatus($("#rpc-status"), "warn", "No RPCs available.");

        setStatus($("#rpc-status"), "info", "Running custom logs test…");
        const latest = await withRpcFallback(net, async (provider, url) => {
          const bn = await provider.getBlockNumber();
          return { url, bn };
        }, { timeoutMs: 9500 });

        if (!latest.ok) return setStatus($("#rpc-status"), "bad", `Failed to read block number: ${String(latest.err?.message || latest.err)}`);

        const bn = latest.res.bn;
        const from = Math.max(0, bn - 2000);

        const r = await withRpcFallback(net, async (provider, url) => {
          const logs = await provider.getLogs({
            address: addr,
            fromBlock: from,
            toBlock: bn,
            topics: [topic0]
          });
          return { url, count: logs.length };
        }, { timeoutMs: 10500 });

        if (r.ok) {
          setStatus($("#rpc-status"), "ok", `Custom logs test OK (${r.res.count} logs) — RPC: <span class="mono">${r.url}</span>`);
        } else {
          setStatus($("#rpc-status"), "bad", `Custom logs test failed: ${String(r.err?.message || r.err)}`);
        }
        gtagEvent("sec_rpc_dev_logs", { net });
      });
    }

// =========================
// Tx Decoder (4-line fixed DOM + Allowance line + MethodId + Tokens touched)
// Drop-in replacement for your whole Tx Decoder block.
// =========================

(() => {
  // ---- Minimal ABIs ----
  const tx_ROUTER_ABI_MIN = [
    "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETH(uint256,uint256,address[],address,uint256)",
    "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)",
    "function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256) payable",
    "function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)"
  ];

  const tx_ERC20_ABI_MIN = [
    "function symbol() view returns (string)",
    "function name() view returns (string)",
    "function decimals() view returns (uint8)"
  ];

  // ---- Constants ----
  const tx_U256_MAX = (1n << 256n) - 1n;

  // Known routers (lowercase keys)
  const tx_KNOWN_ROUTERS = {
    bsc: {
      "0x10ed43c718714eb63d5aa57b78b54704e256024e": "PancakeSwap Router",
      "0x13f4ea83d0bd40e75c8222255bc855a974568dd4": "PancakeSwap V3 Router"
    },
    eth: {
      "0x7a250d5630b4cf539739df2c5dacb4c659f2488d": "Uniswap V2 Router",
      "0xef1c6e67703c7bd7107eed8303fbe6ec2554bf6b": "Uniswap Universal Router"
    }
  };

  // ---- Token meta cache ----
  const tx_TOKEN_META_CACHE = {}; // key: `${net}:${addr}` -> {symbol,name,decimals}

  // ---- Helpers ----
  function tx_esc(s){
    try{
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    } catch { return ""; }
  }

  function tx_badge(kind, label) {
    const k = (kind === "ok" || kind === "warn" || kind === "bad" || kind === "unk") ? kind : "unk";
    return `<span class="v ${k}"><span class="dot"></span>${tx_esc(label)}</span>`;
  }

  function tx_setSum(sel, html) {
    const el = document.querySelector(sel);
    if (el) el.innerHTML = html;
  }

  // Titles already exist in HTML on the left; we only set the value HTML.
  function tx_setLine(sel, _title, badgeHtml) {
    tx_setSum(sel, badgeHtml);
  }

  // Impact line supports a subline (Allowance)
  function tx_setImpactLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-impact", `${badgeHtml}${sub}`);
  }

  // NEW: Target line supports a subline (Tokens touched)
  function tx_setTargetLine(badgeHtml, subLineText) {
    const sub = subLineText
      ? `<span class="tx-sum-sub small muted" style="display:block;margin-top:6px;opacity:.85;">${tx_esc(subLineText)}</span>`
      : "";
    tx_setSum("#tx-sum-target", `${badgeHtml}${sub}`);
  }

  function tx_resetSummary() {
    tx_setLine("#tx-sum-action", "Action", tx_badge("unk", "—"));
    tx_setLine("#tx-sum-risk", "Risk", tx_badge("unk", "—"));
    // use Target line with empty subline (keeps same DOM, just value HTML)
    tx_setTargetLine(tx_badge("unk", "—"), "");
    tx_setImpactLine(tx_badge("unk", "—"), "");
  }

  function tx_isUnlimitedApprove(vBigInt) {
    try { return typeof vBigInt === "bigint" && vBigInt === tx_U256_MAX; } catch { return false; }
  }

  function tx_getKnownRouterName(net, addr) {
    const m = (tx_KNOWN_ROUTERS && tx_KNOWN_ROUTERS[net]) ? tx_KNOWN_ROUTERS[net] : {};
    if (!addr) return "";
    const k = isAddr(addr) ? normAddr(addr) : String(addr).toLowerCase();
    return m[k] || "";
  }

  function tx_decodeTransferLog(log) {
    try {
      const from = "0x" + log.topics[1].slice(26);
      const to   = "0x" + log.topics[2].slice(26);
      const val  = BigInt(log.data);
      return { token: normAddr(log.address), from: normAddr(from), to: normAddr(to), value: val };
    } catch { return null; }
  }

  function tx_decodeApprovalLog(log) {
    try {
      const owner   = "0x" + log.topics[1].slice(26);
      const spender = "0x" + log.topics[2].slice(26);
      const val     = BigInt(log.data);
      return { token: normAddr(log.address), owner: normAddr(owner), spender: normAddr(spender), value: val };
    } catch { return null; }
  }

  // Method selector (4 bytes)
  function tx_callSelector(txData) {
    try {
      const d = String(txData || "");
      if (d && d.startsWith("0x") && d.length >= 10) return d.slice(0, 10);
      return "";
    } catch { return ""; }
  }

  async function tx_getTokenMeta(readProvider, net, tokenAddr) {
    try {
      if (!tokenAddr || !isAddr(tokenAddr)) return null;
      const a = normAddr(tokenAddr);
      const key = `${net}:${a}`;
      if (tx_TOKEN_META_CACHE[key]) return tx_TOKEN_META_CACHE[key];

      const c = new E.Contract(a, tx_ERC20_ABI_MIN, readProvider);
      const [symbol, name, decimals] = await Promise.allSettled([c.symbol(), c.name(), c.decimals()]);

      const meta = {
        symbol: symbol.status === "fulfilled" ? String(symbol.value || "") : "",
        name: name.status === "fulfilled" ? String(name.value || "") : "",
        decimals: decimals.status === "fulfilled" ? Number(decimals.value) : null
      };

      tx_TOKEN_META_CACHE[key] = meta; // cache even partial
      return meta;
    } catch {
      return null;
    }
  }

  function tx_formatUnitsSafe(valueBigInt, decimals) {
    try {
      if (decimals == null || Number.isNaN(decimals)) return null;
      return E.formatUnits(valueBigInt, decimals);
    } catch {
      return null;
    }
  }

  function tx_pickPrimaryToken(approvals, transfers) {
    return (approvals[0]?.token) || (transfers[0]?.token) || "";
  }

  function tx_pickPrimaryApproval(approvals, net){
    // Prefer: unlimited > known-router > larger value > first
    let best = null;
    let bestIsUnlimited = false;
    let bestHasRouter = false;

    for (const a of approvals) {
      if (!a) continue;
      if (!best) { best = a; bestIsUnlimited = tx_isUnlimitedApprove(a.value); bestHasRouter = !!tx_getKnownRouterName(net, a.spender); continue; }

      const aUnlimited = tx_isUnlimitedApprove(a.value);
      const aHasRouter = !!tx_getKnownRouterName(net, a.spender);

      if (!bestIsUnlimited && aUnlimited) { best = a; bestIsUnlimited = true; bestHasRouter = aHasRouter; continue; }
      if (bestIsUnlimited && aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
      }
      if (!bestIsUnlimited && !aUnlimited) {
        if (!bestHasRouter && aHasRouter) { best = a; bestHasRouter = true; continue; }
        if (typeof a.value === "bigint" && typeof best.value === "bigint" && a.value > best.value) { best = a; continue; }
      }
    }
    return best;
  }

  // =========================
  // Main
  // =========================
  async function runTxDecode() {
    const st = $("#tx-status");
    const out = $("#tx-out");
    const evWrap = $("#tx-events");
    clearStatus(st);

    tx_resetSummary();

    const net = netFromSelect("#tx-net");
    const hash = ($("#tx-hash")?.value || "").trim();
    if (!hash || !/^0x([A-Fa-f0-9]{64})$/.test(hash)) {
      setStatus(st, "warn", "Please paste a valid tx hash.");
      return;
    }

    const urls = buildRpcCandidates(net);
if (!urls.length) return setStatus(st, "bad", "No RPC available.");

setStatus(st, "info", "Fetching tx + receipt…");

try {
  const r = await withRpcFallback(net, async (provider, url) => {
    const [tx, rc] = await Promise.all([
      provider.getTransaction(hash),
      provider.getTransactionReceipt(hash)
    ]);

    if (!tx) throw new Error("tx_null");
    return { provider, tx, rc };
  }, { timeoutMs: 12000 });

  if (!r.ok) {
    const msg = String(r.err?.message || r.err || "");
    if (msg.includes("tx_null")) return setStatus(st, "bad", "Tx not found (wrong network / unsynced RPC).");
    return setStatus(st, "bad", `RPC failed: ${msg}`);
  }

  const read = r.res.provider;
  const tx = r.res.tx;
  const rc = r.res.rc;


      const chain = CHAINS[net];
      const txLink = chain.txUrl(hash);

      // best-effort decode (router calls)
      let decoded = null;
      try {
        const iface = new E.Interface(tx_ROUTER_ABI_MIN);
        decoded = iface.parseTransaction({ data: tx.data, value: tx.value });
      } catch {}

      const logs = rc?.logs || [];
      const transfersRaw = logs.filter(l => l.topics?.[0] === TRANSFER_TOPIC0).slice(0, 50);
      const approvalsRaw = logs.filter(l => l.topics?.[0] === APPROVAL_TOPIC0).slice(0, 50);

      const transfers = transfersRaw.map(tx_decodeTransferLog).filter(Boolean);
      const approvals = approvalsRaw.map(tx_decodeApprovalLog).filter(Boolean);

      const decodedName = decoded?.name || "";
      const hasRouterSwap = decodedName.toLowerCase().includes("swap");
      const hasApproval = approvals.length > 0;
      const hasTransfers = transfers.length > 0;

      const rcStatus = (rc && typeof rc.status !== "undefined") ? rc.status : undefined;
      const reverted = (rcStatus === 0 || rcStatus === 0n);

      // --- MethodId (selector) for unknown calls ---
      const methodId = (!decodedName && tx?.to) ? tx_callSelector(tx.data) : "";

      // -------------------------
      // Token meta preload (1–3 tokens touched)
      // Keep it fast and stable: prefer primary token first.
      // -------------------------
      const primaryToken = tx_pickPrimaryToken(approvals, transfers);

      const tokenSet = new Set();
      if (primaryToken) tokenSet.add(primaryToken);
      for (const t of transfers) if (t?.token) tokenSet.add(t.token);
      for (const a of approvals) if (a?.token) tokenSet.add(a.token);

      const tokenList = Array.from(tokenSet).slice(0, 3);
      const metaMap = {};

      await Promise.all(tokenList.map(async (addr) => {
        const meta = await tx_getTokenMeta(read, net, addr);
        metaMap[addr] = meta || null;
      }));

      const tokensTouched = tokenList
        .map(addr => (metaMap[addr]?.symbol || metaMap[addr]?.name || "").trim())
        .filter(Boolean)
        .slice(0, 3);

      // -------------------------
      // Action
      // -------------------------
      let actionLabel = "Unknown";
      let actionKind  = "unk";

      if (!tx.to && rc?.contractAddress) {
        actionLabel = "Contract creation";
        actionKind = reverted ? "warn" : "ok";
      } else if (decodedName) {
        actionLabel = decodedName;
        actionKind  = hasRouterSwap ? "ok" : "warn";
      } else if ((tx.data === "0x" || !tx.data) && tx.value && BigInt(tx.value) > 0n) {
        actionLabel = "Native transfer";
        actionKind = "warn";
      } else if (tx.to) {
        actionLabel = methodId ? `Contract call (unknown • ${methodId})` : "Contract call (unknown)";
        actionKind = "warn";
      }

      // -------------------------
      // Approval analysis
      // -------------------------
      let sawUnlimited = false;
      let sawKnownRouterUnlimited = false;
      let sawFiniteApprove = false;
      let sawRevoke = false;

      const knownRouterNames = new Set();

      for (const a of approvals) {
        if (!a) continue;

        const rn = tx_getKnownRouterName(net, a.spender);
        if (rn) knownRouterNames.add(rn);

        if (tx_isUnlimitedApprove(a.value)) {
          sawUnlimited = true;
          if (rn) sawKnownRouterUnlimited = true;
        } else {
          if (a.value === 0n) sawRevoke = true;
          else sawFiniteApprove = true;
        }
      }

      // -------------------------
      // Allowance subline (ONLY when approvals exist)
      // Allowance: TOKEN → SPENDER (Unlimited / Limited / Revoked)
      // -------------------------
      let allowanceSub = "";
      if (hasApproval) {
        const bestAppr = tx_pickPrimaryApproval(approvals, net);
        if (bestAppr) {
          const tokenAddr = bestAppr.token;
          const spenderAddr = bestAppr.spender;

          const tokenMeta = metaMap[tokenAddr] || null;
          const tokName = (tokenMeta?.symbol || tokenMeta?.name || shortAddr(tokenAddr)).trim();

          const spenderRouter = tx_getKnownRouterName(net, spenderAddr);
          const spenderName = spenderRouter ? spenderRouter : shortAddr(spenderAddr);

          let status = "";
          if (tx_isUnlimitedApprove(bestAppr.value)) {
            status = "Unlimited";
          } else if (bestAppr.value === 0n) {
            status = "Revoked";
          } else {
            // show amount if decimals known
            const dec = tokenMeta?.decimals;
            const pretty = (dec != null) ? tx_formatUnitsSafe(bestAppr.value, dec) : null;
            status = pretty ? `Limited: ${pretty}` : "Limited";
          }

          allowanceSub = `Allowance: ${tokName} \u2192 ${spenderName} (${status})`;
        }
      }

      // -------------------------
      // Target (Token/Asset + creation support)
      // -------------------------
      let targetKind = "unk";
      let targetLabel = "—";

      if (!tx.to && rc?.contractAddress) {
        targetLabel = `New contract (${shortAddr(rc.contractAddress)})`;
        targetKind = reverted ? "warn" : "ok";
      } else if (tx.to) {
        const toRouterName = tx_getKnownRouterName(net, tx.to);
        if (toRouterName) {
          targetLabel = `${toRouterName} (${shortAddr(tx.to)})`;
          targetKind = "warn";
        } else if (primaryToken) {
          const meta = metaMap[primaryToken] || null;
          const nm = (meta?.symbol || meta?.name || "").trim();
          targetLabel = nm ? `${nm} (${shortAddr(primaryToken)})` : shortAddr(primaryToken);
          targetKind = "ok";
        } else {
          targetLabel = shortAddr(tx.to);
          targetKind = "ok";
        }
      }

      // NEW: Tokens touched subline for Summary (only when we have 1–3)
      const touchedSub = tokensTouched.length ? `Tokens touched: ${tokensTouched.join(", ")}` : "";

      // -------------------------
      // Risk (heuristics)
      // -------------------------
      let riskLabel = "Unknown";
      let riskKind  = "unk";

      if (reverted) {
        riskLabel = "Tx reverted (failed)";
        riskKind = "warn";
      } else if (hasRouterSwap) {
        riskLabel = "Likely DEX swap";
        riskKind = "ok";
      } else if (sawUnlimited && !sawKnownRouterUnlimited) {
        riskLabel = "High risk: unlimited approval (unknown spender)";
        riskKind = "bad";
      } else if (sawUnlimited && sawKnownRouterUnlimited) {
        const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
        riskLabel = `Unlimited approval (known router${names ? ": " + names : ""})`;
        riskKind = "warn";
      } else if (hasApproval && !decodedName) {
        riskLabel = "Approval without decoded call";
        riskKind = "warn";
      } else if (!decodedName && hasTransfers) {
        riskLabel = "Transfer activity (unknown call)";
        riskKind = "warn";
      } else if (decodedName) {
        riskLabel = "Contract interaction";
        riskKind = "warn";
      }

      // -------------------------
      // Max impact (Allowance-aware + largest transfer)
      // -------------------------
      let impactLabel = "—";
      let impactKind = "unk";

      if (sawUnlimited) {
        if (sawKnownRouterUnlimited) {
          const names = Array.from(knownRouterNames).slice(0, 2).join(", ");
          impactLabel = `Unlimited spending approved (known router${names ? ": " + names : ""})`;
          impactKind = "warn";
        } else {
          impactLabel = "Unlimited spending approved (unknown spender)";
          impactKind = "bad";
        }
      } else if (sawFiniteApprove) {
        impactLabel = "Spending approved (limited)";
        impactKind = "warn";
      } else if (sawRevoke && !hasTransfers) {
        impactLabel = "Allowance revoked";
        impactKind = "ok";
      } else if (tx.value && BigInt(tx.value) > 0n) {
        impactLabel = `Sends ${E.formatEther(tx.value)} native`;
        impactKind = "warn";
      } else if (hasTransfers) {
        let largest = transfers[0];
        for (const t of transfers) if (t.value > largest.value) largest = t;

        const meta = metaMap[largest?.token] || null;
        const sym = (meta?.symbol || "").trim();
        const dec = meta?.decimals;

        const pretty = (dec != null) ? tx_formatUnitsSafe(largest.value, dec) : null;
        if (pretty && sym) impactLabel = `Largest transfer: ${pretty} ${sym}`;
        else if (sym) impactLabel = `Largest transfer: ${sym} (raw)`;
        else impactLabel = `${transfers.length} token transfer(s)`;

        impactKind = "ok";
      } else if (hasApproval) {
        impactLabel = "Allowance changed";
        impactKind = "warn";
      }

      // -------------------------
      // Fill the 4 fixed lines
      // (Target now includes Tokens touched subline)
      // (+ allowance subline under Max impact)
      // -------------------------
      tx_setLine("#tx-sum-action", "Action", tx_badge(actionKind, actionLabel));
      tx_setLine("#tx-sum-risk", "Risk", tx_badge(riskKind, riskLabel));
      tx_setTargetLine(tx_badge(targetKind, targetLabel), touchedSub);
      tx_setImpactLine(tx_badge(impactKind, impactLabel), allowanceSub);

      // -------------------------
      // Details panel (professional: Status + Gas + MethodId + Tokens touched)
      // -------------------------
      const gasUsed = rc?.gasUsed ? String(rc.gasUsed) : "—";
      const statusTxt = (typeof rcStatus === "undefined") ? "—" : (reverted ? "FAILED" : "SUCCESS");
      const tokensLine = tokensTouched.length ? `<b>Tokens:</b> <span class="mono">${tx_esc(tokensTouched.join(", "))}</span><br>` : "";
      const methodLine = (!decodedName && methodId) ? `<b>Method:</b> <span class="mono">${tx_esc(methodId)}</span><br>` : "";

      out.innerHTML = `
        <div class="small" style="margin-bottom:10px;">
          <b>Tx:</b> <a href="${txLink}" target="_blank" rel="noopener">${shortAddr(hash)}</a>
          <span class="muted">(${tx_esc(String(net).toUpperCase())})</span><br>
          <b>Status:</b> <span class="mono">${tx_esc(statusTxt)}</span> &nbsp; <b>Gas used:</b> <span class="mono">${tx_esc(gasUsed)}</span><br>
          ${methodLine}
          ${tokensLine}
          <b>From:</b> <span class="mono">${tx_esc(tx.from)}</span><br>
          <b>To:</b> <span class="mono">${tx_esc(tx.to || "—")}</span><br>
          <b>Value:</b> <span class="mono">${tx_esc(tx.value ? E.formatEther(tx.value) : "0")}</span>
        </div>
      `;
      out.style.display = "block";

      // -------------------------
      // Events (with token labels best-effort)
      // -------------------------
      const items = [];

      if (decoded?.args) {
        const args = [];
        decoded.args.forEach((v, i) => {
          args.push(`<div class="small mono" style="margin-top:6px;">arg${i}: ${tx_esc(String(v))}</div>`);
        });
        items.push(`
          <div class="card">
            <h3>Decoded Inputs</h3>
            <div class="small">Best-effort decode for common router calls.</div>
            ${args.join("")}
          </div>
        `);
      }

      if (transfers.length) {
        const rows = transfers.map(d => {
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const tag = sym ? ` <span class="muted">(${tx_esc(sym)})</span>` : "";
          return `<div class="small mono" style="margin-top:6px;">Transfer ${shortAddr(d.from)} → ${shortAddr(d.to)}${tag} • raw: ${tx_esc(d.value.toString())}</div>`;
        }).join("");

        items.push(`
          <div class="card">
            <h3>Transfer Events</h3>
            ${rows}
          </div>
        `);
      }

      if (approvals.length) {
        const rows = approvals.map(d => {
          const routerName = tx_getKnownRouterName(net, d.spender);
          const routerTag = routerName ? ` <span class="muted">(${tx_esc(routerName)})</span>` : "";
          const meta = metaMap[d.token] || null;
          const sym = (meta?.symbol || "").trim();
          const tokenTag = sym ? ` <span class="muted">(${tx_esc(sym)})</span>` : "";

          const inf = tx_isUnlimitedApprove(d.value)
            ? ` <span class="muted">(unlimited)</span>`
            : (d.value === 0n ? ` <span class="muted">(revoked)</span>` : "");

          return `<div class="small mono" style="margin-top:6px;">Approval ${shortAddr(d.owner)} → ${shortAddr(d.spender)}${routerTag}${tokenTag} • raw: ${tx_esc(d.value.toString())}${inf}</div>`;
        }).join("");

        items.push(`
          <div class="card">
            <h3>Approval Events</h3>
            ${rows}
          </div>
        `);
      }

      evWrap.innerHTML = items.length
        ? `<div class="grid-2">${items.join("")}</div>`
        : `<div class="small muted">No common events detected (or log count is zero).</div>`;

      setStatus(st, "ok", "Done.");
      gtagEvent("sec_tx_decode", { net });

    } catch (e) {
      setStatus(st, "bad", `Decode failed: ${String(e?.message || e)}`);
    }
  }

  // =========================
  // UI wiring (idempotent)
  // =========================
  let tx_ui_inited = false;

  function initTxUi() {
    if (tx_ui_inited) return;
    tx_ui_inited = true;

    $("#tx-run")?.addEventListener("click", runTxDecode);

    $("#tx-copy-md")?.addEventListener("click", async () => {
      const a = (document.querySelector("#tx-sum-action")?.innerText || "Action —").trim();
      const r = (document.querySelector("#tx-sum-risk")?.innerText || "Risk —").trim();
      const t = (document.querySelector("#tx-sum-target")?.innerText || "Target —").trim();
      const m = (document.querySelector("#tx-sum-impact")?.innerText || "Max impact —").trim();
      const body = ($("#tx-out")?.innerText || "").trim();

      const txt = ["Tx Decoder Summary", a, r, t, m, "", body].join("\n");

      const ok = await copyText(txt);
      setStatus($("#tx-status"), ok ? "ok" : "warn", ok ? "Copied." : "Copy failed.");
    });
  }

  // =========================
  // Export
  // =========================
  window.CX = window.CX || {};
  window.CX.runTxDecode = runTxDecode;
  window.CX.initTxUi = initTxUi;
  window.CX.txDecoder = window.CX.txDecoder || {};
  window.CX.txDecoder.getTokenMeta = tx_getTokenMeta;
  window.CX.txDecoder.metaCache = tx_TOKEN_META_CACHE;

})();



    // =========================
    // Dev Tools (Bookmarklet + Monitor)
    // =========================
    function renderBmHelp(){
      const el = $("#bm-help");
      if (!el) return;
      el.innerHTML = t(currentLang, "bm_help_html") || "";
    }

    function bmGenerate(){
      const base = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
      const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${base}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

      const bm = `javascript:${encodeURIComponent(js)}`;
      setStatus($("#bm-out"), "ok", `Bookmarklet generated. <span class="mono">(copy it)</span>`);
      $("#bm-out").dataset.bm = bm;
      const drag = $("#bm-drag");
if (drag) {
  drag.href = bm;                 
  drag.classList.remove("hidden");
  drag.setAttribute("data-ready", "1");
}
      renderBmHelp();
      gtagEvent("sec_bm_generate");
    }

    async function bmCopy(){
      const bm = $("#bm-out")?.dataset?.bm || "";
      if (!bm) return setStatus($("#bm-out"), "warn", "Generate first.");
      const ok = await copyText(bm);
      setStatus($("#bm-out"), ok ? "ok" : "warn", ok ? "Copied bookmarklet." : "Copy failed.");
    }

    function loadMonitor(){
      try { return JSON.parse(localStorage.getItem(LS_MON) || "[]"); } catch { return []; }
    }
    function saveMonitor(list){
      try { localStorage.setItem(LS_MON, JSON.stringify(list || [])); } catch {}
    }

    function renderMonitorTable(){
      const table = $("#mon-table");
      if (!table) return;
      const head = table.querySelector(".trow.head");
      table.innerHTML = "";
      if (head) table.appendChild(head);

      const list = loadMonitor();
      if (!list.length) {
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell muted">—</div>
    <div class="cell muted">—</div>
    <div class="cell muted hide-sm">—</div>
    <div class="cell muted">—</div>
    <div class="cell muted">—</div>
  </div>
`);
        return;
      }

      for (const item of list) {
        const chain = CHAINS[item.net];
        table.insertAdjacentHTML("beforeend", `
  <div class="trow">
    <div class="cell mono"><a href="${chain.addressUrl(item.addr)}" target="_blank" rel="noopener">${shortAddr(item.addr)}</a></div>
    <div class="cell">${String(item.net || "").toUpperCase()}</div>
    <div class="cell hide-sm">${
  item.lastSeen
    ? new Date(item.lastSeen * 1000).toLocaleString().replace(", ", "<br>")
    : "—"
}</div>
    <div class="cell">${item.status || "—"}</div>

    <div class="cell">
      <button class="mon-remove" type="button"
              data-action="mon-remove"
              data-addr="${item.addr}"
              data-net="${item.net}"
              title="Remove"
              aria-label="Remove">×</button>
    </div>
  </div>
`);
      }
    }

    async function monAdd(){
      const st = $("#mon-status");
      clearStatus(st);

      const net = netFromSelect("#mon-net");
      const addrRaw = ($("#mon-addr")?.value || "").trim();
      if (!isAddr(addrRaw)) return setStatus(st, "warn", "Enter a valid contract address.");

      const addr = normAddr(addrRaw);
      const list = loadMonitor();
      const key = `${net}:${safeLower(addr)}`;
      const filtered = list.filter(x => `${x.net}:${safeLower(x.addr)}` !== key);
      filtered.unshift({ net, addr, status: "added", lastSeen: nowTs() });
      saveMonitor(filtered.slice(0, 50));
      renderMonitorTable();
      setStatus(st, "ok", "Added to monitor list (local).");
      gtagEvent("sec_mon_add", { net });
    }

    async function monCheckAll(){
      const st = $("#mon-status");
      clearStatus(st);

      const list = loadMonitor();
      if (!list.length) return setStatus(st, "warn", "Monitor list is empty.");

      setStatus(st, "info", `Checking ${list.length} contract(s)…`);

      for (const item of list) {
        try{
          const codeRes = await getCodeSafe(item.net, item.addr);
          item.status = (codeRes.ok && codeRes.code && codeRes.code !== "0x") ? "code ✅" : "no code ❌";
          item.lastSeen = nowTs();
        } catch {
          item.status = "error";
          item.lastSeen = nowTs();
        }
      }

      saveMonitor(list);
      renderMonitorTable();
      setStatus(st, "ok", "Monitor check done.");
      gtagEvent("sec_mon_check");
    }

    async function monExport(){
      const list = loadMonitor();
      const ok = await copyText(safeJson(list));
      setStatus($("#mon-status"), ok ? "ok" : "warn", ok ? "Copied JSON." : "Copy failed.");
    }
    function monRemove(addr, net){
  const st = $("#mon-status");
  const addrLower = safeLower(String(addr || "").trim());
  const netLower  = safeLower(String(net || "").trim());

  const list = loadMonitor();
  const next = list.filter(it =>
    !(safeLower(it.net) === netLower && safeLower(it.addr) === addrLower)
  );

  saveMonitor(next);
  renderMonitorTable();
  setStatus(st, "ok", "Removed.");
  gtagEvent("sec_mon_remove", { net: netLower });
}

function bindMonRemove(){
  const table = $("#mon-table");
  if (!table || table.__cxBoundRemove) return;
  table.__cxBoundRemove = true;

  table.addEventListener("click", (e) => {
    const btn = e.target.closest('button[data-action="mon-remove"]');
    if (!btn) return;
    e.preventDefault();
    monRemove(btn.getAttribute("data-addr"), btn.getAttribute("data-net"));
  });
}


    function initDevUi(){
      const base = location.href.split("?")[0];
      const el = $("#bm-base");
      if (el) el.value = base;

      $("#bm-generate")?.addEventListener("click", bmGenerate);
      $("#bm-copy")?.addEventListener("click", bmCopy);

      $("#mon-add")?.addEventListener("click", monAdd);
      $("#mon-check")?.addEventListener("click", monCheckAll);
      $("#mon-export")?.addEventListener("click", monExport);

      renderBmHelp();
      renderMonitorTable();
      bindMonRemove();
      // Always enable the "drag to bookmarks" link (default bookmarklet)
try {
  const hubBase = ($("#bm-base")?.value || location.href.split("?")[0]).trim();
  const js = `
(function(){
  try{
    var href = location.href;
    var u = new URL(href);
    var isTx = /\\/tx\\//i.test(u.pathname);
    var v = href.split("/").pop().split("?")[0].split("#")[0];
    var net = /etherscan\\.io/i.test(u.host) ? "eth" : "bsc";
    var hub = new URL("${hubBase}");
    hub.searchParams.set("tool", isTx ? "tx" : "quick");
    hub.searchParams.set("net", net);
    if (isTx) hub.searchParams.set("tx", v);
    else hub.searchParams.set("token", v);
    hub.hash = isTx ? "#panel-tx" : "#panel-quick";
    window.open(hub.toString(), "_blank");
  }catch(e){ alert("CycleX Hub bookmarklet error"); }
})();`.trim();

  const bmDefault = `javascript:${encodeURIComponent(js)}`;

  const drag = $("#bm-drag");
  if (drag) drag.href = bmDefault;
} catch {}

    }

    // =========================
    // URL auto-run (tool=...)
    // =========================
    async function handleAutoRun(){
      const q = parseQuery();
      if (!q.tool) return;

      const tool = q.tool;
      const netRaw = String(q.net || q.chain || "").toLowerCase();
      const net = (netRaw === "eth" || netRaw === "ethereum" || netRaw === "1") ? "eth" : "bsc";

      if (tool === "quick") {
        showPanel("quick");
        if ($("#qs-net")) $("#qs-net").value = net;
        if (q.token && isAddr(q.token)) {
          if ($("#qs-token")) $("#qs-token").value = normAddr(q.token);
          setTimeout(() => {
  const fn = window.CX_QS_V5?.runQuickScan || window.runQuickScan;
  if (typeof fn === "function") fn();
}, 250);

        }
      }

      if (tool === "liq") {
        showPanel("liq");
        if ($("#liq-net")) $("#liq-net").value = net;
        if (q.token && isAddr(q.token)) {
          if ($("#liq-token")) $("#liq-token").value = normAddr(q.token);
          setTimeout(() => runLiqScan(), 250);
        }
      }

      if (tool === "tx") {
  showPanel("tx");

  if (q.tx && /^0x([A-Fa-f0-9]{64})$/.test(q.tx)) {
    if ($("#tx-hash")) $("#tx-hash").value = q.tx;

    setTimeout(() => {
      const sel = $("#tx-net");
      if (sel) {
        sel.value = net; 
        sel.dispatchEvent(new Event("change", { bubbles: true }));
      }
      const btn = $("#tx-run");
      if (btn) btn.click();
    }, 400);
  }
}
      setTimeout(() => {
  const target = `#panel-${tool}`;   
  const el = document.querySelector(target);
  if (!el) return;

  try { history.replaceState(null, "", target); }
  catch { location.hash = target; }

  el.scrollIntoView({ behavior: "smooth", block: "start" });
}, 450);
    }

    // =========================
// DNA — export for console/tests
// =========================
try {
  window.dnaScan = window.dnaScan || dnaScan;
  window.dnaConnectWallet = window.dnaConnectWallet || dnaConnectWallet;

  window.dnaRequestFullAccess = window.dnaRequestFullAccess || dnaRequestFullAccess;
  window.dnaCheckCycxEligibility_BSC = window.dnaCheckCycxEligibility_BSC || dnaCheckCycxEligibility_BSC;

  window.initWalletSecurityDNAUi = window.initWalletSecurityDNAUi || initWalletSecurityDNAUi;
  window.initDnaCycxGate = window.initDnaCycxGate || initDnaCycxGate;

  // optional (helps console tests)
  window.withRpcFallback = window.withRpcFallback || withRpcFallback;
  window.E = window.E || E;
} catch (e) {
  console.warn("DNA exports failed:", e);
}

    // =========================
    // Boot
    // =========================
    function boot(){
      initLang();
      bindLangButtons();

      initPanels();
      initWalletButtons();
      initApiKeysUi();
      bindAccessModal();

      initQuickScanUi();
      initLiqUi();
      initWalletSecurityDNAUi();
      initRpcUi();
      if (window.CX && typeof window.CX.initTxUi === "function") {
  window.CX.initTxUi();
}
      initDevUi();

      applyI18n(currentLang);
      renderWalletLabels();
      handleAutoRun();

      // UX: close panels via ESC
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") showPanel(null);
      });
    }

    // Run
    boot();
  </script>
</body>
</html>

        
