<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/logo.png">
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">

  <meta charset="UTF-8" />
  <title>CycleX â€“ Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg-main: #05060a;
      --bg-gradient-start: #05060a;
      --bg-gradient-mid: #1a0d3a;
      --bg-gradient-end: #003a4c;

      --text-main: #f4f6ff;
      --text-muted: rgba(244, 246, 255, 0.7);

      --accent-cyan: #00e5ff;
      --accent-green: #5dffb2;
      --accent-purple: #7c5cff;

      --card-bg: rgba(255, 255, 255, 0.06);
      --border-subtle: rgba(255, 255, 255, 0.12);

      --shadow-soft: 0 30px 90px rgba(0, 0, 0, 0.75);
      --radius-xl: 24px;
      --radius-lg: 18px;
      --transition-fast: 0.18s ease-out;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      --maxw: 1160px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: var(--sans);
      background:
        radial-gradient(circle at top left, rgba(124, 92, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at top right, rgba(0, 229, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at bottom, rgba(0, 58, 76, 0.55) 0%, transparent 55%),
        linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
      color: var(--text-main);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      animation: fadeBody 0.7s ease-out forwards;
      opacity: 1;
      overflow-x: hidden;
    }
    @keyframes fadeBody { from { opacity: 0; } to { opacity: 1; } }
    a { color: inherit; text-decoration: none; }

    .page-shell { max-width: var(--maxw); margin: 0 auto; padding: 32px 20px 72px; }

    /* Top bar */
    .top-bar {
      position: sticky;
      top: 14px;
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 18px;
      margin-bottom: 26px;
      border-radius: 999px;
      background: rgba(8, 10, 22, 0.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }
    .brand { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .brand-logo {
      width: 44px; height: 44px; border-radius: 16px; object-fit: contain;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
      flex: 0 0 auto;
    }
    .brand-text { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .brand-title {
      font-weight: 800; letter-spacing: 0.05em; font-size: 18px; text-transform: uppercase;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .brand-sub {
      font-size: 11px; text-transform: uppercase; letter-spacing: 0.16em; color: var(--text-muted);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }

    .lang-switch {
      display: inline-flex;
      align-items: center;
      padding: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.55);
      gap: 2px;
      flex: 0 0 auto;
    }
    .lang-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      padding: 6px 9px;
      border-radius: 999px;
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast), transform var(--transition-fast);
      user-select: none;
      white-space: nowrap;
    }
    .lang-btn:hover { transform: translateY(-1px); }
    .lang-btn.active { background: rgba(0, 229, 255, 0.14); color: var(--accent-cyan); }

    body.lang-switching { animation: langFade 0.28s ease-out; }
    @keyframes langFade { from { opacity: 0.5; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* Hero */
    .hero {
      text-align: center;
      max-width: 980px;
      margin: 0 auto 18px auto;
      animation: fadeUp 0.8s ease-out forwards;
    }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

    .hero-kicker { font-size: 13px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-cyan); margin-bottom: 14px; }
    .hero-title { font-size: clamp(40px, 5vw, 60px); line-height: 1.05; font-weight: 900; margin-bottom: 14px; letter-spacing: -0.02em; }
    .hero-subtitle { max-width: 760px; margin: 0 auto 18px auto; font-size: 16px; line-height: 1.5; color: var(--text-muted); }

    .hero-actions { display: flex; justify-content: center; flex-wrap: wrap; gap: 14px; margin-bottom: 10px; }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 13px 26px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast);
      user-select: none;
      white-space: nowrap;
    }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), #7df2ff);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 229, 255, 0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 229, 255, 0.6); }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-green), #b9ffcf);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 230, 118, 0.4);
    }
    .btn-secondary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 230, 118, 0.7); }

    .btn-ghost {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--text-main);
      box-shadow: 0 12px 34px rgba(0,0,0,0.45);
    }
    .btn-ghost:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }

    .note-line {
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.45;
    }

    /* Tool cubes â€” 2x2 centered */
    .tool-grid-wrap { max-width: 980px; margin: 0 auto 18px; }
    .tool-grid-title {
      text-align: center;
      margin: 14px 0 8px;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(244,246,255,0.72);
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
      margin-top: 10px;
      align-items: stretch;
    }
    .tool-card {
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius-xl);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 22px 22px 18px;
      box-shadow: 0 24px 70px rgba(0,0,0,0.65), inset 0 1px 0 rgba(255,255,255,0.05);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: transform var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
      min-width: 0;
      min-height: 178px;
    }
    .tool-card::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(520px 180px at 18% -5%, rgba(0,229,255,.18), transparent 60%),
        radial-gradient(520px 180px at 85% 0%, rgba(124,92,255,.18), transparent 60%);
      pointer-events:none;
      opacity: .95;
    }
    .tool-card > * { position: relative; }

    .tool-card:hover { transform: translateY(-3px); border-color: rgba(0,229,255,0.28); background: rgba(255,255,255,0.065); }
    .tool-card.active { border-color: rgba(0,229,255,0.42); background: rgba(0,229,255,0.06); }

    .tool-head { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:10px; }
    .tool-name { font-size: 17px; font-weight: 900; letter-spacing: 0.01em; line-height: 1.25; }
    .tool-desc { font-size: 14px; color: var(--text-muted); line-height: 1.5; }

    .badge-row { display:flex; flex-wrap:wrap; gap:8px; margin-top: 14px; }
    .badge {
      display:inline-flex; align-items:center; gap:8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
      user-select: none;
    }
    .badge strong { color: rgba(244,246,255,0.92); font-weight: 800; }
    .badge.beta { border-color: rgba(255,193,7,0.25); background: rgba(255,193,7,0.08); color: rgba(244,246,255,0.92); }

    /* Panels */
    .panel-shell {
      margin-top: 14px;
      padding: 22px 20px;
      border-radius: var(--radius-xl);
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    .panel-shell.hidden { display: none; }

    .panel-head {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .panel-kicker {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--accent-purple);
      margin-bottom: 8px;
    }
    .panel-title { font-size: 28px; font-weight: 900; letter-spacing: -0.01em; line-height: 1.12; }
    .panel-sub { margin-top: 8px; max-width: 900px; color: var(--text-muted); font-size: 14px; line-height: 1.6; }

    .panel-actions { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 14px; }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 16px;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
      min-width: 0;
    }
    .card h3 { font-size: 15px; letter-spacing: 0.02em; margin-bottom: 8px; color: var(--text-main); }
    .muted { color: var(--text-muted); font-size: 13px; line-height: 1.45; }

    .field { margin-top: 10px; }
    .label { font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); margin-bottom: 6px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(5, 7, 18, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    textarea { border-radius: 18px; min-height: 96px; resize: vertical; padding: 12px 12px; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent-cyan); }
    .mono { font-family: var(--mono); }

    .toggle{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      user-select:none;
      width: 100%;
    }
    .toggle input{ width:auto; accent-color: var(--accent-cyan); }

    .status {
      margin-top: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: var(--text-main);
      line-height: 1.5;
      font-size: 13px;
      display: none;
      overflow-wrap: anywhere;
    }
    .status.ok   { display:block; background: rgba(0, 230, 118, 0.10); border-color: rgba(0,230,118,0.35); color: #78ffbf; }
    .status.warn { display:block; background: rgba(255, 193, 7, 0.10); border-color: rgba(255,193,7,0.35); color: #ffd166; }
    .status.bad  { display:block; background: rgba(220, 53, 69, 0.10); border-color: rgba(220,53,69,0.35); color: #ff7a8a; }
    .status.info { display:block; background: rgba(0, 229, 255, 0.10); border-color: rgba(0,229,255,0.30); color: #7df2ff; }

    .small { font-size: 12px; color: var(--text-muted); line-height: 1.45; }

    .table {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      overflow: hidden;
    }
    .trow {
      display: grid;
      grid-template-columns: 1.3fr 1.1fr 0.9fr 0.9fr;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      align-items: center;
      font-size: 13px;
    }
    .trow.head {
      border-top: none;
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(244,246,255,0.75);
    }

    /* RPC table needs extra columns (logs) */
    .trow.rpc { grid-template-columns: 1.55fr 0.7fr 0.7fr 0.6fr 0.6fr; }

    .trow .cell { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .trow .cell.wrap { white-space: normal; overflow: visible; }
    .trow .cell .mini { font-size: 12px; color: rgba(244,246,255,0.82); }
    .trow.highlight { background: rgba(0,230,118,0.10); border-top-color: rgba(0,230,118,0.20); }

    .chips { display:flex; flex-wrap:wrap; gap:10px; margin-top: 10px; }
    .chip {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: rgba(244,246,255,0.88);
      cursor: pointer;
      user-select: none;
      transition: transform var(--transition-fast), border-color var(--transition-fast);
      font-size: 12px;
    }
    .chip:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }
    .chip .x { opacity: .85; color: var(--text-muted); }

    .share-row { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }

    /* Footer */
    .footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      margin-top: 20px;
      padding-top: 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .footer-tagline { color: var(--accent-cyan); font-weight: 700; }

    /* RTL tweaks */
    html[dir="rtl"] body { direction: rtl; }
    html[dir="rtl"] .top-bar { flex-direction: row-reverse; }
    html[dir="rtl"] .brand { flex-direction: row-reverse; }
    html[dir="rtl"] .panel-head { flex-direction: row-reverse; }
    html[dir="rtl"] .row { flex-direction: row-reverse; }
    html[dir="rtl"] .panel-actions { justify-content: flex-start; }

    /* Responsiveness */
    @media (max-width: 980px) {
      .grid-2 { grid-template-columns: 1fr; }
      .trow { grid-template-columns: 1.2fr 1fr 0.9fr; }
      .trow .hide-sm { display: none; }
      .panel-title { font-size: 24px; }
      .trow.rpc { grid-template-columns: 1.7fr 0.9fr 0.9fr; }
    }
    @media (max-width: 900px) {
      .tool-grid { grid-template-columns: 1fr; }
      .tool-card { min-height: unset; }
    }
    @media (max-width: 640px) {
      .top-bar { top: 10px; padding: 10px 12px; }
      .brand-logo { width: 40px; height: 40px; border-radius: 14px; }
      .btn { padding: 12px 18px; font-size: 13px; }
    }
  </style>
</head>
<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector">
        <button class="lang-btn active" data-lang="en">ğŸ‡ºğŸ‡¸ EN</button>
        <button class="lang-btn" data-lang="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="ar">ğŸ‡¸ğŸ‡¦ Ø¹Ø±Ø¨ÙŠ</button>
        <button class="lang-btn" data-lang="ru">ğŸ‡·ğŸ‡º RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Tools</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          A lightweight, client-side toolkit for safer swaps, approvals hygiene, and RPC health checks across BSC + Ethereum.
        </p>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-quick" data-i18n="btn_quick">Run Quick Scan</button>
        </div>

        <div class="note-line" data-i18n="hero_note">
          Note: These checks are informational and do not guarantee safety. Always verify independently.
        </div>
      </section>

      <section class="tool-grid-wrap">
        <div class="tool-grid-title" data-i18n="tools_kicker">CHOOSE A TOOL</div>

        <div class="tool-grid" id="toolGrid">
          <div class="tool-card active" data-tool="quick">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_quick_title">Quick Scan</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_quick_desc">
              Fast token sanity-check: contract, metadata, owner/proxy hints, and shareable report.
            </div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_fast">Fast</strong></div>
              <div class="badge"><strong data-i18n="badge_history">History</strong></div>
              <div class="badge"><strong data-i18n="badge_share">Share</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="approvals">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_approvals_title">Approval Guardian</div>
              <div class="badge"><strong data-i18n="badge_wallet">Wallet</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_approvals_desc">
              Check and revoke ERC-20 allowances safely (approve â†’ 0) with a clean, pro UX.
            </div>
            <div class="badge-row">
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
              <div class="badge"><strong data-i18n="badge_revoke">Revoke</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="rpc">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_rpc_title">RPC Health Checker</div>
              <div class="badge"><strong>BSC</strong> + <strong>ETH</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_rpc_desc">
              Test endpoints, show latency + block height + read logs, then copy the best RPC instantly.
            </div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_table">Table</strong></div>
              <div class="badge"><strong data-i18n="badge_copy">Copy</strong></div>
            </div>
          </div>

          <div class="tool-card" data-tool="monitor">
            <div class="tool-head">
              <div class="tool-name" data-i18n="cube_monitor_title">Contract Diff / Upgrade Monitor</div>
              <div class="badge"><strong data-i18n="badge_watch">Watch</strong></div>
            </div>
            <div class="tool-desc" data-i18n="cube_monitor_desc">
              Save contracts locally, detect bytecode changes and proxy implementation upgrades over time.
            </div>
            <div class="badge-row">
              <div class="badge"><strong data-i18n="badge_local">Local</strong></div>
              <div class="badge"><strong data-i18n="badge_changes">Changes</strong></div>
            </div>
          </div>
        </div>
      </section>

      <!-- PANELS -->
      <section class="panel-shell" id="panel-quick">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_quick_kicker">Quick Scan</div>
            <div class="panel-title" data-i18n="p_quick_title">Score a token in seconds</div>
            <div class="panel-sub" data-i18n="p_quick_sub">
              Paste a token address, choose network, run scan. We save history locally and generate shareable outputs.
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="walletLabel">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseQuick" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="quick_input_title">Token Input</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="qs-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Token contract</div>
              <input id="qs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="qs_tip">
                Tip: open with <span class="mono">?tool=quick&net=bsc&token=0x...</span> to auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="options_label">Options</div>
              <label class="toggle">
                <input type="checkbox" id="qs-require-liq">
                <span data-i18n="opt_require_liq">Require liquidity (stricter score)</span>
              </label>
              <label class="toggle" style="margin-top:10px">
                <input type="checkbox" id="qs-show-json" checked>
                <span data-i18n="opt_show_json">Enable JSON report (copy)</span>
              </label>
            </div>

            <!-- NEW: Explorer API keys (stored locally) -->
            <div class="field" style="margin-top:14px">
              <div class="label" data-i18n="api_keys_label">Explorer API keys (optional)</div>
              <label class="toggle">
                <input type="checkbox" id="api-use">
                <span data-i18n="opt_use_explorer_apis">Use BscScan/Etherscan (adds Verified + ABI heuristics)</span>
              </label>

              <div class="row" style="margin-top:10px">
                <input id="api-bscscan" class="mono" placeholder="BscScan API key (stored locally)" />
                <input id="api-etherscan" class="mono" placeholder="Etherscan API key (stored locally)" />
              </div>

              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="api-save" style="padding:10px 14px; font-size:12px;" data-i18n="btn_save">Save</button>
                <button class="btn btn-ghost" id="api-clear" style="padding:10px 14px; font-size:12px;" data-i18n="btn_clear">Clear</button>
              </div>

              <div class="small" style="margin-top:8px" data-i18n="api_keys_tip">
                Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="qs-run" data-i18n="btn_scan">Scan</button>
                <button class="btn btn-ghost" id="qs-copy-link" data-i18n="btn_copy_link">Copy Share Link</button>
                <button class="btn btn-ghost" id="qs-copy-json" data-i18n="btn_copy_json">Copy JSON</button>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="history_label">History</div>
              <div class="chips" id="qs-history"></div>
              <div class="small" style="margin-top:8px" data-i18n="history_tip">
                Click an item to re-run quickly. Stored locally only.
              </div>
            </div>

            <div class="share-row">
              <button class="btn btn-ghost" id="qs-share-x">Share to X</button>
              <button class="btn btn-ghost" id="qs-share-tg">Share to Telegram</button>
            </div>

            <div id="qs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="results_title">Results</h3>
            <div class="small" data-i18n="results_hint">
              Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.
            </div>

            <div id="qs-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="qs-pairsWrap" style="margin-top:12px;"></div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-approvals">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_app_kicker">Approval Guardian</div>
            <div class="panel-title" data-i18n="p_app_title">Check and revoke allowances</div>
            <div class="panel-sub" data-i18n="p_app_sub">
              Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).
            </div>
          </div>
          <div class="panel-actions">
            <div class="pill"><span data-i18n="pill_wallet">Wallet</span>: <span class="mono" id="ap-wallet">not connected</span></div>
            <button class="btn btn-ghost" id="btnCloseApprovals" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="ap_settings_title">Settings</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="ap-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="row" style="justify-content:space-between">
                <div class="pill"><span data-i18n="ap_connected">Connected:</span> <span id="ap-address" class="mono">â€”</span></div>
                <button class="btn btn-secondary" id="ap-connect" data-i18n="ap_connect">Connect / Refresh</button>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_spender_label">Spender preset</div>
              <div class="row">
                <select id="ap-spender-preset">
                  <option value="pcs_router">PancakeSwap Router (BSC)</option>
                  <option value="uni_router">Uniswap V2 Router (ETH)</option>
                  <option value="custom">Customâ€¦</option>
                </select>
                <input id="ap-spender" class="mono" placeholder="0x spender..." />
              </div>
              <div class="small" style="margin-top:8px" data-i18n="ap_spender_tip">
                Start with a router preset, then add tokens you want to clean up.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_tokens_label">Token list (one per line)</div>
              <textarea id="ap-tokens" class="mono" placeholder="0x...\n0x...\n0x..."></textarea>
              <div class="row" style="margin-top:10px">
                <button class="btn btn-ghost" id="ap-seed-common" data-i18n="ap_seed">Seed common tokens</button>
                <button class="btn btn-ghost" id="ap-seed-history" data-i18n="ap_seed_history">Use scan history</button>
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="ap-check" data-i18n="ap_check">Check Allowances</button>
                <button class="btn btn-ghost" id="ap-revoke-all" data-i18n="ap_revoke_all">Revoke All (non-zero)</button>
              </div>
            </div>

            <div id="ap-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="ap_results">Allowances</h3>
            <div class="small" data-i18n="ap_results_hint">
              If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.
            </div>

            <div id="ap-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Token</div>
                <div class="cell">Allowance</div>
                <div class="cell hide-sm">Symbol</div>
                <div class="cell">Action</div>
              </div>
              <div class="trow">
                <div class="cell muted">â€”</div>
                <div class="cell muted">â€”</div>
                <div class="cell muted hide-sm">â€”</div>
                <div class="cell muted">â€”</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-rpc">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_rpc_kicker">RPC Health Checker</div>
            <div class="panel-title" data-i18n="p_rpc_title">Find the best endpoint</div>
            <div class="panel-sub" data-i18n="p_rpc_sub">
              We test RPC endpoints with eth_blockNumber and measure latency + Read Logs (eth_getLogs). Best result is highlighted and ready to copy.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseRpc" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_inputs">Inputs</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="rpc-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC (top priority)</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-copy-json">Copy JSON list</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
              <div class="trow head rpc">
                <div class="cell">RPC</div>
                <div class="cell">Latency</div>
                <div class="cell hide-sm">Block</div>
                <div class="cell hide-sm">Read logs</div>
                <div class="cell">Status</div>
              </div>
            </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.
            </div>
          </div>
        </div>
      </section>

      <section class="panel-shell hidden" id="panel-monitor">
        <div class="panel-head">
          <div>
            <div class="panel-kicker" data-i18n="p_mon_kicker">Contract Monitor</div>
            <div class="panel-title" data-i18n="p_mon_title">Detect upgrades & bytecode changes</div>
            <div class="panel-sub" data-i18n="p_mon_sub">
              Save contracts locally. We store code hash + proxy implementation. Re-check later to detect changes.
            </div>
          </div>
          <div class="panel-actions">
            <button class="btn btn-ghost" id="btnCloseMonitor" data-i18n="btn_close">Close</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="mon_add_title">Add to watchlist</h3>

            <div class="field">
              <div class="label" data-i18n="net_label">Network</div>
              <select id="mon-net">
                <option value="bsc">BSC (BNB Chain)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="addr_label">Contract address</div>
              <input id="mon-addr" class="mono" placeholder="0x..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="mon-add" data-i18n="mon_add">Add</button>
                <button class="btn btn-ghost" id="mon-check" data-i18n="mon_check">Check all</button>
                <button class="btn btn-ghost" id="mon-export">Export JSON</button>
              </div>
            </div>

            <div id="mon-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="mon_list_title">Watchlist</h3>
            <div class="small" data-i18n="mon_list_hint">Stored locally only. No server tracking.</div>

            <div id="mon-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Contract</div>
                <div class="cell">Network</div>
                <div class="cell hide-sm">Last seen</div>
                <div class="cell">Status</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <script>
(() => {
  "use strict";

  const E = window.ethers;

  // =========================
  // i18n
  // =========================
  const translations = {
    en: {
      brand_sub: "On-Chain Security & Rewards",
      hero_kicker: "Security Hub",
      hero_title: "CycleX Security Tools",
      hero_subtitle: "A lightweight, client-side toolkit for safer swaps, approvals hygiene, and RPC health checks across BSC + Ethereum.",
      btn_back: "Back to Site",
      btn_connect: "Connect Wallet (optional)",
      btn_quick: "Run Quick Scan",
      hero_note: "Note: These checks are informational and do not guarantee safety. Always verify independently.",
      tools_kicker: "CHOOSE A TOOL",

      cube_quick_title: "Quick Scan",
      cube_quick_desc: "Fast token sanity-check: contract, metadata, owner/proxy hints, and shareable report.",
      badge_fast: "Fast",
      badge_history: "History",
      badge_share: "Share",

      cube_approvals_title: "Approval Guardian",
      cube_approvals_desc: "Connect wallet, review allowances, and revoke approvals safely.",
      badge_wallet: "Wallet",
      badge_revoke: "Revoke",

      cube_rpc_title: "RPC Health Checker",
      cube_rpc_desc: "Test endpoints, show latency + block height + read logs, then copy the best RPC instantly.",
      badge_table: "Table",
      badge_copy: "Copy",

      cube_monitor_title: "Contract Diff / Upgrade Monitor",
      cube_monitor_desc: "Save contracts locally, detect bytecode changes and proxy implementation upgrades over time.",
      badge_watch: "Watch",
      badge_local: "Local",
      badge_changes: "Changes",

      p_quick_kicker: "Quick Scan",
      p_quick_title: "Score a token in seconds",
      p_quick_sub: "Paste a token address, choose network, run scan. We save history locally and generate shareable outputs.",
      pill_wallet: "Wallet",
      btn_close: "Close",
      quick_input_title: "Token Input",
      net_label: "Network",
      addr_label: "Token contract",
      qs_tip: "Tip: open with ?tool=quick&net=bsc&token=0x... to auto-run.",
      options_label: "Options",
      opt_require_liq: "Require liquidity (stricter score)",
      opt_show_json: "Enable JSON report (copy)",
      btn_scan: "Scan",
      btn_copy_link: "Copy Share Link",
      btn_copy_json: "Copy JSON",
      history_label: "History",
      history_tip: "Click an item to re-run quickly. Stored locally only.",
      results_title: "Results",
      results_hint: "Green / Yellow / Red signals. Not a guarantee â€” just verifiable on-chain checks.",

      api_keys_label: "Explorer API keys (optional)",
      opt_use_explorer_apis: "Use BscScan/Etherscan (adds Verified + ABI heuristics)",
      btn_save: "Save",
      btn_clear: "Clear",
      api_keys_tip: "Keys are saved in your browser (localStorage) only. Do not paste keys into public HTML.",

      p_app_kicker: "Approval Guardian",
      p_app_title: "Check and revoke allowances",
      p_app_sub: "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
      ap_settings_title: "Settings",
      ap_connected: "Connected:",
      ap_connect: "Connect / Refresh",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "Start with a router preset, then add tokens you want to clean up.",
      ap_tokens_label: "Token list (one per line)",
      ap_seed: "Seed common tokens",
      ap_seed_history: "Use scan history",
      ap_check: "Check Allowances",
      ap_revoke_all: "Revoke All (non-zero)",
      ap_results: "Allowances",
      ap_results_hint: "If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.",

      p_rpc_kicker: "RPC Health Checker",
      p_rpc_title: "Find the best endpoint",
      p_rpc_sub: "We test RPC endpoints with eth_blockNumber and measure latency + Read Logs (eth_getLogs). Best result is highlighted and ready to copy.",
      rpc_inputs: "Inputs",
      rpc_custom_label: "Optional custom RPC (top priority)",
      rpc_test: "Test RPCs",
      rpc_copy_best: "Copy Best RPC",
      rpc_results: "Results",
      rpc_tip: "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",

      p_mon_kicker: "Contract Monitor",
      p_mon_title: "Detect upgrades & bytecode changes",
      p_mon_sub: "Save contracts locally. We store code hash + proxy implementation. Re-check later to detect changes.",
      mon_add_title: "Add to watchlist",
      mon_add: "Add",
      mon_check: "Check all",
      mon_export: "Export JSON",
      mon_list_title: "Watchlist",
      mon_list_hint: "Stored locally only. No server tracking.",

      footer_left: "CycleX Security Hub runs client-side and reads public on-chain data.",
      footer_tagline: "Verify twice. Connect only when you trust the page."
    },

    zh: {
      brand_sub: "é“¾ä¸Šå®‰å…¨ä¸å¥–åŠ±",
      hero_kicker: "å®‰å…¨ä¸­å¿ƒ",
      hero_title: "CycleX å®‰å…¨å·¥å…·",
      hero_subtitle: "è½»é‡çº§å®¢æˆ·ç«¯å·¥å…·ï¼šæ›´å®‰å…¨çš„ Swapã€æˆæƒç®¡ç†ä¸ RPC å¥åº·æ£€æŸ¥ï¼ˆBSC + ä»¥å¤ªåŠï¼‰ã€‚",
      btn_back: "è¿”å›ä¸»ç«™",
      btn_connect: "è¿æ¥é’±åŒ…ï¼ˆå¯é€‰ï¼‰",
      btn_quick: "è¿è¡Œå¿«é€Ÿæ‰«æ",
      hero_note: "æç¤ºï¼šè¿™äº›æ£€æŸ¥ä»…ä¾›å‚è€ƒï¼Œä¸ä¿è¯å®‰å…¨ï¼Œè¯·åŠ¡å¿…è‡ªè¡ŒäºŒæ¬¡éªŒè¯ã€‚",
      tools_kicker: "é€‰æ‹©å·¥å…·",

      cube_quick_title: "å¿«é€Ÿæ‰«æ",
      cube_quick_desc: "å¿«é€ŸåŸºç¡€æ£€æŸ¥ï¼šåˆçº¦ã€å…ƒæ•°æ®ã€owner/proxy çº¿ç´¢ï¼Œå¯ç”Ÿæˆåˆ†äº«æŠ¥å‘Šã€‚",
      badge_fast: "å¿«é€Ÿ",
      badge_history: "å†å²",
      badge_share: "åˆ†äº«",

      cube_approvals_title: "æˆæƒå®ˆå«",
      cube_approvals_desc: "è¿æ¥é’±åŒ…ï¼ŒæŸ¥çœ‹ allowanceï¼Œå¹¶å®‰å…¨æ’¤é”€æˆæƒã€‚",
      badge_wallet: "é’±åŒ…",
      badge_revoke: "æ’¤é”€",

      cube_rpc_title: "RPC å¥åº·æ£€æŸ¥",
      cube_rpc_desc: "æµ‹è¯•èŠ‚ç‚¹ã€æµ‹å»¶è¿Ÿä¸åŒºå—é«˜åº¦/è¯»æ—¥å¿—ï¼Œä¸€é”®å¤åˆ¶æœ€ä½³ RPCã€‚",
      badge_table: "è¡¨æ ¼",
      badge_copy: "å¤åˆ¶",

      cube_monitor_title: "åˆçº¦å˜æ›´ç›‘æ§",
      cube_monitor_desc: "æœ¬åœ°ä¿å­˜å¹¶æ£€æµ‹å­—èŠ‚ç å˜åŒ–ä¸ä»£ç†å®ç°å‡çº§ã€‚",
      badge_watch: "ç›‘æ§",
      badge_local: "æœ¬åœ°",
      badge_changes: "å˜åŒ–",

      p_quick_kicker: "å¿«é€Ÿæ‰«æ",
      p_quick_title: "å‡ ç§’å†…ç»™ä»£å¸æ‰“åˆ†",
      p_quick_sub: "ç²˜è´´ä»£å¸åœ°å€ï¼Œé€‰æ‹©ç½‘ç»œï¼Œè¿è¡Œæ‰«æã€‚å†å²ä»…ä¿å­˜åœ¨æœ¬åœ°ï¼Œå¯åˆ†äº«ç»“æœã€‚",
      pill_wallet: "é’±åŒ…",
      btn_close: "å…³é—­",
      quick_input_title: "ä»£å¸è¾“å…¥",
      net_label: "ç½‘ç»œ",
      addr_label: "ä»£å¸åˆçº¦",
      qs_tip: "æç¤ºï¼šä½¿ç”¨ ?tool=quick&net=bsc&token=0x... æ‰“å¼€å¯è‡ªåŠ¨è¿è¡Œã€‚",
      options_label: "é€‰é¡¹",
      opt_require_liq: "è¦æ±‚æµåŠ¨æ€§ï¼ˆæ›´ä¸¥æ ¼ï¼‰",
      opt_show_json: "å¯ç”¨ JSON æŠ¥å‘Šï¼ˆå¤åˆ¶ï¼‰",
      btn_scan: "æ‰«æ",
      btn_copy_link: "å¤åˆ¶åˆ†äº«é“¾æ¥",
      btn_copy_json: "å¤åˆ¶ JSON",
      history_label: "å†å²",
      history_tip: "ç‚¹å‡»å³å¯å¿«é€Ÿé‡è·‘ã€‚ä»…æœ¬åœ°å­˜å‚¨ã€‚",
      results_title: "ç»“æœ",
      results_hint: "ç»¿/é»„/çº¢ä¿¡å·ã€‚éä¿è¯â€”ä»…å¯é“¾ä¸ŠéªŒè¯çš„æ£€æŸ¥ã€‚",

      api_keys_label: "åŒºå—æµè§ˆå™¨ APIï¼ˆå¯é€‰ï¼‰",
      opt_use_explorer_apis: "ä½¿ç”¨ BscScan/Etherscanï¼ˆå¢åŠ å·²éªŒè¯ + ABI é£é™©æç¤ºï¼‰",
      btn_save: "ä¿å­˜",
      btn_clear: "æ¸…é™¤",
      api_keys_tip: "å¯†é’¥ä»…ä¿å­˜åœ¨ä½ çš„æµè§ˆå™¨ï¼ˆlocalStorageï¼‰ã€‚ä¸è¦æŠŠå¯†é’¥å†™å…¥å…¬å¼€ HTMLã€‚",

      p_app_kicker: "æˆæƒå®ˆå«",
      p_app_title: "æ£€æŸ¥å¹¶æ’¤é”€æˆæƒ",
      p_app_sub: "è¾“å…¥ spender + ä»£å¸ï¼ˆæˆ–ä¸€é”®å¡«å……å¸¸ç”¨ä»£å¸ï¼‰ã€‚è¯»å– allowance(owner, spender)ï¼Œå¹¶ç”¨ approve(spender, 0) æ’¤é”€ã€‚",
      ap_settings_title: "è®¾ç½®",
      ap_connected: "å·²è¿æ¥ï¼š",
      ap_connect: "è¿æ¥ / åˆ·æ–°",
      ap_spender_label: "Spender é¢„è®¾",
      ap_spender_tip: "å…ˆé€‰è·¯ç”±é¢„è®¾ï¼Œç„¶åæ·»åŠ è¦æ¸…ç†çš„ä»£å¸ã€‚",
      ap_tokens_label: "ä»£å¸åˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰",
      ap_seed: "å¡«å……å¸¸ç”¨ä»£å¸",
      ap_seed_history: "ä½¿ç”¨æ‰«æå†å²",
      ap_check: "æ£€æŸ¥æˆæƒ",
      ap_revoke_all: "æ’¤é”€å…¨éƒ¨ï¼ˆéé›¶ï¼‰",
      ap_results: "æˆæƒç»“æœ",
      ap_results_hint: "è‹¥æˆæƒä¸ºâ€œæ— é™â€ï¼Œé™¤éå®Œå…¨ä¿¡ä»»ï¼Œå¦åˆ™å»ºè®®æ’¤é”€ã€‚",

      p_rpc_kicker: "RPC å¥åº·æ£€æŸ¥",
      p_rpc_title: "æ‰¾åˆ°æœ€ä½³èŠ‚ç‚¹",
      p_rpc_sub: "ç”¨ eth_blockNumber æµ‹å»¶è¿Ÿï¼Œå¹¶éªŒè¯è¯»æ—¥å¿— (eth_getLogs)ã€‚æœ€ä½³ç»“æœä¼šé«˜äº®ï¼Œå¯ä¸€é”®å¤åˆ¶ã€‚",
      rpc_inputs: "è¾“å…¥",
      rpc_custom_label: "å¯é€‰ï¼šè‡ªå®šä¹‰ RPCï¼ˆä¼˜å…ˆï¼‰",
      rpc_test: "æµ‹è¯• RPC",
      rpc_copy_best: "å¤åˆ¶æœ€ä½³ RPC",
      rpc_results: "ç»“æœ",
      rpc_tip: "æç¤ºï¼šéƒ¨åˆ† RPC å¯èƒ½å›  CORS/è¶…æ—¶å¤±è´¥ã€‚æµ‹è¯•åé€‰æ‹©ç¨³å®šä¸”æœ€å¿«çš„ã€‚",

      p_mon_kicker: "åˆçº¦ç›‘æ§",
      p_mon_title: "æ£€æµ‹å‡çº§ä¸å­—èŠ‚ç å˜åŒ–",
      p_mon_sub: "æœ¬åœ°ä¿å­˜åˆçº¦å¹¶å®šæœŸå¤æŸ¥ä»¥å‘ç°å˜åŒ–ã€‚",
      mon_add_title: "æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨",
      mon_add: "æ·»åŠ ",
      mon_check: "æ£€æŸ¥å…¨éƒ¨",
      mon_export: "å¯¼å‡º JSON",
      mon_list_title: "ç›‘æ§åˆ—è¡¨",
      mon_list_hint: "ä»…æœ¬åœ°å­˜å‚¨ï¼Œä¸åšæœåŠ¡å™¨è·Ÿè¸ªã€‚",

      footer_left: "CycleX å®‰å…¨ä¸­å¿ƒåœ¨æœ¬åœ°è¿è¡Œï¼Œè¯»å–å…¬å¼€é“¾ä¸Šæ•°æ®ã€‚",
      footer_tagline: "å¤šéªŒè¯ä¸€æ¬¡ï¼Œåªåœ¨ä½ ä¿¡ä»»æ—¶è¿æ¥é’±åŒ…ã€‚"
    },

    ar: {
      brand_sub: "Ø£Ù…Ù† ÙˆÙ…ÙƒØ§ÙØ¢Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
      hero_kicker: "Ù…Ø±ÙƒØ² Ø§Ù„Ø£Ù…Ø§Ù†",
      hero_title: "Ø£Ø¯ÙˆØ§Øª Ø£Ù…Ø§Ù† CycleX",
      hero_subtitle: "Ø£Ø¯ÙˆØ§Øª Ø®ÙÙŠÙØ© Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ Ù„ÙØ­Øµ Ø£Ù…Ø§Ù† Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª ÙˆÙ‚ÙŠØ§Ø³ ØµØ­Ø© RPC (BSC + Ethereum).",
      btn_back: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆÙ‚Ø¹",
      btn_connect: "Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø­ÙØ¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
      btn_quick: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
      hero_note: "Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ù‡ Ø§Ù„ÙØ­ÙˆØµØ§Øª Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠØ© ÙˆÙ„Ø§ ØªØ¶Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù†. ØªØ­Ù‚Ù‚ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¨Ù†ÙØ³Ùƒ.",
      tools_kicker: "Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø©",

      cube_quick_title: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
      cube_quick_desc: "ÙØ­Øµ Ø£Ø³Ø§Ø³ÙŠ Ø³Ø±ÙŠØ¹: Ø§Ù„Ø¹Ù‚Ø¯ØŒ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø¥Ø´Ø§Ø±Ø§Øª owner/proxy ÙˆØªÙ‚Ø±ÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ©.",
      badge_fast: "Ø³Ø±ÙŠØ¹",
      badge_history: "Ø³Ø¬Ù„",
      badge_share: "Ù…Ø´Ø§Ø±ÙƒØ©",

      cube_approvals_title: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      cube_approvals_desc: "Ø§ØªØµÙ„ Ø¨Ø§Ù„Ù…Ø­ÙØ¸Ø© ÙˆØ±Ø§Ø¬Ø¹/Ø£Ù„ØºÙ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª Ø¨Ø£Ù…Ø§Ù†.",
      badge_wallet: "Ù…Ø­ÙØ¸Ø©",
      badge_revoke: "Ø¥Ù„ØºØ§Ø¡",

      cube_rpc_title: "ÙØ­Øµ RPC",
      cube_rpc_desc: "Ø§Ø®ØªØ¨Ø± Ø§Ù„Ù†Ù‚Ø§Ø·ØŒ Ù‚ÙØ³ Ø§Ù„ØªØ£Ø®ÙŠØ± ÙˆØ§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¨Ù„ÙˆÙƒ/Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø³Ø¬Ù„Ø§ØªØŒ ÙˆØ§Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC.",
      badge_table: "Ø¬Ø¯ÙˆÙ„",
      badge_copy: "Ù†Ø³Ø®",

      cube_monitor_title: "Ù…Ø±Ø§Ù‚Ø¨Ø© ØªØºÙŠÙ‘Ø± Ø§Ù„Ø¹Ù‚Ø¯",
      cube_monitor_desc: "Ø­ÙØ¸ Ù…Ø­Ù„ÙŠ ÙˆÙƒØ´Ù ØªØºÙŠÙ‘Ø± Ø§Ù„Ø¨Ø§ÙŠØª ÙƒÙˆØ¯ ÙˆØªØ±Ù‚ÙŠØ© proxy Ù…Ø¹ Ø§Ù„ÙˆÙ‚Øª.",
      badge_watch: "Ù…Ø±Ø§Ù‚Ø¨Ø©",
      badge_local: "Ù…Ø­Ù„ÙŠ",
      badge_changes: "ØªØºÙŠÙŠØ±Ø§Øª",

      p_quick_kicker: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",
      p_quick_title: "Ù‚ÙŠÙ‘Ù… Ø§Ù„ØªÙˆÙƒÙ† Ø®Ù„Ø§Ù„ Ø«ÙˆØ§Ù†Ù",
      p_quick_sub: "Ø§Ù„ØµÙ‚ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ†ØŒ Ø§Ø®ØªØ± Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ Ø´ØºÙ‘Ù„ Ø§Ù„ÙØ­Øµ. Ø§Ù„Ø³Ø¬Ù„ Ù…Ø­Ù„ÙŠ ÙˆÙŠÙ…ÙƒÙ† Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬.",
      pill_wallet: "Ù…Ø­ÙØ¸Ø©",
      btn_close: "Ø¥ØºÙ„Ø§Ù‚",
      quick_input_title: "Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†",
      net_label: "Ø§Ù„Ø´Ø¨ÙƒØ©",
      addr_label: "Ø¹Ù‚Ø¯ Ø§Ù„ØªÙˆÙƒÙ†",
      qs_tip: "Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ Ø¨Ù€ ?tool=quick&net=bsc&token=0x... Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.",
      options_label: "Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª",
      opt_require_liq: "Ø§Ø´ØªØ±Ø§Ø· Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (Ø£ÙƒØ«Ø± ØµØ±Ø§Ù…Ø©)",
      opt_show_json: "ØªÙØ¹ÙŠÙ„ ØªÙ‚Ø±ÙŠØ± JSON (Ù†Ø³Ø®)",
      btn_scan: "ÙØ­Øµ",
      btn_copy_link: "Ù†Ø³Ø® Ø±Ø§Ø¨Ø·",
      btn_copy_json: "Ù†Ø³Ø® JSON",
      history_label: "Ø§Ù„Ø³Ø¬Ù„",
      history_tip: "Ø§Ø¶ØºØ· Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙØ­Øµ Ø¨Ø³Ø±Ø¹Ø©. Ø§Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø­Ù„ÙŠ ÙÙ‚Ø·.",
      results_title: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
      results_hint: "Ø¥Ø´Ø§Ø±Ø§Øª Ø®Ø¶Ø±Ø§Ø¡/ØµÙØ±Ø§Ø¡/Ø­Ù…Ø±Ø§Ø¡. Ù„ÙŠØ³Øª Ø¶Ù…Ø§Ù†Ø§Ù‹ â€” ÙØ­ÙˆØµØ§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ on-chain.",

      api_keys_label: "Ù…ÙØ§ØªÙŠØ­ Explorer (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
      opt_use_explorer_apis: "Ø§Ø³ØªØ®Ø¯Ù… BscScan/Etherscan (Verified + ØªØ­Ø°ÙŠØ±Ø§Øª ABI)",
      btn_save: "Ø­ÙØ¸",
      btn_clear: "Ù…Ø³Ø­",
      api_keys_tip: "Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ØªÙØ­ÙØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ (localStorage). Ù„Ø§ ØªØ¶Ø¹Ù‡Ø§ Ø¯Ø§Ø®Ù„ HTML Ø¹Ø§Ù….",

      p_app_kicker: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      p_app_title: "ÙØ­Øµ ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      p_app_sub: "Ø£Ø¯Ø®Ù„ spender + ØªÙˆÙƒÙ†Ø§Øª (Ø£Ùˆ Ø£Ø¶Ù Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©). Ù†Ù‚Ø±Ø£ allowance(owner, spender) ÙˆÙ†Ù„ØºÙŠ Ø¹Ø¨Ø± approve(spender, 0).",
      ap_settings_title: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
      ap_connected: "Ù…ØªØµÙ„:",
      ap_connect: "Ø§ØªØµØ§Ù„ / ØªØ­Ø¯ÙŠØ«",
      ap_spender_label: "Spender Ø¬Ø§Ù‡Ø²",
      ap_spender_tip: "Ø§Ø¨Ø¯Ø£ Ø¨Ù…ÙˆØ¬Ù‡ Ø¬Ø§Ù‡Ø² Ø«Ù… Ø£Ø¶Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªÙ†Ø¸ÙŠÙÙ‡Ø§.",
      ap_tokens_label: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (Ø³Ø·Ø± Ù„ÙƒÙ„ ØªÙˆÙƒÙ†)",
      ap_seed: "Ø£Ø¶Ù ØªÙˆÙƒÙ†Ø§Øª Ø´Ø§Ø¦Ø¹Ø©",
      ap_seed_history: "Ø§Ø³ØªØ®Ø¯Ù… Ø³Ø¬Ù„ Ø§Ù„ÙØ­Øµ",
      ap_check: "ÙØ­Øµ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      ap_revoke_all: "Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„ (ØºÙŠØ± ØµÙØ±)",
      ap_results: "Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
      ap_results_hint: "Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© â€œØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©â€ØŒ ÙŠÙÙ†ØµØ­ Ø¨Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ«Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹ Ø¨Ø§Ù„Ù€ spender.",

      p_rpc_kicker: "ÙØ­Øµ RPC",
      p_rpc_title: "Ø§Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Endpoint",
      p_rpc_sub: "Ù†Ø®ØªØ¨Ø± RPC Ø¨Ù€ eth_blockNumber ÙˆÙ†Ù‚ÙŠØ³ Ø§Ù„ØªØ£Ø®ÙŠØ± ÙˆÙ†ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø³Ø¬Ù„Ø§Øª (eth_getLogs). Ø§Ù„Ø£ÙØ¶Ù„ ÙŠØ¨Ø±Ø² ÙˆÙŠÙ…ÙƒÙ† Ù†Ø³Ø®Ù‡.",
      rpc_inputs: "Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª",
      rpc_custom_label: "RPC Ù…Ø®ØµØµ (Ø£ÙˆÙ„ÙˆÙŠØ©)",
      rpc_test: "Ø§Ø®ØªØ¨Ø§Ø± RPC",
      rpc_copy_best: "Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC",
      rpc_results: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
      rpc_tip: "Ù…Ù„Ø§Ø­Ø¸Ø©: Ø¨Ø¹Ø¶ RPC ØªÙØ´Ù„ Ø¨Ø³Ø¨Ø¨ CORS/timeout. Ø§Ø®ØªØ¨Ø± ÙˆØ§Ø®ØªØ± Ø§Ù„Ø£Ø³Ø±Ø¹ ÙˆØ§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªÙ‚Ø±Ø§Ø±Ø§Ù‹.",

      p_mon_kicker: "Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù‚Ø¯",
      p_mon_title: "ÙƒØ´Ù Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª ÙˆØªØºÙŠÙ‘Ø± Ø§Ù„Ø¨Ø§ÙŠØª ÙƒÙˆØ¯",
      p_mon_sub: "Ø§Ø­ÙØ¸ Ø§Ù„Ø¹Ù‚ÙˆØ¯ Ù…Ø­Ù„ÙŠØ§Ù‹. Ù†Ø®Ø²Ù† hash Ù„Ù„ÙƒÙˆØ¯ + ØªÙ†ÙÙŠØ° proxy. Ø§ÙØ­Øµ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ù„ÙƒØ´Ù Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª.",
      mon_add_title: "Ø¥Ø¶Ø§ÙØ© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©",
      mon_add: "Ø¥Ø¶Ø§ÙØ©",
      mon_check: "ÙØ­Øµ Ø§Ù„ÙƒÙ„",
      mon_export: "ØªØµØ¯ÙŠØ± JSON",
      mon_list_title: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©",
      mon_list_hint: "ØªØ®Ø²ÙŠÙ† Ù…Ø­Ù„ÙŠ ÙÙ‚Ø·. Ø¨Ø¯ÙˆÙ† ØªØªØ¨Ø¹ Ø®Ø§Ø¯Ù….",

      footer_left: "CycleX Security Hub ÙŠØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙˆÙŠÙ‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© Ù…Ù† Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
      footer_tagline: "ØªØ­Ù‚Ù‚ Ù…Ø±ØªÙŠÙ†. Ù„Ø§ ØªØªØµÙ„ Ø¥Ù„Ø§ Ø¹Ù†Ø¯Ù…Ø§ ØªØ«Ù‚ Ø¨Ø§Ù„ØµÙØ­Ø©."
    },

    ru: {
      brand_sub: "ĞĞ½Ñ‡ĞµĞ¹Ğ½ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ¸ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñ‹",
      hero_kicker: "Security Hub",
      hero_title: "CycleX Security Tools",
      hero_subtitle: "Ğ›Ñ‘Ğ³ĞºĞ¸Ğ¹ ĞºĞ»Ğ¸ĞµĞ½Ñ‚ÑĞºĞ¸Ğ¹ Ğ½Ğ°Ğ±Ğ¾Ñ€ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²: Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½ĞµĞµ swap, Ğ³Ğ¸Ğ³Ğ¸ĞµĞ½Ğ° approvals Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° RPC (BSC + Ethereum).",
      btn_back: "ĞĞ°Ğ·Ğ°Ğ´ Ğ½Ğ° ÑĞ°Ğ¹Ñ‚",
      btn_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº (Ğ¾Ğ¿Ñ†.)",
      btn_quick: "Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ÑĞºĞ°Ğ½",
      hero_note: "Ğ’Ğ°Ğ¶Ğ½Ğ¾: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹ Ğ¸ Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒÑÑ‚ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ ÑĞ°Ğ¼Ğ¸.",
      tools_kicker: "Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞœĞ•ĞĞ¢",

      cube_quick_title: "Quick Scan",
      cube_quick_desc: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¾ĞºĞµĞ½Ğ°: ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚, Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, owner/proxy Ğ¸ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚.",
      badge_fast: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾",
      badge_history: "Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ",
      badge_share: "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ",

      cube_approvals_title: "Approval Guardian",
      cube_approvals_desc: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ allowances Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¾Ñ‚Ğ·Ğ¾Ğ²Ğ¸Ñ‚Ğµ approvals.",
      badge_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
      badge_revoke: "ĞÑ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ",

      cube_rpc_title: "RPC Health Checker",
      cube_rpc_desc: "Ğ¢ĞµÑÑ‚ RPC: Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ°, Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° Ğ±Ğ»Ğ¾ĞºĞ°, Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¾Ğ². ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC.",
      badge_table: "Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°",
      badge_copy: "ĞšĞ¾Ğ¿Ğ¸Ñ",

      cube_monitor_title: "Contract Diff / Upgrade Monitor",
      cube_monitor_desc: "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ Ğ¸ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ bytecode / proxy implementation.",
      badge_watch: "Ğ¡Ğ»ĞµĞ´Ğ¸Ñ‚ÑŒ",
      badge_local: "Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾",
      badge_changes: "Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ",

      p_quick_kicker: "Quick Scan",
      p_quick_title: "ĞÑ†ĞµĞ½Ğ¸Ñ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½ Ğ·Ğ° ÑĞµĞºÑƒĞ½Ğ´Ñ‹",
      p_quick_sub: "Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ°Ğ´Ñ€ĞµÑ Ñ‚Ğ¾ĞºĞµĞ½Ğ°, Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞµÑ‚ÑŒ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ ÑĞºĞ°Ğ½. Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾, Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ.",
      pill_wallet: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº",
      btn_close: "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
      quick_input_title: "Ğ’Ğ²Ğ¾Ğ´ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
      net_label: "Ğ¡ĞµÑ‚ÑŒ",
      addr_label: "ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
      qs_tip: "ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°: Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ ?tool=quick&net=bsc&token=0x... Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°.",
      options_label: "ĞĞ¿Ñ†Ğ¸Ğ¸",
      opt_require_liq: "Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ (ÑÑ‚Ñ€Ğ¾Ğ¶Ğµ)",
      opt_show_json: "Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ JSON-Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ (ĞºĞ¾Ğ¿Ğ¸Ñ)",
      btn_scan: "Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
      btn_copy_link: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
      btn_copy_json: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ JSON",
      history_label: "Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ",
      history_tip: "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ. Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾.",
      results_title: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
      results_hint: "Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Green/Yellow/Red. ĞĞµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ â€” Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ½Ñ‡ĞµĞ¹Ğ½-Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸.",

      api_keys_label: "API ĞºĞ»ÑÑ‡Ğ¸ Explorer (Ğ¾Ğ¿Ñ†.)",
      opt_use_explorer_apis: "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ BscScan/Etherscan (Verified + ABI ÑĞ²Ñ€Ğ¸ÑÑ‚Ğ¸ĞºĞ¸)",
      btn_save: "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ",
      btn_clear: "ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ",
      api_keys_tip: "ĞšĞ»ÑÑ‡Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑÑÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ (localStorage). ĞĞµ Ğ²ÑÑ‚Ğ°Ğ²Ğ»ÑĞ¹Ñ‚Ğµ ĞºĞ»ÑÑ‡Ğ¸ Ğ² Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ HTML.",

      p_app_kicker: "Approval Guardian",
      p_app_title: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ² allowances",
      p_app_sub: "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ spender + Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ (Ğ¸Ğ»Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ). Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ allowance(owner, spender) Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· approve(spender, 0).",
      ap_settings_title: "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸",
      ap_connected: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾:",
      ap_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ / ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ",
      ap_spender_label: "Spender Ğ¿Ñ€ĞµÑĞµÑ‚",
      ap_spender_tip: "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€ĞµÑĞµÑ‚ Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ğ° Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ.",
      ap_tokens_label: "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² (Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ)",
      ap_seed: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ",
      ap_seed_history: "Ğ˜Ğ· Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ ÑĞºĞ°Ğ½Ğ°",
      ap_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ allowances",
      ap_revoke_all: "ĞÑ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ (â‰ 0)",
      ap_results: "Allowances",
      ap_results_hint: "Ğ•ÑĞ»Ğ¸ allowance â€œinfiniteâ€, Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ¾Ñ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ, ĞµÑĞ»Ğ¸ Ğ²Ñ‹ Ğ½Ğµ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ spender Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ.",

      p_rpc_kicker: "RPC Health Checker",
      p_rpc_title: "ĞĞ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ endpoint",
      p_rpc_sub: "Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ eth_blockNumber, Ğ¸Ğ·Ğ¼ĞµÑ€ÑĞµĞ¼ latency Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Read Logs (eth_getLogs). Ğ›ÑƒÑ‡ÑˆĞ¸Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‡ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.",
      rpc_inputs: "ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹",
      rpc_custom_label: "Ğ¡Ğ²Ğ¾Ğ¹ RPC (Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚)",
      rpc_test: "Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ RPC",
      rpc_copy_best: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC",
      rpc_results: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
      rpc_tip: "ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°: Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ RPC Ğ¿Ğ°Ğ´Ğ°ÑÑ‚ Ğ¸Ğ·-Ğ·Ğ° CORS/timeout. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ñ‚ĞµÑÑ‚ Ğ¸ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ°Ğ¼Ñ‹Ğ¹ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹/Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹.",

      p_mon_kicker: "Contract Monitor",
      p_mon_title: "ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹ Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ",
      p_mon_sub: "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ hash ĞºĞ¾Ğ´Ğ° + proxy implementation. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ.",
      mon_add_title: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº",
      mon_add: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
      mon_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ",
      mon_export: "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ JSON",
      mon_list_title: "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ½Ğ°Ğ±Ğ»ÑĞ´ĞµĞ½Ğ¸Ñ",
      mon_list_hint: "Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾. Ğ‘ĞµĞ· ÑĞµÑ€Ğ²ĞµÑ€Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ°.",

      footer_left: "CycleX Security Hub Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ½Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğµ Ğ¸ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¾Ğ½Ñ‡ĞµĞ¹Ğ½-Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.",
      footer_tagline: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°Ğ¹Ñ‚ĞµÑÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ."
    }
  };

  let currentLang = "en";

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function setDirForLang(lang) {
    const html = document.documentElement;
    if (lang === "ar") {
      html.setAttribute("dir", "rtl");
      html.setAttribute("lang", "ar");
    } else {
      html.setAttribute("dir", "ltr");
      html.setAttribute("lang", lang);
    }
  }

  function t(key) {
    return (translations[currentLang] && translations[currentLang][key]) || translations.en[key] || key;
  }

  function applyI18n() {
    document.body.classList.add("lang-switching");
    setTimeout(() => document.body.classList.remove("lang-switching"), 260);

    $$("[data-i18n]").forEach((el) => {
      const k = el.getAttribute("data-i18n");
      const val = t(k);
      el.innerHTML = val;
    });
    setDirForLang(currentLang);
  }

  function setLang(lang) {
    currentLang = lang;
    try { localStorage.setItem("cx_sec_lang", lang); } catch {}
    $$(".lang-btn").forEach(b => b.classList.toggle("active", b.dataset.lang === lang));
    applyI18n();
    // re-render dynamic labels that are not data-i18n:
    renderWalletLabels();
  }

  function initLang() {
    let saved = null;
    try { saved = localStorage.getItem("cx_sec_lang"); } catch {}
    if (saved && translations[saved]) currentLang = saved;
    setLang(currentLang);
  }

  // =========================
  // Utils
  // =========================
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const nowTs = () => Math.floor(Date.now() / 1000);

  function shortAddr(a) {
    if (!a || typeof a !== "string") return "â€”";
    return a.slice(0, 6) + "â€¦" + a.slice(-4);
  }

  function safeJson(obj) {
    try { return JSON.stringify(obj, null, 2); } catch { return "{}"; }
  }

  async function copyText(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      // fallback
      try {
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        return true;
      } catch {
        return false;
      }
    }
  }

  function setStatus(el, type, html) {
    el.classList.remove("ok", "warn", "bad", "info");
    el.classList.add(type);
    el.style.display = "block";
    el.innerHTML = html;
  }

  function clearStatus(el) {
    el.style.display = "none";
    el.innerHTML = "";
    el.classList.remove("ok", "warn", "bad", "info");
  }

  function gtagEvent(name, params = {}) {
    try {
      if (typeof window.gtag === "function") window.gtag("event", name, params);
    } catch {}
  }

  function parseQuery() {
    const u = new URL(location.href);
    return {
      tool: u.searchParams.get("tool") || "",
      net: (u.searchParams.get("net") || "").toLowerCase(),
      token: u.searchParams.get("token") || ""
    };
  }

  // =========================
  // Panels / Tiles
  // =========================
  const toolCards = $$("#toolGrid .tool-card");
  const panels = {
    quick: $("#panel-quick"),
    approvals: $("#panel-approvals"),
    rpc: $("#panel-rpc"),
    monitor: $("#panel-monitor")
  };

  function showPanel(key) {
    Object.entries(panels).forEach(([k, el]) => {
      if (!el) return;
      el.classList.toggle("hidden", k !== key);
    });
    toolCards.forEach(c => c.classList.toggle("active", c.dataset.tool === key));
    gtagEvent("sec_tool_open", { tool: key });
  }

  toolCards.forEach((card) => {
    card.addEventListener("click", () => showPanel(card.dataset.tool));
  });

  $("#btnCloseQuick")?.addEventListener("click", () => showPanel(null));
  $("#btnCloseApprovals")?.addEventListener("click", () => showPanel(null));
  $("#btnCloseRpc")?.addEventListener("click", () => showPanel(null));
  $("#btnCloseMonitor")?.addEventListener("click", () => showPanel(null));

  // "Run Quick Scan" CTA
  $("#btn-quick")?.addEventListener("click", () => {
    showPanel("quick");
    $("#qs-token")?.focus();
  });

  // =========================
  // Wallet (Injected)
  // =========================
  const wallet = {
    provider: null,   // E.BrowserProvider
    signer: null,
    address: "",
    chainId: 0
  };

  function renderWalletLabels() {
    const w = wallet.address ? shortAddr(wallet.address) : "not connected";
    const wFull = wallet.address ? wallet.address : "not connected";
    $("#walletLabel") && ($("#walletLabel").textContent = wFull);
    $("#ap-wallet") && ($("#ap-wallet").textContent = wFull);
    $("#ap-address") && ($("#ap-address").textContent = wallet.address ? shortAddr(wallet.address) : "â€”");
  }

  async function connectInjected() {
    const status = $("#qs-status");
    if (!window.ethereum) {
      setStatus(status, "warn",
        "No injected wallet detected.<br>" +
        "Open this page inside MetaMask/Trust/OKX in-app browser, or install a wallet extension."
      );
      return false;
    }

    try {
      const bp = new E.BrowserProvider(window.ethereum);
      await bp.send("eth_requestAccounts", []);
      const signer = await bp.getSigner();
      const addr = await signer.getAddress();
      const net = await bp.getNetwork();

      wallet.provider = bp;
      wallet.signer = signer;
      wallet.address = addr;
      wallet.chainId = Number(net.chainId || 0);

      renderWalletLabels();
      gtagEvent("sec_wallet_connected", { chainId: wallet.chainId });

      // friendly status
      setStatus(status, "ok", `Wallet connected: <span class="mono">${addr}</span>`);
      return true;
    } catch (e) {
      setStatus(status, "bad", `Wallet connection failed: ${String(e?.message || e)}`);
      return false;
    }
  }

  async function ensureChain(targetChainId) {
    if (!window.ethereum) return false;
    try {
      const hex = "0x" + targetChainId.toString(16);
      await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: hex }] });
      return true;
    } catch (e) {
      return false;
    }
  }

  $("#btn-connect")?.addEventListener("click", async () => {
    await connectInjected();
  });

  $("#ap-connect")?.addEventListener("click", async () => {
    await connectInjected();
    renderWalletLabels();
  });

  // =========================
  // Explorer API keys (local)
  // =========================
  const LS_KEYS = "cx_sec_explorer_keys";
  function loadApiKeys() {
    try {
      const raw = localStorage.getItem(LS_KEYS);
      if (!raw) return { bscscan: "", etherscan: "", use: false };
      const obj = JSON.parse(raw);
      return {
        bscscan: obj?.bscscan || "",
        etherscan: obj?.etherscan || "",
        use: !!obj?.use
      };
    } catch {
      return { bscscan: "", etherscan: "", use: false };
    }
  }

  function saveApiKeys(keys) {
    try {
      localStorage.setItem(LS_KEYS, JSON.stringify(keys));
    } catch {}
  }

  function initApiKeysUi() {
    const keys = loadApiKeys();
    const use = $("#api-use");
    const b = $("#api-bscscan");
    const e = $("#api-etherscan");
    if (use) use.checked = keys.use;
    if (b) b.value = keys.bscscan;
    if (e) e.value = keys.etherscan;

    $("#api-save")?.addEventListener("click", () => {
      const nk = {
        use: !!$("#api-use")?.checked,
        bscscan: ($("#api-bscscan")?.value || "").trim(),
        etherscan: ($("#api-etherscan")?.value || "").trim()
      };
      saveApiKeys(nk);
      setStatus($("#qs-status"), "ok", "Saved keys to localStorage.");
      gtagEvent("sec_keys_saved", { use: nk.use ? 1 : 0 });
    });

    $("#api-clear")?.addEventListener("click", () => {
      saveApiKeys({ use: false, bscscan: "", etherscan: "" });
      if ($("#api-use")) $("#api-use").checked = false;
      if ($("#api-bscscan")) $("#api-bscscan").value = "";
      if ($("#api-etherscan")) $("#api-etherscan").value = "";
      setStatus($("#qs-status"), "ok", "Cleared keys.");
      gtagEvent("sec_keys_cleared");
    });
  }

  // =========================
  // Network constants
  // =========================
  const CHAINS = {
    bsc: {
      chainId: 56,
      name: "BSC",
      wrapped: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // WBNB
      explorer: "https://bscscan.com/address/",
      rpcList: [
        "https://bsc-dataseed.binance.org",
        "https://bsc-dataseed1.bnbchain.org",
        "https://bsc-dataseed2.bnbchain.org",
        "https://bsc.publicnode.com",
        "https://rpc.ankr.com/bsc"
      ],
      v2: {
        factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73", // Pancake V2 factory
        router:  "0x10ED43C718714eb63d5aA57B78B54704E256024E"
      },
      v3: {
        factory: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865" // Pancake V3 factory
      }
    },
    eth: {
      chainId: 1,
      name: "Ethereum",
      wrapped: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
      explorer: "https://etherscan.io/address/",
      rpcList: [
        "https://cloudflare-eth.com",
        "https://ethereum.publicnode.com",
        "https://rpc.ankr.com/eth"
      ],
      v2: {
        factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", // Uniswap V2 factory
        router:  "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D"
      },
      v3: {
        factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984" // Uniswap V3 factory
      }
    }
  };

  function getDefaultProvider(netKey) {
    const c = CHAINS[netKey] || CHAINS.bsc;
    return new E.JsonRpcProvider(c.rpcList[0], c.chainId);
  }

  function getProviderForRpc(rpcUrl, chainId) {
    return new E.JsonRpcProvider(rpcUrl, chainId);
  }

  // =========================
  // Quick Scan
  // =========================
  const QS_LS_HISTORY = "cx_sec_qs_history";

  function loadHistory() {
    try {
      const raw = localStorage.getItem(QS_LS_HISTORY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function saveHistory(items) {
    try { localStorage.setItem(QS_LS_HISTORY, JSON.stringify(items.slice(0, 20))); } catch {}
  }

  function pushHistory(entry) {
    const cur = loadHistory();
    const key = `${entry.net}:${entry.token.toLowerCase()}`;
    const filtered = cur.filter(x => `${x.net}:${(x.token||"").toLowerCase()}` !== key);
    filtered.unshift({ ...entry, ts: nowTs() });
    saveHistory(filtered);
    renderHistory();
  }

  function renderHistory() {
    const box = $("#qs-history");
    if (!box) return;
    const items = loadHistory();
    box.innerHTML = "";
    if (!items.length) {
      box.innerHTML = `<div class="small muted">â€”</div>`;
      return;
    }
    items.forEach((it) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span class="mono">${it.net.toUpperCase()}</span> <span class="mono">${shortAddr(it.token)}</span> <span class="x">â†»</span>`;
      chip.addEventListener("click", () => {
        $("#qs-net").value = it.net;
        $("#qs-token").value = it.token;
        showPanel("quick");
        runQuickScan();
      });
      box.appendChild(chip);
    });
  }

  const ERC20_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)",
    "function owner() view returns (address)"
  ];

  const PAIR_ABI = [
    "function getReserves() view returns (uint112,uint112,uint32)",
    "function token0() view returns (address)",
    "function token1() view returns (address)"
  ];

  const FACTORY_V2_ABI = [
    "function getPair(address,address) view returns (address)"
  ];

  const FACTORY_V3_ABI = [
    "function getPool(address,address,uint24) view returns (address)"
  ];

  const PROXY_IMPL_SLOT = "0x360894A13BA1A3210667C828492DB98DCA3E2076CC3735A920A3CA505D382BBC"; // EIP-1967 impl
  function slotToAddress(hex) {
    if (!hex || hex === "0x") return "";
    const h = hex.replace(/^0x/, "").padStart(64, "0");
    const addr = "0x" + h.slice(24);
    try { return E.getAddress(addr); } catch { return ""; }
  }

  async function getProxyImpl(provider, addr) {
    try {
      const v = await provider.send("eth_getStorageAt", [addr, PROXY_IMPL_SLOT, "latest"]);
      const impl = slotToAddress(v);
      if (impl && impl !== "0x0000000000000000000000000000000000000000") return impl;
      return "";
    } catch {
      return "";
    }
  }

  async function keywordHeuristicsFromSource(sourceText) {
    const s = (sourceText || "").toLowerCase();
    const has = (k) => s.includes(k);
    return {
      mint: has(" mint(") || has("function mint") || has(" _mint("),
      pause: has("pause") || has("paused"),
      blacklist: has("blacklist") || has("denylist"),
      tax: has("tax") || has("fee") || has("buyfee") || has("sellfee") || has("marketingfee")
    };
  }

  async function fetchExplorerData(netKey, tokenAddr) {
    const keys = loadApiKeys();
    if (!keys.use) return { ok: false };

    const isBsc = netKey === "bsc";
    const key = isBsc ? keys.bscscan : keys.etherscan;
    if (!key) return { ok: false };

    const apiBase = isBsc ? "https://api.bscscan.com/api" : "https://api.etherscan.io/api";

    // Source code / verified
    try {
      const url = `${apiBase}?module=contract&action=getsourcecode&address=${tokenAddr}&apikey=${encodeURIComponent(key)}`;
      const r = await fetch(url, { method: "GET" });
      const j = await r.json();
      const item = j?.result?.[0];
      const source = item?.SourceCode || "";
      const abi = item?.ABI || "";
      const contractName = item?.ContractName || "";
      const isVerified = !!source && source !== "0x" && source !== "";
      return { ok: true, isVerified, contractName, source, abi };
    } catch {
      return { ok: false };
    }
  }

  async function checkV2Liquidity(provider, netKey, tokenAddr) {
    const c = CHAINS[netKey];
    const fac = new E.Contract(c.v2.factory, FACTORY_V2_ABI, provider);
    const pairAddr = await fac.getPair(tokenAddr, c.wrapped);
    if (!pairAddr || pairAddr === E.ZeroAddress) return { exists: false, pair: "" };

    const pair = new E.Contract(pairAddr, PAIR_ABI, provider);
    const [r0, r1] = await pair.getReserves();
    const t0 = (await pair.token0()).toLowerCase();
    const t1 = (await pair.token1()).toLowerCase();
    const wrappedLower = c.wrapped.toLowerCase();

    const wrappedReserve = (t0 === wrappedLower) ? r0 : (t1 === wrappedLower ? r1 : 0n);
    return { exists: true, pair: pairAddr, wrappedReserve: wrappedReserve.toString() };
  }

  async function checkV3Pools(provider, netKey, tokenAddr) {
    const c = CHAINS[netKey];
    const fac = new E.Contract(c.v3.factory, FACTORY_V3_ABI, provider);

    // try common fees (include Pancake/Uni variants)
    const fees = netKey === "eth" ? [500, 3000, 10000] : [100, 500, 2500, 10000];
    const found = [];
    for (const f of fees) {
      try {
        const pool = await fac.getPool(tokenAddr, c.wrapped, f);
        if (pool && pool !== E.ZeroAddress) found.push({ fee: f, pool });
      } catch {}
    }
    return { pools: found };
  }

  function scoreFromSignals(sig) {
    let score = 50;

    if (sig.hasCode) score += 10; else score -= 40;
    if (sig.verified) score += 12;
    if (sig.isProxy) score -= 8;

    if (sig.hasV2) score += 10;
    if (sig.hasV3) score += 6;

    if (sig.requireLiquidity && !(sig.hasV2 || sig.hasV3)) score -= 25;

    if (sig.mint) score -= 10;
    if (sig.pause) score -= 6;
    if (sig.blacklist) score -= 10;
    if (sig.tax) score -= 6;

    score = clamp(score, 0, 100);

    let level = "warn";
    if (score >= 75) level = "ok";
    if (score < 45) level = "bad";

    return { score, level };
  }

  function badgeRowHtml(label, value, type = "info") {
    const cls = type === "ok" ? "status ok" : type === "bad" ? "status bad" : type === "warn" ? "status warn" : "status info";
    return `<div class="${cls}" style="display:block; margin-top:10px;"><b>${label}:</b> ${value}</div>`;
  }

  async function runQuickScan() {
    const status = $("#qs-status");
    const out = $("#qs-out");
    const pairsWrap = $("#qs-pairsWrap");

    clearStatus(status);
    if (pairsWrap) pairsWrap.innerHTML = "";

    const netKey = ($("#qs-net")?.value || "bsc").toLowerCase();
    const token = ($("#qs-token")?.value || "").trim();
    const requireLiq = !!$("#qs-require-liq")?.checked;
    const showJson = !!$("#qs-show-json")?.checked;

    if (!E.isAddress(token)) {
      setStatus(status, "bad", "Invalid token address.");
      return;
    }

    const chain = CHAINS[netKey] || CHAINS.bsc;
    const provider = getDefaultProvider(netKey);

    setStatus(status, "info", "Scanningâ€¦");

    const result = {
      net: netKey,
      chainId: chain.chainId,
      token: E.getAddress(token),
      ts: nowTs(),
      meta: {},
      proxy: {},
      liquidity: {},
      heuristics: {},
      score: {}
    };

    try {
      // code present?
      const code = await provider.getCode(result.token);
      result.meta.hasCode = !!code && code !== "0x";

      // basic ERC20 metadata
      const erc = new E.Contract(result.token, ERC20_ABI, provider);
      let name = "", symbol = "", decimals = null, totalSupply = null;
      try { name = await erc.name(); } catch {}
      try { symbol = await erc.symbol(); } catch {}
      try { decimals = await erc.decimals(); } catch {}
      try { totalSupply = await erc.totalSupply(); } catch {}
      result.meta.name = name || "";
      result.meta.symbol = symbol || "";
      result.meta.decimals = (decimals !== null && decimals !== undefined) ? Number(decimals) : null;
      result.meta.totalSupply = totalSupply ? totalSupply.toString() : "";

      // owner
      let owner = "";
      try { owner = await erc.owner(); } catch {}
      result.meta.owner = owner || "";

      // proxy detection
      const impl = await getProxyImpl(provider, result.token);
      result.proxy.isProxy = !!impl;
      result.proxy.implementation = impl || "";

      // Explorer verified + keyword heuristics
      const ex = await fetchExplorerData(netKey, result.token);
      result.meta.verified = !!ex?.isVerified;
      result.meta.contractName = ex?.contractName || "";
      if (ex?.ok && ex?.isVerified && ex?.source) {
        const h = await keywordHeuristicsFromSource(ex.source);
        result.heuristics = { ...h };
      } else {
        result.heuristics = { mint: false, pause: false, blacklist: false, tax: false };
      }

      // Liquidity V2
      let v2 = { exists: false };
      try { v2 = await checkV2Liquidity(provider, netKey, result.token); } catch {}
      result.liquidity.v2 = v2;

      // Liquidity V3 pools
      let v3 = { pools: [] };
      try { v3 = await checkV3Pools(provider, netKey, result.token); } catch {}
      result.liquidity.v3 = v3;

      // Score
      const sig = {
        hasCode: !!result.meta.hasCode,
        verified: !!result.meta.verified,
        isProxy: !!result.proxy.isProxy,
        hasV2: !!v2?.exists,
        hasV3: (v3?.pools?.length || 0) > 0,
        requireLiquidity: requireLiq,
        mint: !!result.heuristics.mint,
        pause: !!result.heuristics.pause,
        blacklist: !!result.heuristics.blacklist,
        tax: !!result.heuristics.tax
      };
      const sc = scoreFromSignals(sig);
      result.score = { ...sc, signals: sig };

      // render
      const level = sc.level;
      const colorWord = level === "ok" ? "GREEN" : level === "warn" ? "YELLOW" : "RED";

      let html = `
        <div><b>Network:</b> ${chain.name} (${chain.chainId})</div>
        <div><b>Token:</b> <a class="mono" target="_blank" rel="noopener" href="${chain.explorer}${result.token}">${result.token}</a></div>
        <div style="margin-top:6px"><b>Score:</b> <span class="mono">${sc.score}/100</span> â€” <b>${colorWord}</b></div>
        <div class="small" style="margin-top:8px">
          Signals: ${sig.verified ? "Verified âœ“" : "Not verified"} â€¢ ${sig.isProxy ? "Proxy hint âš " : "No proxy hint"} â€¢
          ${sig.hasV2 ? "V2 LP âœ“" : "No V2 LP"} â€¢ ${sig.hasV3 ? "V3 pool âœ“" : "No V3 pool"}
        </div>
      `;

      // details blocks
      const metaLine = [
        result.meta.name ? `Name: <span class="mono">${result.meta.name}</span>` : null,
        result.meta.symbol ? `Symbol: <span class="mono">${result.meta.symbol}</span>` : null,
        (result.meta.decimals !== null) ? `Decimals: <span class="mono">${result.meta.decimals}</span>` : null
      ].filter(Boolean).join(" â€¢ ");

      if (metaLine) html += `<div class="small" style="margin-top:10px">${metaLine}</div>`;

      if (result.meta.owner) {
        html += `<div class="small" style="margin-top:6px"><b>Owner:</b> <span class="mono">${result.meta.owner}</span></div>`;
      }

      if (result.proxy.isProxy) {
        html += `<div class="small" style="margin-top:6px"><b>Proxy implementation:</b> <span class="mono">${result.proxy.implementation}</span></div>`;
      }

      // heuristics row
      const h = result.heuristics || {};
      const hList = [
        h.mint ? "mint âš " : "mint âœ“",
        h.pause ? "pause âš " : "pause âœ“",
        h.blacklist ? "blacklist âš " : "blacklist âœ“",
        h.tax ? "tax/fee âš " : "tax/fee âœ“"
      ].join(" â€¢ ");
      html += `<div class="small" style="margin-top:10px"><b>Heuristics:</b> ${hList}</div>`;

      // liquidity info
      if (pairsWrap) {
        let lpHtml = `<div class="small" style="margin-top:10px"><b>Liquidity:</b></div>`;
        if (v2?.exists) {
          lpHtml += badgeRowHtml("V2 Pair", `<a target="_blank" rel="noopener" href="${chain.explorer}${v2.pair}">${v2.pair}</a>`, "ok");
        } else {
          lpHtml += badgeRowHtml("V2 Pair", "Not found", requireLiq ? "bad" : "warn");
        }
        if ((v3?.pools?.length || 0) > 0) {
          const pools = v3.pools.map(p => `Fee ${p.fee}: <a target="_blank" rel="noopener" href="${chain.explorer}${p.pool}">${shortAddr(p.pool)}</a>`).join("<br>");
          lpHtml += badgeRowHtml("V3 Pools", pools, "ok");
        } else {
          lpHtml += badgeRowHtml("V3 Pools", "Not found", "warn");
        }
        pairsWrap.innerHTML = lpHtml;
      }

      // final out
      out.classList.remove("ok", "warn", "bad", "info");
      out.classList.add(level);
      out.style.display = "block";
      out.innerHTML = html;

      // history
      pushHistory({ net: netKey, token: result.token });

      // save last scan for share/copy
      window.__cxLastScan = result;

      setStatus(status, level, `Scan complete. Score: <b>${sc.score}/100</b>.`);
      gtagEvent("sec_quick_scan_done", { net: netKey, score: sc.score });

    } catch (e) {
      setStatus(status, "bad", `Scan failed: ${String(e?.message || e)}`);
      if (out) {
        out.classList.remove("ok", "warn", "bad", "info");
        out.classList.add("bad");
        out.style.display = "block";
        out.innerHTML = `<b>Failed.</b><br>${String(e?.message || e)}`;
      }
    }
  }

  $("#qs-run")?.addEventListener("click", runQuickScan);

  $("#qs-copy-json")?.addEventListener("click", async () => {
    const last = window.__cxLastScan;
    if (!last) return setStatus($("#qs-status"), "warn", "Nothing to copy yet. Run a scan first.");
    const ok = await copyText(safeJson(last));
    setStatus($("#qs-status"), ok ? "ok" : "bad", ok ? "Copied JSON to clipboard." : "Copy failed.");
    gtagEvent("sec_copy_json", { ok: ok ? 1 : 0 });
  });

  $("#qs-copy-link")?.addEventListener("click", async () => {
    const netKey = ($("#qs-net")?.value || "bsc").toLowerCase();
    const token = ($("#qs-token")?.value || "").trim();
    if (!E.isAddress(token)) return setStatus($("#qs-status"), "bad", "Invalid token address.");

    const u = new URL(location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", netKey);
    u.searchParams.set("token", E.getAddress(token));

    const ok = await copyText(u.toString());
    setStatus($("#qs-status"), ok ? "ok" : "bad", ok ? "Share link copied." : "Copy failed.");
    gtagEvent("sec_copy_link", { ok: ok ? 1 : 0 });
  });

  $("#qs-share-x")?.addEventListener("click", () => {
    const last = window.__cxLastScan;
    const base = new URL(location.href);
    base.searchParams.set("tool", "quick");
    if (last?.net) base.searchParams.set("net", last.net);
    if (last?.token) base.searchParams.set("token", last.token);
    const text = last
      ? `Quick Scan ${last.net.toUpperCase()} â€¢ ${shortAddr(last.token)} â€¢ Score ${last.score.score}/100`
      : "CycleX Security Hub â€” Quick Scan";
    const share = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(base.toString())}`;
    window.open(share, "_blank", "noopener,noreferrer");
    gtagEvent("sec_share_x");
  });

  $("#qs-share-tg")?.addEventListener("click", () => {
    const last = window.__cxLastScan;
    const base = new URL(location.href);
    base.searchParams.set("tool", "quick");
    if (last?.net) base.searchParams.set("net", last.net);
    if (last?.token) base.searchParams.set("token", last.token);
    const text = last
      ? `Quick Scan ${last.net.toUpperCase()} â€¢ ${shortAddr(last.token)} â€¢ Score ${last.score.score}/100`
      : "CycleX Security Hub â€” Quick Scan";
    const share = `https://t.me/share/url?url=${encodeURIComponent(base.toString())}&text=${encodeURIComponent(text)}`;
    window.open(share, "_blank", "noopener,noreferrer");
    gtagEvent("sec_share_tg");
  });

  // =========================
  // Approval Guardian
  // =========================
  const ERC20_ALLOW_ABI = [
    "function allowance(address owner, address spender) view returns (uint256)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function approve(address spender, uint256 value) returns (bool)"
  ];

  function getSpenderPreset(netKey, presetKey) {
    if (presetKey === "custom") return "";
    if (presetKey === "pcs_router") return CHAINS.bsc.v2.router;
    if (presetKey === "uni_router") return CHAINS.eth.v2.router;
    return "";
  }

  function normalizeLines(text) {
    return (text || "")
      .split("\n")
      .map(s => s.trim())
      .filter(Boolean);
  }

  async function apEnsureWalletForNet(netKey) {
    const st = $("#ap-status");
    if (!wallet.address || !wallet.provider || !wallet.signer) {
      setStatus(st, "info", "Connecting walletâ€¦");
      const ok = await connectInjected();
      if (!ok) return false;
    }

    const target = CHAINS[netKey].chainId;
    if (wallet.chainId !== target) {
      setStatus(st, "warn", `Wallet network mismatch. Trying to switch to ${CHAINS[netKey].name}â€¦`);
      const switched = await ensureChain(target);
      if (!switched) {
        setStatus(st, "bad", `Please switch network in your wallet to ${CHAINS[netKey].name}.`);
        return false;
      }
      // refresh provider/signer after switch
      await connectInjected();
    }
    return true;
  }

  function apRenderTable(rows) {
    const table = $("#ap-table");
    if (!table) return;

    // keep header, remove others
    const kids = Array.from(table.querySelectorAll(".trow")).slice(1);
    kids.forEach(k => k.remove());

    if (!rows.length) {
      const tr = document.createElement("div");
      tr.className = "trow";
      tr.innerHTML = `<div class="cell muted">â€”</div><div class="cell muted">â€”</div><div class="cell muted hide-sm">â€”</div><div class="cell muted">â€”</div>`;
      table.appendChild(tr);
      return;
    }

    rows.forEach(r => {
      const tr = document.createElement("div");
      tr.className = "trow" + (r.nonZero ? " highlight" : "");
      tr.innerHTML = `
        <div class="cell wrap"><span class="mono">${r.token}</span></div>
        <div class="cell"><span class="mono">${r.allowanceHuman}</span></div>
        <div class="cell hide-sm"><span class="mini">${r.symbol || "â€”"}</span></div>
        <div class="cell">
          <button class="btn btn-ghost" style="padding:8px 12px; font-size:12px;" ${r.nonZero ? "" : "disabled"}>Revoke</button>
        </div>
      `;
      const btn = tr.querySelector("button");
      btn?.addEventListener("click", async () => {
        await apRevokeOne(r.token);
      });
      table.appendChild(tr);
    });
  }

  async function apCheck() {
    const st = $("#ap-status");
    clearStatus(st);

    const netKey = ($("#ap-net")?.value || "bsc").toLowerCase();
    const ok = await apEnsureWalletForNet(netKey);
    if (!ok) return;

    const preset = ($("#ap-spender-preset")?.value || "custom");
    const presetAddr = getSpenderPreset(netKey, preset);
    if (preset !== "custom") $("#ap-spender").value = presetAddr;

    const spender = ($("#ap-spender")?.value || "").trim();
    if (!E.isAddress(spender)) return setStatus(st, "bad", "Invalid spender address.");

    const tokenLines = normalizeLines($("#ap-tokens")?.value || "");
    const tokens = tokenLines.filter(E.isAddress).map(a => E.getAddress(a));
    if (!tokens.length) return setStatus(st, "warn", "Paste at least 1 token address.");

    setStatus(st, "info", "Checking allowancesâ€¦");

    const rows = [];
    for (const token of tokens) {
      try {
        const c = new E.Contract(token, ERC20_ALLOW_ABI, wallet.provider);
        const [allow, sym, dec] = await Promise.all([
          c.allowance(wallet.address, spender),
          c.symbol().catch(() => ""),
          c.decimals().catch(() => 18)
        ]);
        const d = Number(dec || 18);
        const human = (() => {
          try { return E.formatUnits(allow, d); } catch { return allow.toString(); }
        })();
        const nonZero = allow > 0n;
        rows.push({ token, symbol: sym, allowance: allow, allowanceHuman: human, nonZero });
      } catch (e) {
        rows.push({ token, symbol: "", allowance: 0n, allowanceHuman: "error", nonZero: false });
      }
    }

    window.__cxAp = { net: netKey, spender, rows };
    apRenderTable(rows);

    const nz = rows.filter(r => r.nonZero).length;
    setStatus(st, nz ? "warn" : "ok", nz ? `Found ${nz} non-zero allowance(s).` : "No non-zero allowances found.");
    gtagEvent("sec_allow_check_done", { net: netKey, nonZero: nz });
  }

  async function apRevokeOne(tokenAddr) {
    const st = $("#ap-status");
    const netKey = ($("#ap-net")?.value || "bsc").toLowerCase();
    const ok = await apEnsureWalletForNet(netKey);
    if (!ok) return;

    const spender = ($("#ap-spender")?.value || "").trim();
    if (!E.isAddress(spender)) return setStatus(st, "bad", "Invalid spender address.");

    try {
      setStatus(st, "info", `Revokingâ€¦ ${shortAddr(tokenAddr)}`);
      const c = new E.Contract(tokenAddr, ERC20_ALLOW_ABI, wallet.signer);
      const tx = await c.approve(E.getAddress(spender), 0);
      setStatus(st, "info", `Tx sent: <span class="mono">${tx.hash}</span><br>Waiting confirmationâ€¦`);
      await tx.wait();
      setStatus(st, "ok", "Revoke confirmed.");
      gtagEvent("sec_revoke_one_done", { net: netKey });
      await apCheck();
    } catch (e) {
      setStatus(st, "bad", `Revoke failed: ${String(e?.message || e)}`);
    }
  }

  async function apRevokeAll() {
    const st = $("#ap-status");
    if (!window.__cxAp?.rows?.length) return setStatus(st, "warn", "Run Check first.");

    const rows = window.__cxAp.rows.filter(r => r.nonZero);
    if (!rows.length) return setStatus(st, "ok", "Nothing to revoke.");

    setStatus(st, "warn", `Revoking ${rows.length} allowance(s)â€¦ Please confirm transactions in your wallet.`);

    for (const r of rows) {
      await apRevokeOne(r.token);
    }
  }

  $("#ap-check")?.addEventListener("click", apCheck);
  $("#ap-revoke-all")?.addEventListener("click", apRevokeAll);

  $("#ap-spender-preset")?.addEventListener("change", () => {
    const netKey = ($("#ap-net")?.value || "bsc").toLowerCase();
    const preset = ($("#ap-spender-preset")?.value || "custom");
    const p = getSpenderPreset(netKey, preset);
    if (preset !== "custom") $("#ap-spender").value = p;
  });

  $("#ap-net")?.addEventListener("change", () => {
    // refresh preset to match chain
    const netKey = ($("#ap-net")?.value || "bsc").toLowerCase();
    const preset = ($("#ap-spender-preset")?.value || "custom");
    const p = getSpenderPreset(netKey, preset);
    if (preset !== "custom") $("#ap-spender").value = p;
  });

  $("#ap-seed-common")?.addEventListener("click", () => {
    // minimal seed list â€“ keep it clean
    const netKey = ($("#ap-net")?.value || "bsc").toLowerCase();
    const common = netKey === "bsc"
      ? [
          "0xe9e7cea3dedca5984780bafc599bd69add087d56", // BUSD (legacy)
          "0x55d398326f99059ff775485246999027b3197955", // USDT
          "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d"  // USDC
        ]
      : [
          "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
          "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"  // USDC
        ];
    $("#ap-tokens").value = common.join("\n");
    setStatus($("#ap-status"), "ok", "Seeded common tokens.");
    gtagEvent("sec_seed_common", { net: netKey });
  });

  $("#ap-seed-history")?.addEventListener("click", () => {
    const items = loadHistory();
    const uniq = Array.from(new Set(items.map(x => (x.token || "").toLowerCase()))).slice(0, 10);
    $("#ap-tokens").value = uniq.map(a => E.getAddress(a)).join("\n");
    setStatus($("#ap-status"), uniq.length ? "ok" : "warn", uniq.length ? "Loaded from scan history." : "No scan history yet.");
    gtagEvent("sec_seed_history", { count: uniq.length });
  });

  // =========================
  // RPC Health Checker
  // =========================
  function rpcGetList(netKey) {
    const c = CHAINS[netKey] || CHAINS.bsc;
    const custom = ($("#rpc-custom")?.value || "").trim();
    const list = [];
    if (custom) list.push(custom);
    c.rpcList.forEach(u => list.push(u));
    // de-dupe
    return Array.from(new Set(list));
  }

  function rpcAddRow(row) {
    const table = $("#rpc-table");
    if (!table) return;

    const div = document.createElement("div");
    div.className = "trow rpc";
    div.dataset.rpc = row.rpc;
    div.innerHTML = `
      <div class="cell wrap"><span class="mono">${row.rpc}</span></div>
      <div class="cell"><span class="mono">${row.latencyMs ?? "â€”"}</span></div>
      <div class="cell hide-sm"><span class="mono">${row.block ?? "â€”"}</span></div>
      <div class="cell hide-sm">${row.readLogs === true ? "âœ“" : row.readLogs === false ? "âœ—" : "â€”"}</div>
      <div class="cell">${row.ok ? "OK" : "FAIL"}</div>
    `;
    if (row.best) div.classList.add("highlight");
    table.appendChild(div);
  }

  async function rpcTestOne(rpcUrl, chainId, netKey) {
    const t0 = performance.now();
    const p = getProviderForRpc(rpcUrl, chainId);

    // blockNumber
    let block = null;
    try {
      block = await Promise.race([
        p.getBlockNumber(),
        new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), 8000))
      ]);
    } catch (e) {
      return { rpc: rpcUrl, ok: false, latencyMs: null, block: null, readLogs: null, err: String(e?.message || e) };
    }

    const latencyMs = Math.round(performance.now() - t0);

    // read logs check (very small range)
    let readLogs = false;
    try {
      const addr = CHAINS[netKey].wrapped;
      const topic0 = E.id("Transfer(address,address,uint256)");
      const fromBlock = Math.max(0, Number(block) - 120);
      const params = [{
        address: addr,
        fromBlock: E.toBeHex(fromBlock),
        toBlock: E.toBeHex(Number(block)),
        topics: [topic0]
      }];

      // raw call
      const logs = await Promise.race([
        p.send("eth_getLogs", params),
        new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), 9000))
      ]);
      readLogs = Array.isArray(logs);
    } catch {
      readLogs = false;
    }

    return { rpc: rpcUrl, ok: true, latencyMs, block, readLogs };
  }

  async function rpcTestAll() {
    const st = $("#rpc-status");
    clearStatus(st);

    const netKey = ($("#rpc-net")?.value || "bsc").toLowerCase();
    const c = CHAINS[netKey] || CHAINS.bsc;

    // clear table rows except header
    const table = $("#rpc-table");
    if (table) {
      const rows = Array.from(table.querySelectorAll(".trow")).slice(1);
      rows.forEach(r => r.remove());
    }

    const list = rpcGetList(netKey);
    setStatus(st, "info", `Testing ${list.length} RPC(s)â€¦`);

    const results = [];
    for (const rpc of list) {
      const r = await rpcTestOne(rpc, c.chainId, netKey);
      results.push(r);
      rpcAddRow({ ...r, best: false });
    }

    // pick best: ok + readLogs true preferred, lowest latency
    const okOnes = results.filter(r => r.ok);
    const okWithLogs = okOnes.filter(r => r.readLogs);
    const pickFrom = okWithLogs.length ? okWithLogs : okOnes;
    const best = pickFrom.sort((a,b) => (a.latencyMs ?? 1e9) - (b.latencyMs ?? 1e9))[0] || null;

    // re-highlight
    if (best && table) {
      Array.from(table.querySelectorAll(".trow.rpc")).forEach(r => {
        r.classList.toggle("highlight", r.dataset.rpc === best.rpc);
      });
    }

    window.__cxRpc = { net: netKey, results, best };

    if (!best) setStatus(st, "bad", "All RPCs failed (CORS/timeout). Try a different endpoint or run from a different network.");
    else setStatus(st, best.readLogs ? "ok" : "warn", `Best RPC: <span class="mono">${best.rpc}</span> (${best.latencyMs}ms) â€¢ logs: ${best.readLogs ? "OK" : "FAIL"}`);

    gtagEvent("sec_rpc_test_done", { net: netKey, ok: okOnes.length });
  }

  $("#rpc-test")?.addEventListener("click", rpcTestAll);

  $("#rpc-copy-best")?.addEventListener("click", async () => {
    const st = $("#rpc-status");
    const best = window.__cxRpc?.best;
    if (!best) return setStatus(st, "warn", "Run Test RPCs first.");
    const ok = await copyText(best.rpc);
    setStatus(st, ok ? "ok" : "bad", ok ? "Copied best RPC." : "Copy failed.");
    gtagEvent("sec_rpc_copy_best", { ok: ok ? 1 : 0 });
  });

  $("#rpc-copy-json")?.addEventListener("click", async () => {
    const st = $("#rpc-status");
    const res = window.__cxRpc?.results;
    if (!res?.length) return setStatus(st, "warn", "Run Test RPCs first.");
    const list = res.map(r => r.rpc);
    const ok = await copyText(safeJson(list));
    setStatus(st, ok ? "ok" : "bad", ok ? "Copied JSON list." : "Copy failed.");
    gtagEvent("sec_rpc_copy_json", { ok: ok ? 1 : 0 });
  });

  // =========================
  // Contract Monitor
  // =========================
  const MON_LS = "cx_sec_monitor_list";

  function monLoad() {
    try {
      const raw = localStorage.getItem(MON_LS);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }

  function monSave(arr) {
    try { localStorage.setItem(MON_LS, JSON.stringify(arr)); } catch {}
  }

  function monKey(net, addr) {
    return `${net}:${addr.toLowerCase()}`;
  }

  async function monFetchInfo(netKey, addr) {
    const c = CHAINS[netKey] || CHAINS.bsc;
    const p = getDefaultProvider(netKey);
    const code = await p.getCode(addr);
    const hasCode = code && code !== "0x";
    const codeHash = hasCode ? E.keccak256(code) : "";
    const impl = hasCode ? await getProxyImpl(p, addr) : "";
    return { net: netKey, chainId: c.chainId, addr, hasCode, codeHash, impl, ts: nowTs() };
  }

  function monRender() {
    const table = $("#mon-table");
    if (!table) return;

    // remove existing non-header rows
    const rows = Array.from(table.querySelectorAll(".trow")).slice(1);
    rows.forEach(r => r.remove());

    const list = monLoad();
    if (!list.length) {
      const tr = document.createElement("div");
      tr.className = "trow";
      tr.innerHTML = `<div class="cell muted">â€”</div><div class="cell muted">â€”</div><div class="cell muted hide-sm">â€”</div><div class="cell muted">â€”</div>`;
      table.appendChild(tr);
      return;
    }

    list.forEach((it) => {
      const tr = document.createElement("div");
      tr.className = "trow";
      tr.innerHTML = `
        <div class="cell wrap"><span class="mono">${it.addr}</span></div>
        <div class="cell"><span class="mono">${it.net.toUpperCase()}</span></div>
        <div class="cell hide-sm"><span class="mini">${it.lastSeen ? new Date(it.lastSeen*1000).toLocaleString() : "â€”"}</span></div>
        <div class="cell"><span class="mini">${it.status || "â€”"}</span></div>
      `;
      table.appendChild(tr);
    });
  }

  async function monAdd() {
    const st = $("#mon-status");
    clearStatus(st);

    const netKey = ($("#mon-net")?.value || "bsc").toLowerCase();
    const addrRaw = ($("#mon-addr")?.value || "").trim();
    if (!E.isAddress(addrRaw)) return setStatus(st, "bad", "Invalid contract address.");

    const addr = E.getAddress(addrRaw);
    setStatus(st, "info", "Savingâ€¦");

    try {
      const info = await monFetchInfo(netKey, addr);
      if (!info.hasCode) return setStatus(st, "warn", "No contract code found at this address.");

      const list = monLoad();
      const k = monKey(netKey, addr);
      const filtered = list.filter(x => monKey(x.net, x.addr) !== k);

      filtered.unshift({
        net: netKey,
        addr,
        codeHash: info.codeHash,
        impl: info.impl || "",
        lastSeen: info.ts,
        status: "saved"
      });

      monSave(filtered.slice(0, 40));
      monRender();

      setStatus(st, "ok", "Added to watchlist.");
      gtagEvent("sec_mon_add", { net: netKey });
    } catch (e) {
      setStatus(st, "bad", `Add failed: ${String(e?.message || e)}`);
    }
  }

  async function monCheckAll() {
    const st = $("#mon-status");
    clearStatus(st);

    const list = monLoad();
    if (!list.length) return setStatus(st, "warn", "Watchlist is empty.");

    setStatus(st, "info", `Checking ${list.length} contract(s)â€¦`);

    const updated = [];
    for (const it of list) {
      try {
        const info = await monFetchInfo(it.net, it.addr);
        let status = "unchanged";
        if (!info.hasCode) status = "no code";
        else {
          const codeChanged = (it.codeHash && info.codeHash && it.codeHash !== info.codeHash);
          const implChanged = (it.impl || "") !== (info.impl || "");
          if (implChanged && info.impl) status = "proxy upgraded";
          else if (codeChanged) status = "bytecode changed";
        }
        updated.push({
          ...it,
          lastSeen: info.ts,
          status,
          codeHash: info.codeHash || it.codeHash,
          impl: info.impl || it.impl || ""
        });
      } catch {
        updated.push({ ...it, status: "check failed", lastSeen: nowTs() });
      }
    }

    monSave(updated);
    monRender();

    const changed = updated.filter(x => x.status !== "unchanged").length;
    setStatus(st, changed ? "warn" : "ok", changed ? `${changed} change(s) detected.` : "All unchanged.");
    gtagEvent("sec_mon_check_all", { changed });
  }

  $("#mon-add")?.addEventListener("click", monAdd);
  $("#mon-check")?.addEventListener("click", monCheckAll);
  $("#mon-export")?.addEventListener("click", async () => {
    const st = $("#mon-status");
    const list = monLoad();
    const ok = await copyText(safeJson(list));
    setStatus(st, ok ? "ok" : "bad", ok ? "Copied watchlist JSON." : "Copy failed.");
    gtagEvent("sec_mon_export", { ok: ok ? 1 : 0 });
  });

  // =========================
  // Init / Auto-run from URL
  // =========================
  $("#qs-run") && ($("#qs-run").disabled = false);

  initLang();
  initApiKeysUi();
  renderHistory();
  monRender();
  renderWalletLabels();

  // default: show quick panel initially
  showPanel("quick");

  // close buttons should hide all panels (nice)
  function showPanelOrNone(key) {
    if (!key) {
      Object.values(panels).forEach(el => el && el.classList.add("hidden"));
      toolCards.forEach(c => c.classList.remove("active"));
      return;
    }
    showPanel(key);
  }

  $("#btnCloseQuick")?.addEventListener("click", () => showPanelOrNone(null));
  $("#btnCloseApprovals")?.addEventListener("click", () => showPanelOrNone(null));
  $("#btnCloseRpc")?.addEventListener("click", () => showPanelOrNone(null));
  $("#btnCloseMonitor")?.addEventListener("click", () => showPanelOrNone(null));

  // language buttons
  $$(".lang-btn").forEach((btn) => {
    btn.addEventListener("click", () => setLang(btn.dataset.lang));
  });

  // Auto-run from query
  const q = parseQuery();
  if (q.tool && panels[q.tool]) showPanel(q.tool);
  if (q.tool === "quick") {
    if (q.net && CHAINS[q.net]) $("#qs-net").value = q.net;
    if (q.token && E.isAddress(q.token)) $("#qs-token").value = E.getAddress(q.token);
    // auto-run after slight delay
    setTimeout(() => {
      if ($("#qs-token")?.value && E.isAddress($("#qs-token").value)) runQuickScan();
    }, 450);
  }

})();
  </script>
</body>
</html>

