<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (optional, same as main site) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/logo.png">
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">

  <meta charset="UTF-8" />
  <title>CycleX â€“ Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg-main: #05060a;
      --bg-gradient-start: #05060a;
      --bg-gradient-mid: #1a0d3a;
      --bg-gradient-end: #003a4c;

      --text-main: #f4f6ff;
      --text-muted: rgba(244, 246, 255, 0.7);

      --accent-cyan: #00e5ff;
      --accent-green: #5dffb2;
      --accent-purple: #7c5cff;

      --card-bg: rgba(255, 255, 255, 0.06);
      --border-subtle: rgba(255, 255, 255, 0.12);

      --shadow-soft: 0 30px 90px rgba(0, 0, 0, 0.75);
      --radius-xl: 24px;
      --transition-fast: 0.18s ease-out;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top left, rgba(124, 92, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at top right, rgba(0, 229, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at bottom, rgba(0, 58, 76, 0.55) 0%, transparent 55%),
        linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
      color: var(--text-main);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      animation: fadeBody 0.7s ease-out forwards;
      opacity: 1;
    }
    @keyframes fadeBody { from { opacity: 0; } to { opacity: 1; } }
    a { color: inherit; text-decoration: none; }

    .page-shell { max-width: 1160px; margin: 0 auto; padding: 32px 20px 64px; }

    .top-bar {
      position: sticky;
      top: 14px;
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 18px;
      margin-bottom: 18px;
      border-radius: 999px;
      background: rgba(8, 10, 22, 0.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .brand { display: flex; align-items: center; gap: 10px; }
    .brand-logo {
      width: 44px; height: 44px; border-radius: 16px; object-fit: contain;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
    }
    .brand-text { display: flex; flex-direction: column; gap: 2px; }
    .brand-title { font-weight: 700; letter-spacing: 0.05em; font-size: 18px; text-transform: uppercase; }
    .brand-sub { font-size: 11px; text-transform: uppercase; letter-spacing: 0.16em; color: var(--text-muted); }

    .lang-switch {
      display: inline-flex;
      align-items: center;
      padding: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.55);
      gap: 2px;
    }
    .lang-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      padding: 5px 8px;
      border-radius: 999px;
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast);
    }
    .lang-btn.active { background: rgba(0, 229, 255, 0.14); color: var(--accent-cyan); }

    body.lang-switching { animation: langFade 0.3s ease-out; }
    @keyframes langFade { from { opacity: 0.4; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    .hero {
      text-align: center;
      max-width: 920px;
      margin: 0 auto 14px auto;
      animation: fadeUp 0.8s ease-out forwards;
    }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

    .hero-kicker { font-size: 13px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-cyan); margin-bottom: 12px; }
    .hero-title { font-size: clamp(38px, 5vw, 58px); line-height: 1.05; font-weight: 800; margin-bottom: 10px; letter-spacing: -0.02em; }
    .hero-subtitle { max-width: 760px; margin: 0 auto 10px auto; font-size: 16px; line-height: 1.5; color: var(--text-muted); }

    .disclaimer {
      max-width: 820px;
      margin: 0 auto 16px auto;
      font-size: 12px;
      line-height: 1.55;
      color: rgba(244,246,255,0.68);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
    }

    .hero-actions {
      display: flex; justify-content: center; flex-wrap: wrap; gap: 12px; margin-bottom: 6px;
    }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 13px 26px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast);
    }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), #7df2ff);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 229, 255, 0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 229, 255, 0.6); }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-green), #b9ffcf);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 230, 118, 0.4);
    }
    .btn-secondary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 230, 118, 0.7); }

    .btn-ghost {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--text-main);
      box-shadow: 0 12px 34px rgba(0,0,0,0.45);
    }
    .btn-ghost:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }

    .section {
      margin-bottom: 18px;
      padding: 26px 22px;
      border-radius: var(--radius-xl);
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65), inset 0 1px 0 rgba(255, 255, 255, 0.05);
      text-align: left;
    }
    .section-head { text-align: center; margin-bottom: 14px; }
    .section-kicker { font-size: 12px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-purple); margin-bottom: 10px; }
    .section-title { font-size: 28px; font-weight: 800; margin-bottom: 8px; }
    .section-body { max-width: 920px; margin: 0 auto; font-size: 14px; line-height: 1.6; color: var(--text-muted); }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 14px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; margin-top: 14px; }

    .card {
      background: var(--card-bg);
      border-radius: 18px;
      border: 1px solid var(--border-subtle);
      padding: 16px;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
      min-width: 0;
    }

    .card h3 { font-size: 15px; letter-spacing: 0.02em; margin-bottom: 8px; color: var(--text-main); }
    .muted { color: var(--text-muted); font-size: 13px; line-height: 1.45; }

    .field { margin-top: 10px; }
    .label { font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); margin-bottom: 6px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(5, 7, 18, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    textarea { border-radius: 18px; min-height: 92px; resize: vertical; padding: 12px 12px; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent-cyan); }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .status {
      margin-top: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: var(--text-main);
      line-height: 1.5;
      font-size: 13px;
      display: none;
    }
    .status.ok   { display:block; background: rgba(0, 230, 118, 0.10); border-color: rgba(0,230,118,0.35); color: #78ffbf; }
    .status.warn { display:block; background: rgba(255, 193, 7, 0.10); border-color: rgba(255,193,7,0.35); color: #ffd166; }
    .status.bad  { display:block; background: rgba(220, 53, 69, 0.10); border-color: rgba(220,53,69,0.35); color: #ff7a8a; }
    .status.info { display:block; background: rgba(0, 229, 255, 0.10); border-color: rgba(0,229,255,0.30); color: #7df2ff; }

    .small { font-size: 12px; color: var(--text-muted); line-height: 1.45; }

    .table {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      overflow: hidden;
    }
    .trow {
      display: grid;
      grid-template-columns: 1.3fr 1.1fr 0.9fr 0.9fr;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      align-items: center;
      font-size: 13px;
    }
    .trow.head { border-top: none; background: rgba(255,255,255,0.05); font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); }
    .trow .cell { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    .footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      margin-top: 24px;
      padding-top: 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .footer-tagline { color: var(--accent-cyan); font-weight: 500; }

    /* Toggle style */
    .toggle{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      cursor:pointer;
      user-select:none;
      width: 100%;
    }
    .toggle input{ width:auto; }

    /* Feature tiles */
    .feature-grid{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-top: 12px;
    }
    .feature-tile{
      text-align:left;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 14px 14px;
      cursor: pointer;
      transition: transform var(--transition-fast), border-color var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      min-width: 0;
    }
    .feature-tile:hover{
      transform: translateY(-1px);
      border-color: rgba(0,229,255,0.24);
    }
    .feature-tile.active{
      border-color: rgba(0,229,255,0.42);
      background: rgba(0,229,255,0.08);
    }
    .feature-name{
      font-weight: 800;
      font-size: 13px;
      letter-spacing: 0.02em;
      margin-bottom: 6px;
    }
    .feature-desc{
      font-size: 12px;
      line-height: 1.45;
      color: rgba(244,246,255,0.72);
    }

    .tool-section { display: none; }
    .tool-section.active { display: block; }

    @media (max-width: 1100px) {
      .feature-grid{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (max-width: 820px) {
      .grid-2, .grid-3 { grid-template-columns: 1fr; }
      .trow { grid-template-columns: 1.2fr 1fr 0.9fr; }
      .trow .hide-sm { display: none; }
      .feature-grid{ grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 420px) {
      .feature-grid{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector">
        <button class="lang-btn active" data-lang="en">ğŸ‡ºğŸ‡¸ EN</button>
        <button class="lang-btn" data-lang="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="ar">ğŸ‡¸ğŸ‡¦ Ø¹Ø±Ø¨ÙŠ</button>
        <button class="lang-btn" data-lang="ru">ğŸ‡·ğŸ‡º RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Hub</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          Choose a tool below. Everything runs client-side and reads public on-chain data.
        </p>

        <div class="disclaimer" data-i18n="hero_disclaimer">
          Disclaimer: Any score or output here may rely on public data and best-effort checks that can be incomplete or outdated. Always verify independently. Using these tools is at your own risk.
        </div>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-run-quick" data-i18n="btn_run_quick">Run Quick Scan</button>
        </div>

        <div class="feature-grid" id="feature-grid">
          <button class="feature-tile active" data-tool="score">
            <div class="feature-name" data-i18n="tile_score_title">Contract Score</div>
            <div class="feature-desc" data-i18n="tile_score_desc">Score tokens on BSC + Ethereum using on-chain signals.</div>
          </button>

          <button class="feature-tile" data-tool="approvals">
            <div class="feature-name" data-i18n="tile_approvals_title">Approvals Guardian</div>
            <div class="feature-desc" data-i18n="tile_approvals_desc">Check & revoke ERC-20 allowances (BSC wallet).</div>
          </button>

          <button class="feature-tile" data-tool="watchlist">
            <div class="feature-name" data-i18n="tile_watch_title">Watchlist / History</div>
            <div class="feature-desc" data-i18n="tile_watch_desc">Save scans & build a local watchlist (browser).</div>
          </button>

          <button class="feature-tile" data-tool="decoder">
            <div class="feature-name" data-i18n="tile_decoder_title">Tx Decoder</div>
            <div class="feature-desc" data-i18n="tile_decoder_desc">Decode tx hashes or calldata (best effort).</div>
          </button>

          <button class="feature-tile" data-tool="rpc">
            <div class="feature-name" data-i18n="tile_rpc_title">RPC Checker</div>
            <div class="feature-desc" data-i18n="tile_rpc_desc">Find the fastest working BSC RPC (stable).</div>
          </button>
        </div>
      </section>

      <!-- 1) Contract Score -->
      <section class="section tool-section active" id="tool-score">
        <div class="section-head">
          <div class="section-kicker" data-i18n="cs_kicker">Contract Score</div>
          <div class="section-title" data-i18n="cs_title">Score a token using on-chain signals</div>
          <div class="section-body" data-i18n="cs_sub">
            Works on <b>BSC</b> and <b>Ethereum</b>. We check metadata, proxy hints, owner patterns, balance concentration, and V2-style liquidity pairs (USDT included).
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="cs_input_title">Token</h3>

            <div class="field">
              <div class="label" data-i18n="cs_chain">Network</div>
              <select id="cs-chain">
                <option value="bsc">BNB Chain (BSC)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="cs_token_label">Token contract address</div>
              <input id="cs-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="cs_tip">
                Tip: open this page with <span class="mono">?token=0x...</span> and it will auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="cs_actions_label">Actions</div>
              <div class="row">
                <button class="btn btn-primary" id="cs-scan" data-i18n="cs_scan">Scan</button>
                <button class="btn btn-ghost" id="cs-share" data-i18n="cs_share">Copy Share Link</button>
                <button class="btn btn-ghost" id="cs-copy-json" data-i18n="cs_copy_json">Copy JSON report</button>
                <button class="btn btn-ghost" id="cs-add-watch" data-i18n="cs_add_watch">Add to Watchlist</button>
                <button class="btn btn-ghost" id="cs-open-explorer" data-i18n="cs_open_explorer">Open Explorer</button>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="cs_controls">Score controls</div>

              <div class="small" style="margin-bottom:8px" data-i18n="cs_strict_tip">
                Higher strictness = harsher scoring. This helps you control how â€œsensitiveâ€ the score is.
              </div>

              <input type="range" id="cs-strict" min="0" max="100" value="55" />
              <div class="row" style="justify-content:space-between; margin-top:8px">
                <span class="pill"><span data-i18n="cs_strict_label">Strictness:</span> <span id="cs-strict-val" class="mono">55</span></span>
                <span class="pill"><span data-i18n="cs_mode_label">Mode:</span> <span id="cs-mode" class="mono">Balanced</span></span>
              </div>

              <div class="row" style="margin-top:12px">
                <label class="toggle">
                  <input type="checkbox" id="cs-require-liq" checked>
                  <span data-i18n="cs_require_liq">Require liquidity</span>
                </label>
              </div>

              <div class="grid-2" style="margin-top:12px">
                <div>
                  <div class="label" data-i18n="cs_owner_thr">Owner concentration threshold (%)</div>
                  <input id="cs-owner-thr" class="mono" value="20" />
                </div>
                <div>
                  <div class="label" data-i18n="cs_liq_thr">Min liquidity threshold (USD, approx)</div>
                  <input id="cs-liq-thr" class="mono" value="25000" />
                </div>
              </div>
            </div>

            <div id="cs-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="cs_results_title">Results</h3>
            <div class="small" data-i18n="cs_results_hint">
              This is not a honeypot guarantee. Itâ€™s a practical on-chain â€œhygieneâ€ score with adjustable strictness.
            </div>

            <div id="cs-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="cs-pairs" style="margin-top:12px;"></div>
          </div>
        </div>
      </section>

      <!-- 2) Approvals Guardian -->
      <section class="section tool-section" id="tool-approvals">
        <div class="section-head">
          <div class="section-kicker" data-i18n="ap_kicker">Approvals Guardian</div>
          <div class="section-title" data-i18n="ap_title">Check and revoke ERC-20 allowances</div>
          <div class="section-body" data-i18n="ap_sub">
            Targeted tool: provide token(s) and spender. We read <span class="mono">allowance(owner, spender)</span> and can revoke by sending <span class="mono">approve(spender, 0)</span>.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="ap_owner">Owner wallet</h3>
            <div class="row" style="justify-content:space-between">
              <div class="pill"><span data-i18n="ap_connected">Connected:</span> <span id="ap-address" class="mono">â€”</span></div>
              <button class="btn btn-secondary" id="ap-connect" data-i18n="ap_connect">Connect / Refresh</button>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_spender_label">Spender</div>
              <div class="row">
                <select id="ap-spender-preset">
                  <option value="pcs_router">PancakeSwap Router (V2)</option>
                  <option value="custom">Customâ€¦</option>
                </select>
                <input id="ap-spender" class="mono" placeholder="0x spender..." />
              </div>
              <div class="small" style="margin-top:8px" data-i18n="ap_spender_tip">
                If youâ€™re unsure: start with PancakeSwap Router preset.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_tokens_label">Token list (one per line)</div>
              <textarea id="ap-tokens" class="mono" placeholder="0x...\n0x...\n0x..."></textarea>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="ap-check" data-i18n="ap_check">Check Allowances</button>
                <button class="btn btn-ghost" id="ap-revoke-all" data-i18n="ap_revoke_all">Revoke All (non-zero)</button>
                <button class="btn btn-ghost" id="ap-use-scan" data-i18n="ap_use_scan">Use scanned token</button>
                <button class="btn btn-ghost" id="ap-add-common" data-i18n="ap_add_common">Add common tokens</button>
              </div>
            </div>

            <div id="ap-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="ap_results">Allowances</h3>
            <div class="small" data-i18n="ap_results_hint">
              If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.
            </div>

            <div id="ap-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Token</div>
                <div class="cell">Allowance</div>
                <div class="cell hide-sm">Symbol</div>
                <div class="cell">Action</div>
              </div>
              <div class="trow">
                <div class="cell muted">â€”</div>
                <div class="cell muted">â€”</div>
                <div class="cell muted hide-sm">â€”</div>
                <div class="cell muted">â€”</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- 3) Watchlist / History -->
      <section class="section tool-section" id="tool-watchlist">
        <div class="section-head">
          <div class="section-kicker" data-i18n="wl_kicker">Watchlist / History</div>
          <div class="section-title" data-i18n="wl_title">Save tokens locally and revisit fast</div>
          <div class="section-body" data-i18n="wl_sub">
            Stored in your browser (localStorage). No server, no accounts. Great for building personal â€œdo-not-touch / watchâ€ lists.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="wl_add_title">Add to watchlist</h3>

            <div class="field">
              <div class="label" data-i18n="wl_chain">Network</div>
              <select id="wl-chain">
                <option value="bsc">BNB Chain (BSC)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="wl_token">Token address</div>
              <input id="wl-token" class="mono" placeholder="0x..." />
            </div>

            <div class="field">
              <div class="label" data-i18n="wl_label">Label (optional)</div>
              <input id="wl-label" placeholder="e.g. risky / new / watch" />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="wl-add" data-i18n="wl_add_btn">Add</button>
                <button class="btn btn-ghost" id="wl-export" data-i18n="wl_export">Export JSON</button>
                <button class="btn btn-ghost" id="wl-import" data-i18n="wl_import">Import JSON</button>
              </div>
              <div class="small" style="margin-top:8px" data-i18n="wl_import_tip">
                Import replaces your current watchlist with the pasted JSON.
              </div>
            </div>

            <div id="wl-status" class="status info"></div>

            <div class="field">
              <div class="label" data-i18n="wl_list">Your watchlist</div>
              <div id="wl-list"></div>
            </div>
          </div>

          <div class="card">
            <h3 data-i18n="wl_history_title">Recent scans</h3>
            <div class="small" data-i18n="wl_history_hint">
              Last 10 scans saved locally. Click to re-open or re-scan.
            </div>
            <div id="wl-history" style="margin-top:12px;"></div>
          </div>
        </div>
      </section>

      <!-- 4) Tx Decoder -->
      <section class="section tool-section" id="tool-decoder">
        <div class="section-head">
          <div class="section-kicker" data-i18n="tx_kicker">Tx Decoder</div>
          <div class="section-title" data-i18n="tx_title">Decode transaction hashes or calldata</div>
          <div class="section-body" data-i18n="tx_sub">
            Best-effort decoding. We detect common selectors (ERC-20 approve/transfer) and can try pulling method names from public signature databases.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="tx_input">Input</h3>

            <div class="field">
              <div class="label" data-i18n="tx_chain">Network</div>
              <select id="tx-chain">
                <option value="bsc">BNB Chain (BSC)</option>
                <option value="eth">Ethereum</option>
              </select>
            </div>

            <div class="field">
              <div class="label" data-i18n="tx_hash">Tx hash (optional)</div>
              <input id="tx-hash" class="mono" placeholder="0x..." />
            </div>

            <div class="field">
              <div class="label" data-i18n="tx_to">To address (optional)</div>
              <input id="tx-to" class="mono" placeholder="0x..." />
            </div>

            <div class="field">
              <div class="label" data-i18n="tx_data">Calldata / input data (optional)</div>
              <textarea id="tx-data" class="mono" placeholder="0x..."></textarea>
              <div class="small" style="margin-top:8px" data-i18n="tx_tip">
                Tip: paste tx hash OR paste calldata. If both exist, hash wins.
              </div>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="tx-decode" data-i18n="tx_decode">Decode</button>
                <button class="btn btn-ghost" id="tx-copy" data-i18n="tx_copy">Copy output</button>
              </div>
            </div>

            <div id="tx-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="tx_output_title">Decoded output</h3>
            <div class="small" data-i18n="tx_output_hint">
              If the ABI is unknown, youâ€™ll still get selector + best guesses and links.
            </div>

            <div id="tx-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a hash or calldata, then press <b>Decode</b>.
            </div>
          </div>
        </div>
      </section>

      <!-- 5) RPC Checker (BSC only, unchanged behavior) -->
      <section class="section tool-section" id="tool-rpc">
        <div class="section-head">
          <div class="section-kicker" data-i18n="rpc_kicker">RPC Checker</div>
          <div class="section-title" data-i18n="rpc_title">Find the fastest working BSC RPC</div>
          <div class="section-body" data-i18n="rpc_sub">
            We measure response time using <span class="mono">eth_blockNumber</span> via ethers. Fastest result is highlighted.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_list">Endpoints</h3>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-share-x" data-i18n="rpc_share_x">Share on X</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
              <div class="trow head">
                <div class="cell">RPC</div>
                <div class="cell">Latency</div>
                <div class="cell hide-sm">Block</div>
                <div class="cell">Status</div>
              </div>
            </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: If one RPC fails due to CORS/timeout, try another â€” we auto-fallback in CycleX anyway.
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>
    </main>
  </div>

  <!-- Load ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <script>
    // ====== i18n ======
    const translations = {
      en: {
        brand_sub: "On-Chain Security & Rewards",
        hero_kicker: "Security Hub",
        hero_title: "CycleX Security Hub",
        hero_subtitle: "Choose a tool below. Everything runs client-side and reads public on-chain data.",
        hero_disclaimer: "Disclaimer: Any score or output here may rely on public data and best-effort checks that can be incomplete or outdated. Always verify independently. Using these tools is at your own risk.",
        btn_back: "Back to Site",
        btn_connect: "Connect Wallet (optional)",
        btn_run_quick: "Run Quick Scan",

        tile_score_title: "Contract Score",
        tile_score_desc: "Score tokens on BSC + Ethereum using on-chain signals.",
        tile_approvals_title: "Approvals Guardian",
        tile_approvals_desc: "Check & revoke ERC-20 allowances (BSC wallet).",
        tile_watch_title: "Watchlist / History",
        tile_watch_desc: "Save scans & build a local watchlist (browser).",
        tile_decoder_title: "Tx Decoder",
        tile_decoder_desc: "Decode tx hashes or calldata (best effort).",
        tile_rpc_title: "RPC Checker",
        tile_rpc_desc: "Find the fastest working BSC RPC (stable).",

        cs_kicker: "Contract Score",
        cs_title: "Score a token using on-chain signals",
        cs_sub: "Works on BSC and Ethereum. We check metadata, proxy hints, owner patterns, balance concentration, and V2-style liquidity pairs (USDT included).",
        cs_input_title: "Token",
        cs_chain: "Network",
        cs_token_label: "Token contract address",
        cs_tip: "Tip: open this page with ?token=0x... and it will auto-run.",
        cs_actions_label: "Actions",
        cs_scan: "Scan",
        cs_share: "Copy Share Link",
        cs_copy_json: "Copy JSON report",
        cs_add_watch: "Add to Watchlist",
        cs_open_explorer: "Open Explorer",
        cs_controls: "Score controls",
        cs_strict_tip: "Higher strictness = harsher scoring. This helps you control how â€œsensitiveâ€ the score is.",
        cs_strict_label: "Strictness:",
        cs_mode_label: "Mode:",
        cs_require_liq: "Require liquidity",
        cs_owner_thr: "Owner concentration threshold (%)",
        cs_liq_thr: "Min liquidity threshold (USD, approx)",
        cs_results_title: "Results",
        cs_results_hint: "This is not a honeypot guarantee. Itâ€™s a practical on-chain â€œhygieneâ€ score with adjustable strictness.",

        ap_kicker: "Approvals Guardian",
        ap_title: "Check and revoke ERC-20 allowances",
        ap_sub: "This tool is targeted: you provide token(s) and spender. We read allowance(owner, spender) and can revoke by sending approve(spender, 0).",
        ap_owner: "Owner wallet",
        ap_connected: "Connected:",
        ap_connect: "Connect / Refresh",
        ap_spender_label: "Spender",
        ap_spender_tip: "If youâ€™re unsure: start with PancakeSwap Router preset.",
        ap_tokens_label: "Token list (one per line)",
        ap_check: "Check Allowances",
        ap_revoke_all: "Revoke All (non-zero)",
        ap_use_scan: "Use scanned token",
        ap_add_common: "Add common tokens",
        ap_results: "Allowances",
        ap_results_hint: "If allowance is â€œinfiniteâ€, revoke is recommended unless you fully trust the spender.",

        wl_kicker: "Watchlist / History",
        wl_title: "Save tokens locally and revisit fast",
        wl_sub: "Stored in your browser (localStorage). No server, no accounts. Great for building personal â€œdo-not-touch / watchâ€ lists.",
        wl_add_title: "Add to watchlist",
        wl_chain: "Network",
        wl_token: "Token address",
        wl_label: "Label (optional)",
        wl_add_btn: "Add",
        wl_export: "Export JSON",
        wl_import: "Import JSON",
        wl_import_tip: "Import replaces your current watchlist with the pasted JSON.",
        wl_list: "Your watchlist",
        wl_history_title: "Recent scans",
        wl_history_hint: "Last 10 scans saved locally. Click to re-open or re-scan.",

        tx_kicker: "Tx Decoder",
        tx_title: "Decode transaction hashes or calldata",
        tx_sub: "Best-effort decoding. We detect common selectors (ERC-20 approve/transfer) and can try pulling method names from public signature databases.",
        tx_input: "Input",
        tx_chain: "Network",
        tx_hash: "Tx hash (optional)",
        tx_to: "To address (optional)",
        tx_data: "Calldata / input data (optional)",
        tx_tip: "Tip: paste tx hash OR paste calldata. If both exist, hash wins.",
        tx_decode: "Decode",
        tx_copy: "Copy output",
        tx_output_title: "Decoded output",
        tx_output_hint: "If the ABI is unknown, youâ€™ll still get selector + best guesses and links.",

        rpc_kicker: "RPC Checker",
        rpc_title: "Find the fastest working BSC RPC",
        rpc_sub: "We measure response time using eth_blockNumber via ethers. Fastest result is highlighted.",
        rpc_list: "Endpoints",
        rpc_custom_label: "Optional custom RPC",
        rpc_test: "Test RPCs",
        rpc_copy_best: "Copy Best RPC",
        rpc_share_x: "Share on X",
        rpc_results: "Results",
        rpc_tip: "Tip: If one RPC fails due to CORS/timeout, try another â€” we auto-fallback in CycleX anyway.",

        footer_left: "CycleX Security Hub runs client-side and reads public on-chain data.",
        footer_tagline: "Verify twice. Connect only when you trust the page."
      },

      zh: {
        brand_sub: "é“¾ä¸Šå®‰å…¨ä¸å¥–åŠ±æœºåˆ¶",
        hero_kicker: "å®‰å…¨ä¸­å¿ƒ",
        hero_title: "CycleX å®‰å…¨ä¸­å¿ƒ",
        hero_subtitle: "è¯·é€‰æ‹©ä¸‹æ–¹å·¥å…·ã€‚æ‰€æœ‰åŠŸèƒ½åœ¨æœ¬åœ°è¿è¡Œå¹¶è¯»å–å…¬å¼€é“¾ä¸Šæ•°æ®ã€‚",
        hero_disclaimer: "å…è´£å£°æ˜ï¼šæœ¬é¡µé¢çš„è¯„åˆ†/è¾“å‡ºå¯èƒ½ä¾èµ–å…¬å¼€æ•°æ®ä¸å°½åŠ›è€Œä¸ºçš„æ£€æŸ¥ï¼Œå¯èƒ½ä¸å®Œæ•´æˆ–è¿‡æ—¶ã€‚è¯·åŠ¡å¿…è‡ªè¡ŒäºŒæ¬¡éªŒè¯ï¼Œä½¿ç”¨é£é™©è‡ªè´Ÿã€‚",
        btn_back: "è¿”å›ç½‘ç«™",
        btn_connect: "è¿æ¥é’±åŒ…ï¼ˆå¯é€‰ï¼‰",
        btn_run_quick: "å¿«é€Ÿæ‰«æ",

        tile_score_title: "åˆçº¦è¯„åˆ†",
        tile_score_desc: "åœ¨ BSC + ä»¥å¤ªåŠä¸ŠåŸºäºé“¾ä¸Šä¿¡å·ç»™å‡ºè¯„åˆ†ã€‚",
        tile_approvals_title: "æˆæƒå®ˆå«",
        tile_approvals_desc: "æ£€æŸ¥å¹¶æ’¤é”€ ERC-20 æˆæƒï¼ˆBSC é’±åŒ…ï¼‰ã€‚",
        tile_watch_title: "å…³æ³¨åˆ—è¡¨ / å†å²",
        tile_watch_desc: "ä¿å­˜æ‰«æè®°å½•å¹¶å»ºç«‹æœ¬åœ°å…³æ³¨åˆ—è¡¨ã€‚",
        tile_decoder_title: "äº¤æ˜“è§£ç ",
        tile_decoder_desc: "è§£ç äº¤æ˜“å“ˆå¸Œæˆ– calldataï¼ˆå°½åŠ›è€Œä¸ºï¼‰ã€‚",
        tile_rpc_title: "RPC ä½“æ£€",
        tile_rpc_desc: "æ‰¾å‡ºæœ€å¿«å¯ç”¨çš„ BSC RPCï¼ˆç¨³å®šç‰ˆï¼‰ã€‚",

        cs_kicker: "åˆçº¦è¯„åˆ†",
        cs_title: "åŸºäºé“¾ä¸Šä¿¡å·ç»™ä»£å¸è¯„åˆ†",
        cs_sub: "æ”¯æŒ BSC ä¸ä»¥å¤ªåŠã€‚æ£€æŸ¥å…ƒæ•°æ®ã€ä»£ç†/owner çº¿ç´¢ã€æŒä»“é›†ä¸­åº¦ä¸ V2 é£æ ¼æµåŠ¨æ€§ï¼ˆåŒ…å« USDTï¼‰ã€‚",
        cs_input_title: "ä»£å¸",
        cs_chain: "ç½‘ç»œ",
        cs_token_label: "ä»£å¸åˆçº¦åœ°å€",
        cs_tip: "æç¤ºï¼šç”¨ ?token=0x... æ‰“å¼€é¡µé¢å¯è‡ªåŠ¨æ‰«æã€‚",
        cs_actions_label: "æ“ä½œ",
        cs_scan: "æ‰«æ",
        cs_share: "å¤åˆ¶åˆ†äº«é“¾æ¥",
        cs_copy_json: "å¤åˆ¶ JSON æŠ¥å‘Š",
        cs_add_watch: "åŠ å…¥å…³æ³¨åˆ—è¡¨",
        cs_open_explorer: "æ‰“å¼€æµè§ˆå™¨",
        cs_controls: "è¯„åˆ†æ§åˆ¶",
        cs_strict_tip: "ä¸¥æ ¼åº¦è¶Šé«˜ï¼Œè¯„åˆ†è¶Šä¸¥æ ¼ã€‚ç”¨äºæ§åˆ¶è¯„åˆ†æ•æ„Ÿåº¦ã€‚",
        cs_strict_label: "ä¸¥æ ¼åº¦ï¼š",
        cs_mode_label: "æ¨¡å¼ï¼š",
        cs_require_liq: "è¦æ±‚æµåŠ¨æ€§",
        cs_owner_thr: "Owner æŒä»“é˜ˆå€¼ï¼ˆ%ï¼‰",
        cs_liq_thr: "æœ€ä½æµåŠ¨æ€§é˜ˆå€¼ï¼ˆUSD ä¼°ç®—ï¼‰",
        cs_results_title: "ç»“æœ",
        cs_results_hint: "è¿™ä¸æ˜¯èœœç½ä¿è¯ï¼Œè€Œæ˜¯å¯è°ƒä¸¥æ ¼åº¦çš„é“¾ä¸Šå«ç”Ÿè¯„åˆ†ã€‚",

        ap_kicker: "æˆæƒå®ˆå«",
        ap_title: "æ£€æŸ¥å¹¶æ’¤é”€ ERC-20 æˆæƒ",
        ap_sub: "å®šå‘å·¥å…·ï¼šè¾“å…¥ä»£å¸ä¸ spenderï¼Œè¯»å– allowanceï¼Œå¯é€šè¿‡ approve(spender, 0) æ’¤é”€ã€‚",
        ap_owner: "é’±åŒ…åœ°å€",
        ap_connected: "å·²è¿æ¥ï¼š",
        ap_connect: "è¿æ¥ / åˆ·æ–°",
        ap_spender_label: "Spender",
        ap_spender_tip: "ä¸ç¡®å®šçš„è¯ï¼šå…ˆé€‰ PancakeSwap Router é¢„è®¾ã€‚",
        ap_tokens_label: "ä»£å¸åˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰",
        ap_check: "æ£€æŸ¥æˆæƒ",
        ap_revoke_all: "æ’¤é”€å…¨éƒ¨ï¼ˆéé›¶ï¼‰",
        ap_use_scan: "ä½¿ç”¨å·²æ‰«æä»£å¸",
        ap_add_common: "æ·»åŠ å¸¸ç”¨ä»£å¸",
        ap_results: "æˆæƒç»“æœ",
        ap_results_hint: "è‹¥æˆæƒä¸ºâ€œæ— é™â€ï¼Œé™¤éå®Œå…¨ä¿¡ä»»ï¼Œå¦åˆ™å»ºè®®æ’¤é”€ã€‚",

        wl_kicker: "å…³æ³¨åˆ—è¡¨ / å†å²",
        wl_title: "æœ¬åœ°ä¿å­˜ä»£å¸ï¼Œéšæ—¶å›çœ‹",
        wl_sub: "ä¿å­˜åœ¨æµè§ˆå™¨ï¼ˆlocalStorageï¼‰ã€‚æ— æœåŠ¡å™¨ã€æ— è´¦å·ã€‚é€‚åˆå»ºç«‹ä¸ªäººâ€œé¿é›·/å…³æ³¨â€åˆ—è¡¨ã€‚",
        wl_add_title: "åŠ å…¥å…³æ³¨åˆ—è¡¨",
        wl_chain: "ç½‘ç»œ",
        wl_token: "ä»£å¸åœ°å€",
        wl_label: "æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰",
        wl_add_btn: "æ·»åŠ ",
        wl_export: "å¯¼å‡º JSON",
        wl_import: "å¯¼å…¥ JSON",
        wl_import_tip: "å¯¼å…¥ä¼šç”¨ç²˜è´´çš„ JSON è¦†ç›–å½“å‰å…³æ³¨åˆ—è¡¨ã€‚",
        wl_list: "ä½ çš„å…³æ³¨åˆ—è¡¨",
        wl_history_title: "æœ€è¿‘æ‰«æ",
        wl_history_hint: "æœ¬åœ°ä¿å­˜æœ€è¿‘ 10 æ¡æ‰«æè®°å½•ã€‚ç‚¹å‡»å¯æ‰“å¼€æˆ–é‡æ–°æ‰«æã€‚",

        tx_kicker: "äº¤æ˜“è§£ç ",
        tx_title: "è§£ç äº¤æ˜“å“ˆå¸Œæˆ– calldata",
        tx_sub: "å°½åŠ›è€Œä¸ºè§£ç ã€‚è¯†åˆ«å¸¸è§é€‰æ‹©å™¨ï¼ˆERC-20 approve/transferï¼‰ï¼Œå¹¶å°è¯•ä»å…¬å¼€ç­¾ååº“è·å–æ–¹æ³•åã€‚",
        tx_input: "è¾“å…¥",
        tx_chain: "ç½‘ç»œ",
        tx_hash: "äº¤æ˜“å“ˆå¸Œï¼ˆå¯é€‰ï¼‰",
        tx_to: "To åœ°å€ï¼ˆå¯é€‰ï¼‰",
        tx_data: "Calldata / è¾“å…¥æ•°æ®ï¼ˆå¯é€‰ï¼‰",
        tx_tip: "æç¤ºï¼šç²˜è´´ tx hash æˆ– calldataã€‚ä¸¤è€…éƒ½æœ‰æ—¶ä¼˜å…ˆ hashã€‚",
        tx_decode: "è§£ç ",
        tx_copy: "å¤åˆ¶è¾“å‡º",
        tx_output_title: "è§£ç è¾“å‡º",
        tx_output_hint: "å³ä½¿ ABI ä¸æ˜ï¼Œä¹Ÿä¼šç»™å‡º selectorã€çŒœæµ‹ç»“æœä¸é“¾æ¥ã€‚",

        rpc_kicker: "RPC ä½“æ£€",
        rpc_title: "æ‰¾å‡ºæœ€å¿«å¯ç”¨çš„ BSC RPC",
        rpc_sub: "é€šè¿‡ ethers è°ƒç”¨ eth_blockNumber æµ‹é‡å»¶è¿Ÿï¼Œæœ€å¿«çš„ä¼šé«˜äº®ã€‚",
        rpc_list: "èŠ‚ç‚¹åˆ—è¡¨",
        rpc_custom_label: "å¯é€‰ï¼šè‡ªå®šä¹‰ RPC",
        rpc_test: "æµ‹è¯• RPC",
        rpc_copy_best: "å¤åˆ¶æœ€ä½³ RPC",
        rpc_share_x: "åˆ†äº«åˆ° X",
        rpc_results: "ç»“æœ",
        rpc_tip: "æç¤ºï¼šå¦‚æœæŸä¸ª RPC å›  CORS/è¶…æ—¶å¤±è´¥ï¼Œæ¢ä¸€ä¸ªå³å¯ï¼Œæˆ‘ä»¬ä¹Ÿä¼šè‡ªåŠ¨ fallbackã€‚",

        footer_left: "CycleX å®‰å…¨ä¸­å¿ƒåœ¨æœ¬åœ°è¿è¡Œï¼Œè¯»å–å…¬å¼€é“¾ä¸Šæ•°æ®ã€‚",
        footer_tagline: "å¤šéªŒè¯ä¸€æ¬¡ï¼Œåªåœ¨ä½ ä¿¡ä»»æ—¶è¿æ¥é’±åŒ…ã€‚"
      },

      ar: {
        brand_sub: "Ø£Ù…Ù† ÙˆÙ…ÙƒØ§ÙØ¢Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©",
        hero_kicker: "Ù…Ø±ÙƒØ² Ø§Ù„Ø£Ù…Ø§Ù†",
        hero_title: "Ù…Ø±ÙƒØ² Ø£Ù…Ø§Ù† CycleX",
        hero_subtitle: "Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø© Ø£Ø¯Ù†Ø§Ù‡. ÙƒÙ„ Ø´ÙŠØ¡ ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆÙŠÙ‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
        hero_disclaimer: "ØªÙ†Ø¨ÙŠÙ‡: Ù‚Ø¯ ØªØ¹ØªÙ…Ø¯ Ø§Ù„Ø¯Ø±Ø¬Ø§Øª/Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ù‡Ù†Ø§ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© ÙˆÙØ­ÙˆØµØ§Øª â€œØ£ÙØ¶Ù„ Ø¬Ù‡Ø¯â€ Ù‚Ø¯ ØªÙƒÙˆÙ† ØºÙŠØ± ÙƒØ§Ù…Ù„Ø© Ø£Ùˆ Ù‚Ø¯ÙŠÙ…Ø©. ØªØ­Ù‚Ù‚ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¨Ù†ÙØ³Ùƒ. Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ù„Ù‰ Ù…Ø³Ø¤ÙˆÙ„ÙŠØªÙƒ.",
        btn_back: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆÙ‚Ø¹",
        btn_connect: "Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø­ÙØ¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
        btn_run_quick: "ÙØ­Øµ Ø³Ø±ÙŠØ¹",

        tile_score_title: "ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ù‚Ø¯",
        tile_score_desc: "ØªÙ‚ÙŠÙŠÙ… ØªÙˆÙƒÙ†Ø§Øª BSC ÙˆEthereum Ø¨Ø¥Ø´Ø§Ø±Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
        tile_approvals_title: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
        tile_approvals_desc: "ÙØ­Øµ ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„Ø³Ù…Ø§Ø­ÙŠØ§Øª (Ù…Ø­ÙØ¸Ø© BSC).",
        tile_watch_title: "Ù‚Ø§Ø¦Ù…Ø© Ù…ØªØ§Ø¨Ø¹Ø© / Ø³Ø¬Ù„",
        tile_watch_desc: "Ø­ÙØ¸ Ø§Ù„ÙØ­ÙˆØµØ§Øª ÙˆØ¨Ù†Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø­Ù„ÙŠØ©.",
        tile_decoder_title: "ÙÙƒ ØªØ±Ù…ÙŠØ² Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©",
        tile_decoder_desc: "ÙÙƒ ØªØ±Ù…ÙŠØ² hash Ø£Ùˆ calldata (Ø£ÙØ¶Ù„ Ø¬Ù‡Ø¯).",
        tile_rpc_title: "ÙØ­Øµ RPC",
        tile_rpc_desc: "Ø§Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø£Ø³Ø±Ø¹ RPC ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ BSC (Ù…Ø³ØªÙ‚Ø±).",

        cs_kicker: "ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ù‚Ø¯",
        cs_title: "Ù‚ÙŠÙ‘Ù… Ø§Ù„ØªÙˆÙƒÙ† Ø¨Ø¥Ø´Ø§Ø±Ø§Øª on-chain",
        cs_sub: "ÙŠØ¯Ø¹Ù… BSC ÙˆEthereum. Ù†ÙØ­Øµ Ø§Ù„Ù…ÙŠØªØ§Ø¯Ø§ØªØ§ØŒ Ø¥Ø´Ø§Ø±Ø§Øª proxy/ownerØŒ ØªØ±ÙƒÙ‘Ø² Ø§Ù„Ø±ØµÙŠØ¯ØŒ ÙˆØ³ÙŠÙˆÙ„Ø© V2 (Ø¨Ù…Ø§ ÙÙŠÙ‡Ø§ USDT).",
        cs_input_title: "Ø§Ù„ØªÙˆÙƒÙ†",
        cs_chain: "Ø§Ù„Ø´Ø¨ÙƒØ©",
        cs_token_label: "Ø¹Ù†ÙˆØ§Ù† Ø¹Ù‚Ø¯ Ø§Ù„ØªÙˆÙƒÙ†",
        cs_tip: "Ù†ØµÙŠØ­Ø©: Ø§ÙØªØ­ Ø§Ù„ØµÙØ­Ø© Ù…Ø¹ ?token=0x... ÙˆØ³ÙŠØ¹Ù…Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.",
        cs_actions_label: "Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª",
        cs_scan: "ÙØ­Øµ",
        cs_share: "Ù†Ø³Ø® Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©",
        cs_copy_json: "Ù†Ø³Ø® ØªÙ‚Ø±ÙŠØ± JSON",
        cs_add_watch: "Ø¥Ø¶Ø§ÙØ© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©",
        cs_open_explorer: "ÙØªØ­ Ø§Ù„Ù…Ø³ØªÙƒØ´Ù",
        cs_controls: "Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¯Ø±Ø¬Ø©",
        cs_strict_tip: "ÙƒÙ„Ù…Ø§ Ø²Ø§Ø¯Øª Ø§Ù„ØµØ±Ø§Ù…Ø©ØŒ Ø£ØµØ¨Ø­Øª Ø§Ù„Ø¯Ø±Ø¬Ø© Ø£ÙƒØ«Ø± ØªØ´Ø¯Ø¯Ø§Ù‹. Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„ØªÙ‚ÙŠÙŠÙ….",
        cs_strict_label: "Ø§Ù„ØµØ±Ø§Ù…Ø©:",
        cs_mode_label: "Ø§Ù„ÙˆØ¶Ø¹:",
        cs_require_liq: "Ø§Ø´ØªØ±Ø§Ø· Ø§Ù„Ø³ÙŠÙˆÙ„Ø©",
        cs_owner_thr: "Ø¹ØªØ¨Ø© ØªØ±ÙƒÙ‘Ø² Ø§Ù„Ù…Ø§Ù„Ùƒ (%)",
        cs_liq_thr: "Ø­Ø¯ Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø³ÙŠÙˆÙ„Ø© (USD ØªÙ‚Ø±ÙŠØ¨ÙŠ)",
        cs_results_title: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
        cs_results_hint: "Ù‡Ø°Ø§ Ù„ÙŠØ³ Ø¶Ù…Ø§Ù†Ø§Ù‹ Ø¶Ø¯ honeypot â€” Ø¥Ù†Ù‡ ØªÙ‚ÙŠÙŠÙ… â€œÙ†Ø¸Ø§ÙØ©â€ Ø¹Ù…Ù„ÙŠ Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¶Ø¨Ø·.",

        ap_kicker: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª",
        ap_title: "ÙØ­Øµ ÙˆØ¥Ù„ØºØ§Ø¡ Ø³Ù…Ø§Ø­ÙŠØ§Øª ERC-20",
        ap_sub: "Ø£Ø¯Ø§Ø© Ù…ÙˆØ¬Ù‡Ø©: ØªÙØ¯Ø®Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ù€ spender. Ù†Ù‚Ø±Ø£ allowance ÙˆÙŠÙ…ÙƒÙ† Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ø¹Ø¨Ø± approve(spender, 0).",
        ap_owner: "Ù…Ø­ÙØ¸Ø© Ø§Ù„Ù…Ø§Ù„Ùƒ",
        ap_connected: "Ù…ØªØµÙ„:",
        ap_connect: "Ø§ØªØµØ§Ù„ / ØªØ­Ø¯ÙŠØ«",
        ap_spender_label: "Spender",
        ap_spender_tip: "Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ØªØ£ÙƒØ¯Ø§Ù‹: Ø§Ø¨Ø¯Ø£ Ø¨Ù…ÙØ³Ø¨Ù‚ PancakeSwap Router.",
        ap_tokens_label: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª (ÙƒÙ„ Ø³Ø·Ø± ØªÙˆÙƒÙ†)",
        ap_check: "ÙØ­Øµ Ø§Ù„Ø³Ù…Ø§Ø­ÙŠØ§Øª",
        ap_revoke_all: "Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„ (ØºÙŠØ± ØµÙØ±)",
        ap_use_scan: "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ù…ÙØ­ÙˆØµ",
        ap_add_common: "Ø£Ø¶Ù ØªÙˆÙƒÙ†Ø§Øª Ø´Ø§Ø¦Ø¹Ø©",
        ap_results: "Ø§Ù„Ø³Ù…Ø§Ø­ÙŠØ§Øª",
        ap_results_hint: "Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø³Ù…Ø§Ø­ÙŠØ© â€œÙ„Ø§ Ù†Ù‡Ø§Ø¦ÙŠØ©â€ØŒ ÙŠÙˆØµÙ‰ Ø¨Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ«Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹ Ø¨Ø§Ù„Ù€ spender.",

        wl_kicker: "Ù‚Ø§Ø¦Ù…Ø© Ù…ØªØ§Ø¨Ø¹Ø© / Ø³Ø¬Ù„",
        wl_title: "Ø§Ø­ÙØ¸ ØªÙˆÙƒÙ†Ø§Øª Ù…Ø­Ù„ÙŠØ§Ù‹ ÙˆØ§Ø±Ø¬Ø¹ Ù„Ù‡Ø§ Ø¨Ø³Ø±Ø¹Ø©",
        wl_sub: "ØªÙØ­ÙØ¸ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ (localStorage). Ø¨Ø¯ÙˆÙ† Ø®Ø§Ø¯Ù… ÙˆØ¨Ø¯ÙˆÙ† Ø­Ø³Ø§Ø¨Ø§Øª. Ù…Ù…ØªØ§Ø²Ø© Ù„Ù‚ÙˆØ§Ø¦Ù… â€œØªØ¬Ù†Ù‘Ø¨/Ø±Ø§Ù‚Ø¨â€.",
        wl_add_title: "Ø¥Ø¶Ø§ÙØ© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©",
        wl_chain: "Ø§Ù„Ø´Ø¨ÙƒØ©",
        wl_token: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙˆÙƒÙ†",
        wl_label: "ÙˆØ³Ù… (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
        wl_add_btn: "Ø¥Ø¶Ø§ÙØ©",
        wl_export: "ØªØµØ¯ÙŠØ± JSON",
        wl_import: "Ø§Ø³ØªÙŠØ±Ø§Ø¯ JSON",
        wl_import_tip: "Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙŠØ³ØªØ¨Ø¯Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø§Ù„Ù€ JSON Ø§Ù„Ù…Ù„ØµÙˆÙ‚.",
        wl_list: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù„Ø¯ÙŠÙƒ",
        wl_history_title: "Ø¢Ø®Ø± Ø§Ù„ÙØ­ÙˆØµØ§Øª",
        wl_history_hint: "Ø¢Ø®Ø± 10 ÙØ­ÙˆØµØ§Øª Ù…Ø­ÙÙˆØ¸Ø© Ù…Ø­Ù„ÙŠØ§Ù‹. Ø§Ø¶ØºØ· Ù„Ù„ÙØªØ­ Ø£Ùˆ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙØ­Øµ.",

        tx_kicker: "ÙÙƒ ØªØ±Ù…ÙŠØ² Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©",
        tx_title: "ÙÙƒ ØªØ±Ù…ÙŠØ² hash Ø£Ùˆ calldata",
        tx_sub: "Ø£ÙØ¶Ù„ Ø¬Ù‡Ø¯. Ù†ÙƒØ´Ù selectors Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© (ERC-20 approve/transfer) ÙˆÙ†Ø­Ø§ÙˆÙ„ Ø¬Ù„Ø¨ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¯ÙˆØ§Ù„ Ù…Ù† Ù‚ÙˆØ§Ø¹Ø¯ Ø¹Ø§Ù…Ø©.",
        tx_input: "Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª",
        tx_chain: "Ø§Ù„Ø´Ø¨ÙƒØ©",
        tx_hash: "Tx hash (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
        tx_to: "Ø¹Ù†ÙˆØ§Ù† To (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
        tx_data: "Calldata / input data (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)",
        tx_tip: "Ù†ØµÙŠØ­Ø©: Ø£Ù„ØµÙ‚ hash Ø£Ùˆ calldata. Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø§Ø«Ù†ÙŠÙ†: hash Ø£ÙˆÙ„Ø§Ù‹.",
        tx_decode: "ÙÙƒ Ø§Ù„ØªØ±Ù…ÙŠØ²",
        tx_copy: "Ù†Ø³Ø® Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª",
        tx_output_title: "Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª",
        tx_output_hint: "Ø­ØªÙ‰ Ø¨Ø¯ÙˆÙ† ABI Ù…Ø¹Ø±ÙˆÙØŒ Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ selector ÙˆØªØ®Ù…ÙŠÙ†Ø§Øª ÙˆØ±ÙˆØ§Ø¨Ø·.",

        rpc_kicker: "ÙØ­Øµ RPC",
        rpc_title: "Ø§Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø£Ø³Ø±Ø¹ RPC ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ BSC",
        rpc_sub: "Ù†Ù‚ÙŠØ³ Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø¹Ø¨Ø± ethers Ùˆ eth_blockNumber. Ø§Ù„Ø£Ø³Ø±Ø¹ Ø³ÙŠØ¸Ù‡Ø± Ù…Ù…ÙŠØ²Ø§Ù‹.",
        rpc_list: "Ø§Ù„Ù†Ù‚Ø§Ø·",
        rpc_custom_label: "Ø§Ø®ØªÙŠØ§Ø±ÙŠ: RPC Ù…Ø®ØµØµ",
        rpc_test: "Ø§Ø®ØªØ¨Ø§Ø± RPC",
        rpc_copy_best: "Ù†Ø³Ø® Ø£ÙØ¶Ù„ RPC",
        rpc_share_x: "Ù…Ø´Ø§Ø±ÙƒØ© Ø¹Ù„Ù‰ X",
        rpc_results: "Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
        rpc_tip: "Ù†ØµÙŠØ­Ø©: Ø¥Ø°Ø§ ÙØ´Ù„ RPC Ø¨Ø³Ø¨Ø¨ CORS/timeout Ø¬Ø±Ù‘Ø¨ ØºÙŠØ±Ù‡ â€” Ù„Ø¯ÙŠÙ†Ø§ fallback Ø£ÙŠØ¶Ø§Ù‹.",

        footer_left: "Ù…Ø±ÙƒØ² Ø£Ù…Ø§Ù† CycleX ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆÙŠÙ‚Ø±Ø£ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù„Ø³Ù„Ø©.",
        footer_tagline: "ØªØ­Ù‚Ù‚ Ù…Ø±ØªÙŠÙ†. Ù„Ø§ ØªØªØµÙ„ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ«Ù‚ Ø¨Ø§Ù„ØµÙØ­Ø©."
      },

      ru: {
        brand_sub: "ĞĞ½Ñ‡ĞµĞ¹Ğ½-Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ¸ Ğ²Ğ¾Ğ·Ğ½Ğ°Ğ³Ñ€Ğ°Ğ¶Ğ´ĞµĞ½Ğ¸Ñ",
        hero_kicker: "Ğ¦ĞµĞ½Ñ‚Ñ€ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸",
        hero_title: "CycleX Security Hub",
        hero_subtitle: "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ½Ğ¸Ğ¶Ğµ. Ğ’ÑÑ‘ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ Ğ¸ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ on-chain Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.",
        hero_disclaimer: "Ğ”Ğ¸ÑĞºĞ»ĞµĞ¹Ğ¼ĞµÑ€: Ğ¾Ñ†ĞµĞ½ĞºĞ¸/Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ğ¿Ğ¸Ñ€Ğ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ â€œbest effortâ€, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ±Ñ‹Ğ²Ğ°ÑÑ‚ Ğ½ĞµĞ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ²ÑˆĞ¸Ğ¼Ğ¸. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ğ²Ğ°Ñˆ Ñ€Ğ¸ÑĞº.",
        btn_back: "ĞĞ°Ğ·Ğ°Ğ´ Ğ½Ğ° ÑĞ°Ğ¹Ñ‚",
        btn_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
        btn_run_quick: "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°",

        tile_score_title: "ĞÑ†ĞµĞ½ĞºĞ° ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°",
        tile_score_desc: "ĞÑ†ĞµĞ½ĞºĞ° Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² BSC + Ethereum Ğ¿Ğ¾ on-chain ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°Ğ¼.",
        tile_approvals_title: "Approvals Guardian",
        tile_approvals_desc: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ² allowance (BSC ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº).",
        tile_watch_title: "Watchlist / History",
        tile_watch_desc: "Ğ¡ĞºĞ°Ğ½-Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¸ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ watchlist Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ.",
        tile_decoder_title: "Tx Decoder",
        tile_decoder_desc: "Ğ”ĞµĞºĞ¾Ğ´ Ñ…ÑÑˆĞµĞ¹ Ğ¸Ğ»Ğ¸ calldata (best effort).",
        tile_rpc_title: "RPC Checker",
        tile_rpc_desc: "Ğ¡Ğ°Ğ¼Ñ‹Ğ¹ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ BSC RPC (ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾).",

        cs_kicker: "ĞÑ†ĞµĞ½ĞºĞ° ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°",
        cs_title: "ĞÑ†ĞµĞ½Ğ¸Ñ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½ Ğ¿Ğ¾ on-chain ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°Ğ¼",
        cs_sub: "Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ² BSC Ğ¸ Ethereum. ĞœĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, proxy-Ñ…Ğ¸Ğ½Ñ‚Ñ‹, owner-Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹, ĞºĞ¾Ğ½Ñ†ĞµĞ½Ñ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ¸ V2-Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ (USDT Ğ²ĞºĞ»ÑÑ‡Ñ‘Ğ½).",
        cs_input_title: "Ğ¢Ğ¾ĞºĞµĞ½",
        cs_chain: "Ğ¡ĞµÑ‚ÑŒ",
        cs_token_label: "ĞĞ´Ñ€ĞµÑ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ° Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
        cs_tip: "Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ Ñ ?token=0x... â€” Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ±ÑƒĞ´ĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼.",
        cs_actions_label: "Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ",
        cs_scan: "Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
        cs_share: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
        cs_copy_json: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ JSON Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚",
        cs_add_watch: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² watchlist",
        cs_open_explorer: "ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ explorer",
        cs_controls: "ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ Ğ¾Ñ†ĞµĞ½ĞºĞ¸",
        cs_strict_tip: "Ğ§ĞµĞ¼ Ğ²Ñ‹ÑˆĞµ strictness â€” Ñ‚ĞµĞ¼ ÑÑ‚Ñ€Ğ¾Ğ¶Ğµ Ğ¾Ñ†ĞµĞ½ĞºĞ°. Ğ­Ñ‚Ğ¾ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ¸Ñ€ÑƒĞµÑ‚ Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ.",
        cs_strict_label: "Strictness:",
        cs_mode_label: "Mode:",
        cs_require_liq: "Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ",
        cs_owner_thr: "ĞŸĞ¾Ñ€Ğ¾Ğ³ ĞºĞ¾Ğ½Ñ†ĞµĞ½Ñ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ owner (%)",
        cs_liq_thr: "ĞœĞ¸Ğ½. Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ (USD, Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ¾)",
        cs_results_title: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
        cs_results_hint: "Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ Ğ¾Ñ‚ honeypot â€” ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸Ñ‡Ğ½Ğ°Ñ on-chain Ğ¾Ñ†ĞµĞ½ĞºĞ° Ñ Ñ€ĞµĞ³ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹ strictness.",

        ap_kicker: "Approvals Guardian",
        ap_title: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ² ERC-20 Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹",
        ap_sub: "Ğ¢Ğ¾Ñ‡ĞµÑ‡Ğ½Ñ‹Ğ¹ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚: Ğ²Ñ‹ Ğ·Ğ°Ğ´Ğ°Ñ‘Ñ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ¸ spender. ĞœÑ‹ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ allowance Ğ¸ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¾Ñ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· approve(spender, 0).",
        ap_owner: "ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ğ°",
        ap_connected: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾:",
        ap_connect: "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ / Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ",
        ap_spender_label: "Spender",
        ap_spender_tip: "Ğ•ÑĞ»Ğ¸ Ğ½Ğµ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹: Ğ½Ğ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ñ Ğ¿Ñ€ĞµÑĞµÑ‚Ğ° PancakeSwap Router.",
        ap_tokens_label: "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² (Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ)",
        ap_check: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ allowance",
        ap_revoke_all: "ĞÑ‚Ğ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ (Ğ½ĞµĞ½ÑƒĞ»ĞµĞ²Ñ‹Ğµ)",
        ap_use_scan: "Ğ˜ÑĞ¿. Ğ¾Ñ‚ÑĞºĞ°Ğ½. Ñ‚Ğ¾ĞºĞµĞ½",
        ap_add_common: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ",
        ap_results: "Allowances",
        ap_results_hint: "Ğ•ÑĞ»Ğ¸ allowance â€œĞ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹â€, Ğ¾Ñ‚Ğ·Ñ‹Ğ² Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ, ĞµÑĞ»Ğ¸ Ğ²Ñ‹ Ğ½Ğµ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ spender Ğ½Ğ° 100%.",

        wl_kicker: "Watchlist / History",
        wl_title: "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞ¹Ñ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹Ñ‚ĞµÑÑŒ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾",
        wl_sub: "Ğ¥Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ (localStorage). Ğ‘ĞµĞ· ÑĞµÑ€Ğ²ĞµÑ€Ğ° Ğ¸ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ¾Ğ². ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ»Ñ â€œavoid/watchâ€ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ².",
        wl_add_title: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² watchlist",
        wl_chain: "Ğ¡ĞµÑ‚ÑŒ",
        wl_token: "ĞĞ´Ñ€ĞµÑ Ñ‚Ğ¾ĞºĞµĞ½Ğ°",
        wl_label: "ĞœĞµÑ‚ĞºĞ° (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
        wl_add_btn: "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
        wl_export: "Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ JSON",
        wl_import: "Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ JSON",
        wl_import_tip: "Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ watchlist Ğ²ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¼ JSON.",
        wl_list: "Ğ’Ğ°Ñˆ watchlist",
        wl_history_title: "ĞĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ğµ ÑĞºĞ°Ğ½Ñ‹",
        wl_history_hint: "ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 10 ÑĞºĞ°Ğ½Ğ¾Ğ² Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾. ĞšĞ»Ğ¸Ğº â€” Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ.",

        tx_kicker: "Tx Decoder",
        tx_title: "Ğ”ĞµĞºĞ¾Ğ´ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹: hash Ğ¸Ğ»Ğ¸ calldata",
        tx_sub: "Best-effort. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ selectors (ERC-20 approve/transfer) Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸Ğ¼ĞµĞ½Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ğ¸Ğ· Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ±Ğ°Ğ·.",
        tx_input: "Ğ’Ğ²Ğ¾Ğ´",
        tx_chain: "Ğ¡ĞµÑ‚ÑŒ",
        tx_hash: "Tx hash (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
        tx_to: "To Ğ°Ğ´Ñ€ĞµÑ (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
        tx_data: "Calldata / input data (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)",
        tx_tip: "Ğ¡Ğ¾Ğ²ĞµÑ‚: Ğ²ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ hash Ğ¸Ğ»Ğ¸ calldata. Ğ•ÑĞ»Ğ¸ Ğ¾Ğ±Ğ° â€” hash Ğ²Ğ°Ğ¶Ğ½ĞµĞµ.",
        tx_decode: "Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
        tx_copy: "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ‹Ğ²Ğ¾Ğ´",
        tx_output_title: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚",
        tx_output_hint: "Ğ”Ğ°Ğ¶Ğµ Ğ±ĞµĞ· ABI Ğ²Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ selector, Ğ´Ğ¾Ğ³Ğ°Ğ´ĞºĞ¸ Ğ¸ ÑÑÑ‹Ğ»ĞºĞ¸.",

        rpc_kicker: "RPC Checker",
        rpc_title: "ĞĞ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ ÑĞ°Ğ¼Ñ‹Ğ¹ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ RPC Ğ´Ğ»Ñ BSC",
        rpc_sub: "Ğ˜Ğ·Ğ¼ĞµÑ€ÑĞµĞ¼ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºÑƒ Ñ‡ĞµÑ€ĞµĞ· ethers Ğ¸ eth_blockNumber. Ğ¡Ğ°Ğ¼Ñ‹Ğ¹ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‡ĞµĞ½.",
        rpc_list: "Ğ­Ğ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ñ‹",
        rpc_custom_label: "ĞĞ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾: ÑĞ²Ğ¾Ğ¹ RPC",
        rpc_test: "Ğ¢ĞµÑÑ‚ RPC",
        rpc_copy_best: "Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ RPC",
        rpc_share_x: "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ² X",
        rpc_results: "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹",
        rpc_tip: "Ğ¡Ğ¾Ğ²ĞµÑ‚: ĞµÑĞ»Ğ¸ RPC Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ğ¸Ğ·-Ğ·Ğ° CORS/timeout â€” Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹, Ñƒ Ğ½Ğ°Ñ Ñ‚Ğ°ĞºĞ¶Ğµ ĞµÑÑ‚ÑŒ fallback.",

        footer_left: "CycleX Security Hub Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ½Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğµ Ğ¸ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ on-chain Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.",
        footer_tagline: "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°Ğ¹Ñ‚Ğµ ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ."
      }
    };

    let CX_LANG = "en";

    function setLanguage(lang) {
      const dict = translations[lang] || translations.en;
      CX_LANG = (translations[lang] ? lang : "en");

      document.body.classList.add("lang-switching");

      document.querySelectorAll("[data-i18n]").forEach((el) => {
        const key = el.getAttribute("data-i18n");
        const val = (dict[key] !== undefined) ? dict[key] : translations.en[key];
        if (val !== undefined) el.innerHTML = val;
      });

      document.querySelectorAll(".lang-btn").forEach((btn) => {
        btn.classList.toggle("active", btn.getAttribute("data-lang") === lang);
      });

      document.documentElement.dir = (lang === "ar") ? "rtl" : "ltr";
      setTimeout(() => document.body.classList.remove("lang-switching"), 250);

      wlRender();
      wlRenderHistory();
    }

    document.querySelectorAll(".lang-btn").forEach((btn) => {
      btn.addEventListener("click", () => setLanguage(btn.getAttribute("data-lang")));
    });
    setLanguage("en");

    // ====== Shared helpers ======
    const CX_DEBUG = false;
    function cxlog(...a){ if(CX_DEBUG) console.log(...a); }

    function ga(ev, params){
      try { if (typeof gtag === "function") gtag("event", ev, params || {}); } catch {}
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    function isHexAddr(x){ return typeof x === "string" && /^0x[0-9a-fA-F]{40}$/.test(x.trim()); }
    function isHexData(x){ return typeof x === "string" && /^0x[0-9a-fA-F]*$/.test(x.trim()); }
    function toChecksum(x){ return ethers.getAddress(x.trim()); }

    async function copyText(text){
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        return true;
      }
    }

    function setStatus(el, kind, html){
      el.className = "status " + (kind || "info");
      el.innerHTML = html || "";
      el.style.display = "block";
    }

    function fmtAddr(a){
      try {
        const x = toChecksum(a);
        return x.slice(0, 6) + "â€¦" + x.slice(-4);
      } catch { return a; }
    }

    function fmtBigintUnits(v, decimals){
      try {
        const s = ethers.formatUnits(v, decimals);
        const [i, f=""] = s.split(".");
        const intWithCommas = i.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        const ff = f.slice(0, 6).replace(/0+$/, "");
        return intWithCommas + (ff ? "." + ff : "");
      } catch {
        return String(v);
      }
    }

    function fmtUsd(x){
      if (!Number.isFinite(x)) return "â€”";
      if (x >= 1_000_000_000) return "$" + (x/1_000_000_000).toFixed(2) + "B";
      if (x >= 1_000_000) return "$" + (x/1_000_000).toFixed(2) + "M";
      if (x >= 1_000) return "$" + (x/1_000).toFixed(2) + "K";
      return "$" + x.toFixed(2);
    }

    function pctOf(part, total){
      try {
        if (!part || !total || total === 0n) return null;
        return Number((part * 10000n) / total) / 100;
      } catch { return null; }
    }

    // ====== Tool switch (tiles) ======
    function showTool(toolKey){
      const map = {
        score: "tool-score",
        approvals: "tool-approvals",
        watchlist: "tool-watchlist",
        decoder: "tool-decoder",
        rpc: "tool-rpc"
      };
      const id = map[toolKey] || "tool-score";

      document.querySelectorAll(".tool-section").forEach(s => s.classList.remove("active"));
      const el = document.getElementById(id);
      if (el) el.classList.add("active");

      document.querySelectorAll(".feature-tile").forEach(b => {
        b.classList.toggle("active", b.getAttribute("data-tool") === toolKey);
      });

      try {
        const u = new URL(window.location.href);
        u.hash = toolKey ? ("#" + toolKey) : "";
        history.replaceState(null, "", u.toString());
      } catch {}

      el?.scrollIntoView({ behavior: "smooth", block: "start" });
      ga("cx_security_tool_open", { tool: toolKey });
    }

    document.querySelectorAll(".feature-tile").forEach(btn => {
      btn.addEventListener("click", () => showTool(btn.getAttribute("data-tool")));
    });

    // ====== Networks config (Contract Score) ======
    const ZERO = "0x0000000000000000000000000000000000000000";
    const DEAD = "0x000000000000000000000000000000000000dEaD";

    const NETWORKS = {
      bsc: {
        key: "bsc",
        name: "BSC",
        chainId: 56,
        explorer: (addr) => `https://bscscan.com/address/${addr}`,
        chainlink_native_usd: "0x0567F2323251f0Aab15c8DfB1967E4e8A7D42aeE", // BNB/USD
        rpcs: [
          "https://bsc-rpc.publicnode.com",
          "https://bsc.publicnode.com",
          "https://rpc.ankr.com/bsc",
          "https://1rpc.io/bnb",
          "https://bsc.drpc.org",
          "https://bsc.meowrpc.com",
          "https://bnb.api.onfinality.io/public",
          "https://bsc.blockpi.network/v1/rpc/public",
          "https://bsc-mainnet.public.blastapi.io",
          "https://bsc-dataseed.binance.org",
          "https://bsc-dataseed1.bnbchain.org",
          "https://bsc-dataseed2.bnbchain.org",
          "https://bsc-dataseed3.bnbchain.org",
          "https://bsc-dataseed1.defibit.io",
          "https://bsc-dataseed2.defibit.io",
          "https://bsc-dataseed3.defibit.io"
        ],
        bases: [
          { key: "WBNB", name: "WBNB", addr: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", decimals: 18, kind: "native" },
          { key: "USDT", name: "USDT", addr: "0x55d398326f99059fF775485246999027B3197955", decimals: 18, kind: "stable" },
          { key: "USDC", name: "USDC", addr: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", decimals: 18, kind: "stable" },
          { key: "BUSD", name: "BUSD", addr: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", decimals: 18, kind: "stable" }
        ],
        dexFactories: [
          { name: "PancakeSwap V2", factory: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73" }
        ]
      },
      eth: {
        key: "eth",
        name: "Ethereum",
        chainId: 1,
        explorer: (addr) => `https://etherscan.io/address/${addr}`,
        chainlink_native_usd: "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419", // ETH/USD
        rpcs: [
          "https://ethereum.publicnode.com",
          "https://eth.llamarpc.com",
          "https://rpc.ankr.com/eth",
          "https://1rpc.io/eth",
          "https://cloudflare-eth.com"
        ],
        bases: [
          { key: "WETH", name: "WETH", addr: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", decimals: 18, kind: "native" },
          { key: "USDT", name: "USDT", addr: "0xdAC17F958D2ee523a2206206994597C13D831ec7", decimals: 6, kind: "stable" },
          { key: "USDC", name: "USDC", addr: "0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", decimals: 6, kind: "stable" },
          { key: "DAI",  name: "DAI",  addr: "0x6B175474E89094C44Da98b954EedeAC495271d0F", decimals: 18, kind: "stable" }
        ],
        dexFactories: [
          { name: "Uniswap V2", factory: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f" },
          { name: "SushiSwap",  factory: "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac" }
        ]
      }
    };

    // ====== ABIs ======
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)",
      "function owner() view returns (address)",
      "function getOwner() view returns (address)",
      "function admin() view returns (address)",
    ];

    const FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];

    const PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const LP_ABI = [
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)"
    ];

    const CL_ABI = [
      "function decimals() view returns (uint8)",
      "function latestRoundData() view returns (uint80,int256,uint256,uint256,uint80)"
    ];

    // ====== Proxy detection (EIP-1967) ======
    const EIP1967_IMPL_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const EIP1967_ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

    function slotToAddress(storageHex){
      if (!storageHex || storageHex === "0x") return null;
      const h = storageHex.toLowerCase().replace(/^0x/,"").padStart(64,"0");
      const addr = "0x" + h.slice(24);
      if (/^0x0{40}$/.test(addr)) return null;
      try { return toChecksum(addr); } catch { return null; }
    }

    async function detectProxy(provider, token){
      try {
        const implRaw = await provider.getStorage(token, EIP1967_IMPL_SLOT);
        const impl = slotToAddress(implRaw);
        const adminRaw = await provider.getStorage(token, EIP1967_ADMIN_SLOT);
        const admin = slotToAddress(adminRaw);
        if (impl) return { isProxy: true, impl, admin };
        return { isProxy: false, impl: null, admin: admin || null };
      } catch {
        return { isProxy: false, impl: null, admin: null };
      }
    }

    // ====== Provider cache (per chain) ======
    const _providers = { bsc: null, eth: null };
    const _providerUrl = { bsc: "", eth: "" };

    async function pickProvider(chainKey) {
      const net = NETWORKS[chainKey];
      if (!net) throw new Error("Unknown network");
      if (_providers[chainKey]) return _providers[chainKey];

      for (const url of net.rpcs) {
        try {
          const p = new ethers.JsonRpcProvider(url);
          const bn = await p.getBlockNumber();
          const network = await p.getNetwork();
          if (Number(network.chainId) !== net.chainId) throw new Error("Wrong chainId");
          _providers[chainKey] = p;
          _providerUrl[chainKey] = url;
          cxlog("âœ… RPC:", chainKey, url, "block:", bn);
          return p;
        } catch (e) {
          cxlog("âš ï¸ RPC fail:", chainKey, url, e?.message || e);
        }
      }
      throw new Error("All RPCs failed (browser/CORS or provider down)");
    }

    // ====== Native/USD (Chainlink) ======
    const _nativeUsdCache = { bsc: null, eth: null };

    async function getNativeUsd(chainKey, provider){
      const cache = _nativeUsdCache[chainKey];
      if (cache && (Date.now() - cache.t) < 60_000) return cache;

      const net = NETWORKS[chainKey];
      try {
        const feed = new ethers.Contract(net.chainlink_native_usd, CL_ABI, provider);
        const dec = Number(await feed.decimals());
        const rd = await feed.latestRoundData();
        const ans = Number(rd[1]);
        if (Number.isFinite(ans) && ans > 0) {
          const px = ans / (10 ** dec);
          _nativeUsdCache[chainKey] = { px, source: "Chainlink", t: Date.now() };
          return _nativeUsdCache[chainKey];
        }
      } catch {}

      _nativeUsdCache[chainKey] = { px: NaN, source: "Unavailable", t: Date.now() };
      return _nativeUsdCache[chainKey];
    }

    // ====== Contract Score: report + history + watchlist ======
    let csLastReport = null;
    let csLastToken = null;

    const CS_HISTORY_KEY = "cx_securityhub_cs_history_v1";
    const WL_KEY = "cx_securityhub_watchlist_v1";

    function loadJSON(key, fallback){
      try {
        const raw = localStorage.getItem(key);
        const v = JSON.parse(raw || "");
        return (v ?? fallback);
      } catch { return fallback; }
    }
    function saveJSON(key, val){
      try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
    }

    function csLoadHistory(){ return Array.isArray(loadJSON(CS_HISTORY_KEY, [])) ? loadJSON(CS_HISTORY_KEY, []) : []; }
    function csSaveToHistory(item){
      const h = csLoadHistory();
      const next = [item, ...h.filter(x => (x?.token||"").toLowerCase() !== item.token.toLowerCase() || (x?.chain||"") !== item.chain)].slice(0, 10);
      saveJSON(CS_HISTORY_KEY, next);
    }

    function wlLoad(){ return Array.isArray(loadJSON(WL_KEY, [])) ? loadJSON(WL_KEY, []) : []; }
    function wlSave(arr){ saveJSON(WL_KEY, arr); }

    function wlAdd(chain, token, label){
      const t = toChecksum(token);
      const list = wlLoad();
      const item = { chain, token: t, label: (label||"").slice(0, 60), ts: Date.now() };
      const next = [item, ...list.filter(x => !(x.chain === chain && (x.token||"").toLowerCase() === t.toLowerCase()))];
      wlSave(next);
      return item;
    }
    function wlRemove(chain, token){
      const t = toChecksum(token);
      const list = wlLoad();
      wlSave(list.filter(x => !(x.chain === chain && (x.token||"").toLowerCase() === t.toLowerCase())));
    }

    function wlSetStatus(kind, html){ setStatus(document.getElementById("wl-status"), kind, html); }

    function wlRender(){
      const box = document.getElementById("wl-list");
      const list = wlLoad();
      if (!list.length) { box.innerHTML = `<div class="small muted">â€”</div>`; return; }

      box.innerHTML = list.map(x => {
        const exp = NETWORKS[x.chain]?.explorer?.(x.token) || "#";
        const when = new Date(x.ts).toLocaleString();
        const lbl = x.label ? `â€¢ ${x.label}` : "";
        return `
          <div class="card" style="padding:12px; margin-top:10px;">
            <div class="row" style="justify-content:space-between; gap:8px;">
              <div class="pill"><b>${(x.chain||"").toUpperCase()}</b> ${lbl}</div>
              <div class="row" style="gap:8px">
                <button class="btn btn-ghost" data-wl-scan="${x.chain}|${x.token}" style="padding:10px 14px; font-size:12px;">Scan</button>
                <a class="btn btn-ghost" href="${exp}" target="_blank" rel="noopener" style="padding:10px 14px; font-size:12px;">Explorer</a>
                <button class="btn btn-ghost" data-wl-del="${x.chain}|${x.token}" style="padding:10px 14px; font-size:12px;">Remove</button>
              </div>
            </div>
            <div class="small" style="margin-top:8px">
              <span class="mono">${x.token}</span><br>
              <span class="muted">${when}</span>
            </div>
          </div>
        `;
      }).join("");

      box.querySelectorAll("button[data-wl-del]").forEach(btn => {
        btn.addEventListener("click", () => {
          const [chain, token] = btn.getAttribute("data-wl-del").split("|");
          wlRemove(chain, token);
          wlRender();
          wlSetStatus("ok", "<strong>âœ… Removed.</strong>");
          ga("cx_security_watch_remove", { chain });
        });
      });

      box.querySelectorAll("button[data-wl-scan]").forEach(btn => {
        btn.addEventListener("click", () => {
          const [chain, token] = btn.getAttribute("data-wl-scan").split("|");
          document.getElementById("cs-chain").value = chain;
          document.getElementById("cs-token").value = token;
          showTool("score");
          csScan();
        });
      });
    }

    function wlRenderHistory(){
      const el = document.getElementById("wl-history");
      const h = csLoadHistory();
      if (!h.length) { el.innerHTML = `<div class="small muted">â€”</div>`; return; }

      el.innerHTML = h.map(x => {
        const when = new Date(x.ts).toLocaleString();
        const exp = NETWORKS[x.chain]?.explorer?.(x.token) || "#";
        return `
          <div class="card" style="padding:12px; margin-top:10px;">
            <div class="row" style="justify-content:space-between; gap:8px;">
              <div class="pill"><b>${(x.symbol||"â€”")}</b> â€¢ ${(x.chain||"").toUpperCase()} â€¢ Risk: ${x.riskScore} â€¢ Grade: ${x.grade}</div>
              <div class="row" style="gap:8px">
                <button class="btn btn-ghost" data-h-scan="${x.chain}|${x.token}" style="padding:10px 14px; font-size:12px;">Re-scan</button>
                <a class="btn btn-ghost" href="${exp}" target="_blank" rel="noopener" style="padding:10px 14px; font-size:12px;">Explorer</a>
              </div>
            </div>
            <div class="small" style="margin-top:8px">
              <span class="mono">${x.token}</span><br>
              <b>${(x.headline || "")}</b><br>
              <span class="muted">${when}</span>
            </div>
          </div>
        `;
      }).join("");

      el.querySelectorAll("button[data-h-scan]").forEach(btn => {
        btn.addEventListener("click", () => {
          const [chain, token] = btn.getAttribute("data-h-scan").split("|");
          document.getElementById("cs-chain").value = chain;
          document.getElementById("cs-token").value = token;
          showTool("score");
          csScan();
        });
      });
    }

    // ====== Contract Score: pairs scan ======
    async function scanPairsV2(provider, chainKey, token){
      const net = NETWORKS[chainKey];
      const bases = net.bases;
      const factories = net.dexFactories;

      const nativeUsd = await getNativeUsd(chainKey, provider);
      const pairs = [];

      for (const dex of factories) {
        const f = new ethers.Contract(dex.factory, FACTORY_ABI, provider);

        for (const base of bases) {
          try {
            let pair = await f.getPair(token, base.addr);
            pair = toChecksum(String(pair));
            if (/^0x0{40}$/i.test(pair)) continue;

            const p = new ethers.Contract(pair, PAIR_ABI, provider);
            const t0 = toChecksum(await p.token0());
            const r = await p.getReserves();
            const r0 = BigInt(r[0]);
            const r1 = BigInt(r[1]);

            const baseRes = (t0 === toChecksum(base.addr)) ? r0 : r1;
            const tokenRes = (t0 === toChecksum(base.addr)) ? r1 : r0;

            // LP burn (best effort)
            let burnPct = null;
            try {
              const lp = new ethers.Contract(pair, LP_ABI, provider);
              const ts = BigInt(await lp.totalSupply());
              if (ts > 0n) {
                const z = BigInt(await lp.balanceOf(ZERO));
                const d = BigInt(await lp.balanceOf(DEAD));
                const burned = z + d;
                burnPct = Number((burned * 10000n) / ts) / 100;
              }
            } catch {}

            let liqUsdApprox = null;
            try {
              const baseAmt = Number(ethers.formatUnits(baseRes, base.decimals));
              if (base.kind === "stable") {
                liqUsdApprox = baseAmt * 2;
              } else if (base.kind === "native") {
                if (Number.isFinite(nativeUsd.px)) liqUsdApprox = baseAmt * nativeUsd.px * 2;
              }
            } catch {}

            pairs.push({
              dex: dex.name,
              factory: dex.factory,
              base: base.name,
              baseAddr: base.addr,
              pair,
              baseReserve: baseRes,
              tokenReserve: tokenRes,
              liqUsdApprox,
              burnPct
            });
          } catch {}
        }
      }

      pairs.sort((a,b) => (b.liqUsdApprox || 0) - (a.liqUsdApprox || 0));
      return { pairs, nativeUsd };
    }

    function csBuildShareLink(chain, token){
      const u = new URL(window.location.href);
      u.searchParams.set("token", token);
      u.searchParams.set("chain", chain);
      u.hash = "#score";
      return u.toString();
    }

    function csGradeFromRisk(risk){
      // risk: 0 (best) -> 100 (worst)
      if (risk <= 8) return "A";
      if (risk <= 18) return "B";
      if (risk <= 32) return "C";
      if (risk <= 48) return "D";
      if (risk <= 70) return "E";
      return "F";
    }

    function csHeadline(grade){
      if (grade === "A") return "âœ… Strong signals (basic hygiene)";
      if (grade === "B") return "âœ… Looks OK (some caution)";
      if (grade === "C") return "âš ï¸ Caution (mixed signals)";
      if (grade === "D") return "âš ï¸ Higher risk (multiple signals)";
      if (grade === "E") return "âŒ High risk signals";
      return "âŒ Very high risk signals";
    }

    function csModeFromStrict(x){
      if (x <= 33) return "Relaxed";
      if (x <= 66) return "Balanced";
      return "Strict";
    }

    function safeNum(x, def){
      const n = Number(String(x).trim());
      return Number.isFinite(n) ? n : def;
    }

    async function csScan(){
      const chainKey = document.getElementById("cs-chain").value;
      const tokenRaw = (document.getElementById("cs-token").value || "").trim();
      const out = document.getElementById("cs-out");
      const status = document.getElementById("cs-status");

      if (!tokenRaw || !isHexAddr(tokenRaw)) {
        setStatus(status, "warn", "<strong>âš ï¸ Paste a valid token address.</strong>");
        return;
      }
      const token = toChecksum(tokenRaw);

      const strict = Number(document.getElementById("cs-strict").value || 55);
      const requireLiq = !!document.getElementById("cs-require-liq").checked;
      const ownerThr = safeNum(document.getElementById("cs-owner-thr").value, 20);
      const liqThr = safeNum(document.getElementById("cs-liq-thr").value, 25000);

      const mode = csModeFromStrict(strict);
      document.getElementById("cs-mode").textContent = mode;

      setStatus(status, "info", `<strong>â³ Scanningâ€¦</strong><br>Network: <b>${NETWORKS[chainKey].name}</b> â€¢ Strictness: <span class="mono">${strict}</span>`);
      setStatus(out, "info", "<strong>â³ Workingâ€¦</strong>");

      ga("cx_security_cs_scan_start", { chain: chainKey, token });

      try {
        const provider = await pickProvider(chainKey);

        // code exists?
        const code = await provider.getCode(token);
        const isContract = code && code !== "0x";
        if (!isContract) {
          setStatus(out, "bad", `<strong>âŒ Not a contract.</strong><br>${token} has no bytecode on ${NETWORKS[chainKey].name}.`);
          setStatus(status, "bad", "<strong>âŒ Scan finished:</strong> address is not a token contract.");
          return;
        }

        const c = new ethers.Contract(token, ERC20_ABI, provider);

        // metadata
        let name = "â€”", symbol = "â€”", decimals = 18, supply = 0n;
        try { name = await c.name(); } catch {}
        try { symbol = await c.symbol(); } catch {}
        try { decimals = Number(await c.decimals()); } catch { decimals = 18; }
        try { supply = BigInt(await c.totalSupply()); } catch { supply = 0n; }

        // owner
        let owner = null;
        for (const fn of ["owner", "getOwner", "admin"]) {
          try {
            const o = await c[fn]();
            if (o && isHexAddr(String(o))) { owner = toChecksum(String(o)); break; }
          } catch {}
        }
        const ownerRenounced = owner ? (owner === ZERO) : null;

        // balances
        let ownerBal = null, contractBal = null, deadBal = null;
        try { contractBal = BigInt(await c.balanceOf(token)); } catch {}
        try { deadBal = BigInt(await c.balanceOf(DEAD)); } catch {}
        if (owner) { try { ownerBal = BigInt(await c.balanceOf(owner)); } catch {} }

        const ownerPct = (ownerBal != null && supply) ? pctOf(ownerBal, supply) : null;
        const contractPct = (contractBal != null && supply) ? pctOf(contractBal, supply) : null;
        const deadPct = (deadBal != null && supply) ? pctOf(deadBal, supply) : null;

        // proxy
        const proxy = await detectProxy(provider, token);

        // liquidity scan
        const { pairs, nativeUsd } = await scanPairsV2(provider, chainKey, token);
        const best = pairs[0] || null;

        // ===== scoring (controllable strictness) =====
        // riskScore: 0 best -> 100 worst
        // strictness scales penalties: 0.6 .. 1.6
        const k = 0.6 + (strict / 100) * 1.0;

        let risk = 0;
        const notes = [];

        notes.push(`âœ… Bytecode found`);

        // metadata reliability
        if (!name || name === "â€”") { risk += 3 * k; notes.push(`âš ï¸ Name unreadable (non-standard)`); }
        if (!symbol || symbol === "â€”") { risk += 3 * k; notes.push(`âš ï¸ Symbol unreadable (non-standard)`); }

        // owner
        if (!owner) {
          risk += 6 * k;
          notes.push(`âš ï¸ Owner not detectable (less transparent)`);
        } else if (ownerRenounced) {
          notes.push(`âœ… Ownership appears renounced (owner=0x0)`);
        } else {
          risk += 10 * k;
          notes.push(`âš ï¸ Owner detected (not renounced): ${fmtAddr(owner)}`);
        }

        // proxy
        if (proxy?.isProxy && proxy.impl) {
          risk += 8 * k;
          notes.push(`âš ï¸ Proxy detected (EIP-1967). Impl: ${fmtAddr(proxy.impl)}`);
        } else {
          notes.push(`âœ… No EIP-1967 proxy slot detected (best effort)`);
        }

        // concentration
        if (ownerPct != null) {
          if (ownerPct >= ownerThr) { risk += 24 * k; notes.push(`âŒ Owner holds ~${ownerPct.toFixed(2)}% (â‰¥ ${ownerThr}%)`); }
          else if (ownerPct >= Math.max(5, ownerThr/4)) { risk += 10 * k; notes.push(`âš ï¸ Owner holds ~${ownerPct.toFixed(2)}%`); }
          else notes.push(`âœ… Owner concentration: ~${ownerPct.toFixed(2)}%`);
        } else {
          risk += 6 * k; notes.push(`âš ï¸ Could not compute owner concentration`);
        }

        if (deadPct != null && deadPct > 0) notes.push(`â„¹ï¸ Burn/Dead holds ~${deadPct.toFixed(2)}%`);
        if (contractPct != null && contractPct > 0) notes.push(`â„¹ï¸ Contract holds ~${contractPct.toFixed(2)}%`);

        // liquidity
        if (!pairs.length) {
          if (requireLiq) { risk += 26 * k; notes.push(`âŒ No V2-style liquidity pair found (require-liquidity enabled)`); }
          else { risk += 10 * k; notes.push(`âš ï¸ No V2-style liquidity pair found (may be unlisted or V3-only)`); }
        } else {
          notes.push(`âœ… Best pair: ${best.dex} â€¢ ${best.base} â€¢ ${fmtAddr(best.pair)}`);
          if (best.liqUsdApprox != null) {
            notes.push(`â„¹ï¸ Liquidity (approx): ${fmtUsd(best.liqUsdApprox)} (2Ã—base side)`);
            if (best.liqUsdApprox < liqThr) { risk += 14 * k; notes.push(`âš ï¸ Low liquidity (< ${fmtUsd(liqThr)})`); }
          } else {
            risk += 6 * k; notes.push(`âš ï¸ Liquidity not computable (missing price)`); 
          }

          if (best.burnPct != null) {
            if (best.burnPct >= 50) notes.push(`âœ… LP burn seems high: ${best.burnPct.toFixed(2)}%`);
            else { risk += 6 * k; notes.push(`âš ï¸ LP burn seems low: ${best.burnPct.toFixed(2)}%`); }
          } else {
            notes.push(`â„¹ï¸ LP burn: unknown`);
          }

          if (best.base && best.base.toUpperCase().includes("WBNB") && Number.isFinite(nativeUsd.px)) {
            notes.push(`â„¹ï¸ Native/USD: ${nativeUsd.px.toFixed(2)} (${nativeUsd.source})`);
          }
          if (best.base && best.base.toUpperCase().includes("WETH") && Number.isFinite(nativeUsd.px)) {
            notes.push(`â„¹ï¸ ETH/USD: ${nativeUsd.px.toFixed(2)} (${nativeUsd.source})`);
          }
        }

        // normalize risk
        risk = Math.max(0, Math.min(100, Math.round(risk)));

        const grade = csGradeFromRisk(risk);
        const headline = csHeadline(grade);

        const supplyHuman = supply ? fmtBigintUnits(supply, decimals) : "â€”";

        csLastReport = {
          chain: chainKey,
          token,
          name,
          symbol,
          decimals,
          totalSupply: supply ? supply.toString() : null,
          owner: owner || null,
          ownerRenounced,
          pct: { owner: ownerPct, contract: contractPct, dead: deadPct },
          proxy,
          strictness: strict,
          requireLiquidity: requireLiq,
          thresholds: { ownerPct: ownerThr, liqUsd: liqThr },
          nativeUsd: Number.isFinite(nativeUsd.px) ? { price: nativeUsd.px, source: nativeUsd.source } : null,
          pairs: pairs.slice(0, 12).map(p => ({
            dex: p.dex,
            base: p.base,
            baseAddr: p.baseAddr,
            pair: p.pair,
            liquidityUsdApprox: (p.liqUsdApprox != null) ? Number(p.liqUsdApprox) : null,
            lpBurnPct: (p.burnPct != null) ? Number(p.burnPct) : null
          })),
          riskScore: risk,
          grade,
          headline,
          generatedAt: new Date().toISOString(),
          rpc: _providerUrl[chainKey] || "auto"
        };

        csLastToken = token;

        csSaveToHistory({
          chain: chainKey,
          token,
          symbol: symbol || "â€”",
          riskScore: risk,
          grade,
          headline,
          ts: Date.now()
        });

        wlRenderHistory();

        // output
        const html = `
          <strong>${headline}</strong><br><br>
          <div class="pill">${(chainKey||"").toUpperCase()} â€¢ Risk: <span class="mono">${risk}</span> â€¢ Grade: <span class="mono">${grade}</span></div>
          <div style="margin-top:10px" class="small">
            <b>Token:</b> <span class="mono">${token}</span><br>
            <b>Name:</b> ${String(name).replace(/</g,"&lt;")}<br>
            <b>Symbol:</b> ${String(symbol).replace(/</g,"&lt;")}<br>
            <b>Decimals:</b> ${decimals}<br>
            <b>Total supply:</b> ${supply ? supplyHuman : "â€”"}<br>
            <b>Owner:</b> ${owner ? fmtAddr(owner) : "â€”"} â€¢ ${ownerRenounced === true ? "renounced" : (ownerRenounced === false ? "not renounced" : "unknown")}
          </div>
          <div style="margin-top:12px" class="small">
            <b>Signals:</b><br>
            ${notes.map(n => "â€¢ " + n).join("<br>")}
          </div>
          <div style="margin-top:12px" class="small">
            <b>Share:</b> <span class="mono">${csBuildShareLink(chainKey, token)}</span>
          </div>
        `;

        setStatus(out, (grade === "A" || grade === "B") ? "ok" : (grade === "C" || grade === "D") ? "warn" : "bad", html);
        setStatus(status, "ok", `<strong>Done.</strong> RPC: <span class="mono">${_providerUrl[chainKey] || "auto"}</span>`);

        // render pair cards
        const pairsBox = document.getElementById("cs-pairs");
        if (!pairs.length) {
          pairsBox.innerHTML = "";
        } else {
          pairsBox.innerHTML = pairs.slice(0, 6).map(p => `
            <div class="card" style="padding:12px; margin-top:10px;">
              <div class="row" style="justify-content:space-between; gap:8px;">
                <div class="pill"><b>${p.dex}</b> â€¢ ${p.base}</div>
                <div class="pill">LP Burn: <span class="mono">${p.burnPct != null ? p.burnPct.toFixed(2) + "%" : "â€”"}</span></div>
              </div>
              <div class="small" style="margin-top:8px">
                <b>Pair:</b> <span class="mono">${p.pair}</span><br>
                <b>Liquidity (approx):</b> ${p.liqUsdApprox != null ? fmtUsd(p.liqUsdApprox) : "â€”"}
              </div>
            </div>
          `).join("");
        }

        ga("cx_security_cs_scan_done", { chain: chainKey, token, risk, grade });

      } catch (e) {
        console.error(e);
        setStatus(out, "bad", `<strong>âŒ Scan failed.</strong><br>${(e?.message || e || "Unknown error").toString()}`);
        setStatus(status, "bad", "<strong>âŒ Scan failed.</strong> Try again.");
        ga("cx_security_cs_scan_fail", { err: String(e?.message || e || "error") });
      }
    }

    // strictness UI
    const csStrict = document.getElementById("cs-strict");
    const csStrictVal = document.getElementById("cs-strict-val");
    function csUpdateStrictUI(){
      const v = Number(csStrict.value || 55);
      csStrictVal.textContent = String(v);
      document.getElementById("cs-mode").textContent = csModeFromStrict(v);
    }
    csStrict.addEventListener("input", csUpdateStrictUI);
    csUpdateStrictUI();

    // Contract Score buttons
    document.getElementById("cs-scan").addEventListener("click", csScan);

    document.getElementById("cs-share").addEventListener("click", async () => {
      const chainKey = document.getElementById("cs-chain").value;
      const tokenRaw = (document.getElementById("cs-token").value || "").trim();
      if (!tokenRaw || !isHexAddr(tokenRaw)) {
        setStatus(document.getElementById("cs-status"), "warn", "<strong>âš ï¸ Paste a valid token address first.</strong>");
        return;
      }
      const token = toChecksum(tokenRaw);
      const link = csBuildShareLink(chainKey, token);
      await copyText(link);
      setStatus(document.getElementById("cs-status"), "ok", `<strong>âœ… Share link copied.</strong><br><span class="mono">${link}</span>`);
      ga("cx_security_cs_share_link", { chain: chainKey });
    });

    document.getElementById("cs-copy-json").addEventListener("click", async () => {
      const status = document.getElementById("cs-status");
      if (!csLastReport) {
        setStatus(status, "warn", "<strong>âš ï¸ No report yet.</strong><br>Run Scan first.");
        return;
      }
      await copyText(JSON.stringify(csLastReport, null, 2));
      setStatus(status, "ok", "<strong>âœ… JSON report copied.</strong>");
      ga("cx_security_cs_copy_json", { chain: csLastReport.chain });
    });

    document.getElementById("cs-open-explorer").addEventListener("click", () => {
      const chainKey = document.getElementById("cs-chain").value;
      const tokenRaw = (document.getElementById("cs-token").value || "").trim();
      if (!tokenRaw || !isHexAddr(tokenRaw)) {
        setStatus(document.getElementById("cs-status"), "warn", "<strong>âš ï¸ Paste a valid token address first.</strong>");
        return;
      }
      const token = toChecksum(tokenRaw);
      window.open(NETWORKS[chainKey].explorer(token), "_blank", "noopener");
      ga("cx_security_cs_open_explorer", { chain: chainKey });
    });

    document.getElementById("cs-add-watch").addEventListener("click", () => {
      const chainKey = document.getElementById("cs-chain").value;
      const tokenRaw = (document.getElementById("cs-token").value || "").trim();
      if (!tokenRaw || !isHexAddr(tokenRaw)) {
        setStatus(document.getElementById("cs-status"), "warn", "<strong>âš ï¸ Paste a valid token address first.</strong>");
        return;
      }
      const token = toChecksum(tokenRaw);
      wlAdd(chainKey, token, (csLastReport?.symbol && csLastReport.symbol !== "â€”") ? csLastReport.symbol : "");
      wlRender();
      setStatus(document.getElementById("cs-status"), "ok", "<strong>âœ… Added to watchlist.</strong>");
      ga("cx_security_watch_add_from_scan", { chain: chainKey });
    });

    // autorun from query
    function csAutoFromQuery(){
      try {
        const u = new URL(window.location.href);
        const t = u.searchParams.get("token");
        const c = u.searchParams.get("chain");
        if (c && NETWORKS[c]) document.getElementById("cs-chain").value = c;
        if (t && isHexAddr(t)) {
          document.getElementById("cs-token").value = toChecksum(t);
          showTool("score");
          csScan();
        }
      } catch {}
    }

    // ====== 2) Approvals Guardian (BSC wallet) ======
    window.cxAppKitModal = null;

    let apSigner = null;
    let apOwner = null;

    const ALLOW_ABI = [
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 value) returns (bool)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    const MAX_UINT = (1n << 256n) - 1n;

    function apSetStatus(kind, html){
      setStatus(document.getElementById("ap-status"), kind, html);
    }

    const BSC_WBNB = NETWORKS.bsc.bases.find(b=>b.key==="WBNB")?.addr;
    const BSC_USDT = NETWORKS.bsc.bases.find(b=>b.key==="USDT")?.addr;
    const BSC_USDC = NETWORKS.bsc.bases.find(b=>b.key==="USDC")?.addr;
    const BSC_BUSD = NETWORKS.bsc.bases.find(b=>b.key==="BUSD")?.addr;

    function apGetSpender(){
      const preset = document.getElementById("ap-spender-preset").value;
      const input = document.getElementById("ap-spender").value.trim();
      // PancakeSwap Router V2
      const pcsRouter = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
      if (preset === "pcs_router") return pcsRouter || input;
      if (preset === "custom") return input;
      return input;
    }

    function apParseTokens(){
      const raw = document.getElementById("ap-tokens").value || "";
      return raw
        .split(/\r?\n/)
        .map(x => x.trim())
        .filter(Boolean)
        .filter(isHexAddr)
        .map(toChecksum);
    }

    function apSetTokensList(tokens){
      const uniq = [...new Set(tokens.map(t => toChecksum(t)))];
      document.getElementById("ap-tokens").value = uniq.join("\n");
    }

    function apAddTokens(tokens){
      const cur = apParseTokens();
      apSetTokensList([...cur, ...tokens]);
    }

    function apRenderRows(rows){
      const table = document.getElementById("ap-table");
      const head = table.querySelector(".trow.head");
      table.innerHTML = "";
      table.appendChild(head);

      if (!rows.length) {
        const row = document.createElement("div");
        row.className = "trow";
        row.innerHTML = `<div class="cell muted">â€”</div><div class="cell muted">â€”</div><div class="cell muted hide-sm">â€”</div><div class="cell muted">â€”</div>`;
        table.appendChild(row);
        return;
      }

      for (const r of rows) {
        const row = document.createElement("div");
        row.className = "trow";
        const allowanceStr = r.allowanceInf ? "âˆ (infinite)" : r.allowanceHuman;

        row.innerHTML = `
          <div class="cell mono" title="${r.token}">${r.token}</div>
          <div class="cell">${allowanceStr}</div>
          <div class="cell hide-sm">${r.symbol || "â€”"}</div>
          <div class="cell">
            <button class="btn btn-ghost" data-token="${r.token}" ${(!r.canRevoke ? "disabled" : "")} style="padding:10px 14px; font-size:12px;">
              Revoke
            </button>
          </div>
        `;
        table.appendChild(row);
      }

      table.querySelectorAll("button[data-token]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const token = btn.getAttribute("data-token");
          await apRevokeOne(token);
        });
      });
    }

    async function apEnsureConnected() {
      const modal = window.cxAppKitModal;
      if (!modal?.open) {
        apSetStatus("warn", "<strong>âš ï¸ Wallet modal not ready yet.</strong><br>Wait a second and try again.");
        return false;
      }

      apSetStatus("info", "<strong>â³ Connecting walletâ€¦</strong>");
      await modal.open({ view: "ConnectWallet" });

      const start = Date.now();
      while (Date.now() - start < 90000) {
        const p = modal.getWalletProvider?.();
        if (p) {
          const bp = new ethers.BrowserProvider(p);
          apSigner = await bp.getSigner();
          apOwner = await apSigner.getAddress();
          document.getElementById("ap-address").textContent = apOwner;
          apSetStatus("ok", "<strong>âœ… Wallet connected.</strong>");
          ga("cx_security_wallet_connected", {});
          return true;
        }
        await sleep(250);
      }

      apSetStatus("warn", "<strong>âš ï¸ Connection timeout.</strong><br>Please try again.");
      return false;
    }

    async function apCheck() {
      const ok = apOwner ? true : await apEnsureConnected();
      if (!ok) return;

      const spenderRaw = apGetSpender();
      if (!isHexAddr(spenderRaw)) {
        apSetStatus("bad", "<strong>âŒ Invalid spender address.</strong>");
        return;
      }
      const spender = toChecksum(spenderRaw);

      const tokens = apParseTokens();
      if (!tokens.length) {
        apSetStatus("warn", "<strong>âš ï¸ No valid token addresses.</strong><br>Paste at least one token address (one per line).");
        return;
      }

      apSetStatus("info", `<strong>â³ Checking allowancesâ€¦</strong><br>Owner: <span class="mono">${fmtAddr(apOwner)}</span> â€¢ Spender: <span class="mono">${fmtAddr(spender)}</span>`);
      ga("cx_security_ap_check", { n: tokens.length });

      const rows = [];
      for (const t of tokens) {
        try {
          const c = new ethers.Contract(t, ALLOW_ABI, apSigner);
          let sym = "â€”", dec = 18;
          try { sym = await c.symbol(); } catch {}
          try { dec = Number(await c.decimals()); } catch { dec = 18; }

          const a = BigInt(await c.allowance(apOwner, spender));
          const isInf = (a > (MAX_UINT / 2n));
          const human = isInf ? "âˆ" : (a === 0n ? "0" : fmtBigintUnits(a, dec));

          rows.push({
            token: t,
            symbol: sym,
            allowance: a,
            allowanceInf: isInf,
            allowanceHuman: human,
            canRevoke: (a > 0n)
          });
        } catch {
          rows.push({
            token: t,
            symbol: "â€”",
            allowance: 0n,
            allowanceInf: false,
            allowanceHuman: "error",
            canRevoke: false
          });
        }
      }

      apRenderRows(rows);

      const nonZero = rows.filter(r => r.allowance > 0n).length;
      apSetStatus(nonZero ? "warn" : "ok",
        `<strong>Done.</strong><br>Checked ${rows.length} token(s). Non-zero: ${nonZero}.`);
    }

    async function apRevokeOne(tokenAddr) {
      const spenderRaw = apGetSpender();
      if (!apOwner || !apSigner) {
        apSetStatus("warn", "<strong>âš ï¸ Connect wallet first.</strong>");
        return;
      }
      if (!isHexAddr(spenderRaw)) {
        apSetStatus("bad", "<strong>âŒ Invalid spender address.</strong>");
        return;
      }
      const spender = toChecksum(spenderRaw);
      const token = toChecksum(tokenAddr);

      apSetStatus("info", `<strong>â³ Revokingâ€¦</strong><br>Token: <span class="mono">${fmtAddr(token)}</span> â€¢ Spender: <span class="mono">${fmtAddr(spender)}</span>`);

      try {
        const c = new ethers.Contract(token, ALLOW_ABI, apSigner);
        const tx = await c.approve(spender, 0);
        apSetStatus("info", `<strong>â³ Pendingâ€¦</strong><br><span class="mono">${tx.hash}</span>`);
        await tx.wait();
        apSetStatus("ok", "<strong>âœ… Revoke successful.</strong>");
        ga("cx_security_ap_revoke_ok", { token });
        await apCheck();
      } catch (e) {
        console.error(e);
        apSetStatus("bad", `<strong>âŒ Revoke failed.</strong><br>${(e?.message || e).toString()}`);
        ga("cx_security_ap_revoke_fail", { token, err: String(e?.message || e || "error") });
      }
    }

    async function apRevokeAllNonZero() {
      const ok = apOwner ? true : await apEnsureConnected();
      if (!ok) return;

      const tokens = apParseTokens();
      if (!tokens.length) {
        apSetStatus("warn", "<strong>âš ï¸ No valid token addresses.</strong>");
        return;
      }

      await apCheck();

      const rows = [];
      document.querySelectorAll("#ap-table button[data-token]").forEach(btn => {
        if (!btn.disabled) rows.push(btn.getAttribute("data-token"));
      });

      if (!rows.length) {
        apSetStatus("ok", "<strong>âœ… Nothing to revoke.</strong>");
        return;
      }

      apSetStatus("warn", `<strong>â³ Revoking ${rows.length} token(s)â€¦</strong><br>This will send multiple transactions.`);
      for (const t of rows) {
        await apRevokeOne(t);
        await sleep(500);
      }
      apSetStatus("ok", "<strong>âœ… Revoke batch finished.</strong>");
    }

    document.getElementById("ap-spender-preset").addEventListener("change", () => {
      const preset = document.getElementById("ap-spender-preset").value;
      const input = document.getElementById("ap-spender");
      const pcsRouter = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
      if (preset === "pcs_router") {
        input.value = pcsRouter || "";
        input.disabled = true;
      } else {
        input.value = "";
        input.disabled = false;
      }
    });

    document.getElementById("ap-spender").value = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
    document.getElementById("ap-spender").disabled = true;

    document.getElementById("ap-connect").addEventListener("click", apEnsureConnected);
    document.getElementById("ap-check").addEventListener("click", apCheck);
    document.getElementById("ap-revoke-all").addEventListener("click", apRevokeAllNonZero);

    document.getElementById("ap-use-scan").addEventListener("click", () => {
      if (!csLastToken || !isHexAddr(csLastToken)) {
        apSetStatus("warn", "<strong>âš ï¸ No scanned token yet.</strong><br>Run a scan first, then use this.");
        return;
      }
      apAddTokens([csLastToken]);
      apSetStatus("ok", "<strong>âœ… Added scanned token to list.</strong>");
      ga("cx_security_ap_use_scan", { token: csLastToken });
    });

    document.getElementById("ap-add-common").addEventListener("click", () => {
      const arr = [BSC_WBNB, BSC_USDT, BSC_USDC, BSC_BUSD].filter(Boolean);
      apAddTokens(arr);
      apSetStatus("ok", "<strong>âœ… Added common tokens (WBNB/USDT/USDC/BUSD).</strong>");
      ga("cx_security_ap_add_common", {});
    });

    // ====== Watchlist UI events ======
    document.getElementById("wl-add").addEventListener("click", () => {
      const chain = document.getElementById("wl-chain").value;
      const tokenRaw = (document.getElementById("wl-token").value || "").trim();
      const label = (document.getElementById("wl-label").value || "").trim();
      if (!tokenRaw || !isHexAddr(tokenRaw)) {
        wlSetStatus("warn", "<strong>âš ï¸ Paste a valid token address.</strong>");
        return;
      }
      wlAdd(chain, tokenRaw, label);
      wlRender();
      wlSetStatus("ok", "<strong>âœ… Added.</strong>");
      ga("cx_security_watch_add", { chain });
    });

    document.getElementById("wl-export").addEventListener("click", async () => {
      const j = JSON.stringify(wlLoad(), null, 2);
      await copyText(j);
      wlSetStatus("ok", "<strong>âœ… Watchlist JSON copied.</strong>");
      ga("cx_security_watch_export", {});
    });

    document.getElementById("wl-import").addEventListener("click", async () => {
      const raw = prompt("Paste watchlist JSON:");
      if (!raw) return;
      try {
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) throw new Error("Not an array");
        // basic sanitize
        const clean = arr
          .filter(x => x && (x.chain === "bsc" || x.chain === "eth") && isHexAddr(x.token))
          .map(x => ({ chain: x.chain, token: toChecksum(x.token), label: String(x.label||"").slice(0,60), ts: Number(x.ts||Date.now()) }));
        wlSave(clean);
        wlRender();
        wlSetStatus("ok", "<strong>âœ… Imported.</strong>");
        ga("cx_security_watch_import", { n: clean.length });
      } catch (e) {
        wlSetStatus("bad", `<strong>âŒ Import failed.</strong><br>${String(e?.message || e)}`);
      }
    });

    // ====== Tx Decoder ======
    let txLastText = "";

    function txSetStatus(kind, html){ setStatus(document.getElementById("tx-status"), kind, html); }

    const ERC20_IFACE = new ethers.Interface([
      "function approve(address spender, uint256 value)",
      "function transfer(address to, uint256 value)",
      "function transferFrom(address from, address to, uint256 value)"
    ]);

    const SELECTOR_MAP = {
      "0x095ea7b3": "approve(address,uint256)",
      "0xa9059cbb": "transfer(address,uint256)",
      "0x23b872dd": "transferFrom(address,address,uint256)",
      "0x39509351": "increaseAllowance(address,uint256)",
      "0xa457c2d7": "decreaseAllowance(address,uint256)",
      "0x38ed1739": "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
      "0x7ff36ab5": "swapExactETHForTokens(uint256,address[],address,uint256)",
      "0x18cbafe5": "swapExactTokensForETH(uint256,uint256,address[],address,uint256)",
      "0xf305d719": "addLiquidityETH(address,uint256,uint256,uint256,address,uint256)",
      "0xe8e33700": "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)",
      "0x5ae401dc": "multicall(bytes[])"
    };

    async function txFetch4byte(selector){
      try {
        const url = `https://www.4byte.directory/api/v1/signatures/?hex_signature=${encodeURIComponent(selector)}`;
        const r = await fetch(url);
        const j = await r.json();
        const res = j?.results || [];
        return res.slice(0, 3).map(x => x.text_signature);
      } catch { return []; }
    }

    function txPretty(obj){
      return JSON.stringify(obj, null, 2);
    }

    async function txDecode(){
      const chainKey = document.getElementById("tx-chain").value;
      const hashRaw = (document.getElementById("tx-hash").value || "").trim();
      const toRaw = (document.getElementById("tx-to").value || "").trim();
      const dataRaw = (document.getElementById("tx-data").value || "").trim();

      txSetStatus("info", "<strong>â³ Decodingâ€¦</strong>");
      ga("cx_security_tx_decode_start", { chain: chainKey });

      try {
        const provider = await pickProvider(chainKey);

        let tx = null;
        let data = null;
        let toAddr = null;

        if (hashRaw && /^0x[0-9a-fA-F]{64}$/.test(hashRaw)) {
          tx = await provider.getTransaction(hashRaw);
          if (!tx) throw new Error("Transaction not found (RPC)");
          data = tx.data;
          toAddr = tx.to || null;
        } else {
          data = dataRaw;
          toAddr = (isHexAddr(toRaw) ? toChecksum(toRaw) : null);
        }

        if (!data || !isHexData(data) || data.length < 10) throw new Error("Missing/invalid calldata");

        const selector = data.slice(0, 10).toLowerCase();
        const known = SELECTOR_MAP[selector] || null;

        let decoded = null;
        try {
          if (selector === "0x095ea7b3" || selector === "0xa9059cbb" || selector === "0x23b872dd") {
            decoded = ERC20_IFACE.parseTransaction({ data });
          }
        } catch {}

        const sigs = await txFetch4byte(selector);

        const outObj = {
          chain: chainKey,
          txHash: tx ? hashRaw : null,
          to: toAddr,
          selector,
          knownSignature: known,
          signaturesFrom4byte: sigs.length ? sigs : null,
          decoded: decoded ? {
            name: decoded.name,
            signature: decoded.signature,
            args: decoded.args?.map(a => (typeof a === "bigint" ? a.toString() : String(a)))
          } : null,
          rawDataLen: data.length
        };

        if (tx) {
          outObj.txMeta = {
            from: tx.from,
            value: tx.value ? ethers.formatEther(tx.value) : "0",
            nonce: tx.nonce,
            gasLimit: tx.gasLimit ? tx.gasLimit.toString() : null,
            maxFeePerGas: tx.maxFeePerGas ? tx.maxFeePerGas.toString() : null,
            maxPriorityFeePerGas: tx.maxPriorityFeePerGas ? tx.maxPriorityFeePerGas.toString() : null
          };
        }

        txLastText = txPretty(outObj);

        setStatus(document.getElementById("tx-out"), "ok", `<strong>Decoded (best effort).</strong><br><pre class="mono" style="white-space:pre-wrap; margin-top:10px">${txLastText.replace(/</g,"&lt;")}</pre>`);
        txSetStatus("ok", "<strong>âœ… Done.</strong>");
        ga("cx_security_tx_decode_done", { chain: chainKey, selector });

      } catch (e) {
        console.error(e);
        txSetStatus("bad", `<strong>âŒ Decode failed.</strong><br>${String(e?.message || e)}`);
        ga("cx_security_tx_decode_fail", { err: String(e?.message || e || "error") });
      }
    }

    document.getElementById("tx-decode").addEventListener("click", txDecode);
    document.getElementById("tx-copy").addEventListener("click", async () => {
      if (!txLastText) {
        txSetStatus("warn", "<strong>âš ï¸ No output yet.</strong>");
        return;
      }
      await copyText(txLastText);
      txSetStatus("ok", "<strong>âœ… Copied.</strong>");
      ga("cx_security_tx_copy", {});
    });

    // ====== RPC Checker (unchanged behavior) ======
    const RPCS_DEFAULT = [
      "https://bsc-rpc.publicnode.com",
      "https://bsc.publicnode.com",
      "https://rpc.ankr.com/bsc",
      "https://1rpc.io/bnb",
      "https://bsc.drpc.org",
      "https://bsc.meowrpc.com",
      "https://bnb.api.onfinality.io/public",
      "https://bsc.blockpi.network/v1/rpc/public",
      "https://bsc-mainnet.public.blastapi.io",
      "https://bsc-dataseed.binance.org",
      "https://bsc-dataseed1.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io"
    ];

    let _bestRpc = "";

    function openXShare(text){
      const u = `https://x.com/intent/tweet?text=${encodeURIComponent(text)}`;
      window.open(u, "_blank", "noopener");
    }

    function buildSelfBase(){
      const u = new URL(window.location.href);
      u.search = "";
      u.hash = "";
      return u.toString();
    }

    const WBNB = NETWORKS.bsc.bases.find(b=>b.key==="WBNB")?.addr;

    function rpcRow(url, latency, block, ok, logsOk, errMsg){
      const table = document.getElementById("rpc-table");
      const row = document.createElement("div");
      row.className = "trow";

      const tag = ok
        ? (logsOk ? "âœ… OK â€¢ logs" : "âœ… OK â€¢ no logs")
        : ("âŒ Fail" + (errMsg ? ` â€¢ ${errMsg}` : ""));

      const lat = ok ? (latency.toFixed(0) + " ms") : "â€”";
      const blockStr = ok ? String(block) : "â€”";

      row.innerHTML = `
        <div class="cell mono" title="${url}">${url}</div>
        <div class="cell">${lat}</div>
        <div class="cell hide-sm">${blockStr}</div>
        <div class="cell" title="${(errMsg||"").replace(/"/g,"'")}">${tag}</div>
      `;

      if (ok && url === _bestRpc) {
        row.style.background = "rgba(0,230,118,0.10)";
        row.style.borderTopColor = "rgba(0,230,118,0.20)";
      }

      table.appendChild(row);
    }

    async function rpcTestAll(){
      const status = document.getElementById("rpc-status");
      const custom = (document.getElementById("rpc-custom").value || "").trim();

      const list = [...RPCS_DEFAULT];
      if (custom) list.unshift(custom);

      const table = document.getElementById("rpc-table");
      table.innerHTML = `
        <div class="trow head">
          <div class="cell">RPC</div>
          <div class="cell">Latency</div>
          <div class="cell hide-sm">Block</div>
          <div class="cell">Status</div>
        </div>
      `;

      setStatus(status, "info", `<strong>â³ Testing ${list.length} RPC(s)â€¦</strong><br>Note: some endpoints block browsers (CORS).`);
      _bestRpc = "";
      let bestMs = Infinity;

      ga("cx_security_rpc_test_start", { n: list.length });

      for (const url of list) {
        let ok = false;
        let logsOk = false;
        let ms = 0;
        let block = 0;
        let errMsg = "";

        try {
          const p = new ethers.JsonRpcProvider(url);
          const t0 = performance.now();
          block = await p.getBlockNumber();
          const net = await p.getNetwork();
          const t1 = performance.now();
          ms = (t1 - t0);

          if (Number(net.chainId) !== 56) throw new Error("Wrong chainId");
          ok = true;

          try {
            const filter = { address: WBNB, fromBlock: block, toBlock: block };
            await p.getLogs(filter);
            logsOk = true;
          } catch {
            logsOk = false;
          }

          if (ms < bestMs) {
            bestMs = ms;
            _bestRpc = url;
          }
        } catch (e) {
          ok = false;
          const m = (e?.message || "").toString();
          errMsg = m.includes("CORS") ? "CORS" :
                   m.includes("Failed to fetch") ? "fetch" :
                   m.includes("timeout") ? "timeout" :
                   m ? m.slice(0, 18) : "";
        }

        rpcRow(url, ms, block, ok, logsOk, errMsg);
        await sleep(90);
      }

      if (_bestRpc) {
        setStatus(status, "ok", `<strong>âœ… Best RPC:</strong> <span class="mono">${_bestRpc}</span>`);
        ga("cx_security_rpc_test_done", { best: _bestRpc });
      } else {
        setStatus(status, "bad", "<strong>âŒ All RPC tests failed.</strong><br>Try a different custom RPC or run from a different network (some RPCs block browsers).");
        ga("cx_security_rpc_test_fail", {});
      }
    }

    async function rpcCopyBest(){
      const status = document.getElementById("rpc-status");
      if (!_bestRpc) {
        setStatus(status, "warn", "<strong>âš ï¸ No best RPC yet.</strong><br>Run Test RPCs first.");
        return;
      }
      await copyText(_bestRpc);
      setStatus(status, "ok", `<strong>âœ… Copied:</strong> <span class="mono">${_bestRpc}</span>`);
      ga("cx_security_rpc_copy_best", { best: _bestRpc });
    }

    function rpcShareX(){
      const status = document.getElementById("rpc-status");
      if (!_bestRpc) {
        setStatus(status, "warn", "<strong>âš ï¸ No best RPC yet.</strong><br>Run Test RPCs first.");
        return;
      }
      const txt = `CycleX Security Hub â€” BSC RPC test\nBest RPC: ${_bestRpc}\n(eth_blockNumber + light logs test)\n${buildSelfBase()}`;
      openXShare(txt);
      setStatus(status, "info", "<strong>Opened X share.</strong>");
      ga("cx_security_rpc_share_x", { best: _bestRpc });
    }

    document.getElementById("rpc-test").addEventListener("click", rpcTestAll);
    document.getElementById("rpc-copy-best").addEventListener("click", rpcCopyBest);
    document.getElementById("rpc-share-x").addEventListener("click", rpcShareX);

    // ===== Quick scan button =====
    document.getElementById("btn-run-quick").addEventListener("click", async () => {
      ga("cx_security_quick_scan", {});
      showTool("score");
      await csScan();
      showTool("rpc");
      await rpcTestAll();
      showTool("score");
    });

    document.getElementById("btn-connect").addEventListener("click", apEnsureConnected);

    // ===== initial render =====
    wlRender();
    wlRenderHistory();
    csAutoFromQuery();

    // open from hash
    try {
      const h = (window.location.hash || "").replace("#", "");
      if (["score","approvals","watchlist","decoder","rpc"].includes(h)) showTool(h);
    } catch {}
  </script>

  <!-- AppKit (wallet list) -->
  <script type="module">
    import { createAppKit } from "https://esm.sh/@reown/appkit@1.8.15";
    import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@1.8.15";
    import { bsc } from "https://esm.sh/@reown/appkit/networks";

    const projectId = "7886bcb95105e9e47337cec481d5de75";

    const modal = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc],
      defaultNetwork: bsc,
      projectId,
      analytics: false,
      metadata: {
        name: "CycleX",
        description: "CycleX Security Hub",
        url: window.location.origin,
        icons: [`${window.location.origin}/logo.png`]
      }
    });

    window.cxAppKitModal = modal;
  </script>
</body>
</html>
