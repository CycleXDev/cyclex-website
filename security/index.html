<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (optional, same as main site) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXDFXJWCNQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BXDFXJWCNQ');
  </script>

  <link rel="icon" href="/logo.png">
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">

  <meta charset="UTF-8" />
  <title>CycleX ‚Äì Security Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg-main: #05060a;
      --bg-gradient-start: #05060a;
      --bg-gradient-mid: #1a0d3a;
      --bg-gradient-end: #003a4c;

      --text-main: #f4f6ff;
      --text-muted: rgba(244, 246, 255, 0.7);

      --accent-cyan: #00e5ff;
      --accent-green: #5dffb2;
      --accent-purple: #7c5cff;

      --card-bg: rgba(255, 255, 255, 0.06);
      --border-subtle: rgba(255, 255, 255, 0.12);

      --shadow-soft: 0 30px 90px rgba(0, 0, 0, 0.75);
      --radius-xl: 24px;
      --transition-fast: 0.18s ease-out;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top left, rgba(124, 92, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at top right, rgba(0, 229, 255, 0.35) 0%, transparent 45%),
        radial-gradient(circle at bottom, rgba(0, 58, 76, 0.55) 0%, transparent 55%),
        linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
      color: var(--text-main);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      animation: fadeBody 0.7s ease-out forwards;
      opacity: 1;
    }
    @keyframes fadeBody { from { opacity: 0; } to { opacity: 1; } }
    a { color: inherit; text-decoration: none; }

    .page-shell { max-width: 1160px; margin: 0 auto; padding: 32px 20px 64px; }

    .top-bar {
      position: sticky;
      top: 14px;
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 18px;
      margin-bottom: 26px;
      border-radius: 999px;
      background: rgba(8, 10, 22, 0.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .brand { display: flex; align-items: center; gap: 10px; }
    .brand-logo {
      width: 44px; height: 44px; border-radius: 16px; object-fit: contain;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
    }
    .brand-text { display: flex; flex-direction: column; gap: 2px; }
    .brand-title { font-weight: 700; letter-spacing: 0.05em; font-size: 18px; text-transform: uppercase; }
    .brand-sub { font-size: 11px; text-transform: uppercase; letter-spacing: 0.16em; color: var(--text-muted); }

    .lang-switch {
      display: inline-flex;
      align-items: center;
      padding: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.55);
      gap: 2px;
    }
    .lang-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      padding: 5px 8px;
      border-radius: 999px;
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast);
    }
    .lang-btn.active { background: rgba(0, 229, 255, 0.14); color: var(--accent-cyan); }

    body.lang-switching { animation: langFade 0.3s ease-out; }
    @keyframes langFade { from { opacity: 0.4; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    .hero {
      text-align: center;
      max-width: 920px;
      margin: 0 auto 22px auto;
      animation: fadeUp 0.8s ease-out forwards;
    }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

    .hero-kicker { font-size: 13px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-cyan); margin-bottom: 14px; }
    .hero-title { font-size: clamp(40px, 5vw, 60px); line-height: 1.05; font-weight: 800; margin-bottom: 14px; letter-spacing: -0.02em; }
    .hero-subtitle { max-width: 720px; margin: 0 auto 18px auto; font-size: 16px; line-height: 1.5; color: var(--text-muted); }

    .hero-actions {
      display: flex; justify-content: center; flex-wrap: wrap; gap: 14px; margin-bottom: 10px;
    }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 13px 26px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast);
    }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), #7df2ff);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 229, 255, 0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 229, 255, 0.6); }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-green), #b9ffcf);
      color: #020308;
      box-shadow: 0 14px 40px rgba(0, 230, 118, 0.4);
    }
    .btn-secondary:hover { transform: translateY(-1px); box-shadow: 0 18px 60px rgba(0, 230, 118, 0.7); }

    .btn-ghost {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--text-main);
      box-shadow: 0 12px 34px rgba(0,0,0,0.45);
    }
    .btn-ghost:hover { transform: translateY(-1px); border-color: rgba(0,229,255,0.26); }

    .section {
      margin-bottom: 18px;
      padding: 28px 22px;
      border-radius: var(--radius-xl);
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65), inset 0 1px 0 rgba(255, 255, 255, 0.05);
      text-align: left;
    }
    .section-head { text-align: center; margin-bottom: 14px; }
    .section-kicker { font-size: 12px; letter-spacing: 0.16em; text-transform: uppercase; color: var(--accent-purple); margin-bottom: 10px; }
    .section-title { font-size: 30px; font-weight: 800; margin-bottom: 8px; }
    .section-body { max-width: 900px; margin: 0 auto; font-size: 14px; line-height: 1.6; color: var(--text-muted); }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 14px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; margin-top: 14px; }

    .card {
      background: var(--card-bg);
      border-radius: 18px;
      border: 1px solid var(--border-subtle);
      padding: 16px;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
      min-width: 0;
    }

    .card h3 { font-size: 15px; letter-spacing: 0.02em; margin-bottom: 8px; color: var(--text-main); }
    .muted { color: var(--text-muted); font-size: 13px; line-height: 1.45; }

    .field { margin-top: 10px; }
    .label { font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); margin-bottom: 6px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(5, 7, 18, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    textarea { border-radius: 18px; min-height: 92px; resize: vertical; padding: 12px 12px; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent-cyan); }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .status {
      margin-top: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: var(--text-main);
      line-height: 1.5;
      font-size: 13px;
      display: none;
    }
    .status.ok   { display:block; background: rgba(0, 230, 118, 0.10); border-color: rgba(0,230,118,0.35); color: #78ffbf; }
    .status.warn { display:block; background: rgba(255, 193, 7, 0.10); border-color: rgba(255,193,7,0.35); color: #ffd166; }
    .status.bad  { display:block; background: rgba(220, 53, 69, 0.10); border-color: rgba(220,53,69,0.35); color: #ff7a8a; }
    .status.info { display:block; background: rgba(0, 229, 255, 0.10); border-color: rgba(0,229,255,0.30); color: #7df2ff; }

    .small { font-size: 12px; color: var(--text-muted); line-height: 1.45; }

    .table {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      overflow: hidden;
    }
    .trow {
      display: grid;
      grid-template-columns: 1.3fr 1.1fr 0.9fr 0.9fr;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      align-items: center;
      font-size: 13px;
    }
    .trow.head { border-top: none; background: rgba(255,255,255,0.05); font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(244,246,255,0.75); }
    .trow .cell { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    .footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      margin-top: 28px;
      padding-top: 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .footer-tagline { color: var(--accent-cyan); font-weight: 500; }

    /* V2: toggle style */
    .toggle{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      cursor:pointer;
      user-select:none;
      width: 100%;
    }
    .toggle input{ width:auto; }

    @media (max-width: 980px) {
      .grid-2, .grid-3 { grid-template-columns: 1fr; }
      .trow { grid-template-columns: 1.2fr 1fr 0.9fr; }
      .trow .hide-sm { display: none; }
    }
  </style>
</head>

<body>
  <div class="page-shell">
    <header class="top-bar">
      <a class="brand" href="/" title="Back to CycleX">
        <img src="/logo.png" alt="CycleX logo" class="brand-logo" />
        <div class="brand-text">
          <div class="brand-title">CYCLEX</div>
          <div class="brand-sub" data-i18n="brand_sub">On-Chain Security & Rewards</div>
        </div>
      </a>

      <div class="lang-switch" aria-label="Language selector">
        <button class="lang-btn active" data-lang="en">üá∫üá∏ EN</button>
        <button class="lang-btn" data-lang="zh">üá®üá≥ ‰∏≠Êñá</button>
        <button class="lang-btn" data-lang="ar">üá∏üá¶ ÿπÿ±ÿ®Ÿä</button>
        <button class="lang-btn" data-lang="ru">üá∑üá∫ RU</button>
      </div>
    </header>

    <main>
      <section class="hero">
        <div class="hero-kicker" data-i18n="hero_kicker">Security Hub</div>
        <h1 class="hero-title" data-i18n="hero_title">CycleX Security Tools</h1>
        <p class="hero-subtitle" data-i18n="hero_subtitle">
          A lightweight, client-side toolkit for safer swaps, approvals hygiene, DEX redirects, and RPC health checks.
        </p>

        <div class="hero-actions">
          <a class="btn btn-primary" href="/" data-i18n="btn_back">Back to Site</a>
          <button class="btn btn-secondary" id="btn-connect" data-i18n="btn_connect">Connect Wallet (optional)</button>
          <button class="btn btn-ghost" id="btn-run-all" data-i18n="btn_run_all">Run Quick Scan</button>
        </div>

        <div class="small" style="margin-top:10px" data-i18n="hero_note">
          Note: These checks are informational and do not guarantee safety. Always verify independently.
        </div>
      </section>

      <!-- 1) SafeSwap Gate -->
      <section class="section" id="safeswap">
        <div class="section-head">
          <div class="section-kicker" data-i18n="ss_kicker">SafeSwap Gate</div>
          <div class="section-title" data-i18n="ss_title">Check token basics before you swap</div>
          <div class="section-body" data-i18n="ss_sub">
            Enter a token address on BSC. We‚Äôll read on-chain metadata, owner/proxy hints, and multi-DEX liquidity signals ‚Äî then generate shareable outputs.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="ss_input_title">Token Address</h3>

            <div class="field">
              <div class="label" data-i18n="ss_token_label">Token contract (BSC)</div>
              <input id="ss-token" class="mono" placeholder="0x..." />
              <div class="small" style="margin-top:8px" data-i18n="ss_tip">
                Tip: You can open this page with <span class="mono">?token=0x...</span> and it will auto-run.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ss_actions_label">Actions</div>
              <div class="row">
                <button class="btn btn-primary" id="ss-scan" data-i18n="ss_scan">Scan</button>
                <button class="btn btn-ghost" id="ss-share" data-i18n="ss_share">Copy Share Link</button>
                <button class="btn btn-ghost" id="ss-copy-json" data-i18n="ss_copy_json">Copy JSON report</button>

                <!-- NEW (no design change): dependency buttons -->
                <button class="btn btn-ghost" id="ss-copy-summary" data-i18n="ss_copy_summary">Copy Summary</button>
                <button class="btn btn-ghost" id="ss-share-x" data-i18n="ss_share_x">Share on X</button>

                <a class="btn btn-ghost" id="ss-pcs" href="#" target="_blank" rel="noopener">PancakeSwap</a>
                <a class="btn btn-ghost" id="ss-bsc" href="#" target="_blank" rel="noopener">BscScan</a>
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ss_options_label">Options</div>

              <label class="toggle">
                <input type="checkbox" id="ss-require-liq">
                <span data-i18n="ss_require_liq">Require liquidity (production)</span>
              </label>

              <div class="small" style="margin-top:8px" data-i18n="ss_require_liq_tip">
                When enabled, ‚ÄúNo DEX pair‚Äù becomes Red. When disabled, it‚Äôs treated as ‚ÄúNot listed yet‚Äù.
              </div>

              <div class="row" style="margin-top:12px">
                <select id="ss-dex-select"></select>
                <select id="ss-base-select"></select>
                <button class="btn btn-ghost" id="ss-open-manual" data-i18n="ss_open_swap">Open Swap</button>
              </div>
            </div>

            <div id="ss-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="ss_results_title">Results</h3>
            <div class="small" data-i18n="ss_results_hint">
              We score signals as Green / Yellow / Red. This is not a honeypot guarantee ‚Äî just solid on-chain hygiene checks.
            </div>

            <div id="ss-out" class="status info" style="display:block; margin-top:10px;">
              <strong>Ready.</strong><br>
              Paste a token address and click <b>Scan</b>.
            </div>

            <div id="ss-links" style="margin-top:12px;"></div>

            <!-- NEW: history (no CSS changes) -->
            <div id="ss-history" style="margin-top:12px;"></div>
          </div>
        </div>
      </section>

      <!-- 2) Approvals Guardian -->
      <section class="section" id="approvals">
        <div class="section-head">
          <div class="section-kicker" data-i18n="ap_kicker">Approvals Guardian</div>
          <div class="section-title" data-i18n="ap_title">Check and revoke ERC-20 allowances</div>
          <div class="section-body" data-i18n="ap_sub">
            This tool is targeted: you provide token(s) and spender. We read <span class="mono">allowance(owner, spender)</span> and can revoke by sending <span class="mono">approve(spender, 0)</span>.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="ap_owner">Owner wallet</h3>
            <div class="row" style="justify-content:space-between">
              <div class="pill"><span data-i18n="ap_connected">Connected:</span> <span id="ap-address" class="mono">‚Äî</span></div>
              <button class="btn btn-secondary" id="ap-connect" data-i18n="ap_connect">Connect / Refresh</button>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_spender_label">Spender</div>
              <div class="row">
                <select id="ap-spender-preset">
                  <option value="pcs_router">PancakeSwap Router (V2)</option>
                  <option value="custom">Custom‚Ä¶</option>
                </select>
                <input id="ap-spender" class="mono" placeholder="0x spender..." />
              </div>
              <div class="small" style="margin-top:8px" data-i18n="ap_spender_tip">
                If you‚Äôre unsure: start with PancakeSwap Router preset.
              </div>
            </div>

            <div class="field">
              <div class="label" data-i18n="ap_tokens_label">Token list (one per line)</div>
              <textarea id="ap-tokens" class="mono" placeholder="0x...\n0x...\n0x..."></textarea>
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="ap-check" data-i18n="ap_check">Check Allowances</button>
                <button class="btn btn-ghost" id="ap-revoke-all" data-i18n="ap_revoke_all">Revoke All (non-zero)</button>

                <!-- NEW: faster workflow -->
                <button class="btn btn-ghost" id="ap-use-scan" data-i18n="ap_use_scan">Use scanned token</button>
                <button class="btn btn-ghost" id="ap-add-common" data-i18n="ap_add_common">Add common tokens</button>
              </div>
            </div>

            <div id="ap-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="ap_results">Allowances</h3>
            <div class="small" data-i18n="ap_results_hint">
              If allowance is ‚Äúinfinite‚Äù, revoke is recommended unless you fully trust the spender.
            </div>

            <div id="ap-table" class="table" style="margin-top:12px;">
              <div class="trow head">
                <div class="cell">Token</div>
                <div class="cell">Allowance</div>
                <div class="cell hide-sm">Symbol</div>
                <div class="cell">Action</div>
              </div>
              <div class="trow">
                <div class="cell muted">‚Äî</div>
                <div class="cell muted">‚Äî</div>
                <div class="cell muted hide-sm">‚Äî</div>
                <div class="cell muted">‚Äî</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- 3) DEX Guard Bookmarklet -->
      <section class="section" id="bookmarklet">
        <div class="section-head">
          <div class="section-kicker" data-i18n="bm_kicker">DEX Guard</div>
          <div class="section-title" data-i18n="bm_title">Bookmarklet redirect to your security page</div>
          <div class="section-body" data-i18n="bm_sub">
            Save a bookmark that extracts token params from DEX pages and opens this Security Hub with <span class="mono">?token=</span>.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="bm_drag">Drag to bookmarks bar</h3>
            <div class="small" data-i18n="bm_drag_tip">
              On desktop: drag this button into your bookmarks bar.
            </div>

            <div class="field">
              <a id="bm-link" class="btn btn-primary" href="#">DEX Guard ‚Üí CycleX Scan</a>
            </div>

            <div class="small" style="margin-top:10px" data-i18n="bm_note">
              Works best when a DEX URL includes <span class="mono">outputCurrency / inputCurrency</span> (or similar).
            </div>
          </div>

          <div class="card">
            <h3 data-i18n="bm_code">Bookmarklet code</h3>
            <div class="small" data-i18n="bm_code_tip">If your browser blocks drag-drop, create a bookmark and paste this into the URL field:</div>
            <textarea id="bm-code" class="mono" readonly></textarea>
          </div>
        </div>
      </section>

      <!-- 4) RPC Checker -->
      <section class="section" id="rpc">
        <div class="section-head">
          <div class="section-kicker" data-i18n="rpc_kicker">RPC Checker</div>
          <div class="section-title" data-i18n="rpc_title">Find the fastest working BSC RPC</div>
          <div class="section-body" data-i18n="rpc_sub">
            We measure response time using <span class="mono">eth_blockNumber</span> via ethers. Fastest result is highlighted.
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h3 data-i18n="rpc_list">Endpoints</h3>

            <div class="field">
              <div class="label" data-i18n="rpc_custom_label">Optional custom RPC</div>
              <input id="rpc-custom" class="mono" placeholder="https://..." />
            </div>

            <div class="field">
              <div class="row">
                <button class="btn btn-primary" id="rpc-test" data-i18n="rpc_test">Test RPCs</button>
                <button class="btn btn-ghost" id="rpc-copy-best" data-i18n="rpc_copy_best">Copy Best RPC</button>
                <button class="btn btn-ghost" id="rpc-share-x" data-i18n="rpc_share_x">Share on X</button>
              </div>
            </div>

            <div id="rpc-status" class="status info"></div>
          </div>

          <div class="card">
            <h3 data-i18n="rpc_results">Results</h3>

            <div id="rpc-table" class="table">
              <div class="trow head">
                <div class="cell">RPC</div>
                <div class="cell">Latency</div>
                <div class="cell hide-sm">Block</div>
                <div class="cell">Status</div>
              </div>
            </div>

            <div class="small" style="margin-top:10px" data-i18n="rpc_tip">
              Tip: If one RPC fails due to CORS/timeout, try another ‚Äî we auto-fallback in CycleX anyway.
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div data-i18n="footer_left">
          CycleX Security Hub runs client-side and reads public on-chain data.
        </div>
        <div class="footer-tagline" data-i18n="footer_tagline">
          Verify twice. Connect only when you trust the page.
        </div>
      </footer>
    </main>
  </div>

  <!-- Load ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>

  <script>
    // ====== i18n ======
    const translations = {
      en: {
        brand_sub: "On-Chain Security & Rewards",
        hero_kicker: "Security Hub",
        hero_title: "CycleX Security Tools",
        hero_subtitle: "A lightweight, client-side toolkit for safer swaps, approvals hygiene, DEX redirects, and RPC health checks.",
        btn_back: "Back to Site",
        btn_connect: "Connect Wallet (optional)",
        btn_run_all: "Run Quick Scan",
        hero_note: "Note: These checks are informational and do not guarantee safety. Always verify independently.",

        ss_kicker: "SafeSwap Gate",
        ss_title: "Check token basics before you swap",
        ss_sub: "Enter a token address on BSC. We‚Äôll read on-chain metadata, owner/proxy hints, and multi-DEX liquidity signals ‚Äî then generate shareable outputs.",
        ss_input_title: "Token Address",
        ss_token_label: "Token contract (BSC)",
        ss_tip: "Tip: You can open this page with ?token=0x... and it will auto-run.",
        ss_actions_label: "Actions",
        ss_scan: "Scan",
        ss_share: "Copy Share Link",
        ss_copy_json: "Copy JSON report",
        ss_copy_summary: "Copy Summary",
        ss_share_x: "Share on X",
        ss_options_label: "Options",
        ss_require_liq: "Require liquidity (production)",
        ss_require_liq_tip: "When enabled, ‚ÄúNo DEX pair‚Äù becomes Red. When disabled, it‚Äôs treated as ‚ÄúNot listed yet‚Äù.",
        ss_open_swap: "Open Swap",
        ss_results_title: "Results",
        ss_results_hint: "We score signals as Green / Yellow / Red. This is not a honeypot guarantee ‚Äî just solid on-chain hygiene checks.",

        ap_kicker: "Approvals Guardian",
        ap_title: "Check and revoke ERC-20 allowances",
        ap_sub: "This tool is targeted: you provide token(s) and spender. We read allowance(owner, spender) and can revoke by sending approve(spender, 0).",
        ap_owner: "Owner wallet",
        ap_connected: "Connected:",
        ap_connect: "Connect / Refresh",
        ap_spender_label: "Spender",
        ap_spender_tip: "If you‚Äôre unsure: start with PancakeSwap Router preset.",
        ap_tokens_label: "Token list (one per line)",
        ap_check: "Check Allowances",
        ap_revoke_all: "Revoke All (non-zero)",
        ap_use_scan: "Use scanned token",
        ap_add_common: "Add common tokens",
        ap_results: "Allowances",
        ap_results_hint: "If allowance is ‚Äúinfinite‚Äù, revoke is recommended unless you fully trust the spender.",

        bm_kicker: "DEX Guard",
        bm_title: "Bookmarklet redirect to your security page",
        bm_sub: "Save a bookmark that extracts token params from DEX pages and opens this Security Hub with ?token=.",
        bm_drag: "Drag to bookmarks bar",
        bm_drag_tip: "On desktop: drag this button into your bookmarks bar.",
        bm_note: "Works best when a DEX URL includes outputCurrency / inputCurrency (or similar).",
        bm_code: "Bookmarklet code",
        bm_code_tip: "If your browser blocks drag-drop, create a bookmark and paste this into the URL field:",

        rpc_kicker: "RPC Checker",
        rpc_title: "Find the fastest working BSC RPC",
        rpc_sub: "We measure response time using eth_blockNumber via ethers. Fastest result is highlighted.",
        rpc_list: "Endpoints",
        rpc_custom_label: "Optional custom RPC",
        rpc_test: "Test RPCs",
        rpc_copy_best: "Copy Best RPC",
        rpc_share_x: "Share on X",
        rpc_results: "Results",
        rpc_tip: "Tip: If one RPC fails due to CORS/timeout, try another ‚Äî we auto-fallback in CycleX anyway.",

        footer_left: "CycleX Security Hub runs client-side and reads public on-chain data.",
        footer_tagline: "Verify twice. Connect only when you trust the page."
      },
      zh: {
        brand_sub: "Èìæ‰∏äÂÆâÂÖ®‰∏éÂ•ñÂä±Êú∫Âà∂",
        hero_kicker: "ÂÆâÂÖ®‰∏≠ÂøÉ",
        hero_title: "CycleX ÂÆâÂÖ®Â∑•ÂÖ∑",
        hero_subtitle: "ËΩªÈáèÁ∫ßÂÆ¢Êà∑Á´ØÂ∑•ÂÖ∑ÔºöÊç¢Â∏ÅÂâçÊ£ÄÊü•„ÄÅÊéàÊùÉÁÆ°ÁêÜ„ÄÅDEX Ë∑≥ËΩ¨‰∏é RPC ‰ΩìÊ£Ä„ÄÇ",
        btn_back: "ËøîÂõûÁΩëÁ´ô",
        btn_connect: "ËøûÊé•Èí±ÂåÖÔºàÂèØÈÄâÔºâ",
        btn_run_all: "Âø´ÈÄüÊâ´Êèè",
        hero_note: "ÊèêÁ§∫ÔºöËøô‰∫õÊ£ÄÊü•‰ªÖ‰æõÂèÇËÄÉÔºå‰∏ç‰øùËØÅÂÆâÂÖ®ÔºåËØ∑Ëá™Ë°å‰∫åÊ¨°È™åËØÅ„ÄÇ",

        ss_kicker: "SafeSwap Gate",
        ss_title: "Êç¢Â∏ÅÂâçÂÖàÂÅöÂü∫Á°ÄÊ£ÄÊü•",
        ss_sub: "ËæìÂÖ• BSC ‰ª£Â∏ÅÂú∞ÂùÄÔºåËØªÂèñÈìæ‰∏ä‰ø°ÊÅØ„ÄÅowner/proxy Á∫øÁ¥¢‰∏éÂ§ö DEX ÊµÅÂä®ÊÄß‰ø°Âè∑ÔºåÂπ∂ÁîüÊàêÂèØÂàÜ‰∫´ÁªìÊûú„ÄÇ",
        ss_input_title: "‰ª£Â∏ÅÂú∞ÂùÄ",
        ss_token_label: "‰ª£Â∏ÅÂêàÁ∫¶ÔºàBSCÔºâ",
        ss_tip: "ÊèêÁ§∫ÔºöÂèØ‰ª•Áî® ?token=0x... ÊâìÂºÄÊú¨È°µÂπ∂Ëá™Âä®Êâ´Êèè„ÄÇ",
        ss_actions_label: "Êìç‰Ωú",
        ss_scan: "Êâ´Êèè",
        ss_share: "Â§çÂà∂ÂàÜ‰∫´ÈìæÊé•",
        ss_copy_json: "Â§çÂà∂ JSON Êä•Âëä",
        ss_copy_summary: "Â§çÂà∂ÊëòË¶Å",
        ss_share_x: "ÂàÜ‰∫´Âà∞ X",
        ss_options_label: "ÈÄâÈ°π",
        ss_require_liq: "Âº∫Âà∂Ë¶ÅÊ±ÇÊµÅÂä®ÊÄßÔºàÁîü‰∫ßÊ®°ÂºèÔºâ",
        ss_require_liq_tip: "ÂºÄÂêØÂêéÔºöÊ≤°Êúâ DEX Pair ‰ºöÂèòÁ∫¢ÔºõÂÖ≥Èó≠ÂàôËßÜ‰∏∫‚ÄúÂ∞öÊú™‰∏äÊû∂‚Äù„ÄÇ",
        ss_open_swap: "ÊâìÂºÄÂÖëÊç¢",
        ss_results_title: "ÁªìÊûú",
        ss_results_hint: "Áî®Áªø/ÈªÑ/Á∫¢‰ø°Âè∑ËØÑÂàÜ„ÄÇËøô‰∏çÊòØËúúÁΩê‰øùËØÅÔºåÂè™ÊòØÈìæ‰∏äÂü∫Á°ÄÂÆâÂÖ®Ê£ÄÊü•„ÄÇ",

        ap_kicker: "ÊéàÊùÉÂÆàÂç´",
        ap_title: "Ê£ÄÊü•Âπ∂Êí§ÈîÄ ERC-20 ÊéàÊùÉ",
        ap_sub: "ÂÆöÂêëÂ∑•ÂÖ∑ÔºöËæìÂÖ•‰ª£Â∏Å‰∏é spenderÔºåËØªÂèñ allowanceÔºåÂèØÈÄöËøá approve(spender, 0) Êí§ÈîÄ„ÄÇ",
        ap_owner: "Èí±ÂåÖÂú∞ÂùÄ",
        ap_connected: "Â∑≤ËøûÊé•Ôºö",
        ap_connect: "ËøûÊé• / Âà∑Êñ∞",
        ap_spender_label: "Spender",
        ap_spender_tip: "‰∏çÁ°ÆÂÆöÁöÑËØùÔºöÂÖàÈÄâ PancakeSwap Router È¢ÑËÆæ„ÄÇ",
        ap_tokens_label: "‰ª£Â∏ÅÂàóË°®ÔºàÊØèË°å‰∏Ä‰∏™Ôºâ",
        ap_check: "Ê£ÄÊü•ÊéàÊùÉ",
        ap_revoke_all: "Êí§ÈîÄÂÖ®ÈÉ®ÔºàÈùûÈõ∂Ôºâ",
        ap_use_scan: "‰ΩøÁî®Â∑≤Êâ´Êèè‰ª£Â∏Å",
        ap_add_common: "Ê∑ªÂä†Â∏∏Áî®‰ª£Â∏Å",
        ap_results: "ÊéàÊùÉÁªìÊûú",
        ap_results_hint: "Ëã•ÊéàÊùÉ‰∏∫‚ÄúÊó†Èôê‚ÄùÔºåÈô§ÈùûÂÆåÂÖ®‰ø°‰ªªÔºåÂê¶ÂàôÂª∫ËÆÆÊí§ÈîÄ„ÄÇ",

        bm_kicker: "DEX Guard",
        bm_title: "‰π¶Á≠æËÑöÊú¨Ôºö‰ªé DEX ‰∏ÄÈîÆË∑≥ËΩ¨Êâ´Êèè",
        bm_sub: "‰øùÂ≠ò‰π¶Á≠æÔºå‰ªé DEX URL ÊèêÂèñ token ÂèÇÊï∞Âπ∂ÊâìÂºÄÊú¨È°µÊâ´Êèè„ÄÇ",
        bm_drag: "ÊãñÂà∞‰π¶Á≠æÊ†è",
        bm_drag_tip: "Ê°åÈù¢Á´ØÔºöÊääÊåâÈíÆÊãñÂà∞‰π¶Á≠æÊ†èÂç≥ÂèØ„ÄÇ",
        bm_note: "ÂΩì DEX URL Âê´ outputCurrency / inputCurrencyÔºàÊàñÁ±ª‰ººÔºâÊó∂ÊïàÊûúÊúÄ‰Ω≥„ÄÇ",
        bm_code: "‰π¶Á≠æ‰ª£Á†Å",
        bm_code_tip: "Ëã•ÊµèËßàÂô®ÈòªÊ≠¢ÊãñÊãΩÔºåËØ∑ÂàõÂª∫‰π¶Á≠æÂπ∂Êää‰ª•‰∏ãÂÜÖÂÆπÁ≤òË¥¥Âà∞ URLÔºö",

        rpc_kicker: "RPC ‰ΩìÊ£Ä",
        rpc_title: "ÊâæÂá∫ÊúÄÂø´ÂèØÁî®ÁöÑ BSC RPC",
        rpc_sub: "ÈÄöËøá ethers Ë∞ÉÁî® eth_blockNumber ÊµãÈáèÂª∂ËøüÔºåÊúÄÂø´ÁöÑ‰ºöÈ´ò‰∫Æ„ÄÇ",
        rpc_list: "ËäÇÁÇπÂàóË°®",
        rpc_custom_label: "ÂèØÈÄâÔºöËá™ÂÆö‰πâ RPC",
        rpc_test: "ÊµãËØï RPC",
        rpc_copy_best: "Â§çÂà∂ÊúÄ‰Ω≥ RPC",
        rpc_share_x: "ÂàÜ‰∫´Âà∞ X",
        rpc_results: "ÁªìÊûú",
        rpc_tip: "ÊèêÁ§∫ÔºöÂ¶ÇÊûúÊüê‰∏™ RPC Âõ† CORS/Ë∂ÖÊó∂Â§±Ë¥•ÔºåÊç¢‰∏Ä‰∏™Âç≥ÂèØÔºåÊàë‰ª¨‰πü‰ºöËá™Âä® fallback„ÄÇ",

        footer_left: "CycleX ÂÆâÂÖ®‰∏≠ÂøÉÂú®Êú¨Âú∞ËøêË°åÔºåËØªÂèñÂÖ¨ÂºÄÈìæ‰∏äÊï∞ÊçÆ„ÄÇ",
        footer_tagline: "Â§öÈ™åËØÅ‰∏ÄÊ¨°ÔºåÂè™Âú®‰Ω†‰ø°‰ªªÊó∂ËøûÊé•Èí±ÂåÖ„ÄÇ"
      },
      ar: {
        brand_sub: "ÿ£ŸÖŸÜ ŸàŸÖŸÉÿßŸÅÿ¢ÿ™ ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©",
        hero_kicker: "ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ£ŸÖÿßŸÜ",
        hero_title: "ÿ£ÿØŸàÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ ŸÖŸÜ CycleX",
        hero_subtitle: "ÿ£ÿØŸàÿßÿ™ ÿÆŸÅŸäŸÅÿ© ÿπŸÑŸâ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠: ŸÅÿ≠ÿµ ŸÇÿ®ŸÑ ÿßŸÑÿ¥ÿ±ÿßÿ°ÿå ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸàÿßŸÅŸÇÿßÿ™ÿå ÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸá DEXÿå ŸàŸÅÿ≠ÿµ RPC.",
        btn_back: "ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÖŸàŸÇÿπ",
        btn_connect: "ÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)",
        btn_run_all: "ŸÅÿ≠ÿµ ÿ≥ÿ±Ÿäÿπ",
        hero_note: "ŸÖŸÑÿßÿ≠ÿ∏ÿ©: Ÿáÿ∞Ÿá ÿßŸÑŸÅÿ≠Ÿàÿµÿßÿ™ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿäÿ© ŸàŸÑÿß ÿ™ÿ∂ŸÖŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ. ÿ™ÿ≠ŸÇŸÇ ÿØÿßÿ¶ŸÖÿßŸã ÿ®ŸÜŸÅÿ≥ŸÉ.",

        ss_kicker: "SafeSwap Gate",
        ss_title: "ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ÿ≥ÿßÿ≥Ÿäÿßÿ™ ÿßŸÑÿ™ŸàŸÉŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ®ÿßÿØŸÑÿ©",
        ss_sub: "ÿ£ÿØÿÆŸÑ ÿπŸÜŸàÿßŸÜ ÿ™ŸàŸÉŸÜ ÿπŸÑŸâ BSC ŸàŸÜŸÇÿ±ÿ£ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸàÿßŸÑÿ•ÿ¥ÿßÿ±ÿßÿ™ (owner/proxy) Ÿàÿ≥ŸäŸàŸÑÿ© ŸÖÿ™ÿπÿØÿØÿ© DEX ŸàŸÜŸÜÿ¥ÿ¶ ŸÖÿÆÿ±ÿ¨ÿßÿ™ ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉÿ©.",
        ss_input_title: "ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ™ŸàŸÉŸÜ",
        ss_token_label: "ÿπŸÇÿØ ÿßŸÑÿ™ŸàŸÉŸÜ (BSC)",
        ss_tip: "ŸÜÿµŸäÿ≠ÿ©: ÿßŸÅÿ™ÿ≠ ÿßŸÑÿµŸÅÿ≠ÿ© ŸÖÿπ ?token=0x... Ÿàÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑŸÅÿ≠ÿµ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã.",
        ss_actions_label: "ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™",
        ss_scan: "ŸÅÿ≠ÿµ",
        ss_share: "ŸÜÿ≥ÿÆ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉÿ©",
        ss_copy_json: "ŸÜÿ≥ÿÆ ÿ™ŸÇÿ±Ÿäÿ± JSON",
        ss_copy_summary: "ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸÑÿÆÿµ",
        ss_share_x: "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿπŸÑŸâ X",
        ss_options_label: "ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™",
        ss_require_liq: "ÿßÿ¥ÿ™ÿ±ÿßÿ∑ ÿßŸÑÿ≥ŸäŸàŸÑÿ© (Ÿàÿ∂ÿπ ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨)",
        ss_require_liq_tip: "ÿπŸÜÿØ ÿßŸÑÿ™ŸÅÿπŸäŸÑ: ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ Pair Ÿäÿµÿ®ÿ≠ ÿ£ÿ≠ŸÖÿ±. ÿπŸÜÿØ ÿßŸÑÿ™ÿπÿ∑ŸäŸÑ: ŸäŸèÿπÿ™ÿ®ÿ± (ÿ∫Ÿäÿ± ŸÖŸèÿØÿ±ÿ¨ ÿ®ÿπÿØ).",
        ss_open_swap: "ŸÅÿ™ÿ≠ ÿßŸÑŸÖÿ®ÿßÿØŸÑÿ©",
        ss_results_title: "ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨",
        ss_results_hint: "ÿ•ÿ¥ÿßÿ±ÿßÿ™ ÿ£ÿÆÿ∂ÿ±/ÿ£ÿµŸÅÿ±/ÿ£ÿ≠ŸÖÿ±. Ÿáÿ∞ÿß ŸÑŸäÿ≥ ÿ∂ŸÖÿßŸÜÿßŸã ÿ∂ÿØ honeypot ‚Äî ŸÅŸÇÿ∑ ŸÅÿ≠Ÿàÿµÿßÿ™ ÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©.",

        ap_kicker: "ÿ≠ÿßÿ±ÿ≥ ÿßŸÑŸÖŸàÿßŸÅŸÇÿßÿ™",
        ap_title: "ŸÅÿ≠ÿµ Ÿàÿ•ŸÑÿ∫ÿßÿ° ÿ≥ŸÖÿßÿ≠Ÿäÿßÿ™ ERC-20",
        ap_sub: "ÿ£ÿØÿßÿ© ŸÖŸàÿ¨Ÿáÿ©: ÿ™ŸèÿØÿÆŸÑ ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ ŸàÿßŸÑŸÄ spender. ŸÜŸÇÿ±ÿ£ allowance ŸàŸäŸÖŸÉŸÜ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ° ÿπÿ®ÿ± approve(spender, 0).",
        ap_owner: "ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑŸÖÿßŸÑŸÉ",
        ap_connected: "ŸÖÿ™ÿµŸÑ:",
        ap_connect: "ÿßÿ™ÿµÿßŸÑ / ÿ™ÿ≠ÿØŸäÿ´",
        ap_spender_label: "Spender",
        ap_spender_tip: "ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ŸÖÿ™ÿ£ŸÉÿØÿßŸã: ÿßÿ®ÿØÿ£ ÿ®ŸÖŸèÿ≥ÿ®ŸÇ PancakeSwap Router.",
        ap_tokens_label: "ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ (ŸÉŸÑ ÿ≥ÿ∑ÿ± ÿ™ŸàŸÉŸÜ)",
        ap_check: "ŸÅÿ≠ÿµ ÿßŸÑÿ≥ŸÖÿßÿ≠Ÿäÿßÿ™",
        ap_revoke_all: "ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑŸÉŸÑ (ÿ∫Ÿäÿ± ÿµŸÅÿ±)",
        ap_use_scan: "ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ™ŸàŸÉŸÜ ÿßŸÑŸÖŸÅÿ≠Ÿàÿµ",
        ap_add_common: "ÿ£ÿ∂ŸÅ ÿ™ŸàŸÉŸÜÿßÿ™ ÿ¥ÿßÿ¶ÿπÿ©",
        ap_results: "ÿßŸÑÿ≥ŸÖÿßÿ≠Ÿäÿßÿ™",
        ap_results_hint: "ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿ≥ŸÖÿßÿ≠Ÿäÿ© ‚ÄúŸÑÿß ŸÜŸáÿßÿ¶Ÿäÿ©‚Äùÿå ŸäŸàÿµŸâ ÿ®ÿßŸÑÿ•ŸÑÿ∫ÿßÿ° ÿ•ŸÑÿß ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿ´ŸÇ ÿ™ŸÖÿßŸÖÿßŸã ÿ®ÿßŸÑŸÄ spender.",

        bm_kicker: "DEX Guard",
        bm_title: "Bookmarklet ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸá ŸÑŸÑŸÅÿ≠ÿµ",
        bm_sub: "ÿßÿ≠ŸÅÿ∏ Bookmark Ÿäÿ≥ÿ™ÿÆÿ±ÿ¨ ŸÖÿπÿßŸÖŸÑÿßÿ™ ÿßŸÑÿ™ŸàŸÉŸÜ ŸÖŸÜ ÿµŸÅÿ≠ÿßÿ™ DEX ŸàŸäŸÅÿ™ÿ≠ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ±ŸÉÿ≤ ŸÖÿπ ?token=.",
        bm_drag: "ÿßÿ≥ÿ≠ÿ® ÿ•ŸÑŸâ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©",
        bm_drag_tip: "ÿπŸÑŸâ ÿ≥ÿ∑ÿ≠ ÿßŸÑŸÖŸÉÿ™ÿ®: ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿ≤ÿ± ÿ•ŸÑŸâ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©.",
        bm_note: "ŸäÿπŸÖŸÑ ÿ£ŸÅÿ∂ŸÑ ÿπŸÜÿØŸÖÿß Ÿäÿ≠ÿ™ŸàŸä ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿπŸÑŸâ outputCurrency / inputCurrency (ÿ£Ÿà ŸÖÿß ÿ¥ÿßÿ®Ÿá).",
        bm_code: "ŸÉŸàÿØ ÿßŸÑŸÄ Bookmarklet",
        bm_code_tip: "ÿ•ÿ∞ÿß ŸÖŸÜÿπ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ÿßŸÑÿ≥ÿ≠ÿ®ÿå ÿ£ŸÜÿ¥ÿ¶ Bookmark ŸàÿßŸÑÿµŸÇ Ÿáÿ∞ÿß ŸÅŸä ÿÆÿßŸÜÿ© URL:",

        rpc_kicker: "ŸÅÿ≠ÿµ RPC",
        rpc_title: "ÿßÿπÿ´ÿ± ÿπŸÑŸâ ÿ£ÿ≥ÿ±ÿπ RPC ŸäÿπŸÖŸÑ ÿπŸÑŸâ BSC",
        rpc_sub: "ŸÜŸÇŸäÿ≥ ÿ≤ŸÖŸÜ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿπÿ®ÿ± ethers Ÿà eth_blockNumber. ÿßŸÑÿ£ÿ≥ÿ±ÿπ ÿ≥Ÿäÿ∏Ÿáÿ± ŸÖŸÖŸäÿ≤ÿßŸã.",
        rpc_list: "ÿßŸÑŸÜŸÇÿßÿ∑",
        rpc_custom_label: "ÿßÿÆÿ™Ÿäÿßÿ±Ÿä: RPC ŸÖÿÆÿµÿµ",
        rpc_test: "ÿßÿÆÿ™ÿ®ÿßÿ± RPC",
        rpc_copy_best: "ŸÜÿ≥ÿÆ ÿ£ŸÅÿ∂ŸÑ RPC",
        rpc_share_x: "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿπŸÑŸâ X",
        rpc_results: "ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨",
        rpc_tip: "ŸÜÿµŸäÿ≠ÿ©: ÿ•ÿ∞ÿß ŸÅÿ¥ŸÑ RPC ÿ®ÿ≥ÿ®ÿ® CORS/timeout ÿ¨ÿ±Ÿëÿ® ÿ∫Ÿäÿ±Ÿá ‚Äî ŸÑÿØŸäŸÜÿß fallback ÿ£Ÿäÿ∂ÿßŸã.",

        footer_left: "ŸÖÿ±ŸÉÿ≤ ÿ£ŸÖÿßŸÜ CycleX ŸäÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸàŸäŸÇÿ±ÿ£ ÿ®ŸäÿßŸÜÿßÿ™ ÿπÿßŸÖÿ© ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©.",
        footer_tagline: "ÿ™ÿ≠ŸÇŸÇ ŸÖÿ±ÿ™ŸäŸÜ. ŸÑÿß ÿ™ÿ™ÿµŸÑ ÿ•ŸÑÿß ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿ´ŸÇ ÿ®ÿßŸÑÿµŸÅÿ≠ÿ©."
      },
      ru: {
        brand_sub: "–û–Ω—á–µ–π–Ω-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏—è",
        hero_kicker: "–¶–µ–Ω—Ç—Ä –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏",
        hero_title: "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ CycleX",
        hero_subtitle: "–õ—ë–≥–∫–∏–π –Ω–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –≤ –±—Ä–∞—É–∑–µ—Ä–µ: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–¥ —Å–≤–æ–ø–æ–º, –≥–∏–≥–∏–µ–Ω–∞ approvals, DEX-—Ä–µ–¥–∏—Ä–µ–∫—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ RPC.",
        btn_back: "–ù–∞–∑–∞–¥ –Ω–∞ —Å–∞–π—Ç",
        btn_connect: "–ü–æ–¥–∫–ª—é—á–∏—Ç—å –∫–æ—à–µ–ª—ë–∫ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)",
        btn_run_all: "–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞",
        hero_note: "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ—Å—è—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –∏ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å. –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ.",

        ss_kicker: "SafeSwap Gate",
        ss_title: "–ü—Ä–æ–≤–µ—Ä—å —Ç–æ–∫–µ–Ω –ø–µ—Ä–µ–¥ —Å–≤–æ–ø–æ–º",
        ss_sub: "–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞ –≤ BSC. –ú—ã –ø—Ä–æ—á–∏—Ç–∞–µ–º on-chain –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ, owner/proxy –ø–æ–¥—Å–∫–∞–∑–∫–∏ –∏ —Å–∏–≥–Ω–∞–ª—ã –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö DEX ‚Äî –∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∏–º —É–¥–æ–±–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.",
        ss_input_title: "–ê–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞",
        ss_token_label: "–ö–æ–Ω—Ç—Ä–∞–∫—Ç —Ç–æ–∫–µ–Ω–∞ (BSC)",
        ss_tip: "–°–æ–≤–µ—Ç: –æ—Ç–∫—Ä–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å ?token=0x... –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
        ss_actions_label: "–î–µ–π—Å—Ç–≤–∏—è",
        ss_scan: "–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å",
        ss_share: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É",
        ss_copy_json: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å JSON –æ—Ç—á—ë—Ç",
        ss_copy_summary: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫—Ä–∞—Ç–∫–æ",
        ss_share_x: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –≤ X",
        ss_options_label: "–û–ø—Ü–∏–∏",
        ss_require_liq: "–¢—Ä–µ–±–æ–≤–∞—Ç—å –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å (production)",
        ss_require_liq_tip: "–í–∫–ª.: –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ Pair —Å—Ç–∞–Ω–µ—Ç –∫—Ä–∞—Å–Ω—ã–º. –í—ã–∫–ª.: —ç—Ç–æ ‚Äú–µ—â—ë –Ω–µ –∑–∞–ª–∏—Å—Ç–∏–ª–∏‚Äù.",
        ss_open_swap: "–û—Ç–∫—Ä—ã—Ç—å —Å–≤–æ–ø",
        ss_results_title: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã",
        ss_results_hint: "–°–∏–≥–Ω–∞–ª—ã: –∑–µ–ª—ë–Ω—ã–π/–∂—ë–ª—Ç—ã–π/–∫—Ä–∞—Å–Ω—ã–π. –≠—Ç–æ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç honeypot ‚Äî —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ on-chain –ø—Ä–æ–≤–µ—Ä–∫–∏.",

        ap_kicker: "Approvals Guardian",
        ap_title: "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ—Ç–∑—ã–≤ ERC-20 —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π",
        ap_sub: "–¢–æ—á–µ—á–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: –≤—ã –∑–∞–¥–∞—ë—Ç–µ —Ç–æ–∫–µ–Ω—ã –∏ spender. –ú—ã —á–∏—Ç–∞–µ–º allowance –∏ –º–æ–∂–µ–º –æ—Ç–æ–∑–≤–∞—Ç—å —á–µ—Ä–µ–∑ approve(spender, 0).",
        ap_owner: "–ö–æ—à–µ–ª—ë–∫ –≤–ª–∞–¥–µ–ª—å—Ü–∞",
        ap_connected: "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ:",
        ap_connect: "–ü–æ–¥–∫–ª—é—á–∏—Ç—å / –æ–±–Ω–æ–≤–∏—Ç—å",
        ap_spender_label: "Spender",
        ap_spender_tip: "–ï—Å–ª–∏ –Ω–µ —É–≤–µ—Ä–µ–Ω—ã: –Ω–∞—á–Ω–∏—Ç–µ —Å –ø—Ä–µ—Å–µ—Ç–∞ PancakeSwap Router.",
        ap_tokens_label: "–°–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ (–ø–æ –æ–¥–Ω–æ–º—É –≤ —Å—Ç—Ä–æ–∫–µ)",
        ap_check: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å allowance",
        ap_revoke_all: "–û—Ç–æ–∑–≤–∞—Ç—å –≤—Å–µ (–Ω–µ–Ω—É–ª–µ–≤—ã–µ)",
        ap_use_scan: "–ò—Å–ø. –æ—Ç—Å–∫–∞–Ω. —Ç–æ–∫–µ–Ω",
        ap_add_common: "–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ",
        ap_results: "Allowances",
        ap_results_hint: "–ï—Å–ª–∏ allowance ‚Äú–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π‚Äù, –æ—Ç–∑—ã–≤ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è, –µ—Å–ª–∏ –≤—ã –Ω–µ –¥–æ–≤–µ—Ä—è–µ—Ç–µ spender –Ω–∞ 100%.",

        bm_kicker: "DEX Guard",
        bm_title: "Bookmarklet: —Ä–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É",
        bm_sub: "–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –∑–∞–∫–ª–∞–¥–∫—É, –∫–æ—Ç–æ—Ä–∞—è –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ—Ç token-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ DEX URL –∏ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —ç—Ç–æ—Ç —Ü–µ–Ω—Ç—Ä —Å ?token=.",
        bm_drag: "–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –≤ –ø–∞–Ω–µ–ª—å –∑–∞–∫–ª–∞–¥–æ–∫",
        bm_drag_tip: "–ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ: –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –ø–∞–Ω–µ–ª—å –∑–∞–∫–ª–∞–¥–æ–∫.",
        bm_note: "–õ—É—á—à–µ –≤—Å–µ–≥–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –µ—Å–ª–∏ URL —Å–æ–¥–µ—Ä–∂–∏—Ç outputCurrency / inputCurrency (–∏–ª–∏ –ø–æ–¥–æ–±–Ω–æ–µ).",
        bm_code: "–ö–æ–¥ bookmarklet",
        bm_code_tip: "–ï—Å–ª–∏ –±—Ä–∞—É–∑–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç drag&drop ‚Äî —Å–æ–∑–¥–∞–π—Ç–µ –∑–∞–∫–ª–∞–¥–∫—É –∏ –≤—Å—Ç–∞–≤—å—Ç–µ —ç—Ç–æ –≤ –ø–æ–ª–µ URL:",

        rpc_kicker: "RPC Checker",
        rpc_title: "–ù–∞–π–¥–∏—Ç–µ —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π RPC –¥–ª—è BSC",
        rpc_sub: "–ò–∑–º–µ—Ä—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É —á–µ—Ä–µ–∑ ethers –∏ eth_blockNumber. –°–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π –±—É–¥–µ—Ç –ø–æ–¥—Å–≤–µ—á–µ–Ω.",
        rpc_list: "–≠–Ω–¥–ø–æ–∏–Ω—Ç—ã",
        rpc_custom_label: "–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: —Å–≤–æ–π RPC",
        rpc_test: "–¢–µ—Å—Ç RPC",
        rpc_copy_best: "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ª—É—á—à–∏–π RPC",
        rpc_share_x: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –≤ X",
        rpc_results: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã",
        rpc_tip: "–°–æ–≤–µ—Ç: –µ—Å–ª–∏ RPC –ø–∞–¥–∞–µ—Ç –∏–∑-–∑–∞ CORS/timeout ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π, —É –Ω–∞—Å —Ç–∞–∫–∂–µ –µ—Å—Ç—å fallback.",

        footer_left: "CycleX Security Hub —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –∏ —á–∏—Ç–∞–µ—Ç –ø—É–±–ª–∏—á–Ω—ã–µ on-chain –¥–∞–Ω–Ω—ã–µ.",
        footer_tagline: "–ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –¥–≤–∞–∂–¥—ã. –ü–æ–¥–∫–ª—é—á–∞–π—Ç–µ –∫–æ—à–µ–ª—ë–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–æ–≤–µ—Ä—è–µ—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü–µ."
      }
    };

    let CX_LANG = "en";

    function setLanguage(lang) {
      const dict = translations[lang] || translations.en;
      CX_LANG = (translations[lang] ? lang : "en");

      document.body.classList.add("lang-switching");

      document.querySelectorAll("[data-i18n]").forEach((el) => {
        const key = el.getAttribute("data-i18n");
        const val = (dict[key] !== undefined) ? dict[key] : translations.en[key];
        if (val !== undefined) el.innerHTML = val;
      });

      document.querySelectorAll(".lang-btn").forEach((btn) => {
        btn.classList.toggle("active", btn.getAttribute("data-lang") === lang);
      });

      document.documentElement.dir = (lang === "ar") ? "rtl" : "ltr";
      setTimeout(() => document.body.classList.remove("lang-switching"), 250);

      // keep history visible after language switch
      ssRenderHistory();
    }

    document.querySelectorAll(".lang-btn").forEach((btn) => {
      btn.addEventListener("click", () => setLanguage(btn.getAttribute("data-lang")));
    });
    setLanguage("en");

    // ====== Shared helpers ======
    const CX_DEBUG = false;
    function cxlog(...a){ if(CX_DEBUG) console.log(...a); }

    function ga(ev, params){
      try {
        if (typeof gtag === "function") gtag("event", ev, params || {});
      } catch {}
    }

    // More public BSC RPCs (some are more browser-friendly). Source lists include public BSC RPCs. 
    const RPCS_DEFAULT = [
      "https://bsc-rpc.publicnode.com",
      "https://bsc.publicnode.com",
      "https://rpc.ankr.com/bsc",
      "https://1rpc.io/bnb",
      "https://bsc.drpc.org",
      "https://bsc.meowrpc.com",
      "https://bnb.api.onfinality.io/public",
      "https://bsc.blockpi.network/v1/rpc/public",
      "https://bsc-mainnet.public.blastapi.io",
      "https://bsc-dataseed.binance.org",
      "https://bsc-dataseed1.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io"
    ];

    // Core tokens (BSC)
    const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
    const USDT = "0x55d398326f99059fF775485246999027B3197955";
    const USDC = "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d";
    const BUSD = "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56";
    const DEAD = "0x000000000000000000000000000000000000dEaD";
    const ZERO = "0x0000000000000000000000000000000000000000";

    function dexCurrencyParam(addr){
      // Most swap UIs accept "BNB" for native.
      try {
        if (toChecksum(addr) === toChecksum(WBNB)) return "BNB";
      } catch {}
      return addr;
    }

    // DEX Routers (BSC) ‚Äî used for swap links + (best-effort) factory() discovery
    const DEXES = [
      {
        key: "pancake",
        name: "PancakeSwap V2",
        router: "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        swap: (tokenIn, tokenOut) => `https://pancakeswap.finance/swap?inputCurrency=${encodeURIComponent(dexCurrencyParam(tokenIn))}&outputCurrency=${encodeURIComponent(tokenOut)}`
      },
      {
        key: "biswap",
        name: "BiSwap",
        router: "0xE97E2787C9C8d63bFF482Fa3fdc212BbD547aE98",
        swap: (tokenIn, tokenOut) => `https://exchange.biswap.org/swap?inputCurrency=${encodeURIComponent(dexCurrencyParam(tokenIn))}&outputCurrency=${encodeURIComponent(tokenOut)}`
      },
      {
        key: "apeswap",
        name: "ApeSwap",
        router: "0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607",
        swap: (tokenIn, tokenOut) => `https://apeswap.finance/swap?inputCurrency=${encodeURIComponent(dexCurrencyParam(tokenIn))}&outputCurrency=${encodeURIComponent(tokenOut)}`
      },
      {
        key: "mdex",
        name: "MDEX (BSC)",
        router: "0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8",
        swap: (tokenIn, tokenOut) => `https://bscr.mdex.com/#/swap?inputCurrency=${encodeURIComponent(dexCurrencyParam(tokenIn))}&outputCurrency=${encodeURIComponent(tokenOut)}`
      },
      {
        key: "bakery",
        name: "BakerySwap",
        router: "0x824C9364A6CF8f5EB542ad2ca8F5705561C8b1db",
        swap: (tokenIn, tokenOut) => `https://www.bakeryswap.org/#/swap?inputCurrency=${encodeURIComponent(dexCurrencyParam(tokenIn))}&outputCurrency=${encodeURIComponent(tokenOut)}`
      },
      {
        key: "babyswap",
        name: "BabySwap",
        router: "0xC085fDA7Dc3c1A1611f3Ae421e2BD3c75b3a6943",
        swap: (tokenIn, tokenOut) => `https://exchange.babyswap.finance/#/swap?inputCurrency=${encodeURIComponent(dexCurrencyParam(tokenIn))}&outputCurrency=${encodeURIComponent(tokenOut)}`
      }
    ];

    const BASES = [
      { key: "WBNB", name: "WBNB", addr: WBNB, kind: "bnb" },
      { key: "USDT", name: "USDT", addr: USDT, kind: "stable" },
      { key: "USDC", name: "USDC", addr: USDC, kind: "stable" },
      { key: "BUSD", name: "BUSD", addr: BUSD, kind: "stable" }
    ];

    // Pancake factory (for fallback price via WBNB/USDT)
    const PCS_FACTORY = "0xca143ce32fe78f1f7019d7d551a6402fc5350c73";

    // Chainlink BNB/USD feed on BSC
    const CHAINLINK_BNBUSD = "0x0567F2323251f0Aab15c8DfB1967E4e8A7D42aeE";

    let _rpcProvider = null;
    let _rpcUrl = "";
    let _bestRpc = "";
    let ssLastReport = null;
    let ssLastToken = null; // NEW: for approvals fast-fill

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function pickProvider(customList) {
      if (_rpcProvider) return _rpcProvider;

      const list = Array.isArray(customList) && customList.length ? customList : RPCS_DEFAULT;

      for (const url of list) {
        try {
          const p = new ethers.JsonRpcProvider(url);
          const bn = await p.getBlockNumber();
          const net = await p.getNetwork();
          if (Number(net.chainId) !== 56) throw new Error("Wrong chainId");

          _rpcProvider = p;
          _rpcUrl = url;
          cxlog("‚úÖ RPC:", url, "block:", bn);
          return p;
        } catch (e) {
          cxlog("‚ö†Ô∏è RPC fail:", url, e?.message || e);
        }
      }
      throw new Error("All RPCs failed (browser/CORS or provider down)");
    }

    function isHexAddr(x){ return typeof x === "string" && /^0x[0-9a-fA-F]{40}$/.test(x.trim()); }
    function toChecksum(x){ return ethers.getAddress(x.trim()); }

    async function copyText(text){
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        return true;
      }
    }

    function setStatus(el, kind, html){
      el.className = "status " + (kind || "info");
      el.innerHTML = html || "";
      el.style.display = "block";
    }

    function fmtAddr(a){
      try {
        const x = toChecksum(a);
        return x.slice(0, 6) + "‚Ä¶" + x.slice(-4);
      } catch { return a; }
    }

    function fmtBigintUnits(v, decimals){
      try {
        const s = ethers.formatUnits(v, decimals);
        const [i, f=""] = s.split(".");
        const intWithCommas = i.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        const ff = f.slice(0, 6).replace(/0+$/, "");
        return intWithCommas + (ff ? "." + ff : "");
      } catch {
        return String(v);
      }
    }

    function fmtUsd(x){
      if (!Number.isFinite(x)) return "‚Äî";
      if (x >= 1_000_000_000) return "$" + (x/1_000_000_000).toFixed(2) + "B";
      if (x >= 1_000_000) return "$" + (x/1_000_000).toFixed(2) + "M";
      if (x >= 1_000) return "$" + (x/1_000).toFixed(2) + "K";
      return "$" + x.toFixed(2);
    }

    function pctOf(part, total){
      try {
        if (!part || !total || total === 0n) return null;
        return Number((part * 10000n) / total) / 100;
      } catch { return null; }
    }

    // ====== ABIs ======
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)", // NEW
      "function owner() view returns (address)",
      "function getOwner() view returns (address)",
      "function admin() view returns (address)",
    ];

    const FACTORY_ABI = [
      "function getPair(address tokenA, address tokenB) external view returns (address pair)"
    ];

    const ROUTER_ABI = [
      "function factory() view returns (address)",
      "function WETH() view returns (address)"
    ];

    const PAIR_ABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const LP_ABI = [
      "function totalSupply() view returns (uint256)",
      "function balanceOf(address) view returns (uint256)"
    ];

    const CL_ABI = [
      "function decimals() view returns (uint8)",
      "function latestRoundData() view returns (uint80,int256,uint256,uint256,uint80)"
    ];

    // ====== Proxy detection (EIP-1967) ======
    const EIP1967_IMPL_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const EIP1967_ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

    function slotToAddress(storageHex){
      if (!storageHex || storageHex === "0x") return null;
      const h = storageHex.toLowerCase().replace(/^0x/,"").padStart(64,"0");
      const addr = "0x" + h.slice(24);
      if (/^0x0{40}$/.test(addr)) return null;
      try { return toChecksum(addr); } catch { return null; }
    }

    async function detectProxy(provider, token){
      try {
        const implRaw = await provider.getStorage(token, EIP1967_IMPL_SLOT);
        const impl = slotToAddress(implRaw);
        const adminRaw = await provider.getStorage(token, EIP1967_ADMIN_SLOT);
        const admin = slotToAddress(adminRaw);
        if (impl) return { isProxy: true, impl, admin };
        return { isProxy: false, impl: null, admin: admin || null };
      } catch {
        return { isProxy: false, impl: null, admin: null };
      }
    }

    // ====== BNB/USD oracle (Chainlink + fallback) ======
    let _bnbUsdCache = null;

    async function getBnbUsd(provider){
      if (_bnbUsdCache && (Date.now() - _bnbUsdCache.t) < 60_000) return _bnbUsdCache;

      // 1) Chainlink
      try {
        const feed = new ethers.Contract(CHAINLINK_BNBUSD, CL_ABI, provider);
        const dec = Number(await feed.decimals());
        const rd = await feed.latestRoundData();
        const ans = Number(rd[1]);
        if (Number.isFinite(ans) && ans > 0) {
          const px = ans / (10 ** dec);
          _bnbUsdCache = { px, source: "Chainlink", t: Date.now() };
          return _bnbUsdCache;
        }
      } catch {}

      // 2) Fallback: WBNB/USDT reserves on Pancake factory
      try {
        const f = new ethers.Contract(PCS_FACTORY, FACTORY_ABI, provider);
        let pair = await f.getPair(WBNB, USDT);
        pair = toChecksum(String(pair));
        if (pair && !/^0x0{40}$/i.test(pair)) {
          const p = new ethers.Contract(pair, PAIR_ABI, provider);
          const t0 = toChecksum(await p.token0());
          const r = await p.getReserves();
          const r0 = BigInt(r[0]);
          const r1 = BigInt(r[1]);

          const wbnbRes = (t0 === toChecksum(WBNB)) ? r0 : r1;
          const usdtRes = (t0 === toChecksum(WBNB)) ? r1 : r0;

          const wbnbF = Number(ethers.formatUnits(wbnbRes, 18));
          const usdtF = Number(ethers.formatUnits(usdtRes, 18));
          if (wbnbF > 0 && usdtF > 0) {
            const px = usdtF / wbnbF;
            _bnbUsdCache = { px, source: "On-chain (WBNB/USDT)", t: Date.now() };
            return _bnbUsdCache;
          }
        }
      } catch {}

      _bnbUsdCache = { px: NaN, source: "Unavailable", t: Date.now() };
      return _bnbUsdCache;
    }

    // ====== UI init for dropdowns ======
    function initDexBaseDropdowns(){
      const dexSel = document.getElementById("ss-dex-select");
      const baseSel = document.getElementById("ss-base-select");

      dexSel.innerHTML = DEXES.map(d => `<option value="${d.key}">${d.name}</option>`).join("");
      baseSel.innerHTML = BASES.map(b => `<option value="${b.key}">${b.name}</option>`).join("");

      // default: Pancake + WBNB
      dexSel.value = "pancake";
      baseSel.value = "WBNB";
    }

    // ====== SafeSwap V2 scan ======
    async function getDexFactory(provider, dex){
      try {
        const r = new ethers.Contract(dex.router, ROUTER_ABI, provider);
        const f = await r.factory();
        return toChecksum(String(f));
      } catch {
        return null;
      }
    }

    async function scanOnePair(provider, token, base, dex, factoryAddr){
      if (!factoryAddr) return null;

      try {
        const f = new ethers.Contract(factoryAddr, FACTORY_ABI, provider);
        let pair = await f.getPair(token, base.addr);
        pair = toChecksum(String(pair));
        if (/^0x0{40}$/i.test(pair)) return null;

        const p = new ethers.Contract(pair, PAIR_ABI, provider);
        const t0 = toChecksum(await p.token0());
        const r = await p.getReserves();
        const r0 = BigInt(r[0]);
        const r1 = BigInt(r[1]);

        const baseRes = (t0 === toChecksum(base.addr)) ? r0 : r1;
        const tokenRes = (t0 === toChecksum(base.addr)) ? r1 : r0;

        // LP burn basic
        let burnPct = null;
        try {
          const lp = new ethers.Contract(pair, LP_ABI, provider);
          const ts = BigInt(await lp.totalSupply());
          if (ts > 0n) {
            const z = BigInt(await lp.balanceOf(ZERO));
            const d = BigInt(await lp.balanceOf(DEAD));
            const burned = z + d;
            burnPct = Number((burned * 10000n) / ts) / 100; // 2 decimals
          }
        } catch {}

        return {
          dexKey: dex.key,
          dexName: dex.name,
          router: dex.router,
          factory: factoryAddr,
          baseKey: base.key,
          baseName: base.name,
          baseAddr: base.addr,
          pair,
          baseReserve: baseRes,
          tokenReserve: tokenRes,
          burnPct
        };
      } catch {
        return null;
      }
    }

    function ssBuildShareLink(paramsObj){
      const u = new URL(window.location.href);
      ["token","tokenIn","tokenOut","requireLiq","dex","base"].forEach(k => u.searchParams.delete(k));

      if (paramsObj?.token) u.searchParams.set("token", paramsObj.token);
      if (paramsObj?.tokenIn) u.searchParams.set("tokenIn", paramsObj.tokenIn);
      if (paramsObj?.requireLiq) u.searchParams.set("requireLiq", "1");
      if (paramsObj?.dex) u.searchParams.set("dex", paramsObj.dex);
      if (paramsObj?.base) u.searchParams.set("base", paramsObj.base);
      return u.toString();
    }

    function ssRenderLinks(pairs, token, tokenInHint){
      const wrap = document.getElementById("ss-links");
      if (!pairs?.length) {
        wrap.innerHTML = "";
        return;
      }

      const best = pairs[0];
      const tokenIn = tokenInHint && isHexAddr(tokenInHint) ? toChecksum(tokenInHint) : best.baseAddr;

      const btns = pairs.slice(0, 6).map(p => {
        const dex = DEXES.find(d => d.key === p.dexKey);
        const url = dex ? dex.swap(tokenIn, token) : "#";
        const liq = (p.liqUsdApprox != null) ? fmtUsd(p.liqUsdApprox) : "‚Äî";
        const burn = (p.burnPct != null) ? `${p.burnPct.toFixed(2)}%` : "‚Äî";
        return `
          <div class="card" style="padding:12px; margin-top:10px;">
            <div class="row" style="justify-content:space-between; gap:8px;">
              <div class="pill"><b>${p.dexName}</b> ‚Ä¢ ${p.baseName}</div>
              <a class="btn btn-ghost" href="${url}" target="_blank" rel="noopener" style="padding:10px 14px; font-size:12px;">Open Swap</a>
            </div>
            <div class="small" style="margin-top:8px">
              <b>Pair:</b> <span class="mono">${p.pair}</span><br>
              <b>Liquidity (approx):</b> ${liq}<br>
              <b>LP Burn:</b> ${burn}
            </div>
          </div>
        `;
      }).join("");

      wrap.innerHTML = btns;
    }

    // NEW: scan history
    const SS_HISTORY_KEY = "cx_securityhub_history_v1";
    function ssLoadHistory(){
      try {
        const raw = localStorage.getItem(SS_HISTORY_KEY);
        const arr = JSON.parse(raw || "[]");
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }
    function ssSaveToHistory(report){
      try {
        const h = ssLoadHistory();
        const item = {
          token: report.token,
          symbol: report.symbol || "‚Äî",
          score: report.score,
          headline: report.headline,
          ts: Date.now()
        };
        const next = [item, ...h.filter(x => (x?.token || "").toLowerCase() !== item.token.toLowerCase())].slice(0, 10);
        localStorage.setItem(SS_HISTORY_KEY, JSON.stringify(next));
      } catch {}
    }
    function ssRenderHistory(){
      const el = document.getElementById("ss-history");
      if (!el) return;
      const h = ssLoadHistory();
      if (!h.length) { el.innerHTML = ""; return; }

      const rows = h.map(x => {
        const d = new Date(x.ts);
        const when = d.toLocaleString();
        const link = ssBuildShareLink({ token: x.token });
        return `
          <div class="card" style="padding:12px; margin-top:10px;">
            <div class="row" style="justify-content:space-between; gap:8px;">
              <div class="pill"><b>${(x.symbol || "‚Äî")}</b> ‚Ä¢ Score: ${x.score}</div>
              <a class="btn btn-ghost" href="${link}" style="padding:10px 14px; font-size:12px;">Open</a>
            </div>
            <div class="small" style="margin-top:8px">
              <span class="mono">${x.token}</span><br>
              <b>${(x.headline || "")}</b><br>
              <span class="muted">${when}</span>
            </div>
          </div>
        `;
      }).join("");

      el.innerHTML = `
        <div class="small" style="margin-top:10px"><b>Recent scans</b></div>
        ${rows}
      `;
    }

    // NEW: best-effort BscScan verification check (may fail due to CORS)
    async function bsCheckVerified(token){
      try {
        const url = `https://api.bscscan.com/api?module=contract&action=getsourcecode&address=${encodeURIComponent(token)}`;
        const r = await fetch(url, { method: "GET" });
        const j = await r.json();
        const r0 = j?.result?.[0];
        const abi = r0?.ABI;
        if (!abi) return null;
        if (typeof abi === "string" && abi.includes("Contract source code not verified")) return false;
        return true;
      } catch {
        return null; // unknown (CORS)
      }
    }

    function ssSummaryText(report){
      if (!report) return "";
      const best = report.pairs?.[0];
      const liq = (best?.liquidityUsdApprox != null) ? fmtUsd(best.liquidityUsdApprox) : "‚Äî";
      const owner = report.owner ? fmtAddr(report.owner) : "‚Äî";
      const ownRen = (report.ownerRenounced === true) ? "renounced" : (report.ownerRenounced === false ? "not renounced" : "unknown");
      const verified = (report.verified === true) ? "verified" : (report.verified === false ? "not verified" : "unknown");
      return [
        `CycleX Security Hub ‚Äî Token Scan`,
        `Token: ${report.symbol || "‚Äî"} ‚Ä¢ ${report.token}`,
        `Score: ${report.score} (${report.headline})`,
        `Owner: ${owner} ‚Ä¢ ${ownRen} ‚Ä¢ Verified: ${verified}`,
        `Best pair: ${best ? (best.dex + " / " + best.base) : "‚Äî"} ‚Ä¢ Liquidity ~ ${liq}`,
        `Report: ${ssBuildShareLink({ token: report.token, requireLiq: report.requireLiquidity ? 1 : 0 })}`
      ].join("\n");
    }

    function openXShare(text){
      const u = `https://x.com/intent/tweet?text=${encodeURIComponent(text)}`;
      window.open(u, "_blank", "noopener");
    }

    async function ssScanV2() {
      const input = document.getElementById("ss-token");
      const out = document.getElementById("ss-out");
      const status = document.getElementById("ss-status");
      const requireLiq = !!document.getElementById("ss-require-liq").checked;

      let addrRaw = (input.value || "").trim();
      if (!addrRaw) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è Missing token address.</strong><br>Paste a token and try again.");
        return;
      }
      if (!isHexAddr(addrRaw)) {
        setStatus(status, "bad", "<strong>‚ùå Invalid address format.</strong><br>Expected 0x + 40 hex chars.");
        return;
      }
      const token = toChecksum(addrRaw);

      // tokenIn hint from query (DEX Guard)
      let tokenInHint = null;
      try {
        const u = new URL(window.location.href);
        const ti = u.searchParams.get("tokenIn");
        if (ti && isHexAddr(ti)) tokenInHint = toChecksum(ti);
      } catch {}

      // update external links
      document.getElementById("ss-pcs").href = `https://pancakeswap.finance/swap?outputCurrency=${encodeURIComponent(token)}`;
      document.getElementById("ss-bsc").href = `https://bscscan.com/address/${token}`;

      setStatus(status, "info", "<strong>‚è≥ Scanning‚Ä¶</strong><br>Reading metadata, proxy/owner hints, supply distribution, and multi-DEX liquidity.");
      setStatus(out, "info", "<strong>‚è≥ Working‚Ä¶</strong>");
      document.getElementById("ss-links").innerHTML = "";
      ssLastReport = null;

      ga("cx_security_scan_start", { token });

      try {
        const provider = await pickProvider();

        // basic: contract code
        const code = await provider.getCode(token);
        const isContract = code && code !== "0x";
        if (!isContract) {
          setStatus(out, "bad", `<strong>‚ùå Not a contract.</strong><br>${token} has no bytecode on BSC.`);
          setStatus(status, "bad", "<strong>‚ùå Scan finished:</strong> address is not a token contract.");
          return;
        }

        const c = new ethers.Contract(token, ERC20_ABI, provider);

        // metadata (best-effort)
        let name = "‚Äî", symbol = "‚Äî", decimals = 18, supply = 0n;
        try { name = await c.name(); } catch {}
        try { symbol = await c.symbol(); } catch {}
        try { decimals = Number(await c.decimals()); } catch { decimals = 18; }
        try { supply = BigInt(await c.totalSupply()); } catch { supply = 0n; }

        // owner hint (try several patterns)
        let owner = null;
        for (const fn of ["owner", "getOwner", "admin"]) {
          try {
            const o = await c[fn]();
            if (o && isHexAddr(String(o))) { owner = toChecksum(String(o)); break; }
          } catch {}
        }
        const ownerRenounced = owner ? (owner === ZERO) : null;

        // proxy detection
        const proxy = await detectProxy(provider, token);

        // verified on bscscan (best-effort)
        const verified = await bsCheckVerified(token);

        // balances distribution (best-effort)
        let ownerBal = null, contractBal = null, deadBal = null, zeroBal = null;
        try { contractBal = BigInt(await c.balanceOf(token)); } catch {}
        try { deadBal = BigInt(await c.balanceOf(DEAD)); } catch {}
        try { zeroBal = BigInt(await c.balanceOf(ZERO)); } catch {}
        if (owner) { try { ownerBal = BigInt(await c.balanceOf(owner)); } catch {} }

        const ownerPct = (ownerBal != null && supply) ? pctOf(ownerBal, supply) : null;
        const contractPct = (contractBal != null && supply) ? pctOf(contractBal, supply) : null;
        const deadPct = (deadBal != null && supply) ? pctOf(deadBal, supply) : null;

        // multi-DEX / multi-base scan
        const bnbUsd = await getBnbUsd(provider);
        const pairsFound = [];

        for (const dex of DEXES) {
          if (!isHexAddr(dex.router)) continue;

          const factory = await getDexFactory(provider, dex);
          if (!factory) continue;

          for (const base of BASES) {
            const res = await scanOnePair(provider, token, base, dex, factory);
            if (!res) continue;

            let liqUsdApprox = null;
            try {
              const baseAmt = Number(ethers.formatUnits(res.baseReserve, 18));
              if (base.kind === "stable") {
                liqUsdApprox = baseAmt * 2;
              } else if (base.kind === "bnb") {
                liqUsdApprox = (Number.isFinite(bnbUsd.px) ? baseAmt * bnbUsd.px * 2 : null);
              }
            } catch {}

            pairsFound.push({ ...res, liqUsdApprox });
          }
        }

        pairsFound.sort((a,b) => (b.liqUsdApprox || 0) - (a.liqUsdApprox || 0));

        // scoring
        let score = 0;
        const notes = [];

        notes.push(`‚úÖ Contract bytecode found`);

        if (!name || name === "‚Äî") { score += 1; notes.push(`‚ö†Ô∏è Token name unreadable (non-standard)`); }
        if (!symbol || symbol === "‚Äî") { score += 1; notes.push(`‚ö†Ô∏è Symbol unreadable (non-standard)`); }

        if (verified === true) notes.push(`‚úÖ BscScan: source verified`);
        else if (verified === false) { score += 1; notes.push(`‚ö†Ô∏è BscScan: not verified`); }
        else notes.push(`‚ÑπÔ∏è BscScan verification: unknown (CORS/block)`);

        if (proxy?.isProxy && proxy.impl) {
          notes.push(`‚ÑπÔ∏è Proxy detected (EIP-1967). Implementation: ${proxy.impl}`);
          if (proxy.admin) notes.push(`‚ÑπÔ∏è Proxy admin slot: ${proxy.admin}`);
          score += 1;
        }

        if (!owner) {
          score += 1; notes.push(`‚ö†Ô∏è Owner not detectable (may be fine, but less transparent)`);
        } else if (ownerRenounced) {
          notes.push(`‚úÖ Ownership appears renounced (owner=0x0)`);
        } else {
          score += 1;
          notes.push(`‚ö†Ô∏è Owner detected: ${owner} (not renounced)`);
        }

        // distribution signals
        if (ownerPct != null) {
          if (ownerPct >= 20) { score += 3; notes.push(`‚ùå Owner holds ~${ownerPct.toFixed(2)}% of supply (high concentration)`); }
          else if (ownerPct >= 5) { score += 1; notes.push(`‚ö†Ô∏è Owner holds ~${ownerPct.toFixed(2)}% of supply`); }
          else notes.push(`‚úÖ Owner balance concentration: ~${ownerPct.toFixed(2)}%`);
        }
        if (contractPct != null) {
          if (contractPct >= 50) notes.push(`‚ÑπÔ∏è Contract holds ~${contractPct.toFixed(2)}% of supply`);
          else notes.push(`‚ÑπÔ∏è Contract balance: ~${contractPct.toFixed(2)}%`);
        }
        if (deadPct != null && deadPct > 0) notes.push(`‚ÑπÔ∏è Burn/Dead holds ~${deadPct.toFixed(2)}% of supply`);

        if (!pairsFound.length) {
          if (requireLiq) {
            score += 4;
            notes.push(`‚ùå No DEX pair found (require-liquidity enabled)`);
          } else {
            score += 1;
            notes.push(`‚ÑπÔ∏è No DEX pair found (may be ‚ÄúNot listed yet‚Äù)`);
          }
        } else {
          const best = pairsFound[0];
          notes.push(`‚úÖ Best liquidity pair: ${best.dexName} ‚Ä¢ ${best.baseName} ‚Ä¢ ${best.pair}`);

          if (best.liqUsdApprox != null) {
            notes.push(`‚ÑπÔ∏è Liquidity (approx): ${fmtUsd(best.liqUsdApprox)} (method: 2√óbase side)`);
            if (best.baseKey === "WBNB" && Number.isFinite(bnbUsd.px)) {
              notes.push(`‚ÑπÔ∏è BNB/USD: ${bnbUsd.px.toFixed(2)} (${bnbUsd.source})`);
            }
            if (best.liqUsdApprox < 25_000) { score += 2; notes.push(`‚ö†Ô∏è Low liquidity signal (< $25k approx)`); }
          }

          if (best.burnPct != null) {
            if (best.burnPct >= 50) notes.push(`‚úÖ LP burn seems high: ${best.burnPct.toFixed(2)}%`);
            else { score += 1; notes.push(`‚ö†Ô∏è LP burn seems low/unknown: ${best.burnPct.toFixed(2)}%`); }
          }
        }

        let badge = "info";
        let headline = "‚ÑπÔ∏è Informational";
        if (score <= 1) { badge = "ok"; headline = "‚úÖ Looks OK (basic checks)"; }
        else if (score <= 4) { badge = "warn"; headline = "‚ö†Ô∏è Caution (some risk signals)"; }
        else { badge = "bad"; headline = "‚ùå High risk signals"; }

        const supplyHuman = supply ? fmtBigintUnits(supply, decimals) : "‚Äî";

        // build report
        ssLastReport = {
          token,
          name,
          symbol,
          decimals,
          totalSupply: supply ? supply.toString() : null,
          owner: owner || null,
          ownerRenounced: ownerRenounced === null ? null : ownerRenounced,
          verified,
          balances: {
            owner: ownerBal != null ? ownerBal.toString() : null,
            contract: contractBal != null ? contractBal.toString() : null,
            dead: deadBal != null ? deadBal.toString() : null
          },
          pct: {
            owner: ownerPct,
            contract: contractPct,
            dead: deadPct
          },
          proxy,
          requireLiquidity: requireLiq,
          bnbUsd: Number.isFinite(bnbUsd.px) ? { price: bnbUsd.px, source: bnbUsd.source } : null,
          pairs: pairsFound.slice(0, 20).map(p => ({
            dex: p.dexName,
            router: p.router,
            factory: p.factory,
            base: p.baseName,
            baseAddr: p.baseAddr,
            pair: p.pair,
            liquidityUsdApprox: (p.liqUsdApprox != null) ? Number(p.liqUsdApprox) : null,
            lpBurnPct: (p.burnPct != null) ? Number(p.burnPct) : null
          })),
          score,
          headline,
          generatedAt: new Date().toISOString(),
          rpc: _rpcUrl || "auto"
        };

        ssLastToken = token;
        ssSaveToHistory(ssLastReport);
        ssRenderHistory();

        // render main output
        const html = `
          <strong>${headline}</strong><br><br>
          <div class="pill">Token: <span class="mono">${token}</span></div>
          <div style="margin-top:10px" class="small">
            <b>Name:</b> ${String(name).replace(/</g,"&lt;")}<br>
            <b>Symbol:</b> ${String(symbol).replace(/</g,"&lt;")}<br>
            <b>Decimals:</b> ${decimals}<br>
            <b>Total supply:</b> ${supply ? supplyHuman : "‚Äî"}<br>
            <b>Verified:</b> ${verified === true ? "Yes" : (verified === false ? "No" : "Unknown")}
          </div>
          <div style="margin-top:12px" class="small">
            <b>Signals:</b><br>
            ${notes.map(n => "‚Ä¢ " + n).join("<br>")}
          </div>
          <div style="margin-top:12px" class="small">
            <b>Next:</b> Open a DEX only if you trust the token. Consider external audits / community sources.
          </div>
        `;

        setStatus(out, badge, html);
        setStatus(status, badge, `<strong>Done.</strong> Score: ${score} (lower is better). RPC: <span class="mono">${_rpcUrl || "auto"}</span>`);

        // render DEX buttons/cards
        ssRenderLinks(pairsFound, token, tokenInHint);

        ga("cx_security_scan_done", { token, score, badge });

      } catch (e) {
        console.error(e);
        setStatus(out, "bad", `<strong>‚ùå Scan failed.</strong><br>${(e?.message || e || "Unknown error").toString()}`);
        setStatus(status, "bad", "<strong>‚ùå Scan failed.</strong> Try again or test RPCs below.");
        ga("cx_security_scan_fail", { err: String(e?.message || e || "error") });
      }
    }

    async function ssCopyShare() {
      const input = document.getElementById("ss-token");
      const status = document.getElementById("ss-status");
      const raw = (input.value || "").trim();
      if (!raw || !isHexAddr(raw)) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è Paste a valid token address first.</strong>");
        return;
      }
      const token = toChecksum(raw);
      const requireLiq = !!document.getElementById("ss-require-liq").checked;

      let tokenIn = null;
      try {
        const u = new URL(window.location.href);
        const ti = u.searchParams.get("tokenIn");
        if (ti && isHexAddr(ti)) tokenIn = toChecksum(ti);
      } catch {}

      const dex = document.getElementById("ss-dex-select")?.value || "";
      const base = document.getElementById("ss-base-select")?.value || "";

      const link = ssBuildShareLink({ token, tokenIn, requireLiq, dex, base });
      await copyText(link);
      setStatus(status, "ok", `<strong>‚úÖ Share link copied.</strong><br><span class="mono">${link}</span>`);
      ga("cx_security_share_link", { token });
    }

    async function ssCopyJsonReport(){
      const status = document.getElementById("ss-status");
      if (!ssLastReport) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è No report yet.</strong><br>Run Scan first.");
        return;
      }
      const json = JSON.stringify(ssLastReport, null, 2);
      await copyText(json);
      setStatus(status, "ok", "<strong>‚úÖ JSON report copied.</strong>");
      ga("cx_security_copy_json", { token: ssLastReport.token });
    }

    async function ssCopySummary(){
      const status = document.getElementById("ss-status");
      if (!ssLastReport) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è No report yet.</strong><br>Run Scan first.");
        return;
      }
      const txt = ssSummaryText(ssLastReport);
      await copyText(txt);
      setStatus(status, "ok", "<strong>‚úÖ Summary copied.</strong>");
      ga("cx_security_copy_summary", { token: ssLastReport.token });
    }

    async function ssShareX(){
      const status = document.getElementById("ss-status");
      if (!ssLastReport) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è No report yet.</strong><br>Run Scan first.");
        return;
      }
      const txt = ssSummaryText(ssLastReport);
      openXShare(txt);
      setStatus(status, "info", "<strong>Opened X share.</strong>");
      ga("cx_security_share_x", { token: ssLastReport.token });
    }

    async function ssOpenManualSwap(){
      const tokenRaw = (document.getElementById("ss-token").value || "").trim();
      if (!isHexAddr(tokenRaw)) {
        setStatus(document.getElementById("ss-status"), "warn", "<strong>‚ö†Ô∏è Paste a valid token address first.</strong>");
        return;
      }
      const token = toChecksum(tokenRaw);

      const dexKey = document.getElementById("ss-dex-select").value;
      const baseKey = document.getElementById("ss-base-select").value;

      const dex = DEXES.find(d => d.key === dexKey);
      const base = BASES.find(b => b.key === baseKey);

      if (!dex || !base) return;

      let tokenIn = base.addr;
      try {
        const u = new URL(window.location.href);
        const ti = u.searchParams.get("tokenIn");
        if (ti && isHexAddr(ti)) tokenIn = toChecksum(ti);
      } catch {}

      const url = dex.swap(tokenIn, token);
      window.open(url, "_blank", "noopener");
      ga("cx_security_open_swap", { dex: dexKey, base: baseKey });
    }

    function ssAutoFromQuery(){
      try {
        const u = new URL(window.location.href);
        const t = u.searchParams.get("token");
        const req = u.searchParams.get("requireLiq");
        const dex = u.searchParams.get("dex");
        const base = u.searchParams.get("base");

        if (req === "1") document.getElementById("ss-require-liq").checked = true;
        if (dex && document.getElementById("ss-dex-select")) document.getElementById("ss-dex-select").value = dex;
        if (base && document.getElementById("ss-base-select")) document.getElementById("ss-base-select").value = base;

        if (t && isHexAddr(t)) {
          document.getElementById("ss-token").value = toChecksum(t);
          ssScanV2();
        }
      } catch {}
    }

    document.getElementById("ss-scan").addEventListener("click", ssScanV2);
    document.getElementById("ss-share").addEventListener("click", ssCopyShare);
    document.getElementById("ss-copy-json").addEventListener("click", ssCopyJsonReport);
    document.getElementById("ss-copy-summary").addEventListener("click", ssCopySummary);
    document.getElementById("ss-share-x").addEventListener("click", ssShareX);
    document.getElementById("ss-open-manual").addEventListener("click", ssOpenManualSwap);

    // ====== 2) Approvals Guardian ======
    window.cxAppKitModal = null;

    let apSigner = null;
    let apOwner = null;

    const ALLOW_ABI = [
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 value) returns (bool)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    const MAX_UINT = (1n << 256n) - 1n;

    function apSetStatus(kind, html){
      setStatus(document.getElementById("ap-status"), kind, html);
    }

    function apGetSpender(){
      const preset = document.getElementById("ap-spender-preset").value;
      const input = document.getElementById("ap-spender").value.trim();
      if (preset === "pcs_router") return DEXES.find(d=>d.key==="pancake")?.router || input;
      if (preset === "custom") return input;
      return input;
    }

    function apParseTokens(){
      const raw = document.getElementById("ap-tokens").value || "";
      return raw
        .split(/\r?\n/)
        .map(x => x.trim())
        .filter(Boolean)
        .filter(isHexAddr)
        .map(toChecksum);
    }

    function apSetTokensList(tokens){
      const uniq = [...new Set(tokens.map(t => toChecksum(t)))];
      document.getElementById("ap-tokens").value = uniq.join("\n");
    }

    function apAddTokens(tokens){
      const cur = apParseTokens();
      apSetTokensList([...cur, ...tokens]);
    }

    function apRenderRows(rows){
      const table = document.getElementById("ap-table");
      const head = table.querySelector(".trow.head");
      table.innerHTML = "";
      table.appendChild(head);

      if (!rows.length) {
        const row = document.createElement("div");
        row.className = "trow";
        row.innerHTML = `<div class="cell muted">‚Äî</div><div class="cell muted">‚Äî</div><div class="cell muted hide-sm">‚Äî</div><div class="cell muted">‚Äî</div>`;
        table.appendChild(row);
        return;
      }

      for (const r of rows) {
        const row = document.createElement("div");
        row.className = "trow";
        const allowanceStr = r.allowanceInf ? "‚àû (infinite)" : r.allowanceHuman;

        row.innerHTML = `
          <div class="cell mono" title="${r.token}">${r.token}</div>
          <div class="cell">${allowanceStr}</div>
          <div class="cell hide-sm">${r.symbol || "‚Äî"}</div>
          <div class="cell">
            <button class="btn btn-ghost" data-token="${r.token}" ${(!r.canRevoke ? "disabled" : "")} style="padding:10px 14px; font-size:12px;">
              Revoke
            </button>
          </div>
        `;
        table.appendChild(row);
      }

      table.querySelectorAll("button[data-token]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const token = btn.getAttribute("data-token");
          await apRevokeOne(token);
        });
      });
    }

    async function apEnsureConnected() {
      const modal = window.cxAppKitModal;
      if (!modal?.open) {
        apSetStatus("warn", "<strong>‚ö†Ô∏è Wallet modal not ready yet.</strong><br>Wait a second and try again.");
        return false;
      }

      apSetStatus("info", "<strong>‚è≥ Connecting wallet‚Ä¶</strong>");
      await modal.open({ view: "ConnectWallet" });

      const start = Date.now();
      while (Date.now() - start < 90000) {
        const p = modal.getWalletProvider?.();
        if (p) {
          const bp = new ethers.BrowserProvider(p);
          apSigner = await bp.getSigner();
          apOwner = await apSigner.getAddress();
          document.getElementById("ap-address").textContent = apOwner;
          apSetStatus("ok", "<strong>‚úÖ Wallet connected.</strong>");
          ga("cx_security_wallet_connected", {});
          return true;
        }
        await sleep(250);
      }

      apSetStatus("warn", "<strong>‚ö†Ô∏è Connection timeout.</strong><br>Please try again.");
      return false;
    }

    async function apCheck() {
      const ok = apOwner ? true : await apEnsureConnected();
      if (!ok) return;

      const spenderRaw = apGetSpender();
      if (!isHexAddr(spenderRaw)) {
        apSetStatus("bad", "<strong>‚ùå Invalid spender address.</strong>");
        return;
      }
      const spender = toChecksum(spenderRaw);

      const tokens = apParseTokens();
      if (!tokens.length) {
        apSetStatus("warn", "<strong>‚ö†Ô∏è No valid token addresses.</strong><br>Paste at least one token address (one per line).");
        return;
      }

      apSetStatus("info", `<strong>‚è≥ Checking allowances‚Ä¶</strong><br>Owner: <span class="mono">${fmtAddr(apOwner)}</span> ‚Ä¢ Spender: <span class="mono">${fmtAddr(spender)}</span>`);
      ga("cx_security_ap_check", { n: tokens.length });

      const rows = [];
      for (const t of tokens) {
        try {
          const c = new ethers.Contract(t, ALLOW_ABI, apSigner);
          let sym = "‚Äî", dec = 18;
          try { sym = await c.symbol(); } catch {}
          try { dec = Number(await c.decimals()); } catch { dec = 18; }

          const a = BigInt(await c.allowance(apOwner, spender));
          const isInf = (a > (MAX_UINT / 2n));
          const human = isInf ? "‚àû" : (a === 0n ? "0" : fmtBigintUnits(a, dec));

          rows.push({
            token: t,
            symbol: sym,
            allowance: a,
            allowanceInf: isInf,
            allowanceHuman: human,
            canRevoke: (a > 0n)
          });
        } catch {
          rows.push({
            token: t,
            symbol: "‚Äî",
            allowance: 0n,
            allowanceInf: false,
            allowanceHuman: "error",
            canRevoke: false
          });
        }
      }

      apRenderRows(rows);

      const nonZero = rows.filter(r => r.allowance > 0n).length;
      apSetStatus(nonZero ? "warn" : "ok",
        `<strong>Done.</strong><br>Checked ${rows.length} token(s). Non-zero: ${nonZero}.`);
    }

    async function apRevokeOne(tokenAddr) {
      const spenderRaw = apGetSpender();
      if (!apOwner || !apSigner) {
        apSetStatus("warn", "<strong>‚ö†Ô∏è Connect wallet first.</strong>");
        return;
      }
      if (!isHexAddr(spenderRaw)) {
        apSetStatus("bad", "<strong>‚ùå Invalid spender address.</strong>");
        return;
      }
      const spender = toChecksum(spenderRaw);
      const token = toChecksum(tokenAddr);

      apSetStatus("info", `<strong>‚è≥ Revoking‚Ä¶</strong><br>Token: <span class="mono">${fmtAddr(token)}</span> ‚Ä¢ Spender: <span class="mono">${fmtAddr(spender)}</span>`);

      try {
        const c = new ethers.Contract(token, ALLOW_ABI, apSigner);
        const tx = await c.approve(spender, 0);
        apSetStatus("info", `<strong>‚è≥ Pending‚Ä¶</strong><br><span class="mono">${tx.hash}</span>`);
        await tx.wait();
        apSetStatus("ok", "<strong>‚úÖ Revoke successful.</strong>");
        ga("cx_security_ap_revoke_ok", { token });
        await apCheck();
      } catch (e) {
        console.error(e);
        apSetStatus("bad", `<strong>‚ùå Revoke failed.</strong><br>${(e?.message || e).toString()}`);
        ga("cx_security_ap_revoke_fail", { token, err: String(e?.message || e || "error") });
      }
    }

    async function apRevokeAllNonZero() {
      const ok = apOwner ? true : await apEnsureConnected();
      if (!ok) return;

      const tokens = apParseTokens();
      if (!tokens.length) {
        apSetStatus("warn", "<strong>‚ö†Ô∏è No valid token addresses.</strong>");
        return;
      }

      await apCheck();

      const rows = [];
      document.querySelectorAll("#ap-table button[data-token]").forEach(btn => {
        if (!btn.disabled) rows.push(btn.getAttribute("data-token"));
      });

      if (!rows.length) {
        apSetStatus("ok", "<strong>‚úÖ Nothing to revoke.</strong>");
        return;
      }

      apSetStatus("warn", `<strong>‚è≥ Revoking ${rows.length} token(s)‚Ä¶</strong><br>This will send multiple transactions.`);
      for (const t of rows) {
        await apRevokeOne(t);
        await sleep(500);
      }
      apSetStatus("ok", "<strong>‚úÖ Revoke batch finished.</strong>");
    }

    document.getElementById("ap-spender-preset").addEventListener("change", () => {
      const preset = document.getElementById("ap-spender-preset").value;
      const input = document.getElementById("ap-spender");
      if (preset === "pcs_router") {
        input.value = DEXES.find(d=>d.key==="pancake")?.router || "";
        input.disabled = true;
      } else {
        input.value = "";
        input.disabled = false;
      }
    });

    document.getElementById("ap-spender").value = DEXES.find(d=>d.key==="pancake")?.router || "";
    document.getElementById("ap-spender").disabled = true;

    document.getElementById("ap-connect").addEventListener("click", apEnsureConnected);
    document.getElementById("ap-check").addEventListener("click", apCheck);
    document.getElementById("ap-revoke-all").addEventListener("click", apRevokeAllNonZero);

    // NEW: approvals shortcuts
    document.getElementById("ap-use-scan").addEventListener("click", () => {
      if (!ssLastToken || !isHexAddr(ssLastToken)) {
        apSetStatus("warn", "<strong>‚ö†Ô∏è No scanned token yet.</strong><br>Run a token scan first, then use this.");
        return;
      }
      apAddTokens([ssLastToken]);
      apSetStatus("ok", "<strong>‚úÖ Added scanned token to list.</strong>");
      ga("cx_security_ap_use_scan", { token: ssLastToken });
    });

    document.getElementById("ap-add-common").addEventListener("click", () => {
      apAddTokens([WBNB, USDT, USDC, BUSD]);
      apSetStatus("ok", "<strong>‚úÖ Added common tokens (WBNB/USDT/USDC/BUSD).</strong>");
      ga("cx_security_ap_add_common", {});
    });

    // ====== 3) Bookmarklet (multi-DEX param extraction) ======
    function buildSelfBase(){
      const u = new URL(window.location.href);
      u.search = "";
      u.hash = "";
      return u.toString();
    }

    const bookmarklet = `javascript:(function(){try{var u=new URL(location.href);var get=function(k){return u.searchParams.get(k)||'';};var tokenOut=get('outputCurrency')||get('tokenOut')||get('out')||get('currency')||get('address')||get('token')||'';var tokenIn=get('inputCurrency')||get('tokenIn')||get('in')||'';if(!tokenOut){tokenOut=prompt('Paste token address (BSC):');}if(!tokenOut){return;}var dest='${buildSelfBase()}?token='+encodeURIComponent(tokenOut.trim());if(tokenIn){dest += '&tokenIn='+encodeURIComponent(tokenIn.trim());}window.open(dest,'_blank');}catch(e){alert('DEX Guard error: '+e.message);}})();`;

    document.getElementById("bm-link").href = bookmarklet;
    document.getElementById("bm-code").value = bookmarklet;

    // ====== 4) RPC Checker ======
    function rpcRow(url, latency, block, ok, logsOk, errMsg){
      const table = document.getElementById("rpc-table");
      const row = document.createElement("div");
      row.className = "trow";

      const tag = ok
        ? (logsOk ? "‚úÖ OK ‚Ä¢ logs" : "‚úÖ OK ‚Ä¢ no logs")
        : ("‚ùå Fail" + (errMsg ? ` ‚Ä¢ ${errMsg}` : ""));

      const lat = ok ? (latency.toFixed(0) + " ms") : "‚Äî";
      const blockStr = ok ? String(block) : "‚Äî";

      row.innerHTML = `
        <div class="cell mono" title="${url}">${url}</div>
        <div class="cell">${lat}</div>
        <div class="cell hide-sm">${blockStr}</div>
        <div class="cell" title="${(errMsg||"").replace(/"/g,"'")}">${tag}</div>
      `;

      if (ok && url === _bestRpc) {
        row.style.background = "rgba(0,230,118,0.10)";
        row.style.borderTopColor = "rgba(0,230,118,0.20)";
      }

      table.appendChild(row);
    }

    async function rpcTestAll(){
      const status = document.getElementById("rpc-status");
      const custom = (document.getElementById("rpc-custom").value || "").trim();

      const list = [...RPCS_DEFAULT];
      if (custom) list.unshift(custom);

      const table = document.getElementById("rpc-table");
      table.innerHTML = `
        <div class="trow head">
          <div class="cell">RPC</div>
          <div class="cell">Latency</div>
          <div class="cell hide-sm">Block</div>
          <div class="cell">Status</div>
        </div>
      `;

      setStatus(status, "info", `<strong>‚è≥ Testing ${list.length} RPC(s)‚Ä¶</strong><br>Note: some endpoints block browsers (CORS).`);
      _bestRpc = "";
      let bestMs = Infinity;

      ga("cx_security_rpc_test_start", { n: list.length });

      for (const url of list) {
        let ok = false;
        let logsOk = false;
        let ms = 0;
        let block = 0;
        let errMsg = "";

        try {
          const p = new ethers.JsonRpcProvider(url);
          const t0 = performance.now();
          block = await p.getBlockNumber();
          const net = await p.getNetwork();
          const t1 = performance.now();
          ms = (t1 - t0);

          if (Number(net.chainId) !== 56) throw new Error("Wrong chainId");
          ok = true;

          // logs test (light)
          try {
            const filter = { address: WBNB, fromBlock: block, toBlock: block };
            await p.getLogs(filter);
            logsOk = true;
          } catch (e2) {
            logsOk = false;
          }

          if (ms < bestMs) {
            bestMs = ms;
            _bestRpc = url;
          }
        } catch (e) {
          ok = false;
          const m = (e?.message || "").toString();
          errMsg = m.includes("CORS") ? "CORS" :
                   m.includes("Failed to fetch") ? "fetch" :
                   m.includes("timeout") ? "timeout" :
                   m ? m.slice(0, 18) : "";
        }

        rpcRow(url, ms, block, ok, logsOk, errMsg);
        await sleep(90);
      }

      if (_bestRpc) {
        setStatus(status, "ok", `<strong>‚úÖ Best RPC:</strong> <span class="mono">${_bestRpc}</span>`);
        ga("cx_security_rpc_test_done", { best: _bestRpc });
      } else {
        setStatus(status, "bad", "<strong>‚ùå All RPC tests failed.</strong><br>Try a different custom RPC or run from a different network (some RPCs block browsers).");
        ga("cx_security_rpc_test_fail", {});
      }
    }

    async function rpcCopyBest(){
      const status = document.getElementById("rpc-status");
      if (!_bestRpc) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è No best RPC yet.</strong><br>Run Test RPCs first.");
        return;
      }
      await copyText(_bestRpc);
      setStatus(status, "ok", `<strong>‚úÖ Copied:</strong> <span class="mono">${_bestRpc}</span>`);
      ga("cx_security_rpc_copy_best", { best: _bestRpc });
    }

    function rpcShareX(){
      const status = document.getElementById("rpc-status");
      if (!_bestRpc) {
        setStatus(status, "warn", "<strong>‚ö†Ô∏è No best RPC yet.</strong><br>Run Test RPCs first.");
        return;
      }
      const txt = `CycleX Security Hub ‚Äî BSC RPC test\nBest RPC: ${_bestRpc}\n(eth_blockNumber + light logs test)\n${buildSelfBase()}`;
      openXShare(txt);
      setStatus(status, "info", "<strong>Opened X share.</strong>");
      ga("cx_security_rpc_share_x", { best: _bestRpc });
    }

    document.getElementById("rpc-test").addEventListener("click", rpcTestAll);
    document.getElementById("rpc-copy-best").addEventListener("click", rpcCopyBest);
    document.getElementById("rpc-share-x").addEventListener("click", rpcShareX);

    document.getElementById("btn-run-all").addEventListener("click", async () => {
      ga("cx_security_quick_scan", {});
      await ssScanV2();
      await rpcTestAll();
    });

    document.getElementById("btn-connect").addEventListener("click", apEnsureConnected);

    // init dropdowns + autorun + history
    initDexBaseDropdowns();
    ssRenderHistory();
    ssAutoFromQuery();
  </script>

  <!-- AppKit (wallet list) -->
  <script type="module">
    import { createAppKit } from "https://esm.sh/@reown/appkit@1.8.15";
    import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@1.8.15";
    import { bsc } from "https://esm.sh/@reown/appkit/networks";

    const projectId = "7886bcb95105e9e47337cec481d5de75";

    const modal = createAppKit({
      adapters: [new EthersAdapter()],
      networks: [bsc],
      defaultNetwork: bsc,
      projectId,
      analytics: false,
      metadata: {
        name: "CycleX",
        description: "CycleX Security Hub",
        url: window.location.origin,
        icons: [`${window.location.origin}/logo.png`]
      }
    });

    window.cxAppKitModal = modal;
  </script>
</body>
</html>
