<script>
(() => {
  "use strict";

  // =========================
  // i18n
  // =========================
  const translations = {
    en: {
      brand_sub: "On-Chain Security & Rewards",
      hero_kicker: "Security Hub",
      hero_title: "CycleX Security Tools",
      hero_subtitle: "A lightweight, client-side toolkit for safer swaps, approvals hygiene, and RPC health checks across BSC + Ethereum.",
      btn_back: "Back to Site",
      btn_connect: "Connect Wallet (optional)",
      btn_quick: "Run Quick Scan",
      hero_note: "Note: These checks are informational and do not guarantee safety. Always verify independently.",
      tools_kicker: "CHOOSE A TOOL",

      cube_quick_title: "Quick Scan",
      cube_quick_desc: "Fast token sanity-check: contract, metadata, owner/proxy hints, and shareable report.",
      badge_fast: "Fast",
      badge_history: "History",
      badge_share: "Share",

      cube_approvals_title: "Approval Guardian",
      cube_approvals_desc: "Connect wallet, review allowances, and revoke approvals safely.",
      badge_wallet: "Wallet",
      badge_revoke: "Revoke",

      cube_rpc_title: "RPC Health Checker",
      cube_rpc_desc: "Test endpoints, measure latency + chain, and copy the best RPC.",
      badge_table: "Table",
      badge_copy: "Copy",

      cube_monitor_title: "Contract Diff / Upgrade Monitor",
      cube_monitor_desc: "Save contracts locally and detect bytecode changes over time.",
      badge_watch: "Watch",
      badge_local: "Local",
      badge_changes: "Changes",

      p_quick_kicker: "Quick Scan",
      p_quick_title: "Score a token in seconds",
      p_quick_sub: "Paste a token address, choose network, run scan. History is stored locally and you can share results.",
      pill_wallet: "Wallet",
      btn_close: "Close",
      quick_input_title: "Token Input",
      net_label: "Network",
      addr_label: "Token contract",
      qs_tip: "Tip: open with ?tool=quick&net=bsc&token=0x... to auto-run.",
      options_label: "Options",
      opt_require_liq: "Require liquidity (stricter score)",
      opt_show_json: "Enable JSON report (copy)",
      btn_scan: "Scan",
      btn_copy_link: "Copy Share Link",
      btn_copy_json: "Copy JSON",
      history_label: "History",
      history_tip: "Click an item to re-run quickly. Stored locally only.",
      results_title: "Results",
      results_hint: "Green / Yellow / Red signals. Not a guarantee — just verifiable on-chain checks.",

      p_app_kicker: "Approval Guardian",
      p_app_title: "Check and revoke allowances",
      p_app_sub: "Provide spender + tokens (or seed common tokens). We read allowance(owner, spender) and revoke with approve(spender, 0).",
      ap_settings_title: "Settings",
      ap_connected: "Connected:",
      ap_connect: "Connect / Refresh",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "Start with a router preset, then add tokens you want to clean up.",
      ap_tokens_label: "Token list (one per line)",
      ap_seed: "Seed common tokens",
      ap_seed_history: "Use scan history",
      ap_check: "Check Allowances",
      ap_revoke_all: "Revoke All (non-zero)",
      ap_results: "Allowances",
      ap_results_hint: "If allowance is “infinite”, revoke is recommended unless you fully trust the spender.",

      p_rpc_kicker: "RPC Health Checker",
      p_rpc_title: "Find the best endpoint",
      p_rpc_sub: "We test RPC endpoints with eth_blockNumber and measure latency. Best result is highlighted and ready to copy.",
      rpc_inputs: "Inputs",
      rpc_custom_label: "Optional custom RPC (top priority)",
      rpc_test: "Test RPCs",
      rpc_copy_best: "Copy Best RPC",
      rpc_results: "Results",
      rpc_tip: "Tip: Some RPCs fail due to CORS/timeouts. Run the test and pick the stable fastest.",

      p_mon_kicker: "Contract Monitor",
      p_mon_title: "Detect upgrades & bytecode changes",
      p_mon_sub: "Save contracts locally. We store code hash + proxy implementation. Re-check later to detect changes.",
      mon_add_title: "Add to watchlist",
      mon_add: "Add",
      mon_check: "Check all",
      mon_export: "Export JSON",
      mon_list_title: "Watchlist",
      mon_list_hint: "Stored locally only. No server tracking.",

      footer_left: "CycleX Security Hub runs client-side and reads public on-chain data.",
      footer_tagline: "Verify twice. Connect only when you trust the page."
    },

    zh: {
      brand_sub: "链上安全与奖励",
      hero_kicker: "安全中心",
      hero_title: "CycleX 安全工具",
      hero_subtitle: "轻量级客户端工具：更安全的 Swap、授权管理与 RPC 健康检查（BSC + 以太坊）。",
      btn_back: "返回主站",
      btn_connect: "连接钱包（可选）",
      btn_quick: "运行快速扫描",
      hero_note: "提示：这些检查仅供参考，不保证安全，请务必自行二次验证。",
      tools_kicker: "选择工具",

      cube_quick_title: "快速扫描",
      cube_quick_desc: "快速基础检查：合约、元数据、owner/proxy 线索，可生成分享报告。",
      badge_fast: "快速",
      badge_history: "历史",
      badge_share: "分享",

      cube_approvals_title: "授权守卫",
      cube_approvals_desc: "连接钱包，查看 allowance，并安全撤销授权。",
      badge_wallet: "钱包",
      badge_revoke: "撤销",

      cube_rpc_title: "RPC 健康检查",
      cube_rpc_desc: "测试节点、测延迟与链信息，一键复制最佳 RPC。",
      badge_table: "表格",
      badge_copy: "复制",

      cube_monitor_title: "合约变更监控",
      cube_monitor_desc: "本地保存并检测字节码变化（信息性质）。",
      badge_watch: "监控",
      badge_local: "本地",
      badge_changes: "变化",

      p_quick_kicker: "快速扫描",
      p_quick_title: "几秒内给代币打分",
      p_quick_sub: "粘贴代币地址，选择网络，运行扫描。历史仅保存在本地，可分享结果。",
      pill_wallet: "钱包",
      btn_close: "关闭",
      quick_input_title: "代币输入",
      net_label: "网络",
      addr_label: "代币合约",
      qs_tip: "提示：使用 ?tool=quick&net=bsc&token=0x... 打开可自动运行。",
      options_label: "选项",
      opt_require_liq: "要求流动性（更严格）",
      opt_show_json: "启用 JSON 报告（复制）",
      btn_scan: "扫描",
      btn_copy_link: "复制分享链接",
      btn_copy_json: "复制 JSON",
      history_label: "历史",
      history_tip: "点击即可快速重跑。仅本地存储。",
      results_title: "结果",
      results_hint: "绿/黄/红信号。非保证—仅可链上验证的检查。",

      p_app_kicker: "授权守卫",
      p_app_title: "检查并撤销授权",
      p_app_sub: "输入 spender + 代币（或一键填充常用代币）。读取 allowance(owner, spender)，并用 approve(spender, 0) 撤销。",
      ap_settings_title: "设置",
      ap_connected: "已连接：",
      ap_connect: "连接 / 刷新",
      ap_spender_label: "Spender 预设",
      ap_spender_tip: "先选路由预设，然后添加要清理的代币。",
      ap_tokens_label: "代币列表（每行一个）",
      ap_seed: "填充常用代币",
      ap_seed_history: "使用扫描历史",
      ap_check: "检查授权",
      ap_revoke_all: "撤销全部（非零）",
      ap_results: "授权结果",
      ap_results_hint: "若授权为“无限”，除非完全信任，否则建议撤销。",

      p_rpc_kicker: "RPC 健康检查",
      p_rpc_title: "找到最佳节点",
      p_rpc_sub: "用 eth_blockNumber 测延迟。最佳结果会高亮，可一键复制。",
      rpc_inputs: "输入",
      rpc_custom_label: "可选：自定义 RPC（优先）",
      rpc_test: "测试 RPC",
      rpc_copy_best: "复制最佳 RPC",
      rpc_results: "结果",
      rpc_tip: "提示：部分 RPC 可能因 CORS/超时失败。测试后选择稳定且最快的。",

      p_mon_kicker: "合约监控",
      p_mon_title: "检测升级与字节码变化",
      p_mon_sub: "本地保存合约并定期复查以发现变化。",
      mon_add_title: "添加到监控列表",
      mon_add: "添加",
      mon_check: "检查全部",
      mon_export: "导出 JSON",
      mon_list_title: "监控列表",
      mon_list_hint: "仅本地存储，不做服务器跟踪。",

      footer_left: "CycleX 安全中心在本地运行，读取公开链上数据。",
      footer_tagline: "多验证一次，只在你信任时连接钱包。"
    },

    ar: {
      brand_sub: "أمن ومكافآت على السلسلة",
      hero_kicker: "مركز الأمان",
      hero_title: "أدوات أمان CycleX",
      hero_subtitle: "أدوات خفيفة على المتصفح لفحص أمان التوكنات والموافقات وقياس صحة RPC (BSC + Ethereum).",
      btn_back: "العودة للموقع",
      btn_connect: "اتصال المحفظة (اختياري)",
      btn_quick: "فحص سريع",
      hero_note: "ملاحظة: هذه الفحوصات معلوماتية ولا تضمن الأمان. تحقق دائماً بنفسك.",
      tools_kicker: "اختر أداة",

      cube_quick_title: "فحص سريع",
      cube_quick_desc: "فحص أساسي سريع: العقد، البيانات، إشارات owner/proxy وتقرير قابل للمشاركة.",
      badge_fast: "سريع",
      badge_history: "سجل",
      badge_share: "مشاركة",

      cube_approvals_title: "حارس الموافقات",
      cube_approvals_desc: "اتصل بالمحفظة وراجع/ألغِ الموافقات بأمان.",
      badge_wallet: "محفظة",
      badge_revoke: "إلغاء",

      cube_rpc_title: "فحص RPC",
      cube_rpc_desc: "اختبر النقاط، قِس التأخير، وانسخ أفضل RPC.",
      badge_table: "جدول",
      badge_copy: "نسخ",

      cube_monitor_title: "مراقبة تغيّر العقد",
      cube_monitor_desc: "حفظ محلي وكشف تغيّر البايت كود مع الوقت.",
      badge_watch: "مراقبة",
      badge_local: "محلي",
      badge_changes: "تغييرات",

      p_quick_kicker: "فحص سريع",
      p_quick_title: "قيّم التوكن خلال ثوانٍ",
      p_quick_sub: "الصق عنوان التوكن، اختر الشبكة، شغّل الفحص. السجل محلي ويمكن مشاركة النتائج.",
      pill_wallet: "محفظة",
      btn_close: "إغلاق",
      quick_input_title: "إدخال التوكن",
      net_label: "الشبكة",
      addr_label: "عقد التوكن",
      qs_tip: "نصيحة: افتح بـ ?tool=quick&net=bsc&token=0x... للتشغيل التلقائي.",
      options_label: "الخيارات",
      opt_require_liq: "اشتراط السيولة (أكثر صرامة)",
      opt_show_json: "تفعيل تقرير JSON (نسخ)",
      btn_scan: "فحص",
      btn_copy_link: "نسخ رابط",
      btn_copy_json: "نسخ JSON",
      history_label: "السجل",
      history_tip: "اضغط لإعادة الفحص بسرعة. التخزين محلي فقط.",
      results_title: "النتائج",
      results_hint: "إشارات خضراء/صفراء/حمراء. ليست ضماناً — فحوصات قابلة للتحقق on-chain.",

      p_app_kicker: "حارس الموافقات",
      p_app_title: "فحص وإلغاء الموافقات",
      p_app_sub: "أدخل spender + توكنات (أو أضف الشائعة). نقرأ allowance(owner, spender) ونلغي عبر approve(spender, 0).",
      ap_settings_title: "إعدادات",
      ap_connected: "متصل:",
      ap_connect: "اتصال / تحديث",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "ابدأ بمُسبق الراوتر ثم أضف التوكنات التي تريد تنظيفها.",
      ap_tokens_label: "قائمة التوكنات (كل سطر توكن)",
      ap_seed: "إضافة توكنات شائعة",
      ap_seed_history: "استخدام سجل الفحص",
      ap_check: "فحص Allowances",
      ap_revoke_all: "إلغاء الكل (غير صفر)",
      ap_results: "Allowances",
      ap_results_hint: "إذا كانت “لا نهائية”، يوصى بالإلغاء إلا إذا كنت تثق تماماً.",

      p_rpc_kicker: "فحص RPC",
      p_rpc_title: "اعثر على أفضل نقطة",
      p_rpc_sub: "نقيس التأخير عبر eth_blockNumber. الأفضل سيظهر مميزاً ويمكن نسخه.",
      rpc_inputs: "المدخلات",
      rpc_custom_label: "اختياري: RPC مخصص (أولوية)",
      rpc_test: "اختبار RPC",
      rpc_copy_best: "نسخ أفضل RPC",
      rpc_results: "النتائج",
      rpc_tip: "قد تفشل بعض RPC بسبب CORS/timeout. اختبر واختر الأكثر استقراراً.",

      p_mon_kicker: "مراقبة العقد",
      p_mon_title: "كشف الترقيات وتغيّر البايت كود",
      p_mon_sub: "احفظ محلياً وأعد الفحص لاحقاً لاكتشاف التغييرات.",
      mon_add_title: "إضافة للمراقبة",
      mon_add: "إضافة",
      mon_check: "فحص الكل",
      mon_export: "تصدير JSON",
      mon_list_title: "قائمة المراقبة",
      mon_list_hint: "محلي فقط. لا يوجد تتبع سيرفر.",

      footer_left: "مركز أمان CycleX يعمل على المتصفح ويقرأ بيانات عامة على السلسلة.",
      footer_tagline: "تحقق مرتين. لا تتصل إلا إذا كنت تثق بالصفحة."
    },

    ru: {
      brand_sub: "Ончейн-безопасность и вознаграждения",
      hero_kicker: "Центр безопасности",
      hero_title: "Инструменты безопасности CycleX",
      hero_subtitle: "Лёгкий набор инструментов в браузере: проверка токенов, approvals и здоровье RPC (BSC + Ethereum).",
      btn_back: "Назад на сайт",
      btn_connect: "Подключить кошелёк (опционально)",
      btn_quick: "Быстрая проверка",
      hero_note: "Проверки информационные и не гарантируют безопасность. Всегда перепроверяйте.",
      tools_kicker: "ВЫБЕРИТЕ ИНСТРУМЕНТ",

      cube_quick_title: "Quick Scan",
      cube_quick_desc: "Быстрая проверка: контракт, метаданные, owner/proxy подсказки и отчёт для шаринга.",
      badge_fast: "Быстро",
      badge_history: "История",
      badge_share: "Шаринг",

      cube_approvals_title: "Approvals Guardian",
      cube_approvals_desc: "Подключите кошелёк, проверьте allowances и отзовите approvals.",
      badge_wallet: "Кошелёк",
      badge_revoke: "Отозвать",

      cube_rpc_title: "RPC Health Checker",
      cube_rpc_desc: "Тест RPC, замер задержки и копирование лучшего RPC.",
      badge_table: "Таблица",
      badge_copy: "Копировать",

      cube_monitor_title: "Мониторинг контрактов",
      cube_monitor_desc: "Локально сохраняйте и отслеживайте изменения байткода со временем.",
      badge_watch: "Следить",
      badge_local: "Локально",
      badge_changes: "Изменения",

      p_quick_kicker: "Quick Scan",
      p_quick_title: "Оцените токен за секунды",
      p_quick_sub: "Вставьте адрес токена, выберите сеть и запустите проверку. История хранится локально; можно делиться результатами.",
      pill_wallet: "Кошелёк",
      btn_close: "Закрыть",
      quick_input_title: "Ввод токена",
      net_label: "Сеть",
      addr_label: "Контракт токена",
      qs_tip: "Совет: откройте с ?tool=quick&net=bsc&token=0x... для авто-запуска.",
      options_label: "Опции",
      opt_require_liq: "Требовать ликвидность (строже)",
      opt_show_json: "Включить JSON отчёт (копировать)",
      btn_scan: "Сканировать",
      btn_copy_link: "Копировать ссылку",
      btn_copy_json: "Копировать JSON",
      history_label: "История",
      history_tip: "Кликните элемент, чтобы быстро повторить. Только локально.",
      results_title: "Результаты",
      results_hint: "Зелёные/жёлтые/красные сигналы. Не гарантия — проверяемые on-chain проверки.",

      p_app_kicker: "Approvals Guardian",
      p_app_title: "Проверка и отзыв allowances",
      p_app_sub: "Укажите spender + токены (или добавьте популярные). Читаем allowance(owner, spender) и отзываем approve(spender, 0).",
      ap_settings_title: "Настройки",
      ap_connected: "Подключено:",
      ap_connect: "Подключить / обновить",
      ap_spender_label: "Spender preset",
      ap_spender_tip: "Начните с пресета роутера, затем добавьте токены для очистки.",
      ap_tokens_label: "Список токенов (по одному в строке)",
      ap_seed: "Добавить популярные токены",
      ap_seed_history: "Использовать историю",
      ap_check: "Проверить allowances",
      ap_revoke_all: "Отозвать все (ненулевые)",
      ap_results: "Allowances",
      ap_results_hint: "Если allowance “бесконечный”, отзыв рекомендуется, если вы не доверяете на 100%.",

      p_rpc_kicker: "RPC Health Checker",
      p_rpc_title: "Найдите лучший RPC",
      p_rpc_sub: "Тестируем eth_blockNumber и замеряем задержку. Лучший подсвечен и готов к копированию.",
      rpc_inputs: "Ввод",
      rpc_custom_label: "Опционально: свой RPC (в приоритете)",
      rpc_test: "Тест RPC",
      rpc_copy_best: "Копировать лучший RPC",
      rpc_results: "Результаты",
      rpc_tip: "Некоторые RPC падают из-за CORS/таймаутов. Тестируйте и выбирайте стабильный.",

      p_mon_kicker: "Мониторинг",
      p_mon_title: "Отслеживание апгрейдов и изменений байткода",
      p_mon_sub: "Сохраняйте локально и проверяйте позже, чтобы увидеть изменения.",
      mon_add_title: "Добавить в список",
      mon_add: "Добавить",
      mon_check: "Проверить все",
      mon_export: "Экспорт JSON",
      mon_list_title: "Список",
      mon_list_hint: "Только локально. Без серверного трекинга.",

      footer_left: "CycleX Security Hub работает на клиенте и читает публичные on-chain данные.",
      footer_tagline: "Проверяйте дважды. Подключайте кошелёк только если доверяете странице."
    }
  };

  function setLanguage(lang) {
    const dict = translations[lang] || translations.en;

    localStorage.setItem("cx_lang", lang);
    document.documentElement.lang = lang;
    document.documentElement.dir = (lang === "ar") ? "rtl" : "ltr";

    document.body.classList.add("lang-switching");

    document.querySelectorAll("[data-i18n]").forEach((el) => {
      const key = el.getAttribute("data-i18n");
      const val = (dict[key] !== undefined) ? dict[key] : translations.en[key];
      if (val !== undefined) el.innerHTML = val;
    });

    document.querySelectorAll(".lang-btn").forEach((btn) => {
      btn.classList.toggle("active", btn.getAttribute("data-lang") === lang);
    });

    setTimeout(() => document.body.classList.remove("lang-switching"), 250);
  }

  // Bind language buttons
  document.querySelectorAll(".lang-btn").forEach((btn) => {
    btn.addEventListener("click", () => setLanguage(btn.getAttribute("data-lang")));
  });

  // Init language
  setLanguage(localStorage.getItem("cx_lang") || "en");

  // ===============================
  // Shared helpers / state
  // ===============================
  const CX_DEBUG = false;
  function cxlog(...a){ if(CX_DEBUG) console.log(...a); }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  function isHexAddr(x){ return typeof x === "string" && /^0x[0-9a-fA-F]{40}$/.test(x.trim()); }
  function toChecksum(x){ return ethers.getAddress(x.trim()); }

  async function copyText(text){
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      return true;
    }
  }

  function setStatus(el, kind, html){
    if (!el) return;
    el.className = "status " + (kind || "info");
    el.innerHTML = html || "";
    el.style.display = "block";
  }

  function fmtAddr(a){
    try {
      const x = toChecksum(a);
      return x.slice(0, 6) + "…" + x.slice(-4);
    } catch { return a; }
  }

  function fmtBigintUnits(v, decimals){
    try {
      const s = ethers.formatUnits(v, decimals);
      const [i, f=""] = s.split(".");
      const intWithCommas = i.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      const ff = f.slice(0, 6).replace(/0+$/, "");
      return intWithCommas + (ff ? "." + ff : "");
    } catch {
      return String(v);
    }
  }

  function fmtUsd(x){
    if (!Number.isFinite(x)) return "—";
    if (x >= 1_000_000_000) return "$" + (x/1_000_000_000).toFixed(2) + "B";
    if (x >= 1_000_000) return "$" + (x/1_000_000).toFixed(2) + "M";
    if (x >= 1_000) return "$" + (x/1_000).toFixed(2) + "K";
    return "$" + x.toFixed(2);
  }

  const CX = {
    reports: { quick: null },
    providers: { bsc: null, eth: null },
    rpc: { best: "", last: [] },
    wallet: { signer: null, address: null, provider: null },
    monitor: { list: [] }
  };

  // ===============================
  // WalletConnect (Reown AppKit) — init
  // ===============================
  const WALLETCONNECT_PROJECT_ID = "PASTE_YOUR_WC_PROJECT_ID_HERE"; // <-- תדביק פה את ה-Project ID

  function initAppKit(){
    try {
      const AppKit = window.AppKit || window.appKit || window.appkit;
      const AdapterPkg = window.AppKitAdapterEthers || window.AppKitAdapterEthers || window.appKitAdapterEthers;

      const createAppKit = AppKit?.createAppKit || AppKit?.default?.createAppKit;
      const EthersAdapter = AdapterPkg?.EthersAdapter || AdapterPkg?.default?.EthersAdapter;

      if (!createAppKit || !EthersAdapter) {
        console.warn("AppKit not available (scripts not loaded?)");
        return null;
      }

      // Prefer built-in networks if available
      const nets = [];
      if (AppKit?.networks?.bsc) nets.push(AppKit.networks.bsc);
      if (AppKit?.networks?.mainnet) nets.push(AppKit.networks.mainnet);

      // Fallback networks (wagmi-like shape)
      if (!nets.length) {
        nets.push({
          id: 56,
          name: "BNB Smart Chain",
          nativeCurrency: { name:"BNB", symbol:"BNB", decimals:18 },
          rpcUrls: { default: { http: ["https://bsc-dataseed.binance.org"] } },
          blockExplorers: { default: { name:"BscScan", url:"https://bscscan.com" } }
        });
        nets.push({
          id: 1,
          name: "Ethereum",
          nativeCurrency: { name:"Ether", symbol:"ETH", decimals:18 },
          rpcUrls: { default: { http: ["https://cloudflare-eth.com"] } },
          blockExplorers: { default: { name:"Etherscan", url:"https://etherscan.io" } }
        });
      }

      const metadata = {
        name: "CycleX Security Hub",
        description: "Client-side security tools + approvals guardian + RPC checker",
        url: window.location.origin,
        icons: [window.location.origin + "/logo.png"]
      };

      const modal = createAppKit({
        projectId: WALLETCONNECT_PROJECT_ID,
        metadata,
        networks: nets,
        adapters: [new EthersAdapter()],
      });

      window.cxAppKitModal = modal;
      return modal;
    } catch (e) {
      console.warn("initAppKit failed:", e);
      return null;
    }
  }

  // Create modal now (safe even if projectId is placeholder; connect will warn)
  initAppKit();

  // ===============================
  // RPC lists
  // ===============================
  const RPCS = {
    bsc: [
      "https://bsc-dataseed.binance.org",
      "https://bsc-dataseed1.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed1.defibit.io",
    ],
    eth: [
      "https://cloudflare-eth.com",
      "https://rpc.ankr.com/eth",
      "https://ethereum.publicnode.com"
    ]
  };

  async function pickProvider(net, customList){
    if (CX.providers[net]) return CX.providers[net];

    const list = (Array.isArray(customList) && customList.length) ? customList : (RPCS[net] || []);
    const expectChainId = (net === "bsc") ? 56 : 1;

    for (const url of list) {
      try {
        const p = new ethers.JsonRpcProvider(url);
        const bn = await p.getBlockNumber();
        const n = await p.getNetwork();
        if (Number(n.chainId) !== expectChainId) throw new Error("Wrong chainId");
        CX.providers[net] = p;
        cxlog("✅ Provider", net, url, "block", bn);
        return p;
      } catch (e) {
        cxlog("⚠️ Provider fail", net, url, e?.message || e);
      }
    }
    throw new Error(`All ${net.toUpperCase()} RPCs failed (CORS/timeout/blocked)`);
  }

  // ===============================
  // DEX + bases (BSC only for liquidity checks)
  // ===============================
  const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
  const USDT = "0x55d398326f99059fF775485246999027B3197955";
  const USDC = "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d";
  const BUSD = "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56";

  const DEXES_BSC = [
    { key:"pancake",  name:"PancakeSwap V2", router:"0x10ED43C718714eb63d5aA57B78B54704E256024E", swap:(tin,tout)=>`https://pancakeswap.finance/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"apeswap",  name:"ApeSwap",        router:"0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607", swap:(tin,tout)=>`https://apeswap.finance/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"biswap",   name:"BiSwap",         router:"0xE97E2787C9C8d63bFF482Fa3fdc212BbD547aE98", swap:(tin,tout)=>`https://exchange.biswap.org/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"mdex",     name:"MDEX (BSC)",     router:"0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8", swap:(tin,tout)=>`https://bscr.mdex.com/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"bakery",   name:"BakerySwap",     router:"0x824C9364A6CF8f5EB542ad2ca8F5705561C8b1db", swap:(tin,tout)=>`https://www.bakeryswap.org/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
    { key:"babyswap", name:"BabySwap",       router:"0xC085fDA7Dc3c1A1611f3Ae421e2BD3c75b3a6943", swap:(tin,tout)=>`https://exchange.babyswap.finance/#/swap?inputCurrency=${tin}&outputCurrency=${tout}` },
  ];

  const BASES_BSC = [
    { key:"WBNB", name:"WBNB", addr:WBNB, kind:"bnb" },
    { key:"USDT", name:"USDT", addr:USDT, kind:"stable" },
    { key:"USDC", name:"USDC", addr:USDC, kind:"stable" },
    { key:"BUSD", name:"BUSD", addr:BUSD, kind:"stable" }
  ];

  // ===============================
  // ABIs
  // ===============================
  const ERC20_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)",
    "function owner() view returns (address)",
    "function getOwner() view returns (address)",
    "function admin() view returns (address)",
  ];

  const FACTORY_ABI = [ "function getPair(address tokenA, address tokenB) external view returns (address pair)" ];
  const ROUTER_ABI  = [ "function factory() view returns (address)" ];
  const PAIR_ABI    = [ "function token0() view returns (address)", "function token1() view returns (address)", "function getReserves() view returns (uint112,uint112,uint32)" ];
  const LP_ABI      = [ "function totalSupply() view returns (uint256)", "function balanceOf(address) view returns (uint256)" ];

  const CL_ABI = [
    "function decimals() view returns (uint8)",
    "function latestRoundData() view returns (uint80,int256,uint256,uint256,uint80)"
  ];

  // ===============================
  // Proxy detection (EIP-1967)
  // ===============================
  const EIP1967_IMPL_SLOT  = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
  const EIP1967_ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

  function slotToAddress(storageHex){
    if (!storageHex || storageHex === "0x") return null;
    const h = storageHex.toLowerCase().replace(/^0x/,"").padStart(64,"0");
    const addr = "0x" + h.slice(24);
    if (/^0x0{40}$/.test(addr)) return null;
    try { return toChecksum(addr); } catch { return null; }
  }

  async function detectProxy(provider, addr){
    try {
      const implRaw = await provider.getStorage(addr, EIP1967_IMPL_SLOT);
      const impl = slotToAddress(implRaw);
      const adminRaw = await provider.getStorage(addr, EIP1967_ADMIN_SLOT);
      const admin = slotToAddress(adminRaw);
      if (impl) return { isProxy: true, impl, admin };
      return { isProxy: false, impl: null, admin: admin || null };
    } catch {
      return { isProxy: false, impl: null, admin: null };
    }
  }

  // ===============================
  // BNB/USD oracle (BSC)
  // ===============================
  const PCS_FACTORY = "0xca143ce32fe78f1f7019d7d551a6402fc5350c73";
  const CHAINLINK_BNBUSD = "0x0567F2323251f0Aab15c8DfB1967E4e8A7D42aeE";
  let _bnbUsdCache = null;

  async function getBnbUsd(provider){
    if (_bnbUsdCache && (Date.now() - _bnbUsdCache.t) < 60_000) return _bnbUsdCache;

    // 1) Chainlink
    try {
      const feed = new ethers.Contract(CHAINLINK_BNBUSD, CL_ABI, provider);
      const dec = Number(await feed.decimals());
      const rd = await feed.latestRoundData();
      const ans = Number(rd[1]);
      if (Number.isFinite(ans) && ans > 0) {
        const px = ans / (10 ** dec);
        _bnbUsdCache = { px, source: "Chainlink", t: Date.now() };
        return _bnbUsdCache;
      }
    } catch {}

    // 2) Fallback: WBNB/USDT reserves on PCS
    try {
      const f = new ethers.Contract(PCS_FACTORY, FACTORY_ABI, provider);
      let pair = await f.getPair(WBNB, USDT);
      pair = toChecksum(String(pair));
      if (pair && !/^0x0{40}$/i.test(pair)) {
        const p = new ethers.Contract(pair, PAIR_ABI, provider);
        const t0 = toChecksum(await p.token0());
        const r = await p.getReserves();
        const r0 = BigInt(r[0]);
        const r1 = BigInt(r[1]);

        const wbnbRes = (t0 === toChecksum(WBNB)) ? r0 : r1;
        const usdtRes = (t0 === toChecksum(WBNB)) ? r1 : r0;

        const wbnbF = Number(ethers.formatUnits(wbnbRes, 18));
        const usdtF = Number(ethers.formatUnits(usdtRes, 18));
        if (wbnbF > 0 && usdtF > 0) {
          const px = usdtF / wbnbF;
          _bnbUsdCache = { px, source: "On-chain (WBNB/USDT)", t: Date.now() };
          return _bnbUsdCache;
        }
      }
    } catch {}

    _bnbUsdCache = { px: NaN, source: "Unavailable", t: Date.now() };
    return _bnbUsdCache;
  }

  async function getDexFactory(provider, dex){
    try {
      const r = new ethers.Contract(dex.router, ROUTER_ABI, provider);
      const f = await r.factory();
      return toChecksum(String(f));
    } catch {
      return null;
    }
  }

  async function scanOnePair(provider, token, base, dex, factoryAddr){
    if (!factoryAddr) return null;
    try {
      const f = new ethers.Contract(factoryAddr, FACTORY_ABI, provider);
      let pair = await f.getPair(token, base.addr);
      pair = toChecksum(String(pair));
      if (/^0x0{40}$/i.test(pair)) return null;

      const p = new ethers.Contract(pair, PAIR_ABI, provider);
      const t0 = toChecksum(await p.token0());
      const r = await p.getReserves();
      const r0 = BigInt(r[0]);
      const r1 = BigInt(r[1]);

      const baseRes  = (t0 === toChecksum(base.addr)) ? r0 : r1;
      const tokenRes = (t0 === toChecksum(base.addr)) ? r1 : r0;

      let burnPct = null;
      try {
        const lp = new ethers.Contract(pair, LP_ABI, provider);
        const ts = BigInt(await lp.totalSupply());
        if (ts > 0n) {
          const z = BigInt(await lp.balanceOf("0x0000000000000000000000000000000000000000"));
          const d = BigInt(await lp.balanceOf("0x000000000000000000000000000000000000dEaD"));
          const burned = z + d;
          burnPct = Number((burned * 10000n) / ts) / 100;
        }
      } catch {}

      return {
        dexKey: dex.key,
        dexName: dex.name,
        router: dex.router,
        factory: factoryAddr,
        baseKey: base.key,
        baseName: base.name,
        baseAddr: base.addr,
        pair,
        baseReserve: baseRes,
        tokenReserve: tokenRes,
        burnPct
      };
    } catch {
      return null;
    }
  }

  // ===============================
  // Core scan (Quick)
  // ===============================
  async function scanTokenCore({ net, token, requireLiquidity=false }){
    const provider = await pickProvider(net);

    const code = await provider.getCode(token);
    if (!code || code === "0x") {
      return {
        ok: false,
        badge: "bad",
        headline: "❌ Not a contract",
        score: 999,
        notes: [`${token} has no bytecode on ${net.toUpperCase()}.`],
        data: null
      };
    }

    const c = new ethers.Contract(token, ERC20_ABI, provider);

    let name="—", symbol="—", decimals=18, supply=0n;
    try { name = await c.name(); } catch {}
    try { symbol = await c.symbol(); } catch {}
    try { decimals = Number(await c.decimals()); } catch {}
    try { supply = BigInt(await c.totalSupply()); } catch {}

    let owner = null;
    for (const fn of ["owner","getOwner","admin"]) {
      try {
        const o = await c[fn]();
        if (o && isHexAddr(String(o))) { owner = toChecksum(String(o)); break; }
      } catch {}
    }
    const ownerRenounced = owner ? (owner === "0x0000000000000000000000000000000000000000") : null;
    const proxy = await detectProxy(provider, token);

    // ETH: metadata-only
    if (net === "eth") {
      let score = 0;
      const notes = [];
      notes.push("✅ Contract bytecode found");
      if (!name || name==="—") { score += 1; notes.push("⚠️ Token name unreadable (non-standard)"); }
      if (!symbol || symbol==="—") { score += 1; notes.push("⚠️ Symbol unreadable (non-standard)"); }
      if (proxy?.isProxy && proxy.impl) { score += 1; notes.push(`ℹ️ Proxy detected. Impl: ${proxy.impl}`); }
      if (!owner) { score += 1; notes.push("⚠️ Owner not detectable"); }
      else if (ownerRenounced) { notes.push("✅ Ownership appears renounced (owner=0x0)"); }
      else { score += 1; notes.push(`⚠️ Owner detected: ${owner} (not renounced)`); }

      let badge="info", headline="ℹ️ Informational";
      if (score <= 1) { badge="ok"; headline="✅ Looks OK (basic checks)"; }
      else if (score <= 3) { badge="warn"; headline="⚠️ Caution (some signals)"; }
      else { badge="bad"; headline="❌ Higher risk signals"; }

      return {
        ok: true,
        badge,
        headline,
        score,
        notes,
        data: {
          net, token, name, symbol, decimals,
          totalSupply: supply ? supply.toString() : null,
          owner: owner || null,
          ownerRenounced: ownerRenounced === null ? null : ownerRenounced,
          proxy,
          requireLiquidity,
          pairs: [],
          generatedAt: new Date().toISOString()
        }
      };
    }

    // BSC liquidity scan
    const bnbUsd = await getBnbUsd(provider);
    const pairsFound = [];

    for (const dex of DEXES_BSC) {
      const factory = await getDexFactory(provider, dex);
      if (!factory) continue;

      for (const base of BASES_BSC) {
        const res = await scanOnePair(provider, token, base, dex, factory);
        if (!res) continue;

        let liqUsdApprox = null;
        try {
          const baseAmt = Number(ethers.formatUnits(res.baseReserve, 18));
          if (base.kind === "stable") liqUsdApprox = baseAmt * 2;
          else if (base.kind === "bnb") liqUsdApprox = (Number.isFinite(bnbUsd.px) ? baseAmt * bnbUsd.px * 2 : null);
        } catch {}

        pairsFound.push({ ...res, liqUsdApprox });
      }
    }

    pairsFound.sort((a,b) => (b.liqUsdApprox || 0) - (a.liqUsdApprox || 0));

    // scoring
    let score = 0;
    const notes = [];
    notes.push("✅ Contract bytecode found");

    if (!name || name==="—") { score += 1; notes.push("⚠️ Token name unreadable (non-standard)"); }
    if (!symbol || symbol==="—") { score += 1; notes.push("⚠️ Symbol unreadable (non-standard)"); }

    if (proxy?.isProxy && proxy.impl) {
      notes.push(`ℹ️ Proxy detected (EIP-1967). Impl: ${proxy.impl}`);
      if (proxy.admin) notes.push(`ℹ️ Proxy admin slot: ${proxy.admin}`);
      score += 1;
    }

    if (!owner) {
      score += 1;
      notes.push("⚠️ Owner not detectable (may be fine, but less transparent)");
    } else if (ownerRenounced) {
      notes.push("✅ Ownership appears renounced (owner=0x0)");
    } else {
      score += 1;
      notes.push(`⚠️ Owner detected: ${owner} (not renounced)`);
    }

    if (!pairsFound.length) {
      score += requireLiquidity ? 4 : 1;
      notes.push(requireLiquidity ? "❌ No DEX pair found" : "ℹ️ No DEX pair found (may be “Not listed yet”)");
    } else {
      const best = pairsFound[0];
      notes.push(`✅ Best liquidity pair: ${best.dexName} • ${best.baseName} • ${best.pair}`);

      if (best.liqUsdApprox != null) {
        notes.push(`ℹ️ Liquidity (approx): ${fmtUsd(best.liqUsdApprox)} (2×base side)`);
        if (best.baseKey === "WBNB" && Number.isFinite(bnbUsd.px)) {
          notes.push(`ℹ️ BNB/USD: ${bnbUsd.px.toFixed(2)} (${bnbUsd.source})`);
        }
        if (best.liqUsdApprox < 10_000) { score += 2; notes.push("⚠️ Very low liquidity (< $10k approx)"); }
        else if (best.liqUsdApprox < 25_000) { score += 2; notes.push("⚠️ Low liquidity (< $25k approx)"); }
      }

      if (best.burnPct != null) {
        if (best.burnPct >= 50) notes.push(`✅ LP burn seems high: ${best.burnPct.toFixed(2)}%`);
        else { score += 1; notes.push(`⚠️ LP burn seems low/unknown: ${best.burnPct.toFixed(2)}%`); }
      }
    }

    let badge="info", headline="ℹ️ Informational";
    if (score <= 1) { badge="ok"; headline="✅ Looks OK (basic checks)"; }
    else if (score <= 4) { badge="warn"; headline="⚠️ Caution (some risk signals)"; }
    else { badge="bad"; headline="❌ High risk signals"; }

    const report = {
      net, token, name, symbol, decimals,
      totalSupply: supply ? supply.toString() : null,
      owner: owner || null,
      ownerRenounced: ownerRenounced === null ? null : ownerRenounced,
      proxy,
      requireLiquidity,
      bnbUsd: Number.isFinite(bnbUsd.px) ? { price: bnbUsd.px, source: bnbUsd.source } : null,
      pairs: pairsFound.slice(0, 30).map(p => ({
        dex: p.dexName,
        router: p.router,
        factory: p.factory,
        base: p.baseName,
        baseAddr: p.baseAddr,
        pair: p.pair,
        liquidityUsdApprox: (p.liqUsdApprox != null) ? Number(p.liqUsdApprox) : null,
        lpBurnPct: (p.burnPct != null) ? Number(p.burnPct) : null
      })),
      score,
      headline,
      notes,
      generatedAt: new Date().toISOString()
    };

    return { ok:true, badge, headline, score, notes, data: report };
  }

  function renderPairsCards(containerId, pairs, token){
    const wrap = document.getElementById(containerId);
    if (!wrap) return;
    wrap.innerHTML = "";

    if (!pairs || !pairs.length) return;

    const top = pairs.slice(0, 6).map(p => {
      const dex = DEXES_BSC.find(d => d.name === p.dex || d.key === p.dexKey);
      const url = dex ? dex.swap(p.baseAddr, token) : "#";
      const liq = (p.liquidityUsdApprox != null) ? fmtUsd(p.liquidityUsdApprox) : "—";
      const burn = (p.lpBurnPct != null) ? `${p.lpBurnPct.toFixed(2)}%` : "—";

      return `
        <div class="card" style="padding:12px; margin-top:10px;">
          <div class="row" style="justify-content:space-between; gap:8px;">
            <div class="pill"><b>${p.dex}</b> • ${p.base}</div>
            <a class="btn btn-ghost" href="${url}" target="_blank" rel="noopener" style="padding:10px 14px; font-size:12px;">Open Swap</a>
          </div>
          <div class="small" style="margin-top:8px">
            <b>Pair:</b> <span class="mono">${p.pair}</span><br>
            <b>Liquidity (approx):</b> ${liq}<br>
            <b>LP Burn:</b> ${burn}
          </div>
        </div>
      `;
    }).join("");

    wrap.innerHTML = top;
  }

  // ===============================
  // Panels / cubes navigation
  // ===============================
  const TOOL_KEYS = ["quick","approvals","rpc","monitor"];

  function hideAllPanels(){
    document.querySelectorAll(".panel-shell").forEach(p => p.classList.add("hidden"));
    document.querySelectorAll(".tool-card").forEach(c => c.classList.remove("active"));
  }

  function showTool(toolKey, {scroll=true} = {}){
    if (!TOOL_KEYS.includes(toolKey)) return;

    document.querySelectorAll(".tool-card").forEach(c => {
      c.classList.toggle("active", c.getAttribute("data-tool") === toolKey);
    });

    document.querySelectorAll(".panel-shell").forEach(p => p.classList.add("hidden"));
    const panel = document.getElementById(`panel-${toolKey}`);
    if (panel) panel.classList.remove("hidden");

    if (scroll && panel) panel.scrollIntoView({ behavior:"smooth", block:"start" });
  }

  // ===============================
  // Quick Scan History
  // ===============================
  const QS_HISTORY_KEY = "cx_qs_history_v1";

  function qsLoadHistory(){
    try { return JSON.parse(localStorage.getItem(QS_HISTORY_KEY) || "[]"); }
    catch { return []; }
  }
  function qsSaveHistory(item){
    const arr = qsLoadHistory();
    const filtered = arr.filter(x => !(x.token === item.token && x.net === item.net));
    filtered.unshift(item);
    localStorage.setItem(QS_HISTORY_KEY, JSON.stringify(filtered.slice(0, 10)));
  }
  function qsRenderHistory(){
    const box = document.getElementById("qs-history");
    if (!box) return;
    const arr = qsLoadHistory();
    box.innerHTML = "";

    if (!arr.length) {
      box.innerHTML = `<div class="small muted">—</div>`;
      return;
    }

    for (const it of arr) {
      const el = document.createElement("div");
      el.className = "chip";
      el.innerHTML = `<span class="mono">${it.net.toUpperCase()}</span> ${fmtAddr(it.token)} <span class="x">•</span> <span>${it.score}</span>`;
      el.addEventListener("click", () => {
        const netSel = document.getElementById("qs-net");
        const tokInp = document.getElementById("qs-token");
        if (netSel) netSel.value = it.net;
        if (tokInp) tokInp.value = it.token;
        qsRun();
      });
      box.appendChild(el);
    }
  }

  // ===============================
  // Quick Scan
  // ===============================
  async function qsRun(){
    const netSel = document.getElementById("qs-net");
    const tokInp = document.getElementById("qs-token");
    const out = document.getElementById("qs-out");
    const status = document.getElementById("qs-status");
    const requireLiqEl = document.getElementById("qs-require-liq");

    if (!netSel || !tokInp || !out || !status || !requireLiqEl) return;

    const net = netSel.value === "eth" ? "eth" : "bsc";
    const raw = (tokInp.value || "").trim();

    if (!raw) { setStatus(status,"warn","<strong>⚠️ Missing token address.</strong>"); return; }
    if (!isHexAddr(raw)) { setStatus(status,"bad","<strong>❌ Invalid address.</strong> Expected 0x + 40 hex chars."); return; }

    const token = toChecksum(raw);
    const requireLiquidity = !!requireLiqEl.checked;

    setStatus(status,"info",`<strong>⏳ Scanning…</strong><br>Network: <span class="mono">${net.toUpperCase()}</span>`);
    setStatus(out,"info","<strong>⏳ Working…</strong>");
    renderPairsCards("qs-pairsWrap", [], token);
    CX.reports.quick = null;

    try {
      const res = await scanTokenCore({ net, token, requireLiquidity });
      if (!res.ok) {
        setStatus(out, res.badge, `<strong>${res.headline}</strong><br>${res.notes.join("<br>")}`);
        setStatus(status, res.badge, `<strong>Done.</strong> Score: ${res.score}`);
        return;
      }

      CX.reports.quick = res.data;

      const supplyHuman = res.data.totalSupply ? fmtBigintUnits(BigInt(res.data.totalSupply), res.data.decimals) : "—";
      const html = `
        <strong>${res.headline}</strong><br><br>
        <div class="pill">Token: <span class="mono">${res.data.token}</span></div>
        <div style="margin-top:10px" class="small">
          <b>Name:</b> ${String(res.data.name).replace(/</g,"&lt;")}<br>
          <b>Symbol:</b> ${String(res.data.symbol).replace(/</g,"&lt;")}<br>
          <b>Decimals:</b> ${res.data.decimals}<br>
          <b>Total supply:</b> ${supplyHuman}
        </div>
        <div style="margin-top:12px" class="small">
          <b>Signals:</b><br>
          ${res.notes.map(n => "• " + n).join("<br>")}
        </div>
      `;
      setStatus(out, res.badge, html);
      setStatus(status, res.badge, `<strong>Done.</strong> Score: ${res.score} (lower is better).`);

      if (net === "bsc" && res.data.pairs?.length) {
        renderPairsCards("qs-pairsWrap", res.data.pairs, res.data.token);
      }

      qsSaveHistory({ net, token: res.data.token, score: res.score, t: Date.now() });
      qsRenderHistory();

    } catch (e) {
      console.error(e);
      setStatus(out, "bad", `<strong>❌ Scan failed.</strong><br>${(e?.message || e).toString()}`);
      setStatus(status, "bad", "<strong>❌ Scan failed.</strong> Try again or test RPCs.");
    }
  }

  function qsBuildShareLink(){
    const net = (document.getElementById("qs-net")?.value === "eth") ? "eth" : "bsc";
    const raw = (document.getElementById("qs-token")?.value || "").trim();
    if (!isHexAddr(raw)) return null;

    const token = toChecksum(raw);
    const requireLiquidity = !!document.getElementById("qs-require-liq")?.checked;

    const u = new URL(window.location.href);
    u.searchParams.set("tool", "quick");
    u.searchParams.set("net", net);
    u.searchParams.set("token", token);
    if (requireLiquidity) u.searchParams.set("requireLiq","1"); else u.searchParams.delete("requireLiq");
    return u.toString();
  }

  async function qsCopyLink(){
    const status = document.getElementById("qs-status");
    const link = qsBuildShareLink();
    if (!link) { setStatus(status,"warn","<strong>⚠️ Paste a valid token first.</strong>"); return; }
    await copyText(link);
    setStatus(status,"ok",`<strong>✅ Link copied.</strong><br><span class="mono">${link}</span>`);
  }

  async function qsCopyJson(){
    const status = document.getElementById("qs-status");
    const enabled = !!document.getElementById("qs-show-json")?.checked;
    if (!enabled) { setStatus(status,"warn","<strong>⚠️ JSON report disabled.</strong> Enable it in Options."); return; }
    if (!CX.reports.quick) { setStatus(status,"warn","<strong>⚠️ No report yet.</strong> Run Scan first."); return; }
    await copyText(JSON.stringify(CX.reports.quick, null, 2));
    setStatus(status,"ok","<strong>✅ JSON copied.</strong>");
  }

  function qsShareX(){
    const link = qsBuildShareLink() || window.location.href;
    const txt = `Quick Scan (CycleX Security Hub)\n${link}`;
    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(txt)}`, "_blank", "noopener");
  }
  function qsShareTG(){
    const link = qsBuildShareLink() || window.location.href;
    window.open(`https://t.me/share/url?url=${encodeURIComponent(link)}&text=${encodeURIComponent("Quick Scan (CycleX Security Hub)")}`, "_blank", "noopener");
  }

  // ===============================
  // Wallet connect helpers
  // ===============================
  async function waitForAppKitModal(timeoutMs=12000){
    const t0 = Date.now();
    while (Date.now() - t0 < timeoutMs) {
      if (window.cxAppKitModal?.open && window.cxAppKitModal?.getWalletProvider) return window.cxAppKitModal;
      await sleep(150);
    }
    return null;
  }

  async function ensureChain(net){
    const p = CX.wallet.provider;
    if (!p?.request) return true;

    const chainIdHex = (net === "bsc") ? "0x38" : "0x1";
    try {
      await p.request({ method: "wallet_switchEthereumChain", params: [{ chainId: chainIdHex }] });
      return true;
    } catch (e) {
      // Optional add chain (BSC) if missing
      if (net === "bsc") {
        try {
          await p.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: "0x38",
              chainName: "BNB Smart Chain",
              nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
              rpcUrls: ["https://bsc-dataseed.binance.org"],
              blockExplorerUrls: ["https://bscscan.com"]
            }]
          });
          return true;
        } catch {}
      }
      return false;
    }
  }

  async function ensureConnected(preferredNet="bsc"){
    const status = document.getElementById("ap-status");

    if (String(WALLETCONNECT_PROJECT_ID || "").includes("7886bcb95105e9e47337cec481d5de75")) {
      setStatus(status, "warn", "<strong>⚠️ WalletConnect Project ID .</strong><br>-Project ID -JS (WALLETCONNECT_PROJECT_ID).");
      return false;
    }

    const modal = await waitForAppKitModal();
    if (!modal) {
      setStatus(status, "warn", "<strong>⚠️ Wallet modal not ready yet.</strong><br>Refresh page if this persists.");
      return false;
    }

    setStatus(status, "info", "<strong>⏳ Connecting wallet…</strong>");
    await modal.open({ view: "ConnectWallet" });

    const start = Date.now();
    while (Date.now() - start < 90000) {
      const p = modal.getWalletProvider?.();
      if (p) {
        CX.wallet.provider = p;

        const okChain = await ensureChain(preferredNet);
        if (!okChain) {
          setStatus(status, "warn", "<strong>⚠️ Please switch network in your wallet.</strong>");
          // continue anyway
        }

        const bp = new ethers.BrowserProvider(p);
        CX.wallet.signer = await bp.getSigner();
        CX.wallet.address = await CX.wallet.signer.getAddress();

        // update UI labels
        const addrEl = document.getElementById("ap-address");
        const pillEl = document.getElementById("ap-wallet");
        const wl = document.getElementById("walletLabel");
        if (addrEl) addrEl.textContent = CX.wallet.address;
        if (pillEl) pillEl.textContent = CX.wallet.address;
        if (wl) wl.textContent = CX.wallet.address;

        setStatus(status, "ok", "<strong>✅ Wallet connected.</strong>");
        return true;
      }
      await sleep(250);
    }

    setStatus(status, "warn", "<strong>⚠️ Connection timeout.</strong><br>Please try again.");
    return false;
  }

  // ===============================
  // Approvals Guardian
  // ===============================
  const ALLOW_ABI = [
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 value) returns (bool)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)"
  ];
  const MAX_UINT = (1n << 256n) - 1n;

  const UNI_V2_ROUTER_ETH = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D";
  const PCS_V2_ROUTER_BSC = "0x10ED43C718714eb63d5aA57B78B54704E256024E";

  function apSetStatus(kind, html){ setStatus(document.getElementById("ap-status"), kind, html); }

  function apGetNet(){
    return (document.getElementById("ap-net")?.value === "eth") ? "eth" : "bsc";
  }

  function apGetSpender(){
    const preset = document.getElementById("ap-spender-preset")?.value;
    const input = (document.getElementById("ap-spender")?.value || "").trim();

    if (preset === "pcs_router") return PCS_V2_ROUTER_BSC;
    if (preset === "uni_router") return UNI_V2_ROUTER_ETH;
    if (preset === "custom") return input;
    return input;
  }

  function apParseTokens(){
    const raw = document.getElementById("ap-tokens")?.value || "";
    return raw.split(/\r?\n/).map(x=>x.trim()).filter(Boolean).filter(isHexAddr).map(toChecksum);
  }

  function apRenderRows(rows){
    const table = document.getElementById("ap-table");
    if (!table) return;

    const head = table.querySelector(".trow.head");
    table.innerHTML = "";
    if (head) table.appendChild(head);

    if (!rows.length) {
      const row = document.createElement("div");
      row.className = "trow";
      row.innerHTML = `<div class="cell muted">—</div><div class="cell muted">—</div><div class="cell muted hide-sm">—</div><div class="cell muted">—</div>`;
      table.appendChild(row);
      return;
    }

    for (const r of rows) {
      const row = document.createElement("div");
      row.className = "trow";
      const allowanceStr = r.allowanceInf ? "∞ (infinite)" : r.allowanceHuman;

      row.innerHTML = `
        <div class="cell mono" title="${r.token}">${r.token}</div>
        <div class="cell">${allowanceStr}</div>
        <div class="cell hide-sm">${r.symbol || "—"}</div>
        <div class="cell">
          <button class="btn btn-ghost" data-token="${r.token}" ${(!r.canRevoke ? "disabled" : "")} style="padding:10px 14px; font-size:12px;">
            Revoke
          </button>
        </div>
      `;
      table.appendChild(row);
    }

    table.querySelectorAll("button[data-token]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        const token = btn.getAttribute("data-token");
        await apRevokeOne(token);
      });
    });
  }

  async function apCheck(){
    const net = apGetNet();
    const ok = CX.wallet.address ? true : await ensureConnected(net);
    if (!ok) return;

    await ensureChain(net);

    const spenderRaw = apGetSpender();
    if (!isHexAddr(spenderRaw)) { apSetStatus("bad","<strong>❌ Invalid spender address.</strong>"); return; }
    const spender = toChecksum(spenderRaw);

    const tokens = apParseTokens();
    if (!tokens.length) { apSetStatus("warn","<strong>⚠️ No valid token addresses.</strong><br>One per line."); return; }

    apSetStatus("info", `<strong>⏳ Checking allowances…</strong><br>Owner: <span class="mono">${fmtAddr(CX.wallet.address)}</span> • Spender: <span class="mono">${fmtAddr(spender)}</span>`);

    const rows = [];
    for (const t of tokens) {
      try {
        const c = new ethers.Contract(t, ALLOW_ABI, CX.wallet.signer);
        let sym="—", dec=18;
        try { sym = await c.symbol(); } catch {}
        try { dec = Number(await c.decimals()); } catch {}
        const a = BigInt(await c.allowance(CX.wallet.address, spender));
        const isInf = (a > (MAX_UINT / 2n));
        const human = isInf ? "∞" : (a === 0n ? "0" : fmtBigintUnits(a, dec));
        rows.push({ token:t, symbol:sym, allowance:a, allowanceInf:isInf, allowanceHuman:human, canRevoke:(a>0n) });
      } catch {
        rows.push({ token:t, symbol:"—", allowance:0n, allowanceInf:false, allowanceHuman:"error", canRevoke:false });
      }
    }

    apRenderRows(rows);
    const nonZero = rows.filter(r=>r.allowance>0n).length;
    apSetStatus(nonZero ? "warn" : "ok", `<strong>Done.</strong><br>Checked ${rows.length}. Non-zero: ${nonZero}.`);
  }

  async function apRevokeOne(tokenAddr){
    const net = apGetNet();
    if (!CX.wallet.address || !CX.wallet.signer) { apSetStatus("warn","<strong>⚠️ Connect wallet first.</strong>"); return; }
    await ensureChain(net);

    const spenderRaw = apGetSpender();
    if (!isHexAddr(spenderRaw)) { apSetStatus("bad","<strong>❌ Invalid spender address.</strong>"); return; }
    const spender = toChecksum(spenderRaw);
    const token = toChecksum(tokenAddr);

    apSetStatus("info", `<strong>⏳ Revoking…</strong><br>Token: <span class="mono">${fmtAddr(token)}</span> • Spender: <span class="mono">${fmtAddr(spender)}</span>`);
    try {
      const c = new ethers.Contract(token, ALLOW_ABI, CX.wallet.signer);
      const tx = await c.approve(spender, 0);
      apSetStatus("info", `<strong>⏳ Pending…</strong><br><span class="mono">${tx.hash}</span>`);
      await tx.wait();
      apSetStatus("ok", "<strong>✅ Revoke successful.</strong>");
      await apCheck();
    } catch (e) {
      console.error(e);
      apSetStatus("bad", `<strong>❌ Revoke failed.</strong><br>${(e?.message || e).toString()}`);
    }
  }

  async function apRevokeAllNonZero(){
    const net = apGetNet();
    const ok = CX.wallet.address ? true : await ensureConnected(net);
    if (!ok) return;

    await apCheck();

    const toRevoke = [];
    document.querySelectorAll("#ap-table button[data-token]").forEach(btn => {
      if (!btn.disabled) toRevoke.push(btn.getAttribute("data-token"));
    });

    if (!toRevoke.length) { apSetStatus("ok","<strong>✅ Nothing to revoke.</strong>"); return; }

    apSetStatus("warn", `<strong>⏳ Revoking ${toRevoke.length} token(s)…</strong><br>This will send multiple transactions.`);
    for (const t of toRevoke) { await apRevokeOne(t); await sleep(500); }
    apSetStatus("ok","<strong>✅ Revoke batch finished.</strong>");
  }

  // Seed common tokens + history
  const COMMON_BSC = [
    WBNB,
    USDT,
    USDC,
    BUSD,
    "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" // CAKE
  ];
  const COMMON_ETH = [
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
    "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0x6B175474E89094C44Da98b954EedeAC495271d0F"  // DAI
  ];

  function apSeedCommon(){
    const net = apGetNet();
    const list = (net === "eth") ? COMMON_ETH : COMMON_BSC;
    const ta = document.getElementById("ap-tokens");
    if (!ta) return;
    ta.value = list.join("\n");
    apSetStatus("ok", "<strong>✅ Seeded common tokens.</strong>");
  }

  function apSeedHistory(){
    const net = apGetNet();
    const arr = qsLoadHistory().filter(x => x.net === net).map(x => x.token);
    const unique = Array.from(new Set(arr)).slice(0, 15);
    const ta = document.getElementById("ap-tokens");
    if (!ta) return;

    if (!unique.length) {
      apSetStatus("warn", "<strong>⚠️ No scan history for this network yet.</strong>");
      return;
    }
    ta.value = unique.join("\n");
    apSetStatus("ok", "<strong>✅ Seeded from scan history.</strong>");
  }

  function apApplyPreset(){
    const preset = document.getElementById("ap-spender-preset")?.value;
    const input  = document.getElementById("ap-spender");
    const netSel = document.getElementById("ap-net");
    if (!input) return;

    if (preset === "pcs_router") {
      input.value = PCS_V2_ROUTER_BSC;
      input.disabled = true;
      if (netSel) netSel.value = "bsc";
    } else if (preset === "uni_router") {
      input.value = UNI_V2_ROUTER_ETH;
      input.disabled = true;
      if (netSel) netSel.value = "eth";
    } else {
      input.disabled = false;
      if (!input.value || input.value === PCS_V2_ROUTER_BSC || input.value === UNI_V2_ROUTER_ETH) input.value = "";
    }
  }

  // ===============================
  // RPC Checker
  // ===============================
  function rpcRow(url, latency, block, ok){
    const table = document.getElementById("rpc-table");
    if (!table) return;

    const row = document.createElement("div");
    row.className = "trow";

    const tag = ok ? "✅ OK" : "❌ Fail";
    const lat = ok ? (latency.toFixed(0) + " ms") : "—";
    const blockStr = ok ? String(block) : "—";

    row.innerHTML = `
      <div class="cell mono" title="${url}">${url}</div>
      <div class="cell">${lat}</div>
      <div class="cell hide-sm">${blockStr}</div>
      <div class="cell">${tag}</div>
    `;

    if (ok && url === CX.rpc.best) {
      row.style.background = "rgba(0,230,118,0.10)";
      row.style.borderTopColor = "rgba(0,230,118,0.20)";
    }

    table.appendChild(row);
  }

  async function rpcTestAll(){
    const status = document.getElementById("rpc-status");
    const netSel = document.getElementById("rpc-net");
    const custom = (document.getElementById("rpc-custom")?.value || "").trim();

    const net = (netSel?.value === "eth") ? "eth" : "bsc";
    const expectChainId = (net === "bsc") ? 56 : 1;

    const list = [...(RPCS[net] || [])];
    if (custom) list.unshift(custom);

    const table = document.getElementById("rpc-table");
    if (!table) return;

    table.innerHTML = `
      <div class="trow head">
        <div class="cell">RPC</div>
        <div class="cell">Latency</div>
        <div class="cell hide-sm">Block</div>
        <div class="cell">Status</div>
      </div>
    `;

    setStatus(status, "info", `<strong>⏳ Testing ${list.length} RPC(s)…</strong> <span class="mono">${net.toUpperCase()}</span>`);
    CX.rpc.best = "";
    CX.rpc.last = [];
    let bestMs = Infinity;

    for (const url of list) {
      let ok = false, ms = 0, block = 0;

      try {
        const p = new ethers.JsonRpcProvider(url);
        const t0 = performance.now();
        block = await p.getBlockNumber();
        const n = await p.getNetwork();
        const t1 = performance.now();
        ms = (t1 - t0);
        if (Number(n.chainId) !== expectChainId) throw new Error("Wrong chainId");
        ok = true;

        if (ms < bestMs) { bestMs = ms; CX.rpc.best = url; }
      } catch { ok = false; }

      CX.rpc.last.push({ url, ok, latencyMs: ok ? ms : null, block: ok ? block : null, net });
      rpcRow(url, ms, block, ok);
      await sleep(120);
    }

    if (CX.rpc.best) setStatus(status, "ok", `<strong>✅ Best RPC:</strong> <span class="mono">${CX.rpc.best}</span>`);
    else setStatus(status, "bad", "<strong>❌ All RPC tests failed.</strong><br>Try a different custom RPC.");
  }

  async function rpcCopyBest(){
    const status = document.getElementById("rpc-status");
    if (!CX.rpc.best) { setStatus(status, "warn", "<strong>⚠️ No best RPC yet.</strong><br>Run Test RPCs first."); return; }
    await copyText(CX.rpc.best);
    setStatus(status, "ok", `<strong>✅ Copied:</strong> <span class="mono">${CX.rpc.best}</span>`);
  }

  async function rpcCopyJson(){
    const status = document.getElementById("rpc-status");
    if (!CX.rpc.last?.length) { setStatus(status, "warn", "<strong>⚠️ No results yet.</strong> Run Test RPCs first."); return; }
    await copyText(JSON.stringify(CX.rpc.last, null, 2));
    setStatus(status, "ok", "<strong>✅ JSON copied.</strong>");
  }

  // ===============================
  // Monitor
  // ===============================
  const MON_KEY = "cx_monitor_watchlist_v1";

  function monLoad(){
    try { CX.monitor.list = JSON.parse(localStorage.getItem(MON_KEY) || "[]"); }
    catch { CX.monitor.list = []; }
  }

  function monSave(){
    localStorage.setItem(MON_KEY, JSON.stringify(CX.monitor.list));
  }

  function monRender(){
    const table = document.getElementById("mon-table");
    if (!table) return;

    const head = table.querySelector(".trow.head");
    table.innerHTML = "";
    if (head) table.appendChild(head);

    if (!CX.monitor.list.length) {
      const row = document.createElement("div");
      row.className = "trow";
      row.innerHTML = `<div class="cell muted">—</div><div class="cell muted">—</div><div class="cell muted hide-sm">—</div><div class="cell muted">—</div>`;
      table.appendChild(row);
      return;
    }

    for (const it of CX.monitor.list) {
      const row = document.createElement("div");
      row.className = "trow" + (it.changed ? " highlight" : "");
      const last = it.lastSeen ? new Date(it.lastSeen).toLocaleString() : "—";
      const st = it.changed ? "⚠️ Changed" : "✅ OK";
      row.innerHTML = `
        <div class="cell mono" title="${it.addr}">${fmtAddr(it.addr)} <span class="mini">(${it.addr.slice(0,10)}…)</span></div>
        <div class="cell">${it.net.toUpperCase()}</div>
        <div class="cell hide-sm">${last}</div>
        <div class="cell">${st}</div>
      `;
      table.appendChild(row);
    }
  }

  async function monAdd(){
    const status = document.getElementById("mon-status");
    const netSel = document.getElementById("mon-net");
    const addrInp = document.getElementById("mon-addr");

    if (!netSel || !addrInp) return;

    const net = (netSel.value === "eth") ? "eth" : "bsc";
    const raw = (addrInp.value || "").trim();
    if (!isHexAddr(raw)) { setStatus(status,"bad","<strong>❌ Invalid contract address.</strong>"); return; }

    const addr = toChecksum(raw);
    setStatus(status,"info","<strong>⏳ Adding…</strong>");

    try {
      const provider = await pickProvider(net);
      const code = await provider.getCode(addr);
      if (!code || code === "0x") { setStatus(status,"bad","<strong>❌ No bytecode.</strong> Not a contract."); return; }

      const codeHash = ethers.keccak256(code);
      const proxy = await detectProxy(provider, addr);
      const impl = proxy?.isProxy ? proxy.impl : null;

      const item = {
        addr, net,
        baseHash: codeHash,
        baseImpl: impl,
        lastSeen: Date.now(),
        changed: false
      };

      CX.monitor.list = CX.monitor.list.filter(x => !(x.addr === addr && x.net === net));
      CX.monitor.list.unshift(item);
      monSave();
      monRender();

      setStatus(status,"ok",`<strong>✅ Added.</strong><br>Hash: <span class="mono">${codeHash.slice(0,14)}…</span>${impl ? `<br>Proxy impl: <span class="mono">${impl}</span>` : ""}`);
    } catch (e) {
      console.error(e);
      setStatus(status,"bad",`<strong>❌ Add failed.</strong><br>${(e?.message || e).toString()}`);
    }
  }

  async function monCheckAll(){
    const status = document.getElementById("mon-status");
    if (!CX.monitor.list.length) { setStatus(status,"warn","<strong>⚠️ Watchlist empty.</strong>"); return; }

    setStatus(status,"info",`<strong>⏳ Checking ${CX.monitor.list.length} item(s)…</strong>`);
    let changedCount = 0;

    for (const it of CX.monitor.list) {
      try {
        const provider = await pickProvider(it.net);
        const code = await provider.getCode(it.addr);
        if (!code || code === "0x") {
          it.changed = true;
          changedCount++;
          it.lastSeen = Date.now();
          continue;
        }
        const hash = ethers.keccak256(code);
        const proxy = await detectProxy(provider, it.addr);
        const impl = proxy?.isProxy ? proxy.impl : null;

        const hashChanged = (hash !== it.baseHash);
        const implChanged = ((impl || null) !== (it.baseImpl || null));

        it.changed = hashChanged || implChanged;
        if (it.changed) changedCount++;
        it.lastSeen = Date.now();
      } catch {
        it.changed = true;
        changedCount++;
        it.lastSeen = Date.now();
      }
    }

    monSave();
    monRender();

    if (changedCount) setStatus(status,"warn",`<strong>⚠️ Changes detected:</strong> ${changedCount}/${CX.monitor.list.length}`);
    else setStatus(status,"ok",`<strong>✅ No changes detected.</strong> Checked ${CX.monitor.list.length}.`);
  }

  function monExport(){
    const status = document.getElementById("mon-status");
    const data = JSON.stringify(CX.monitor.list, null, 2);

    try {
      const blob = new Blob([data], { type:"application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "cyclex_monitor_watchlist.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus(status,"ok","<strong>✅ Exported JSON.</strong> (Downloaded)");
    } catch {
      copyText(data);
      setStatus(status,"ok","<strong>✅ Exported JSON.</strong> (Copied)");
    }
  }

  // ===============================
  // Wiring
  // ===============================
  (function initWiring(){
    // cubes -> panels
    document.querySelectorAll(".tool-card").forEach(card => {
      card.addEventListener("click", () => showTool(card.getAttribute("data-tool")));
    });

    // close buttons
    document.getElementById("btnCloseQuick")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });
    document.getElementById("btnCloseApprovals")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });
    document.getElementById("btnCloseRpc")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });
    document.getElementById("btnCloseMonitor")?.addEventListener("click", () => { hideAllPanels(); document.getElementById("toolGrid")?.scrollIntoView({behavior:"smooth"}); });

    // hero buttons
    document.getElementById("btn-quick")?.addEventListener("click", async () => { showTool("quick"); });
    document.getElementById("btn-connect")?.addEventListener("click", async () => {
      showTool("approvals");
      await ensureConnected(apGetNet());
    });

    // quick scan buttons
    document.getElementById("qs-run")?.addEventListener("click", qsRun);
    document.getElementById("qs-copy-link")?.addEventListener("click", qsCopyLink);
    document.getElementById("qs-copy-json")?.addEventListener("click", qsCopyJson);
    document.getElementById("qs-share-x")?.addEventListener("click", qsShareX);
    document.getElementById("qs-share-tg")?.addEventListener("click", qsShareTG);

    // approvals
    document.getElementById("ap-connect")?.addEventListener("click", () => ensureConnected(apGetNet()));
    document.getElementById("ap-check")?.addEventListener("click", apCheck);
    document.getElementById("ap-revoke-all")?.addEventListener("click", apRevokeAllNonZero);
    document.getElementById("ap-seed-common")?.addEventListener("click", apSeedCommon);
    document.getElementById("ap-seed-history")?.addEventListener("click", apSeedHistory);
    document.getElementById("ap-spender-preset")?.addEventListener("change", apApplyPreset);

    // rpc
    document.getElementById("rpc-test")?.addEventListener("click", rpcTestAll);
    document.getElementById("rpc-copy-best")?.addEventListener("click", rpcCopyBest);
    document.getElementById("rpc-copy-json")?.addEventListener("click", rpcCopyJson);

    // monitor
    document.getElementById("mon-add")?.addEventListener("click", monAdd);
    document.getElementById("mon-check")?.addEventListener("click", monCheckAll);
    document.getElementById("mon-export")?.addEventListener("click", monExport);

    // init defaults
    qsRenderHistory();
    monLoad();
    monRender();
    apApplyPreset();

    // URL auto-run support
    const p = new URLSearchParams(window.location.search);
    const tool = p.get("tool");
    if (tool && TOOL_KEYS.includes(tool)) showTool(tool, {scroll:false});

    const token = p.get("token");
    const net = p.get("net");
    if (token && isHexAddr(token)) {
      showTool("quick", {scroll:false});
      const netSel = document.getElementById("qs-net");
      const tokInp = document.getElementById("qs-token");
      const req = document.getElementById("qs-require-liq");
      if (netSel) netSel.value = (net === "eth") ? "eth" : "bsc";
      if (tokInp) tokInp.value = toChecksum(token);
      if (req) req.checked = (p.get("requireLiq") === "1");
      qsRun();
    }
  })();

})();
</script>

</body>
</html>
